// ignore_for_file: non_constant_identifier_names

// ignore_for_file: no_leading_underscores_for_library_prefixes
import 'package:orm/orm.dart' as _i1;

import 'model.dart' as _i3;
import 'prisma.dart' as _i2;

class MeetingSessionCountOutputType {
  const MeetingSessionCountOutputType({this.recordings});

  factory MeetingSessionCountOutputType.fromJson(Map json) =>
      MeetingSessionCountOutputType(recordings: json['recordings']);

  final int? recordings;

  Map<String, dynamic> toJson() => {'recordings': recordings};
}

class SlotOfAppointmentCountOutputType {
  const SlotOfAppointmentCountOutputType({this.user});

  factory SlotOfAppointmentCountOutputType.fromJson(Map json) =>
      SlotOfAppointmentCountOutputType(user: json['user']);

  final int? user;

  Map<String, dynamic> toJson() => {'user': user};
}

class SubDomainCountOutputType {
  const SubDomainCountOutputType({this.consultantProfiles});

  factory SubDomainCountOutputType.fromJson(Map json) =>
      SubDomainCountOutputType(consultantProfiles: json['consultantProfiles']);

  final int? consultantProfiles;

  Map<String, dynamic> toJson() => {'consultantProfiles': consultantProfiles};
}

class TagCountOutputType {
  const TagCountOutputType({this.consultantProfiles});

  factory TagCountOutputType.fromJson(Map json) =>
      TagCountOutputType(consultantProfiles: json['consultantProfiles']);

  final int? consultantProfiles;

  Map<String, dynamic> toJson() => {'consultantProfiles': consultantProfiles};
}

class DomainCountOutputType {
  const DomainCountOutputType({
    this.subDomains,
    this.tags,
    this.consultantProfiles,
  });

  factory DomainCountOutputType.fromJson(Map json) => DomainCountOutputType(
    subDomains: json['subDomains'],
    tags: json['tags'],
    consultantProfiles: json['consultantProfiles'],
  );

  final int? subDomains;

  final int? tags;

  final int? consultantProfiles;

  Map<String, dynamic> toJson() => {
    'subDomains': subDomains,
    'tags': tags,
    'consultantProfiles': consultantProfiles,
  };
}

class SubscriptionPlanCountOutputType {
  const SubscriptionPlanCountOutputType({this.subscriptions});

  factory SubscriptionPlanCountOutputType.fromJson(Map json) =>
      SubscriptionPlanCountOutputType(subscriptions: json['subscriptions']);

  final int? subscriptions;

  Map<String, dynamic> toJson() => {'subscriptions': subscriptions};
}

class SubscriptionCountOutputType {
  const SubscriptionCountOutputType({this.appointments});

  factory SubscriptionCountOutputType.fromJson(Map json) =>
      SubscriptionCountOutputType(appointments: json['appointments']);

  final int? appointments;

  Map<String, dynamic> toJson() => {'appointments': appointments};
}

class ConsulteeProfileCountOutputType {
  const ConsulteeProfileCountOutputType({
    this.consultationRequests,
    this.subscriptionRequests,
    this.consultantReviews,
  });

  factory ConsulteeProfileCountOutputType.fromJson(Map json) =>
      ConsulteeProfileCountOutputType(
        consultationRequests: json['consultationRequests'],
        subscriptionRequests: json['subscriptionRequests'],
        consultantReviews: json['consultantReviews'],
      );

  final int? consultationRequests;

  final int? subscriptionRequests;

  final int? consultantReviews;

  Map<String, dynamic> toJson() => {
    'consultationRequests': consultationRequests,
    'subscriptionRequests': subscriptionRequests,
    'consultantReviews': consultantReviews,
  };
}

class WebinarCountOutputType {
  const WebinarCountOutputType({this.waitlist});

  factory WebinarCountOutputType.fromJson(Map json) =>
      WebinarCountOutputType(waitlist: json['waitlist']);

  final int? waitlist;

  Map<String, dynamic> toJson() => {'waitlist': waitlist};
}

class ClassCountOutputType {
  const ClassCountOutputType({this.waitlist, this.appointments});

  factory ClassCountOutputType.fromJson(Map json) => ClassCountOutputType(
    waitlist: json['waitlist'],
    appointments: json['appointments'],
  );

  final int? waitlist;

  final int? appointments;

  Map<String, dynamic> toJson() => {
    'waitlist': waitlist,
    'appointments': appointments,
  };
}

class ClassPlanCountOutputType {
  const ClassPlanCountOutputType({
    this.topics,
    this.classContents,
    this.classes,
  });

  factory ClassPlanCountOutputType.fromJson(Map json) =>
      ClassPlanCountOutputType(
        topics: json['topics'],
        classContents: json['classContents'],
        classes: json['classes'],
      );

  final int? topics;

  final int? classContents;

  final int? classes;

  Map<String, dynamic> toJson() => {
    'topics': topics,
    'classContents': classContents,
    'classes': classes,
  };
}

class TopicCountOutputType {
  const TopicCountOutputType({this.webinarPlans, this.classPlans});

  factory TopicCountOutputType.fromJson(Map json) => TopicCountOutputType(
    webinarPlans: json['webinarPlans'],
    classPlans: json['classPlans'],
  );

  final int? webinarPlans;

  final int? classPlans;

  Map<String, dynamic> toJson() => {
    'webinarPlans': webinarPlans,
    'classPlans': classPlans,
  };
}

class WebinarPlanCountOutputType {
  const WebinarPlanCountOutputType({this.topics, this.webinars});

  factory WebinarPlanCountOutputType.fromJson(Map json) =>
      WebinarPlanCountOutputType(
        topics: json['topics'],
        webinars: json['webinars'],
      );

  final int? topics;

  final int? webinars;

  Map<String, dynamic> toJson() => {'topics': topics, 'webinars': webinars};
}

class ConsultantProfileCountOutputType {
  const ConsultantProfileCountOutputType({
    this.subDomains,
    this.tags,
    this.reviews,
    this.slotsOfAvailabilityWeekly,
    this.slotsOfAvailabilityCustom,
    this.consultationPlans,
    this.subscriptionPlans,
    this.webinarPlans,
    this.classPlans,
  });

  factory ConsultantProfileCountOutputType.fromJson(Map json) =>
      ConsultantProfileCountOutputType(
        subDomains: json['subDomains'],
        tags: json['tags'],
        reviews: json['reviews'],
        slotsOfAvailabilityWeekly: json['slotsOfAvailabilityWeekly'],
        slotsOfAvailabilityCustom: json['slotsOfAvailabilityCustom'],
        consultationPlans: json['consultationPlans'],
        subscriptionPlans: json['subscriptionPlans'],
        webinarPlans: json['webinarPlans'],
        classPlans: json['classPlans'],
      );

  final int? subDomains;

  final int? tags;

  final int? reviews;

  final int? slotsOfAvailabilityWeekly;

  final int? slotsOfAvailabilityCustom;

  final int? consultationPlans;

  final int? subscriptionPlans;

  final int? webinarPlans;

  final int? classPlans;

  Map<String, dynamic> toJson() => {
    'subDomains': subDomains,
    'tags': tags,
    'reviews': reviews,
    'slotsOfAvailabilityWeekly': slotsOfAvailabilityWeekly,
    'slotsOfAvailabilityCustom': slotsOfAvailabilityCustom,
    'consultationPlans': consultationPlans,
    'subscriptionPlans': subscriptionPlans,
    'webinarPlans': webinarPlans,
    'classPlans': classPlans,
  };
}

class ConsultationPlanCountOutputType {
  const ConsultationPlanCountOutputType({this.consultations});

  factory ConsultationPlanCountOutputType.fromJson(Map json) =>
      ConsultationPlanCountOutputType(consultations: json['consultations']);

  final int? consultations;

  Map<String, dynamic> toJson() => {'consultations': consultations};
}

class AppointmentCountOutputType {
  const AppointmentCountOutputType({this.slotsOfAppointment, this.payment});

  factory AppointmentCountOutputType.fromJson(Map json) =>
      AppointmentCountOutputType(
        slotsOfAppointment: json['slotsOfAppointment'],
        payment: json['payment'],
      );

  final int? slotsOfAppointment;

  final int? payment;

  Map<String, dynamic> toJson() => {
    'slotsOfAppointment': slotsOfAppointment,
    'payment': payment,
  };
}

class DiscountCodeCountOutputType {
  const DiscountCodeCountOutputType({this.payment});

  factory DiscountCodeCountOutputType.fromJson(Map json) =>
      DiscountCodeCountOutputType(payment: json['Payment']);

  final int? payment;

  Map<String, dynamic> toJson() => {'Payment': payment};
}

class SupportTicketCountOutputType {
  const SupportTicketCountOutputType({this.responses});

  factory SupportTicketCountOutputType.fromJson(Map json) =>
      SupportTicketCountOutputType(responses: json['responses']);

  final int? responses;

  Map<String, dynamic> toJson() => {'responses': responses};
}

class UserCountOutputType {
  const UserCountOutputType({
    this.payment,
    this.slotsOfAppointment,
    this.waitlist,
    this.feedbacks,
    this.supportTickets,
    this.supportResponses,
    this.accounts,
    this.sessions,
  });

  factory UserCountOutputType.fromJson(Map json) => UserCountOutputType(
    payment: json['Payment'],
    slotsOfAppointment: json['slotsOfAppointment'],
    waitlist: json['Waitlist'],
    feedbacks: json['feedbacks'],
    supportTickets: json['supportTickets'],
    supportResponses: json['supportResponses'],
    accounts: json['accounts'],
    sessions: json['sessions'],
  );

  final int? payment;

  final int? slotsOfAppointment;

  final int? waitlist;

  final int? feedbacks;

  final int? supportTickets;

  final int? supportResponses;

  final int? accounts;

  final int? sessions;

  Map<String, dynamic> toJson() => {
    'Payment': payment,
    'slotsOfAppointment': slotsOfAppointment,
    'Waitlist': waitlist,
    'feedbacks': feedbacks,
    'supportTickets': supportTickets,
    'supportResponses': supportResponses,
    'accounts': accounts,
    'sessions': sessions,
  };
}

class UserWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserWhereUniqueInput({
    this.id,
    this.email,
    this.phone,
    this.passwordResetToken,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
  });

  final String? id;

  final String? email;

  final String? phone;

  final String? passwordResetToken;

  final String? consultantProfileId;

  final String? consulteeProfileId;

  final String? staffProfileId;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'email': email,
    'phone': phone,
    'passwordResetToken': passwordResetToken,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
  };
}

class CookiePreferenceUserArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CookiePreferenceUserArgs({this.select, this.include});

  final _i2.UserSelect? select;

  final _i2.UserInclude? include;

  @override
  Map<String, dynamic> toJson() => {'select': select, 'include': include};
}

class CookiePreferenceInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CookiePreferenceInclude({this.user});

  final _i1.PrismaUnion<bool, _i2.CookiePreferenceUserArgs>? user;

  @override
  Map<String, dynamic> toJson() => {'user': user};
}

class UserCookiePreferencesArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCookiePreferencesArgs({this.select, this.include});

  final _i2.CookiePreferenceSelect? select;

  final _i2.CookiePreferenceInclude? include;

  @override
  Map<String, dynamic> toJson() => {'select': select, 'include': include};
}

class NotificationPreferenceUserArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NotificationPreferenceUserArgs({this.select, this.include});

  final _i2.UserSelect? select;

  final _i2.UserInclude? include;

  @override
  Map<String, dynamic> toJson() => {'select': select, 'include': include};
}

class NotificationPreferenceSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NotificationPreferenceSelect({
    this.id,
    this.userId,
    this.allNotifications,
    this.mentions,
    this.directMessages,
    this.updates,
    this.user,
  });

  final bool? id;

  final bool? userId;

  final bool? allNotifications;

  final bool? mentions;

  final bool? directMessages;

  final bool? updates;

  final _i1.PrismaUnion<bool, _i2.NotificationPreferenceUserArgs>? user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'allNotifications': allNotifications,
    'mentions': mentions,
    'directMessages': directMessages,
    'updates': updates,
    'user': user,
  };
}

class NotificationPreferenceInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NotificationPreferenceInclude({this.user});

  final _i1.PrismaUnion<bool, _i2.NotificationPreferenceUserArgs>? user;

  @override
  Map<String, dynamic> toJson() => {'user': user};
}

class UserNotificationPreferencesArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserNotificationPreferencesArgs({this.select, this.include});

  final _i2.NotificationPreferenceSelect? select;

  final _i2.NotificationPreferenceInclude? include;

  @override
  Map<String, dynamic> toJson() => {'select': select, 'include': include};
}

class PaymentUserArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentUserArgs({this.select, this.include});

  final _i2.UserSelect? select;

  final _i2.UserInclude? include;

  @override
  Map<String, dynamic> toJson() => {'select': select, 'include': include};
}

enum QueryMode implements _i1.PrismaEnum {
  $default._('default'),
  insensitive._('insensitive');

  const QueryMode._(this.name);

  @override
  final String name;
}

class NestedStringFilter implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedStringFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.contains,
    this.startsWith,
    this.endsWith,
    this.not,
  });

  final String? equals;

  final _i1.PrismaUnion<Iterable<String>, String>? $in;

  final _i1.PrismaUnion<Iterable<String>, String>? notIn;

  final String? lt;

  final String? lte;

  final String? gt;

  final String? gte;

  final String? contains;

  final String? startsWith;

  final String? endsWith;

  final _i1.PrismaUnion<String, _i2.NestedStringFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'lt': lt,
    'lte': lte,
    'gt': gt,
    'gte': gte,
    'contains': contains,
    'startsWith': startsWith,
    'endsWith': endsWith,
    'not': not,
  };
}

class StringFilter implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StringFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.contains,
    this.startsWith,
    this.endsWith,
    this.mode,
    this.not,
  });

  final String? equals;

  final _i1.PrismaUnion<Iterable<String>, String>? $in;

  final _i1.PrismaUnion<Iterable<String>, String>? notIn;

  final String? lt;

  final String? lte;

  final String? gt;

  final String? gte;

  final String? contains;

  final String? startsWith;

  final String? endsWith;

  final _i2.QueryMode? mode;

  final _i1.PrismaUnion<String, _i2.NestedStringFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'lt': lt,
    'lte': lte,
    'gt': gt,
    'gte': gte,
    'contains': contains,
    'startsWith': startsWith,
    'endsWith': endsWith,
    'mode': mode,
    'not': not,
  };
}

class NestedStringNullableFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedStringNullableFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.contains,
    this.startsWith,
    this.endsWith,
    this.not,
  });

  final _i1.PrismaUnion<String, _i1.PrismaNull>? equals;

  final _i1.PrismaUnion<
    Iterable<String>,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  $in;

  final _i1.PrismaUnion<
    Iterable<String>,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  notIn;

  final String? lt;

  final String? lte;

  final String? gt;

  final String? gte;

  final String? contains;

  final String? startsWith;

  final String? endsWith;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<_i2.NestedStringNullableFilter, _i1.PrismaNull>
  >?
  not;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'lt': lt,
    'lte': lte,
    'gt': gt,
    'gte': gte,
    'contains': contains,
    'startsWith': startsWith,
    'endsWith': endsWith,
    'not': not,
  };
}

class StringNullableFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StringNullableFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.contains,
    this.startsWith,
    this.endsWith,
    this.mode,
    this.not,
  });

  final _i1.PrismaUnion<String, _i1.PrismaNull>? equals;

  final _i1.PrismaUnion<
    Iterable<String>,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  $in;

  final _i1.PrismaUnion<
    Iterable<String>,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  notIn;

  final String? lt;

  final String? lte;

  final String? gt;

  final String? gte;

  final String? contains;

  final String? startsWith;

  final String? endsWith;

  final _i2.QueryMode? mode;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<_i2.NestedStringNullableFilter, _i1.PrismaNull>
  >?
  not;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'lt': lt,
    'lte': lte,
    'gt': gt,
    'gte': gte,
    'contains': contains,
    'startsWith': startsWith,
    'endsWith': endsWith,
    'mode': mode,
    'not': not,
  };
}

class NestedDateTimeNullableFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedDateTimeNullableFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? equals;

  final _i1.PrismaUnion<
    Iterable<DateTime>,
    _i1.PrismaUnion<DateTime, _i1.PrismaNull>
  >?
  $in;

  final _i1.PrismaUnion<
    Iterable<DateTime>,
    _i1.PrismaUnion<DateTime, _i1.PrismaNull>
  >?
  notIn;

  final DateTime? lt;

  final DateTime? lte;

  final DateTime? gt;

  final DateTime? gte;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<_i2.NestedDateTimeNullableFilter, _i1.PrismaNull>
  >?
  not;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'lt': lt,
    'lte': lte,
    'gt': gt,
    'gte': gte,
    'not': not,
  };
}

class DateTimeNullableFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DateTimeNullableFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? equals;

  final _i1.PrismaUnion<
    Iterable<DateTime>,
    _i1.PrismaUnion<DateTime, _i1.PrismaNull>
  >?
  $in;

  final _i1.PrismaUnion<
    Iterable<DateTime>,
    _i1.PrismaUnion<DateTime, _i1.PrismaNull>
  >?
  notIn;

  final DateTime? lt;

  final DateTime? lte;

  final DateTime? gt;

  final DateTime? gte;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<_i2.NestedDateTimeNullableFilter, _i1.PrismaNull>
  >?
  not;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'lt': lt,
    'lte': lte,
    'gt': gt,
    'gte': gte,
    'not': not,
  };
}

class NestedBoolFilter implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedBoolFilter({this.equals, this.not});

  final bool? equals;

  final _i1.PrismaUnion<bool, _i2.NestedBoolFilter>? not;

  @override
  Map<String, dynamic> toJson() => {'equals': equals, 'not': not};
}

class BoolFilter implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BoolFilter({this.equals, this.not});

  final bool? equals;

  final _i1.PrismaUnion<bool, _i2.NestedBoolFilter>? not;

  @override
  Map<String, dynamic> toJson() => {'equals': equals, 'not': not};
}

class NestedBoolNullableFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedBoolNullableFilter({this.equals, this.not});

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? equals;

  final _i1.PrismaUnion<
    bool,
    _i1.PrismaUnion<_i2.NestedBoolNullableFilter, _i1.PrismaNull>
  >?
  not;

  @override
  Map<String, dynamic> toJson() => {'equals': equals, 'not': not};
}

class BoolNullableFilter implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BoolNullableFilter({this.equals, this.not});

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? equals;

  final _i1.PrismaUnion<
    bool,
    _i1.PrismaUnion<_i2.NestedBoolNullableFilter, _i1.PrismaNull>
  >?
  not;

  @override
  Map<String, dynamic> toJson() => {'equals': equals, 'not': not};
}

class NestedEnumUserRoleNullableFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedEnumUserRoleNullableFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
  });

  final _i1.PrismaUnion<_i3.UserRole, _i1.PrismaNull>? equals;

  final _i1.PrismaUnion<
    Iterable<_i3.UserRole>,
    _i1.PrismaUnion<_i3.UserRole, _i1.PrismaNull>
  >?
  $in;

  final _i1.PrismaUnion<
    Iterable<_i3.UserRole>,
    _i1.PrismaUnion<_i3.UserRole, _i1.PrismaNull>
  >?
  notIn;

  final _i1.PrismaUnion<
    _i3.UserRole,
    _i1.PrismaUnion<_i2.NestedEnumUserRoleNullableFilter, _i1.PrismaNull>
  >?
  not;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
  };
}

class EnumUserRoleNullableFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumUserRoleNullableFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
  });

  final _i1.PrismaUnion<_i3.UserRole, _i1.PrismaNull>? equals;

  final _i1.PrismaUnion<
    Iterable<_i3.UserRole>,
    _i1.PrismaUnion<_i3.UserRole, _i1.PrismaNull>
  >?
  $in;

  final _i1.PrismaUnion<
    Iterable<_i3.UserRole>,
    _i1.PrismaUnion<_i3.UserRole, _i1.PrismaNull>
  >?
  notIn;

  final _i1.PrismaUnion<
    _i3.UserRole,
    _i1.PrismaUnion<_i2.NestedEnumUserRoleNullableFilter, _i1.PrismaNull>
  >?
  not;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
  };
}

class UserRelationFilter implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserRelationFilter({this.$is, this.isNot});

  final _i1.PrismaUnion<_i2.UserWhereInput, _i1.PrismaNull>? $is;

  final _i1.PrismaUnion<_i2.UserWhereInput, _i1.PrismaNull>? isNot;

  @override
  Map<String, dynamic> toJson() => {'is': $is, 'isNot': isNot};
}

class CookiePreferenceWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CookiePreferenceWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.userId,
    this.essential,
    this.analytics,
    this.marketing,
    this.user,
  });

  final _i1.PrismaUnion<
    _i2.CookiePreferenceWhereInput,
    Iterable<_i2.CookiePreferenceWhereInput>
  >?
  AND;

  final Iterable<_i2.CookiePreferenceWhereInput>? OR;

  final _i1.PrismaUnion<
    _i2.CookiePreferenceWhereInput,
    Iterable<_i2.CookiePreferenceWhereInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? userId;

  final _i1.PrismaUnion<_i2.BoolFilter, bool>? essential;

  final _i1.PrismaUnion<_i2.BoolFilter, bool>? analytics;

  final _i1.PrismaUnion<_i2.BoolFilter, bool>? marketing;

  final _i1.PrismaUnion<_i2.UserRelationFilter, _i2.UserWhereInput>? user;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'userId': userId,
    'essential': essential,
    'analytics': analytics,
    'marketing': marketing,
    'user': user,
  };
}

class CookiePreferenceRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CookiePreferenceRelationFilter({this.$is, this.isNot});

  final _i1.PrismaUnion<_i2.CookiePreferenceWhereInput, _i1.PrismaNull>? $is;

  final _i1.PrismaUnion<_i2.CookiePreferenceWhereInput, _i1.PrismaNull>? isNot;

  @override
  Map<String, dynamic> toJson() => {'is': $is, 'isNot': isNot};
}

class NotificationPreferenceWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NotificationPreferenceWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.userId,
    this.allNotifications,
    this.mentions,
    this.directMessages,
    this.updates,
    this.user,
  });

  final _i1.PrismaUnion<
    _i2.NotificationPreferenceWhereInput,
    Iterable<_i2.NotificationPreferenceWhereInput>
  >?
  AND;

  final Iterable<_i2.NotificationPreferenceWhereInput>? OR;

  final _i1.PrismaUnion<
    _i2.NotificationPreferenceWhereInput,
    Iterable<_i2.NotificationPreferenceWhereInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? userId;

  final _i1.PrismaUnion<_i2.BoolFilter, bool>? allNotifications;

  final _i1.PrismaUnion<_i2.BoolFilter, bool>? mentions;

  final _i1.PrismaUnion<_i2.BoolFilter, bool>? directMessages;

  final _i1.PrismaUnion<_i2.BoolFilter, bool>? updates;

  final _i1.PrismaUnion<_i2.UserRelationFilter, _i2.UserWhereInput>? user;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'userId': userId,
    'allNotifications': allNotifications,
    'mentions': mentions,
    'directMessages': directMessages,
    'updates': updates,
    'user': user,
  };
}

class NotificationPreferenceRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NotificationPreferenceRelationFilter({this.$is, this.isNot});

  final _i1.PrismaUnion<_i2.NotificationPreferenceWhereInput, _i1.PrismaNull>?
  $is;

  final _i1.PrismaUnion<_i2.NotificationPreferenceWhereInput, _i1.PrismaNull>?
  isNot;

  @override
  Map<String, dynamic> toJson() => {'is': $is, 'isNot': isNot};
}

class NestedIntFilter implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedIntFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final int? equals;

  final _i1.PrismaUnion<Iterable<int>, int>? $in;

  final _i1.PrismaUnion<Iterable<int>, int>? notIn;

  final int? lt;

  final int? lte;

  final int? gt;

  final int? gte;

  final _i1.PrismaUnion<int, _i2.NestedIntFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'lt': lt,
    'lte': lte,
    'gt': gt,
    'gte': gte,
    'not': not,
  };
}

class IntFilter implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IntFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final int? equals;

  final _i1.PrismaUnion<Iterable<int>, int>? $in;

  final _i1.PrismaUnion<Iterable<int>, int>? notIn;

  final int? lt;

  final int? lte;

  final int? gt;

  final int? gte;

  final _i1.PrismaUnion<int, _i2.NestedIntFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'lt': lt,
    'lte': lte,
    'gt': gt,
    'gte': gte,
    'not': not,
  };
}

class NestedEnumPaymentGatewayFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedEnumPaymentGatewayFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
  });

  final _i3.PaymentGateway? equals;

  final _i1.PrismaUnion<Iterable<_i3.PaymentGateway>, _i3.PaymentGateway>? $in;

  final _i1.PrismaUnion<Iterable<_i3.PaymentGateway>, _i3.PaymentGateway>?
  notIn;

  final _i1.PrismaUnion<_i3.PaymentGateway, _i2.NestedEnumPaymentGatewayFilter>?
  not;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
  };
}

class EnumPaymentGatewayFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumPaymentGatewayFilter({this.equals, this.$in, this.notIn, this.not});

  final _i3.PaymentGateway? equals;

  final _i1.PrismaUnion<Iterable<_i3.PaymentGateway>, _i3.PaymentGateway>? $in;

  final _i1.PrismaUnion<Iterable<_i3.PaymentGateway>, _i3.PaymentGateway>?
  notIn;

  final _i1.PrismaUnion<_i3.PaymentGateway, _i2.NestedEnumPaymentGatewayFilter>?
  not;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
  };
}

class NestedEnumPaymentStatusFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedEnumPaymentStatusFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
  });

  final _i3.PaymentStatus? equals;

  final _i1.PrismaUnion<Iterable<_i3.PaymentStatus>, _i3.PaymentStatus>? $in;

  final _i1.PrismaUnion<Iterable<_i3.PaymentStatus>, _i3.PaymentStatus>? notIn;

  final _i1.PrismaUnion<_i3.PaymentStatus, _i2.NestedEnumPaymentStatusFilter>?
  not;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
  };
}

class EnumPaymentStatusFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumPaymentStatusFilter({this.equals, this.$in, this.notIn, this.not});

  final _i3.PaymentStatus? equals;

  final _i1.PrismaUnion<Iterable<_i3.PaymentStatus>, _i3.PaymentStatus>? $in;

  final _i1.PrismaUnion<Iterable<_i3.PaymentStatus>, _i3.PaymentStatus>? notIn;

  final _i1.PrismaUnion<_i3.PaymentStatus, _i2.NestedEnumPaymentStatusFilter>?
  not;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
  };
}

class NestedDateTimeFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedDateTimeFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final DateTime? equals;

  final _i1.PrismaUnion<Iterable<DateTime>, DateTime>? $in;

  final _i1.PrismaUnion<Iterable<DateTime>, DateTime>? notIn;

  final DateTime? lt;

  final DateTime? lte;

  final DateTime? gt;

  final DateTime? gte;

  final _i1.PrismaUnion<DateTime, _i2.NestedDateTimeFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'lt': lt,
    'lte': lte,
    'gt': gt,
    'gte': gte,
    'not': not,
  };
}

class DateTimeFilter implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DateTimeFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final DateTime? equals;

  final _i1.PrismaUnion<Iterable<DateTime>, DateTime>? $in;

  final _i1.PrismaUnion<Iterable<DateTime>, DateTime>? notIn;

  final DateTime? lt;

  final DateTime? lte;

  final DateTime? gt;

  final DateTime? gte;

  final _i1.PrismaUnion<DateTime, _i2.NestedDateTimeFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'lt': lt,
    'lte': lte,
    'gt': gt,
    'gte': gte,
    'not': not,
  };
}

class NestedEnumAppointmentsTypeFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedEnumAppointmentsTypeFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
  });

  final _i3.AppointmentsType? equals;

  final _i1.PrismaUnion<Iterable<_i3.AppointmentsType>, _i3.AppointmentsType>?
  $in;

  final _i1.PrismaUnion<Iterable<_i3.AppointmentsType>, _i3.AppointmentsType>?
  notIn;

  final _i1.PrismaUnion<
    _i3.AppointmentsType,
    _i2.NestedEnumAppointmentsTypeFilter
  >?
  not;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
  };
}

class EnumAppointmentsTypeFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumAppointmentsTypeFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
  });

  final _i3.AppointmentsType? equals;

  final _i1.PrismaUnion<Iterable<_i3.AppointmentsType>, _i3.AppointmentsType>?
  $in;

  final _i1.PrismaUnion<Iterable<_i3.AppointmentsType>, _i3.AppointmentsType>?
  notIn;

  final _i1.PrismaUnion<
    _i3.AppointmentsType,
    _i2.NestedEnumAppointmentsTypeFilter
  >?
  not;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
  };
}

class UserListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserListRelationFilter({this.every, this.some, this.none});

  final _i2.UserWhereInput? every;

  final _i2.UserWhereInput? some;

  final _i2.UserWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {'every': every, 'some': some, 'none': none};
}

class NestedEnumPlatformFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedEnumPlatformFilter({this.equals, this.$in, this.notIn, this.not});

  final _i3.Platform? equals;

  final _i1.PrismaUnion<Iterable<_i3.Platform>, _i3.Platform>? $in;

  final _i1.PrismaUnion<Iterable<_i3.Platform>, _i3.Platform>? notIn;

  final _i1.PrismaUnion<_i3.Platform, _i2.NestedEnumPlatformFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
  };
}

class EnumPlatformFilter implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumPlatformFilter({this.equals, this.$in, this.notIn, this.not});

  final _i3.Platform? equals;

  final _i1.PrismaUnion<Iterable<_i3.Platform>, _i3.Platform>? $in;

  final _i1.PrismaUnion<Iterable<_i3.Platform>, _i3.Platform>? notIn;

  final _i1.PrismaUnion<_i3.Platform, _i2.NestedEnumPlatformFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
  };
}

class StringNullableListFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StringNullableListFilter({
    this.equals,
    this.has,
    this.hasEvery,
    this.hasSome,
    this.isEmpty,
  });

  final _i1.PrismaUnion<Iterable<String>, _i1.PrismaNull>? equals;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? has;

  final Iterable<String>? hasEvery;

  final Iterable<String>? hasSome;

  final bool? isEmpty;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'has': has,
    'hasEvery': hasEvery,
    'hasSome': hasSome,
    'isEmpty': isEmpty,
  };
}

class RecordingWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const RecordingWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.title,
    this.recordingUrl,
    this.durationInMinutes,
    this.recordedAt,
    this.meetingSessionId,
    this.createdAt,
    this.updatedAt,
    this.meetingSession,
  });

  final _i1.PrismaUnion<
    _i2.RecordingWhereInput,
    Iterable<_i2.RecordingWhereInput>
  >?
  AND;

  final Iterable<_i2.RecordingWhereInput>? OR;

  final _i1.PrismaUnion<
    _i2.RecordingWhereInput,
    Iterable<_i2.RecordingWhereInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? title;

  final _i1.PrismaUnion<_i2.StringFilter, String>? recordingUrl;

  final _i1.PrismaUnion<_i2.IntFilter, int>? durationInMinutes;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? recordedAt;

  final _i1.PrismaUnion<_i2.StringFilter, String>? meetingSessionId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  final _i1.PrismaUnion<
    _i2.MeetingSessionRelationFilter,
    _i2.MeetingSessionWhereInput
  >?
  meetingSession;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'title': title,
    'recordingUrl': recordingUrl,
    'durationInMinutes': durationInMinutes,
    'recordedAt': recordedAt,
    'meetingSessionId': meetingSessionId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'meetingSession': meetingSession,
  };
}

class RecordingListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const RecordingListRelationFilter({this.every, this.some, this.none});

  final _i2.RecordingWhereInput? every;

  final _i2.RecordingWhereInput? some;

  final _i2.RecordingWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {'every': every, 'some': some, 'none': none};
}

class SlotOfAppointmentRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentRelationFilter({this.$is, this.isNot});

  final _i1.PrismaUnion<_i2.SlotOfAppointmentWhereInput, _i1.PrismaNull>? $is;

  final _i1.PrismaUnion<_i2.SlotOfAppointmentWhereInput, _i1.PrismaNull>? isNot;

  @override
  Map<String, dynamic> toJson() => {'is': $is, 'isNot': isNot};
}

class MeetingSessionWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const MeetingSessionWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.streamCallId,
    this.platform,
    this.passcode,
    this.hostKeys,
    this.slotOfAppointmentId,
    this.createdAt,
    this.updatedAt,
    this.recordings,
    this.slotOfAppointment,
  });

  final _i1.PrismaUnion<
    _i2.MeetingSessionWhereInput,
    Iterable<_i2.MeetingSessionWhereInput>
  >?
  AND;

  final Iterable<_i2.MeetingSessionWhereInput>? OR;

  final _i1.PrismaUnion<
    _i2.MeetingSessionWhereInput,
    Iterable<_i2.MeetingSessionWhereInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? streamCallId;

  final _i1.PrismaUnion<_i2.EnumPlatformFilter, _i3.Platform>? platform;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  passcode;

  final _i2.StringNullableListFilter? hostKeys;

  final _i1.PrismaUnion<_i2.StringFilter, String>? slotOfAppointmentId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  final _i2.RecordingListRelationFilter? recordings;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentRelationFilter,
    _i2.SlotOfAppointmentWhereInput
  >?
  slotOfAppointment;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'streamCallId': streamCallId,
    'platform': platform,
    'passcode': passcode,
    'hostKeys': hostKeys,
    'slotOfAppointmentId': slotOfAppointmentId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'recordings': recordings,
    'slotOfAppointment': slotOfAppointment,
  };
}

class MeetingSessionRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const MeetingSessionRelationFilter({this.$is, this.isNot});

  final _i1.PrismaUnion<_i2.MeetingSessionWhereInput, _i1.PrismaNull>? $is;

  final _i1.PrismaUnion<_i2.MeetingSessionWhereInput, _i1.PrismaNull>? isNot;

  @override
  Map<String, dynamic> toJson() => {'is': $is, 'isNot': isNot};
}

class SlotOfAppointmentWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.slotStartTimeInUTC,
    this.slotEndTimeInUTC,
    this.isTentative,
    this.appointmentId,
    this.createdAt,
    this.updatedAt,
    this.user,
    this.appointment,
    this.meetingSession,
  });

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentWhereInput,
    Iterable<_i2.SlotOfAppointmentWhereInput>
  >?
  AND;

  final Iterable<_i2.SlotOfAppointmentWhereInput>? OR;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentWhereInput,
    Iterable<_i2.SlotOfAppointmentWhereInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? slotStartTimeInUTC;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? slotEndTimeInUTC;

  final _i1.PrismaUnion<_i2.BoolFilter, bool>? isTentative;

  final _i1.PrismaUnion<_i2.StringFilter, String>? appointmentId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  final _i2.UserListRelationFilter? user;

  final _i1.PrismaUnion<
    _i2.AppointmentRelationFilter,
    _i2.AppointmentWhereInput
  >?
  appointment;

  final _i1.PrismaUnion<
    _i2.MeetingSessionRelationFilter,
    _i1.PrismaUnion<_i2.MeetingSessionWhereInput, _i1.PrismaNull>
  >?
  meetingSession;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'isTentative': isTentative,
    'appointmentId': appointmentId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'user': user,
    'appointment': appointment,
    'meetingSession': meetingSession,
  };
}

class SlotOfAppointmentListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentListRelationFilter({this.every, this.some, this.none});

  final _i2.SlotOfAppointmentWhereInput? every;

  final _i2.SlotOfAppointmentWhereInput? some;

  final _i2.SlotOfAppointmentWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {'every': every, 'some': some, 'none': none};
}

class NestedEnumRequestStatusFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedEnumRequestStatusFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
  });

  final _i3.RequestStatus? equals;

  final _i1.PrismaUnion<Iterable<_i3.RequestStatus>, _i3.RequestStatus>? $in;

  final _i1.PrismaUnion<Iterable<_i3.RequestStatus>, _i3.RequestStatus>? notIn;

  final _i1.PrismaUnion<_i3.RequestStatus, _i2.NestedEnumRequestStatusFilter>?
  not;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
  };
}

class EnumRequestStatusFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumRequestStatusFilter({this.equals, this.$in, this.notIn, this.not});

  final _i3.RequestStatus? equals;

  final _i1.PrismaUnion<Iterable<_i3.RequestStatus>, _i3.RequestStatus>? $in;

  final _i1.PrismaUnion<Iterable<_i3.RequestStatus>, _i3.RequestStatus>? notIn;

  final _i1.PrismaUnion<_i3.RequestStatus, _i2.NestedEnumRequestStatusFilter>?
  not;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
  };
}

class NestedFloatNullableFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedFloatNullableFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final _i1.PrismaUnion<double, _i1.PrismaNull>? equals;

  final _i1.PrismaUnion<
    Iterable<double>,
    _i1.PrismaUnion<double, _i1.PrismaNull>
  >?
  $in;

  final _i1.PrismaUnion<
    Iterable<double>,
    _i1.PrismaUnion<double, _i1.PrismaNull>
  >?
  notIn;

  final double? lt;

  final double? lte;

  final double? gt;

  final double? gte;

  final _i1.PrismaUnion<
    double,
    _i1.PrismaUnion<_i2.NestedFloatNullableFilter, _i1.PrismaNull>
  >?
  not;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'lt': lt,
    'lte': lte,
    'gt': gt,
    'gte': gte,
    'not': not,
  };
}

class FloatNullableFilter implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FloatNullableFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final _i1.PrismaUnion<double, _i1.PrismaNull>? equals;

  final _i1.PrismaUnion<
    Iterable<double>,
    _i1.PrismaUnion<double, _i1.PrismaNull>
  >?
  $in;

  final _i1.PrismaUnion<
    Iterable<double>,
    _i1.PrismaUnion<double, _i1.PrismaNull>
  >?
  notIn;

  final double? lt;

  final double? lte;

  final double? gt;

  final double? gte;

  final _i1.PrismaUnion<
    double,
    _i1.PrismaUnion<_i2.NestedFloatNullableFilter, _i1.PrismaNull>
  >?
  not;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'lt': lt,
    'lte': lte,
    'gt': gt,
    'gte': gte,
    'not': not,
  };
}

class NestedFloatFilter implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedFloatFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final double? equals;

  final _i1.PrismaUnion<Iterable<double>, double>? $in;

  final _i1.PrismaUnion<Iterable<double>, double>? notIn;

  final double? lt;

  final double? lte;

  final double? gt;

  final double? gte;

  final _i1.PrismaUnion<double, _i2.NestedFloatFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'lt': lt,
    'lte': lte,
    'gt': gt,
    'gte': gte,
    'not': not,
  };
}

class FloatFilter implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FloatFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final double? equals;

  final _i1.PrismaUnion<Iterable<double>, double>? $in;

  final _i1.PrismaUnion<Iterable<double>, double>? notIn;

  final double? lt;

  final double? lte;

  final double? gt;

  final double? gte;

  final _i1.PrismaUnion<double, _i2.NestedFloatFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'lt': lt,
    'lte': lte,
    'gt': gt,
    'gte': gte,
    'not': not,
  };
}

class NestedEnumScheduleTypeFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedEnumScheduleTypeFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
  });

  final _i3.ScheduleType? equals;

  final _i1.PrismaUnion<Iterable<_i3.ScheduleType>, _i3.ScheduleType>? $in;

  final _i1.PrismaUnion<Iterable<_i3.ScheduleType>, _i3.ScheduleType>? notIn;

  final _i1.PrismaUnion<_i3.ScheduleType, _i2.NestedEnumScheduleTypeFilter>?
  not;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
  };
}

class EnumScheduleTypeFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumScheduleTypeFilter({this.equals, this.$in, this.notIn, this.not});

  final _i3.ScheduleType? equals;

  final _i1.PrismaUnion<Iterable<_i3.ScheduleType>, _i3.ScheduleType>? $in;

  final _i1.PrismaUnion<Iterable<_i3.ScheduleType>, _i3.ScheduleType>? notIn;

  final _i1.PrismaUnion<_i3.ScheduleType, _i2.NestedEnumScheduleTypeFilter>?
  not;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
  };
}

class ConsultantProfileListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileListRelationFilter({this.every, this.some, this.none});

  final _i2.ConsultantProfileWhereInput? every;

  final _i2.ConsultantProfileWhereInput? some;

  final _i2.ConsultantProfileWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {'every': every, 'some': some, 'none': none};
}

class SubDomainWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.name,
    this.domainId,
    this.createdAt,
    this.updatedAt,
    this.domain,
    this.consultantProfiles,
  });

  final _i1.PrismaUnion<
    _i2.SubDomainWhereInput,
    Iterable<_i2.SubDomainWhereInput>
  >?
  AND;

  final Iterable<_i2.SubDomainWhereInput>? OR;

  final _i1.PrismaUnion<
    _i2.SubDomainWhereInput,
    Iterable<_i2.SubDomainWhereInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? name;

  final _i1.PrismaUnion<_i2.StringFilter, String>? domainId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  final _i1.PrismaUnion<_i2.DomainRelationFilter, _i2.DomainWhereInput>? domain;

  final _i2.ConsultantProfileListRelationFilter? consultantProfiles;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'name': name,
    'domainId': domainId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'domain': domain,
    'consultantProfiles': consultantProfiles,
  };
}

class SubDomainListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainListRelationFilter({this.every, this.some, this.none});

  final _i2.SubDomainWhereInput? every;

  final _i2.SubDomainWhereInput? some;

  final _i2.SubDomainWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {'every': every, 'some': some, 'none': none};
}

class TagWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.name,
    this.domainId,
    this.createdAt,
    this.updatedAt,
    this.domain,
    this.consultantProfiles,
  });

  final _i1.PrismaUnion<_i2.TagWhereInput, Iterable<_i2.TagWhereInput>>? AND;

  final Iterable<_i2.TagWhereInput>? OR;

  final _i1.PrismaUnion<_i2.TagWhereInput, Iterable<_i2.TagWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? name;

  final _i1.PrismaUnion<_i2.StringFilter, String>? domainId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  final _i1.PrismaUnion<_i2.DomainRelationFilter, _i2.DomainWhereInput>? domain;

  final _i2.ConsultantProfileListRelationFilter? consultantProfiles;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'name': name,
    'domainId': domainId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'domain': domain,
    'consultantProfiles': consultantProfiles,
  };
}

class TagListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagListRelationFilter({this.every, this.some, this.none});

  final _i2.TagWhereInput? every;

  final _i2.TagWhereInput? some;

  final _i2.TagWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {'every': every, 'some': some, 'none': none};
}

class DomainWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomainWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
    this.subDomains,
    this.tags,
    this.consultantProfiles,
  });

  final _i1.PrismaUnion<_i2.DomainWhereInput, Iterable<_i2.DomainWhereInput>>?
  AND;

  final Iterable<_i2.DomainWhereInput>? OR;

  final _i1.PrismaUnion<_i2.DomainWhereInput, Iterable<_i2.DomainWhereInput>>?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? name;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  final _i2.SubDomainListRelationFilter? subDomains;

  final _i2.TagListRelationFilter? tags;

  final _i2.ConsultantProfileListRelationFilter? consultantProfiles;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'subDomains': subDomains,
    'tags': tags,
    'consultantProfiles': consultantProfiles,
  };
}

class DomainRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomainRelationFilter({this.$is, this.isNot});

  final _i1.PrismaUnion<_i2.DomainWhereInput, _i1.PrismaNull>? $is;

  final _i1.PrismaUnion<_i2.DomainWhereInput, _i1.PrismaNull>? isNot;

  @override
  Map<String, dynamic> toJson() => {'is': $is, 'isNot': isNot};
}

class NestedEnumConsultationModeNullableFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedEnumConsultationModeNullableFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
  });

  final _i1.PrismaUnion<_i3.ConsultationMode, _i1.PrismaNull>? equals;

  final _i1.PrismaUnion<
    Iterable<_i3.ConsultationMode>,
    _i1.PrismaUnion<_i3.ConsultationMode, _i1.PrismaNull>
  >?
  $in;

  final _i1.PrismaUnion<
    Iterable<_i3.ConsultationMode>,
    _i1.PrismaUnion<_i3.ConsultationMode, _i1.PrismaNull>
  >?
  notIn;

  final _i1.PrismaUnion<
    _i3.ConsultationMode,
    _i1.PrismaUnion<
      _i2.NestedEnumConsultationModeNullableFilter,
      _i1.PrismaNull
    >
  >?
  not;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
  };
}

class EnumConsultationModeNullableFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumConsultationModeNullableFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
  });

  final _i1.PrismaUnion<_i3.ConsultationMode, _i1.PrismaNull>? equals;

  final _i1.PrismaUnion<
    Iterable<_i3.ConsultationMode>,
    _i1.PrismaUnion<_i3.ConsultationMode, _i1.PrismaNull>
  >?
  $in;

  final _i1.PrismaUnion<
    Iterable<_i3.ConsultationMode>,
    _i1.PrismaUnion<_i3.ConsultationMode, _i1.PrismaNull>
  >?
  notIn;

  final _i1.PrismaUnion<
    _i3.ConsultationMode,
    _i1.PrismaUnion<
      _i2.NestedEnumConsultationModeNullableFilter,
      _i1.PrismaNull
    >
  >?
  not;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
  };
}

class ConsultationListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationListRelationFilter({this.every, this.some, this.none});

  final _i2.ConsultationWhereInput? every;

  final _i2.ConsultationWhereInput? some;

  final _i2.ConsultationWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {'every': every, 'some': some, 'none': none};
}

class NestedEnumPlanEmailSupportFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedEnumPlanEmailSupportFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
  });

  final _i3.PlanEmailSupport? equals;

  final _i1.PrismaUnion<Iterable<_i3.PlanEmailSupport>, _i3.PlanEmailSupport>?
  $in;

  final _i1.PrismaUnion<Iterable<_i3.PlanEmailSupport>, _i3.PlanEmailSupport>?
  notIn;

  final _i1.PrismaUnion<
    _i3.PlanEmailSupport,
    _i2.NestedEnumPlanEmailSupportFilter
  >?
  not;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
  };
}

class EnumPlanEmailSupportFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumPlanEmailSupportFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
  });

  final _i3.PlanEmailSupport? equals;

  final _i1.PrismaUnion<Iterable<_i3.PlanEmailSupport>, _i3.PlanEmailSupport>?
  $in;

  final _i1.PrismaUnion<Iterable<_i3.PlanEmailSupport>, _i3.PlanEmailSupport>?
  notIn;

  final _i1.PrismaUnion<
    _i3.PlanEmailSupport,
    _i2.NestedEnumPlanEmailSupportFilter
  >?
  not;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
  };
}

class SubscriptionPlanWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.title,
    this.description,
    this.durationInMonths,
    this.price,
    this.callsPerWeek,
    this.sessionDurationInHours,
    this.videoMeetings,
    this.emailSupport,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.consultantProfile,
    this.subscriptions,
  });

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanWhereInput,
    Iterable<_i2.SubscriptionPlanWhereInput>
  >?
  AND;

  final Iterable<_i2.SubscriptionPlanWhereInput>? OR;

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanWhereInput,
    Iterable<_i2.SubscriptionPlanWhereInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? title;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  description;

  final _i1.PrismaUnion<_i2.IntFilter, int>? durationInMonths;

  final _i1.PrismaUnion<_i2.IntFilter, int>? price;

  final _i1.PrismaUnion<_i2.IntFilter, int>? callsPerWeek;

  final _i1.PrismaUnion<_i2.FloatFilter, double>? sessionDurationInHours;

  final _i1.PrismaUnion<_i2.IntFilter, int>? videoMeetings;

  final _i1.PrismaUnion<_i2.EnumPlanEmailSupportFilter, _i3.PlanEmailSupport>?
  emailSupport;

  final _i1.PrismaUnion<_i2.StringFilter, String>? language;

  final _i1.PrismaUnion<_i2.StringFilter, String>? level;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  prerequisites;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  materialProvided;

  final _i2.StringNullableListFilter? learningOutcomes;

  final _i1.PrismaUnion<_i2.StringFilter, String>? consultantProfileId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileRelationFilter,
    _i2.ConsultantProfileWhereInput
  >?
  consultantProfile;

  final _i2.SubscriptionListRelationFilter? subscriptions;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'title': title,
    'description': description,
    'durationInMonths': durationInMonths,
    'price': price,
    'callsPerWeek': callsPerWeek,
    'sessionDurationInHours': sessionDurationInHours,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultantProfile': consultantProfile,
    'subscriptions': subscriptions,
  };
}

class SubscriptionPlanRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanRelationFilter({this.$is, this.isNot});

  final _i1.PrismaUnion<_i2.SubscriptionPlanWhereInput, _i1.PrismaNull>? $is;

  final _i1.PrismaUnion<_i2.SubscriptionPlanWhereInput, _i1.PrismaNull>? isNot;

  @override
  Map<String, dynamic> toJson() => {'is': $is, 'isNot': isNot};
}

class AppointmentListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentListRelationFilter({this.every, this.some, this.none});

  final _i2.AppointmentWhereInput? every;

  final _i2.AppointmentWhereInput? some;

  final _i2.AppointmentWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {'every': every, 'some': some, 'none': none};
}

class SubscriptionWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.startDate,
    this.endDate,
    this.requestStatus,
    this.requestedById,
    this.requestedAt,
    this.requestNotes,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.subscriptionPlanId,
    this.createdAt,
    this.updatedAt,
    this.requestedBy,
    this.subscriptionPlan,
    this.appointments,
  });

  final _i1.PrismaUnion<
    _i2.SubscriptionWhereInput,
    Iterable<_i2.SubscriptionWhereInput>
  >?
  AND;

  final Iterable<_i2.SubscriptionWhereInput>? OR;

  final _i1.PrismaUnion<
    _i2.SubscriptionWhereInput,
    Iterable<_i2.SubscriptionWhereInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? startDate;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? endDate;

  final _i1.PrismaUnion<_i2.EnumRequestStatusFilter, _i3.RequestStatus>?
  requestStatus;

  final _i1.PrismaUnion<_i2.StringFilter, String>? requestedById;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? requestedAt;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  requestNotes;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  feedbackFromConsultee;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  feedbackFromConsultant;

  final _i1.PrismaUnion<
    _i2.FloatNullableFilter,
    _i1.PrismaUnion<double, _i1.PrismaNull>
  >?
  rating;

  final _i1.PrismaUnion<_i2.StringFilter, String>? subscriptionPlanId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  final _i1.PrismaUnion<
    _i2.ConsulteeProfileRelationFilter,
    _i2.ConsulteeProfileWhereInput
  >?
  requestedBy;

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanRelationFilter,
    _i2.SubscriptionPlanWhereInput
  >?
  subscriptionPlan;

  final _i2.AppointmentListRelationFilter? appointments;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'requestStatus': requestStatus,
    'requestedById': requestedById,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'subscriptionPlanId': subscriptionPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'requestedBy': requestedBy,
    'subscriptionPlan': subscriptionPlan,
    'appointments': appointments,
  };
}

class SubscriptionListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionListRelationFilter({this.every, this.some, this.none});

  final _i2.SubscriptionWhereInput? every;

  final _i2.SubscriptionWhereInput? some;

  final _i2.SubscriptionWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {'every': every, 'some': some, 'none': none};
}

class ConsulteeProfileWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.education,
    this.occupation,
    this.aboutMe,
    this.preferredCommunicationMethod,
    this.preferredLanguage,
    this.specialRequirements,
    this.interests,
    this.goals,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.consultationRequests,
    this.subscriptionRequests,
    this.consultantReviews,
    this.user,
  });

  final _i1.PrismaUnion<
    _i2.ConsulteeProfileWhereInput,
    Iterable<_i2.ConsulteeProfileWhereInput>
  >?
  AND;

  final Iterable<_i2.ConsulteeProfileWhereInput>? OR;

  final _i1.PrismaUnion<
    _i2.ConsulteeProfileWhereInput,
    Iterable<_i2.ConsulteeProfileWhereInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  education;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  occupation;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  aboutMe;

  final _i1.PrismaUnion<
    _i2.EnumConsultationModeNullableFilter,
    _i1.PrismaUnion<_i3.ConsultationMode, _i1.PrismaNull>
  >?
  preferredCommunicationMethod;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  preferredLanguage;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  specialRequirements;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  interests;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  goals;

  final _i1.PrismaUnion<_i2.StringFilter, String>? userId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  final _i2.ConsultationListRelationFilter? consultationRequests;

  final _i2.SubscriptionListRelationFilter? subscriptionRequests;

  final _i2.ConsultantReviewListRelationFilter? consultantReviews;

  final _i1.PrismaUnion<_i2.UserRelationFilter, _i2.UserWhereInput>? user;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'education': education,
    'occupation': occupation,
    'aboutMe': aboutMe,
    'preferredCommunicationMethod': preferredCommunicationMethod,
    'preferredLanguage': preferredLanguage,
    'specialRequirements': specialRequirements,
    'interests': interests,
    'goals': goals,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultationRequests': consultationRequests,
    'subscriptionRequests': subscriptionRequests,
    'consultantReviews': consultantReviews,
    'user': user,
  };
}

class ConsulteeProfileRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileRelationFilter({this.$is, this.isNot});

  final _i1.PrismaUnion<_i2.ConsulteeProfileWhereInput, _i1.PrismaNull>? $is;

  final _i1.PrismaUnion<_i2.ConsulteeProfileWhereInput, _i1.PrismaNull>? isNot;

  @override
  Map<String, dynamic> toJson() => {'is': $is, 'isNot': isNot};
}

class ConsultantReviewWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.rating,
    this.reviewDescription,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.createdAt,
    this.updatedAt,
    this.consultantProfile,
    this.consulteeProfile,
  });

  final _i1.PrismaUnion<
    _i2.ConsultantReviewWhereInput,
    Iterable<_i2.ConsultantReviewWhereInput>
  >?
  AND;

  final Iterable<_i2.ConsultantReviewWhereInput>? OR;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewWhereInput,
    Iterable<_i2.ConsultantReviewWhereInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.IntFilter, int>? rating;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  reviewDescription;

  final _i1.PrismaUnion<_i2.StringFilter, String>? consultantProfileId;

  final _i1.PrismaUnion<_i2.StringFilter, String>? consulteeProfileId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileRelationFilter,
    _i2.ConsultantProfileWhereInput
  >?
  consultantProfile;

  final _i1.PrismaUnion<
    _i2.ConsulteeProfileRelationFilter,
    _i2.ConsulteeProfileWhereInput
  >?
  consulteeProfile;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'rating': rating,
    'reviewDescription': reviewDescription,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
  };
}

class ConsultantReviewListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewListRelationFilter({this.every, this.some, this.none});

  final _i2.ConsultantReviewWhereInput? every;

  final _i2.ConsultantReviewWhereInput? some;

  final _i2.ConsultantReviewWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {'every': every, 'some': some, 'none': none};
}

class NestedEnumDayOfWeekFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedEnumDayOfWeekFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
  });

  final _i3.DayOfWeek? equals;

  final _i1.PrismaUnion<Iterable<_i3.DayOfWeek>, _i3.DayOfWeek>? $in;

  final _i1.PrismaUnion<Iterable<_i3.DayOfWeek>, _i3.DayOfWeek>? notIn;

  final _i1.PrismaUnion<_i3.DayOfWeek, _i2.NestedEnumDayOfWeekFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
  };
}

class EnumDayOfWeekFilter implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumDayOfWeekFilter({this.equals, this.$in, this.notIn, this.not});

  final _i3.DayOfWeek? equals;

  final _i1.PrismaUnion<Iterable<_i3.DayOfWeek>, _i3.DayOfWeek>? $in;

  final _i1.PrismaUnion<Iterable<_i3.DayOfWeek>, _i3.DayOfWeek>? notIn;

  final _i1.PrismaUnion<_i3.DayOfWeek, _i2.NestedEnumDayOfWeekFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
  };
}

class SlotOfAvailabilityWeeklyWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityWeeklyWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.dayOfWeekforStartTimeInUTC,
    this.slotStartTimeInUTC,
    this.dayOfWeekforEndTimeInUTC,
    this.slotEndTimeInUTC,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.consultantProfile,
  });

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityWeeklyWhereInput,
    Iterable<_i2.SlotOfAvailabilityWeeklyWhereInput>
  >?
  AND;

  final Iterable<_i2.SlotOfAvailabilityWeeklyWhereInput>? OR;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityWeeklyWhereInput,
    Iterable<_i2.SlotOfAvailabilityWeeklyWhereInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.EnumDayOfWeekFilter, _i3.DayOfWeek>?
  dayOfWeekforStartTimeInUTC;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? slotStartTimeInUTC;

  final _i1.PrismaUnion<_i2.EnumDayOfWeekFilter, _i3.DayOfWeek>?
  dayOfWeekforEndTimeInUTC;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? slotEndTimeInUTC;

  final _i1.PrismaUnion<_i2.StringFilter, String>? consultantProfileId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileRelationFilter,
    _i2.ConsultantProfileWhereInput
  >?
  consultantProfile;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'dayOfWeekforStartTimeInUTC': dayOfWeekforStartTimeInUTC,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'dayOfWeekforEndTimeInUTC': dayOfWeekforEndTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultantProfile': consultantProfile,
  };
}

class SlotOfAvailabilityWeeklyListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityWeeklyListRelationFilter({
    this.every,
    this.some,
    this.none,
  });

  final _i2.SlotOfAvailabilityWeeklyWhereInput? every;

  final _i2.SlotOfAvailabilityWeeklyWhereInput? some;

  final _i2.SlotOfAvailabilityWeeklyWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {'every': every, 'some': some, 'none': none};
}

class SlotOfAvailabilityCustomWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityCustomWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.slotStartTimeInUTC,
    this.slotEndTimeInUTC,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.consultantProfile,
  });

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityCustomWhereInput,
    Iterable<_i2.SlotOfAvailabilityCustomWhereInput>
  >?
  AND;

  final Iterable<_i2.SlotOfAvailabilityCustomWhereInput>? OR;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityCustomWhereInput,
    Iterable<_i2.SlotOfAvailabilityCustomWhereInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? slotStartTimeInUTC;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? slotEndTimeInUTC;

  final _i1.PrismaUnion<_i2.StringFilter, String>? consultantProfileId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileRelationFilter,
    _i2.ConsultantProfileWhereInput
  >?
  consultantProfile;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultantProfile': consultantProfile,
  };
}

class SlotOfAvailabilityCustomListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityCustomListRelationFilter({
    this.every,
    this.some,
    this.none,
  });

  final _i2.SlotOfAvailabilityCustomWhereInput? every;

  final _i2.SlotOfAvailabilityCustomWhereInput? some;

  final _i2.SlotOfAvailabilityCustomWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {'every': every, 'some': some, 'none': none};
}

class ConsultationPlanListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanListRelationFilter({this.every, this.some, this.none});

  final _i2.ConsultationPlanWhereInput? every;

  final _i2.ConsultationPlanWhereInput? some;

  final _i2.ConsultationPlanWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {'every': every, 'some': some, 'none': none};
}

class SubscriptionPlanListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanListRelationFilter({this.every, this.some, this.none});

  final _i2.SubscriptionPlanWhereInput? every;

  final _i2.SubscriptionPlanWhereInput? some;

  final _i2.SubscriptionPlanWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {'every': every, 'some': some, 'none': none};
}

class ClassPlanRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanRelationFilter({this.$is, this.isNot});

  final _i1.PrismaUnion<_i2.ClassPlanWhereInput, _i1.PrismaNull>? $is;

  final _i1.PrismaUnion<_i2.ClassPlanWhereInput, _i1.PrismaNull>? isNot;

  @override
  Map<String, dynamic> toJson() => {'is': $is, 'isNot': isNot};
}

class ClassContentWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassContentWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.title,
    this.description,
    this.contentType,
    this.contentUrl,
    this.order,
    this.hoursAllotted,
    this.classPlanId,
    this.createdAt,
    this.updatedAt,
    this.classPlan,
  });

  final _i1.PrismaUnion<
    _i2.ClassContentWhereInput,
    Iterable<_i2.ClassContentWhereInput>
  >?
  AND;

  final Iterable<_i2.ClassContentWhereInput>? OR;

  final _i1.PrismaUnion<
    _i2.ClassContentWhereInput,
    Iterable<_i2.ClassContentWhereInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? title;

  final _i1.PrismaUnion<_i2.StringFilter, String>? description;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  contentType;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  contentUrl;

  final _i1.PrismaUnion<_i2.IntFilter, int>? order;

  final _i1.PrismaUnion<_i2.FloatFilter, double>? hoursAllotted;

  final _i1.PrismaUnion<_i2.StringFilter, String>? classPlanId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  final _i1.PrismaUnion<_i2.ClassPlanRelationFilter, _i2.ClassPlanWhereInput>?
  classPlan;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'title': title,
    'description': description,
    'contentType': contentType,
    'contentUrl': contentUrl,
    'order': order,
    'hoursAllotted': hoursAllotted,
    'classPlanId': classPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'classPlan': classPlan,
  };
}

class ClassContentListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassContentListRelationFilter({this.every, this.some, this.none});

  final _i2.ClassContentWhereInput? every;

  final _i2.ClassContentWhereInput? some;

  final _i2.ClassContentWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {'every': every, 'some': some, 'none': none};
}

class NestedEnumClassStatusFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedEnumClassStatusFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
  });

  final _i3.ClassStatus? equals;

  final _i1.PrismaUnion<Iterable<_i3.ClassStatus>, _i3.ClassStatus>? $in;

  final _i1.PrismaUnion<Iterable<_i3.ClassStatus>, _i3.ClassStatus>? notIn;

  final _i1.PrismaUnion<_i3.ClassStatus, _i2.NestedEnumClassStatusFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
  };
}

class EnumClassStatusFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumClassStatusFilter({this.equals, this.$in, this.notIn, this.not});

  final _i3.ClassStatus? equals;

  final _i1.PrismaUnion<Iterable<_i3.ClassStatus>, _i3.ClassStatus>? $in;

  final _i1.PrismaUnion<Iterable<_i3.ClassStatus>, _i3.ClassStatus>? notIn;

  final _i1.PrismaUnion<_i3.ClassStatus, _i2.NestedEnumClassStatusFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
  };
}

class NestedEnumWebinarStatusFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedEnumWebinarStatusFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
  });

  final _i3.WebinarStatus? equals;

  final _i1.PrismaUnion<Iterable<_i3.WebinarStatus>, _i3.WebinarStatus>? $in;

  final _i1.PrismaUnion<Iterable<_i3.WebinarStatus>, _i3.WebinarStatus>? notIn;

  final _i1.PrismaUnion<_i3.WebinarStatus, _i2.NestedEnumWebinarStatusFilter>?
  not;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
  };
}

class EnumWebinarStatusFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumWebinarStatusFilter({this.equals, this.$in, this.notIn, this.not});

  final _i3.WebinarStatus? equals;

  final _i1.PrismaUnion<Iterable<_i3.WebinarStatus>, _i3.WebinarStatus>? $in;

  final _i1.PrismaUnion<Iterable<_i3.WebinarStatus>, _i3.WebinarStatus>? notIn;

  final _i1.PrismaUnion<_i3.WebinarStatus, _i2.NestedEnumWebinarStatusFilter>?
  not;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
  };
}

class WebinarPlanRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanRelationFilter({this.$is, this.isNot});

  final _i1.PrismaUnion<_i2.WebinarPlanWhereInput, _i1.PrismaNull>? $is;

  final _i1.PrismaUnion<_i2.WebinarPlanWhereInput, _i1.PrismaNull>? isNot;

  @override
  Map<String, dynamic> toJson() => {'is': $is, 'isNot': isNot};
}

class WebinarWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.status,
    this.feedbackSummary,
    this.webinarPlanId,
    this.createdAt,
    this.updatedAt,
    this.waitlist,
    this.webinarPlan,
    this.appointment,
  });

  final _i1.PrismaUnion<_i2.WebinarWhereInput, Iterable<_i2.WebinarWhereInput>>?
  AND;

  final Iterable<_i2.WebinarWhereInput>? OR;

  final _i1.PrismaUnion<_i2.WebinarWhereInput, Iterable<_i2.WebinarWhereInput>>?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.EnumWebinarStatusFilter, _i3.WebinarStatus>? status;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  feedbackSummary;

  final _i1.PrismaUnion<_i2.StringFilter, String>? webinarPlanId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  final _i2.WaitlistListRelationFilter? waitlist;

  final _i1.PrismaUnion<
    _i2.WebinarPlanRelationFilter,
    _i2.WebinarPlanWhereInput
  >?
  webinarPlan;

  final _i1.PrismaUnion<
    _i2.AppointmentRelationFilter,
    _i1.PrismaUnion<_i2.AppointmentWhereInput, _i1.PrismaNull>
  >?
  appointment;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'status': status,
    'feedbackSummary': feedbackSummary,
    'webinarPlanId': webinarPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'waitlist': waitlist,
    'webinarPlan': webinarPlan,
    'appointment': appointment,
  };
}

class WebinarRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarRelationFilter({this.$is, this.isNot});

  final _i1.PrismaUnion<_i2.WebinarWhereInput, _i1.PrismaNull>? $is;

  final _i1.PrismaUnion<_i2.WebinarWhereInput, _i1.PrismaNull>? isNot;

  @override
  Map<String, dynamic> toJson() => {'is': $is, 'isNot': isNot};
}

class ClassRelationFilter implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassRelationFilter({this.$is, this.isNot});

  final _i1.PrismaUnion<_i2.ClassWhereInput, _i1.PrismaNull>? $is;

  final _i1.PrismaUnion<_i2.ClassWhereInput, _i1.PrismaNull>? isNot;

  @override
  Map<String, dynamic> toJson() => {'is': $is, 'isNot': isNot};
}

class WaitlistWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.joinedAt,
    this.userId,
    this.webinarId,
    this.classId,
    this.user,
    this.webinar,
    this.$class,
  });

  final _i1.PrismaUnion<
    _i2.WaitlistWhereInput,
    Iterable<_i2.WaitlistWhereInput>
  >?
  AND;

  final Iterable<_i2.WaitlistWhereInput>? OR;

  final _i1.PrismaUnion<
    _i2.WaitlistWhereInput,
    Iterable<_i2.WaitlistWhereInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? joinedAt;

  final _i1.PrismaUnion<_i2.StringFilter, String>? userId;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  webinarId;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  classId;

  final _i1.PrismaUnion<_i2.UserRelationFilter, _i2.UserWhereInput>? user;

  final _i1.PrismaUnion<
    _i2.WebinarRelationFilter,
    _i1.PrismaUnion<_i2.WebinarWhereInput, _i1.PrismaNull>
  >?
  webinar;

  final _i1.PrismaUnion<
    _i2.ClassRelationFilter,
    _i1.PrismaUnion<_i2.ClassWhereInput, _i1.PrismaNull>
  >?
  $class;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'joinedAt': joinedAt,
    'userId': userId,
    'webinarId': webinarId,
    'classId': classId,
    'user': user,
    'webinar': webinar,
    'class': $class,
  };
}

class WaitlistListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistListRelationFilter({this.every, this.some, this.none});

  final _i2.WaitlistWhereInput? every;

  final _i2.WaitlistWhereInput? some;

  final _i2.WaitlistWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {'every': every, 'some': some, 'none': none};
}

class ClassWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.startDate,
    this.endDate,
    this.status,
    this.recordingUrls,
    this.feedbackSummary,
    this.classPlanId,
    this.createdAt,
    this.updatedAt,
    this.waitlist,
    this.classPlan,
    this.appointments,
  });

  final _i1.PrismaUnion<_i2.ClassWhereInput, Iterable<_i2.ClassWhereInput>>?
  AND;

  final Iterable<_i2.ClassWhereInput>? OR;

  final _i1.PrismaUnion<_i2.ClassWhereInput, Iterable<_i2.ClassWhereInput>>?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<
    _i2.DateTimeNullableFilter,
    _i1.PrismaUnion<DateTime, _i1.PrismaNull>
  >?
  startDate;

  final _i1.PrismaUnion<
    _i2.DateTimeNullableFilter,
    _i1.PrismaUnion<DateTime, _i1.PrismaNull>
  >?
  endDate;

  final _i1.PrismaUnion<_i2.EnumClassStatusFilter, _i3.ClassStatus>? status;

  final _i2.StringNullableListFilter? recordingUrls;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  feedbackSummary;

  final _i1.PrismaUnion<_i2.StringFilter, String>? classPlanId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  final _i2.WaitlistListRelationFilter? waitlist;

  final _i1.PrismaUnion<_i2.ClassPlanRelationFilter, _i2.ClassPlanWhereInput>?
  classPlan;

  final _i2.AppointmentListRelationFilter? appointments;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'status': status,
    'recordingUrls': recordingUrls,
    'feedbackSummary': feedbackSummary,
    'classPlanId': classPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'waitlist': waitlist,
    'classPlan': classPlan,
    'appointments': appointments,
  };
}

class ClassListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassListRelationFilter({this.every, this.some, this.none});

  final _i2.ClassWhereInput? every;

  final _i2.ClassWhereInput? some;

  final _i2.ClassWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {'every': every, 'some': some, 'none': none};
}

class ClassPlanWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInMonths,
    this.callsPerWeek,
    this.videoMeetings,
    this.emailSupport,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.topics,
    this.classContents,
    this.consultantProfile,
    this.classes,
  });

  final _i1.PrismaUnion<
    _i2.ClassPlanWhereInput,
    Iterable<_i2.ClassPlanWhereInput>
  >?
  AND;

  final Iterable<_i2.ClassPlanWhereInput>? OR;

  final _i1.PrismaUnion<
    _i2.ClassPlanWhereInput,
    Iterable<_i2.ClassPlanWhereInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? title;

  final _i1.PrismaUnion<_i2.StringFilter, String>? description;

  final _i1.PrismaUnion<_i2.IntFilter, int>? price;

  final _i1.PrismaUnion<_i2.StringFilter, String>? priceCurrency;

  final _i1.PrismaUnion<_i2.BoolFilter, bool>? certificateProvided;

  final _i1.PrismaUnion<_i2.IntFilter, int>? durationInMonths;

  final _i1.PrismaUnion<_i2.IntFilter, int>? callsPerWeek;

  final _i1.PrismaUnion<_i2.IntFilter, int>? videoMeetings;

  final _i1.PrismaUnion<_i2.EnumPlanEmailSupportFilter, _i3.PlanEmailSupport>?
  emailSupport;

  final _i1.PrismaUnion<_i2.IntFilter, int>? maxParticipants;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  language;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  level;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  prerequisites;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  materialProvided;

  final _i2.StringNullableListFilter? learningOutcomes;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  consultantProfileId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  final _i2.TopicListRelationFilter? topics;

  final _i2.ClassContentListRelationFilter? classContents;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileRelationFilter,
    _i1.PrismaUnion<_i2.ConsultantProfileWhereInput, _i1.PrismaNull>
  >?
  consultantProfile;

  final _i2.ClassListRelationFilter? classes;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInMonths': durationInMonths,
    'callsPerWeek': callsPerWeek,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'topics': topics,
    'classContents': classContents,
    'consultantProfile': consultantProfile,
    'classes': classes,
  };
}

class ClassPlanListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanListRelationFilter({this.every, this.some, this.none});

  final _i2.ClassPlanWhereInput? every;

  final _i2.ClassPlanWhereInput? some;

  final _i2.ClassPlanWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {'every': every, 'some': some, 'none': none};
}

class TopicWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TopicWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
    this.webinarPlans,
    this.classPlans,
  });

  final _i1.PrismaUnion<_i2.TopicWhereInput, Iterable<_i2.TopicWhereInput>>?
  AND;

  final Iterable<_i2.TopicWhereInput>? OR;

  final _i1.PrismaUnion<_i2.TopicWhereInput, Iterable<_i2.TopicWhereInput>>?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? name;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  final _i2.WebinarPlanListRelationFilter? webinarPlans;

  final _i2.ClassPlanListRelationFilter? classPlans;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'webinarPlans': webinarPlans,
    'classPlans': classPlans,
  };
}

class TopicListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TopicListRelationFilter({this.every, this.some, this.none});

  final _i2.TopicWhereInput? every;

  final _i2.TopicWhereInput? some;

  final _i2.TopicWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {'every': every, 'some': some, 'none': none};
}

class WebinarListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarListRelationFilter({this.every, this.some, this.none});

  final _i2.WebinarWhereInput? every;

  final _i2.WebinarWhereInput? some;

  final _i2.WebinarWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {'every': every, 'some': some, 'none': none};
}

class WebinarPlanWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInHours,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.topics,
    this.consultantProfile,
    this.webinars,
  });

  final _i1.PrismaUnion<
    _i2.WebinarPlanWhereInput,
    Iterable<_i2.WebinarPlanWhereInput>
  >?
  AND;

  final Iterable<_i2.WebinarPlanWhereInput>? OR;

  final _i1.PrismaUnion<
    _i2.WebinarPlanWhereInput,
    Iterable<_i2.WebinarPlanWhereInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? title;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  description;

  final _i1.PrismaUnion<_i2.IntFilter, int>? price;

  final _i1.PrismaUnion<_i2.StringFilter, String>? priceCurrency;

  final _i1.PrismaUnion<_i2.BoolFilter, bool>? certificateProvided;

  final _i1.PrismaUnion<_i2.FloatFilter, double>? durationInHours;

  final _i1.PrismaUnion<_i2.IntFilter, int>? maxParticipants;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  language;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  level;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  prerequisites;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  materialProvided;

  final _i2.StringNullableListFilter? learningOutcomes;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  consultantProfileId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  final _i2.TopicListRelationFilter? topics;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileRelationFilter,
    _i1.PrismaUnion<_i2.ConsultantProfileWhereInput, _i1.PrismaNull>
  >?
  consultantProfile;

  final _i2.WebinarListRelationFilter? webinars;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInHours': durationInHours,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'topics': topics,
    'consultantProfile': consultantProfile,
    'webinars': webinars,
  };
}

class WebinarPlanListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanListRelationFilter({this.every, this.some, this.none});

  final _i2.WebinarPlanWhereInput? every;

  final _i2.WebinarPlanWhereInput? some;

  final _i2.WebinarPlanWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {'every': every, 'some': some, 'none': none};
}

class ConsultantProfileWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    this.domainId,
    this.scheduleType,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.domain,
    this.subDomains,
    this.tags,
    this.reviews,
    this.slotsOfAvailabilityWeekly,
    this.slotsOfAvailabilityCustom,
    this.consultationPlans,
    this.subscriptionPlans,
    this.webinarPlans,
    this.classPlans,
    this.user,
  });

  final _i1.PrismaUnion<
    _i2.ConsultantProfileWhereInput,
    Iterable<_i2.ConsultantProfileWhereInput>
  >?
  AND;

  final Iterable<_i2.ConsultantProfileWhereInput>? OR;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileWhereInput,
    Iterable<_i2.ConsultantProfileWhereInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  description;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  qualifications;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  specialization;

  final _i1.PrismaUnion<
    _i2.FloatNullableFilter,
    _i1.PrismaUnion<double, _i1.PrismaNull>
  >?
  experience;

  final _i1.PrismaUnion<_i2.FloatFilter, double>? rating;

  final _i1.PrismaUnion<_i2.StringFilter, String>? domainId;

  final _i1.PrismaUnion<_i2.EnumScheduleTypeFilter, _i3.ScheduleType>?
  scheduleType;

  final _i1.PrismaUnion<_i2.StringFilter, String>? userId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  final _i1.PrismaUnion<_i2.DomainRelationFilter, _i2.DomainWhereInput>? domain;

  final _i2.SubDomainListRelationFilter? subDomains;

  final _i2.TagListRelationFilter? tags;

  final _i2.ConsultantReviewListRelationFilter? reviews;

  final _i2.SlotOfAvailabilityWeeklyListRelationFilter?
  slotsOfAvailabilityWeekly;

  final _i2.SlotOfAvailabilityCustomListRelationFilter?
  slotsOfAvailabilityCustom;

  final _i2.ConsultationPlanListRelationFilter? consultationPlans;

  final _i2.SubscriptionPlanListRelationFilter? subscriptionPlans;

  final _i2.WebinarPlanListRelationFilter? webinarPlans;

  final _i2.ClassPlanListRelationFilter? classPlans;

  final _i1.PrismaUnion<_i2.UserRelationFilter, _i2.UserWhereInput>? user;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'domainId': domainId,
    'scheduleType': scheduleType,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'domain': domain,
    'subDomains': subDomains,
    'tags': tags,
    'reviews': reviews,
    'slotsOfAvailabilityWeekly': slotsOfAvailabilityWeekly,
    'slotsOfAvailabilityCustom': slotsOfAvailabilityCustom,
    'consultationPlans': consultationPlans,
    'subscriptionPlans': subscriptionPlans,
    'webinarPlans': webinarPlans,
    'classPlans': classPlans,
    'user': user,
  };
}

class ConsultantProfileRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileRelationFilter({this.$is, this.isNot});

  final _i1.PrismaUnion<_i2.ConsultantProfileWhereInput, _i1.PrismaNull>? $is;

  final _i1.PrismaUnion<_i2.ConsultantProfileWhereInput, _i1.PrismaNull>? isNot;

  @override
  Map<String, dynamic> toJson() => {'is': $is, 'isNot': isNot};
}

class ConsultationPlanWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.title,
    this.description,
    this.durationInHours,
    this.price,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.consultantProfile,
    this.consultations,
  });

  final _i1.PrismaUnion<
    _i2.ConsultationPlanWhereInput,
    Iterable<_i2.ConsultationPlanWhereInput>
  >?
  AND;

  final Iterable<_i2.ConsultationPlanWhereInput>? OR;

  final _i1.PrismaUnion<
    _i2.ConsultationPlanWhereInput,
    Iterable<_i2.ConsultationPlanWhereInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? title;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  description;

  final _i1.PrismaUnion<_i2.FloatFilter, double>? durationInHours;

  final _i1.PrismaUnion<_i2.IntFilter, int>? price;

  final _i1.PrismaUnion<_i2.StringFilter, String>? language;

  final _i1.PrismaUnion<_i2.StringFilter, String>? level;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  prerequisites;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  materialProvided;

  final _i2.StringNullableListFilter? learningOutcomes;

  final _i1.PrismaUnion<_i2.StringFilter, String>? consultantProfileId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileRelationFilter,
    _i2.ConsultantProfileWhereInput
  >?
  consultantProfile;

  final _i2.ConsultationListRelationFilter? consultations;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'title': title,
    'description': description,
    'durationInHours': durationInHours,
    'price': price,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultantProfile': consultantProfile,
    'consultations': consultations,
  };
}

class ConsultationPlanRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanRelationFilter({this.$is, this.isNot});

  final _i1.PrismaUnion<_i2.ConsultationPlanWhereInput, _i1.PrismaNull>? $is;

  final _i1.PrismaUnion<_i2.ConsultationPlanWhereInput, _i1.PrismaNull>? isNot;

  @override
  Map<String, dynamic> toJson() => {'is': $is, 'isNot': isNot};
}

class ConsultationWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.consultationPlanId,
    this.requestStatus,
    this.requestedById,
    this.requestedAt,
    this.requestNotes,
    this.directlyBooked,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.createdAt,
    this.updatedAt,
    this.consultationPlan,
    this.requestedBy,
    this.appointment,
  });

  final _i1.PrismaUnion<
    _i2.ConsultationWhereInput,
    Iterable<_i2.ConsultationWhereInput>
  >?
  AND;

  final Iterable<_i2.ConsultationWhereInput>? OR;

  final _i1.PrismaUnion<
    _i2.ConsultationWhereInput,
    Iterable<_i2.ConsultationWhereInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? consultationPlanId;

  final _i1.PrismaUnion<_i2.EnumRequestStatusFilter, _i3.RequestStatus>?
  requestStatus;

  final _i1.PrismaUnion<_i2.StringFilter, String>? requestedById;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? requestedAt;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  requestNotes;

  final _i1.PrismaUnion<_i2.BoolFilter, bool>? directlyBooked;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  feedbackFromConsultee;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  feedbackFromConsultant;

  final _i1.PrismaUnion<
    _i2.FloatNullableFilter,
    _i1.PrismaUnion<double, _i1.PrismaNull>
  >?
  rating;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  final _i1.PrismaUnion<
    _i2.ConsultationPlanRelationFilter,
    _i2.ConsultationPlanWhereInput
  >?
  consultationPlan;

  final _i1.PrismaUnion<
    _i2.ConsulteeProfileRelationFilter,
    _i2.ConsulteeProfileWhereInput
  >?
  requestedBy;

  final _i1.PrismaUnion<
    _i2.AppointmentRelationFilter,
    _i1.PrismaUnion<_i2.AppointmentWhereInput, _i1.PrismaNull>
  >?
  appointment;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'consultationPlanId': consultationPlanId,
    'requestStatus': requestStatus,
    'requestedById': requestedById,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'directlyBooked': directlyBooked,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultationPlan': consultationPlan,
    'requestedBy': requestedBy,
    'appointment': appointment,
  };
}

class ConsultationRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationRelationFilter({this.$is, this.isNot});

  final _i1.PrismaUnion<_i2.ConsultationWhereInput, _i1.PrismaNull>? $is;

  final _i1.PrismaUnion<_i2.ConsultationWhereInput, _i1.PrismaNull>? isNot;

  @override
  Map<String, dynamic> toJson() => {'is': $is, 'isNot': isNot};
}

class SubscriptionRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionRelationFilter({this.$is, this.isNot});

  final _i1.PrismaUnion<_i2.SubscriptionWhereInput, _i1.PrismaNull>? $is;

  final _i1.PrismaUnion<_i2.SubscriptionWhereInput, _i1.PrismaNull>? isNot;

  @override
  Map<String, dynamic> toJson() => {'is': $is, 'isNot': isNot};
}

class AppointmentWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.appointmentType,
    this.consultationId,
    this.subscriptionId,
    this.webinarId,
    this.classId,
    this.createdAt,
    this.updatedAt,
    this.slotsOfAppointment,
    this.consultation,
    this.subscription,
    this.webinar,
    this.$class,
    this.payment,
  });

  final _i1.PrismaUnion<
    _i2.AppointmentWhereInput,
    Iterable<_i2.AppointmentWhereInput>
  >?
  AND;

  final Iterable<_i2.AppointmentWhereInput>? OR;

  final _i1.PrismaUnion<
    _i2.AppointmentWhereInput,
    Iterable<_i2.AppointmentWhereInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.EnumAppointmentsTypeFilter, _i3.AppointmentsType>?
  appointmentType;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  consultationId;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  subscriptionId;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  webinarId;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  classId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  final _i2.SlotOfAppointmentListRelationFilter? slotsOfAppointment;

  final _i1.PrismaUnion<
    _i2.ConsultationRelationFilter,
    _i1.PrismaUnion<_i2.ConsultationWhereInput, _i1.PrismaNull>
  >?
  consultation;

  final _i1.PrismaUnion<
    _i2.SubscriptionRelationFilter,
    _i1.PrismaUnion<_i2.SubscriptionWhereInput, _i1.PrismaNull>
  >?
  subscription;

  final _i1.PrismaUnion<
    _i2.WebinarRelationFilter,
    _i1.PrismaUnion<_i2.WebinarWhereInput, _i1.PrismaNull>
  >?
  webinar;

  final _i1.PrismaUnion<
    _i2.ClassRelationFilter,
    _i1.PrismaUnion<_i2.ClassWhereInput, _i1.PrismaNull>
  >?
  $class;

  final _i2.PaymentListRelationFilter? payment;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'appointmentType': appointmentType,
    'consultationId': consultationId,
    'subscriptionId': subscriptionId,
    'webinarId': webinarId,
    'classId': classId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'slotsOfAppointment': slotsOfAppointment,
    'consultation': consultation,
    'subscription': subscription,
    'webinar': webinar,
    'class': $class,
    'payment': payment,
  };
}

class AppointmentRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentRelationFilter({this.$is, this.isNot});

  final _i1.PrismaUnion<_i2.AppointmentWhereInput, _i1.PrismaNull>? $is;

  final _i1.PrismaUnion<_i2.AppointmentWhereInput, _i1.PrismaNull>? isNot;

  @override
  Map<String, dynamic> toJson() => {'is': $is, 'isNot': isNot};
}

class NestedEnumDiscountTypeFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedEnumDiscountTypeFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
  });

  final _i3.DiscountType? equals;

  final _i1.PrismaUnion<Iterable<_i3.DiscountType>, _i3.DiscountType>? $in;

  final _i1.PrismaUnion<Iterable<_i3.DiscountType>, _i3.DiscountType>? notIn;

  final _i1.PrismaUnion<_i3.DiscountType, _i2.NestedEnumDiscountTypeFilter>?
  not;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
  };
}

class EnumDiscountTypeFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumDiscountTypeFilter({this.equals, this.$in, this.notIn, this.not});

  final _i3.DiscountType? equals;

  final _i1.PrismaUnion<Iterable<_i3.DiscountType>, _i3.DiscountType>? $in;

  final _i1.PrismaUnion<Iterable<_i3.DiscountType>, _i3.DiscountType>? notIn;

  final _i1.PrismaUnion<_i3.DiscountType, _i2.NestedEnumDiscountTypeFilter>?
  not;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
  };
}

class DiscountCodeWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountCodeWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.code,
    this.description,
    this.discountType,
    this.discountValue,
    this.createdAt,
    this.updatedAt,
    this.payment,
  });

  final _i1.PrismaUnion<
    _i2.DiscountCodeWhereInput,
    Iterable<_i2.DiscountCodeWhereInput>
  >?
  AND;

  final Iterable<_i2.DiscountCodeWhereInput>? OR;

  final _i1.PrismaUnion<
    _i2.DiscountCodeWhereInput,
    Iterable<_i2.DiscountCodeWhereInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? code;

  final _i1.PrismaUnion<_i2.StringFilter, String>? description;

  final _i1.PrismaUnion<_i2.EnumDiscountTypeFilter, _i3.DiscountType>?
  discountType;

  final _i1.PrismaUnion<_i2.FloatFilter, double>? discountValue;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  final _i2.PaymentListRelationFilter? payment;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'code': code,
    'description': description,
    'discountType': discountType,
    'discountValue': discountValue,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'Payment': payment,
  };
}

class DiscountCodeRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountCodeRelationFilter({this.$is, this.isNot});

  final _i1.PrismaUnion<_i2.DiscountCodeWhereInput, _i1.PrismaNull>? $is;

  final _i1.PrismaUnion<_i2.DiscountCodeWhereInput, _i1.PrismaNull>? isNot;

  @override
  Map<String, dynamic> toJson() => {'is': $is, 'isNot': isNot};
}

class PaymentWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.amount,
    this.currency,
    this.description,
    this.receiptUrl,
    this.paymentMethod,
    this.paymentIntent,
    this.paymentGateway,
    this.paymentStatus,
    this.expiresAt,
    this.userId,
    this.appointmentId,
    this.discountCodeId,
    this.createdAt,
    this.updatedAt,
    this.user,
    this.appointment,
    this.discountCode,
  });

  final _i1.PrismaUnion<_i2.PaymentWhereInput, Iterable<_i2.PaymentWhereInput>>?
  AND;

  final Iterable<_i2.PaymentWhereInput>? OR;

  final _i1.PrismaUnion<_i2.PaymentWhereInput, Iterable<_i2.PaymentWhereInput>>?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.IntFilter, int>? amount;

  final _i1.PrismaUnion<_i2.StringFilter, String>? currency;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  description;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  receiptUrl;

  final _i1.PrismaUnion<_i2.StringFilter, String>? paymentMethod;

  final _i1.PrismaUnion<_i2.StringFilter, String>? paymentIntent;

  final _i1.PrismaUnion<_i2.EnumPaymentGatewayFilter, _i3.PaymentGateway>?
  paymentGateway;

  final _i1.PrismaUnion<_i2.EnumPaymentStatusFilter, _i3.PaymentStatus>?
  paymentStatus;

  final _i1.PrismaUnion<
    _i2.DateTimeNullableFilter,
    _i1.PrismaUnion<DateTime, _i1.PrismaNull>
  >?
  expiresAt;

  final _i1.PrismaUnion<_i2.StringFilter, String>? userId;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  appointmentId;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  discountCodeId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  final _i1.PrismaUnion<_i2.UserRelationFilter, _i2.UserWhereInput>? user;

  final _i1.PrismaUnion<
    _i2.AppointmentRelationFilter,
    _i1.PrismaUnion<_i2.AppointmentWhereInput, _i1.PrismaNull>
  >?
  appointment;

  final _i1.PrismaUnion<
    _i2.DiscountCodeRelationFilter,
    _i1.PrismaUnion<_i2.DiscountCodeWhereInput, _i1.PrismaNull>
  >?
  discountCode;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'amount': amount,
    'currency': currency,
    'description': description,
    'receiptUrl': receiptUrl,
    'paymentMethod': paymentMethod,
    'paymentIntent': paymentIntent,
    'paymentGateway': paymentGateway,
    'paymentStatus': paymentStatus,
    'expiresAt': expiresAt,
    'userId': userId,
    'appointmentId': appointmentId,
    'discountCodeId': discountCodeId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'user': user,
    'appointment': appointment,
    'discountCode': discountCode,
  };
}

class PaymentListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentListRelationFilter({this.every, this.some, this.none});

  final _i2.PaymentWhereInput? every;

  final _i2.PaymentWhereInput? some;

  final _i2.PaymentWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {'every': every, 'some': some, 'none': none};
}

enum JsonNullValueFilter implements _i1.PrismaEnum {
  dbNull._('DbNull'),
  jsonNull._('JsonNull'),
  anyNull._('AnyNull');

  const JsonNullValueFilter._(this.name);

  @override
  final String name;
}

class JsonNullableFilter implements _i1.JsonConvertible<Map<String, dynamic>> {
  const JsonNullableFilter({
    this.equals,
    this.path,
    this.stringContains,
    this.stringStartsWith,
    this.stringEndsWith,
    this.arrayContains,
    this.arrayStartsWith,
    this.arrayEndsWith,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final _i1.PrismaUnion<_i1.PrismaJson, _i2.JsonNullValueFilter>? equals;

  final Iterable<String>? path;

  final String? stringContains;

  final String? stringStartsWith;

  final String? stringEndsWith;

  final _i1.PrismaUnion<_i1.PrismaJson, _i1.PrismaNull>? arrayContains;

  final _i1.PrismaUnion<_i1.PrismaJson, _i1.PrismaNull>? arrayStartsWith;

  final _i1.PrismaUnion<_i1.PrismaJson, _i1.PrismaNull>? arrayEndsWith;

  final _i1.PrismaJson? lt;

  final _i1.PrismaJson? lte;

  final _i1.PrismaJson? gt;

  final _i1.PrismaJson? gte;

  final _i1.PrismaUnion<_i1.PrismaJson, _i2.JsonNullValueFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'path': path,
    'string_contains': stringContains,
    'string_starts_with': stringStartsWith,
    'string_ends_with': stringEndsWith,
    'array_contains': arrayContains,
    'array_starts_with': arrayStartsWith,
    'array_ends_with': arrayEndsWith,
    'lt': lt,
    'lte': lte,
    'gt': gt,
    'gte': gte,
    'not': not,
  };
}

class StaffProfileWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StaffProfileWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.department,
    this.position,
    this.permissions,
    this.responsibilities,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.user,
  });

  final _i1.PrismaUnion<
    _i2.StaffProfileWhereInput,
    Iterable<_i2.StaffProfileWhereInput>
  >?
  AND;

  final Iterable<_i2.StaffProfileWhereInput>? OR;

  final _i1.PrismaUnion<
    _i2.StaffProfileWhereInput,
    Iterable<_i2.StaffProfileWhereInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  department;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  position;

  final _i2.JsonNullableFilter? permissions;

  final _i2.JsonNullableFilter? responsibilities;

  final _i1.PrismaUnion<_i2.StringFilter, String>? userId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  final _i1.PrismaUnion<_i2.UserRelationFilter, _i2.UserWhereInput>? user;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'department': department,
    'position': position,
    'permissions': permissions,
    'responsibilities': responsibilities,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'user': user,
  };
}

class StaffProfileRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StaffProfileRelationFilter({this.$is, this.isNot});

  final _i1.PrismaUnion<_i2.StaffProfileWhereInput, _i1.PrismaNull>? $is;

  final _i1.PrismaUnion<_i2.StaffProfileWhereInput, _i1.PrismaNull>? isNot;

  @override
  Map<String, dynamic> toJson() => {'is': $is, 'isNot': isNot};
}

class NestedIntNullableFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedIntNullableFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final _i1.PrismaUnion<int, _i1.PrismaNull>? equals;

  final _i1.PrismaUnion<Iterable<int>, _i1.PrismaUnion<int, _i1.PrismaNull>>?
  $in;

  final _i1.PrismaUnion<Iterable<int>, _i1.PrismaUnion<int, _i1.PrismaNull>>?
  notIn;

  final int? lt;

  final int? lte;

  final int? gt;

  final int? gte;

  final _i1.PrismaUnion<
    int,
    _i1.PrismaUnion<_i2.NestedIntNullableFilter, _i1.PrismaNull>
  >?
  not;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'lt': lt,
    'lte': lte,
    'gt': gt,
    'gte': gte,
    'not': not,
  };
}

class IntNullableFilter implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IntNullableFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final _i1.PrismaUnion<int, _i1.PrismaNull>? equals;

  final _i1.PrismaUnion<Iterable<int>, _i1.PrismaUnion<int, _i1.PrismaNull>>?
  $in;

  final _i1.PrismaUnion<Iterable<int>, _i1.PrismaUnion<int, _i1.PrismaNull>>?
  notIn;

  final int? lt;

  final int? lte;

  final int? gt;

  final int? gte;

  final _i1.PrismaUnion<
    int,
    _i1.PrismaUnion<_i2.NestedIntNullableFilter, _i1.PrismaNull>
  >?
  not;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'lt': lt,
    'lte': lte,
    'gt': gt,
    'gte': gte,
    'not': not,
  };
}

class NestedEnumFeedbackStatusFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedEnumFeedbackStatusFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
  });

  final _i3.FeedbackStatus? equals;

  final _i1.PrismaUnion<Iterable<_i3.FeedbackStatus>, _i3.FeedbackStatus>? $in;

  final _i1.PrismaUnion<Iterable<_i3.FeedbackStatus>, _i3.FeedbackStatus>?
  notIn;

  final _i1.PrismaUnion<_i3.FeedbackStatus, _i2.NestedEnumFeedbackStatusFilter>?
  not;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
  };
}

class EnumFeedbackStatusFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumFeedbackStatusFilter({this.equals, this.$in, this.notIn, this.not});

  final _i3.FeedbackStatus? equals;

  final _i1.PrismaUnion<Iterable<_i3.FeedbackStatus>, _i3.FeedbackStatus>? $in;

  final _i1.PrismaUnion<Iterable<_i3.FeedbackStatus>, _i3.FeedbackStatus>?
  notIn;

  final _i1.PrismaUnion<_i3.FeedbackStatus, _i2.NestedEnumFeedbackStatusFilter>?
  not;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
  };
}

class FeedbackWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FeedbackWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.title,
    this.description,
    this.rating,
    this.category,
    this.status,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.user,
  });

  final _i1.PrismaUnion<
    _i2.FeedbackWhereInput,
    Iterable<_i2.FeedbackWhereInput>
  >?
  AND;

  final Iterable<_i2.FeedbackWhereInput>? OR;

  final _i1.PrismaUnion<
    _i2.FeedbackWhereInput,
    Iterable<_i2.FeedbackWhereInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? title;

  final _i1.PrismaUnion<_i2.StringFilter, String>? description;

  final _i1.PrismaUnion<
    _i2.IntNullableFilter,
    _i1.PrismaUnion<int, _i1.PrismaNull>
  >?
  rating;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  category;

  final _i1.PrismaUnion<_i2.EnumFeedbackStatusFilter, _i3.FeedbackStatus>?
  status;

  final _i1.PrismaUnion<_i2.StringFilter, String>? userId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  final _i1.PrismaUnion<_i2.UserRelationFilter, _i2.UserWhereInput>? user;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'title': title,
    'description': description,
    'rating': rating,
    'category': category,
    'status': status,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'user': user,
  };
}

class FeedbackListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FeedbackListRelationFilter({this.every, this.some, this.none});

  final _i2.FeedbackWhereInput? every;

  final _i2.FeedbackWhereInput? some;

  final _i2.FeedbackWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {'every': every, 'some': some, 'none': none};
}

class NestedEnumSupportPriorityFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedEnumSupportPriorityFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
  });

  final _i3.SupportPriority? equals;

  final _i1.PrismaUnion<Iterable<_i3.SupportPriority>, _i3.SupportPriority>?
  $in;

  final _i1.PrismaUnion<Iterable<_i3.SupportPriority>, _i3.SupportPriority>?
  notIn;

  final _i1.PrismaUnion<
    _i3.SupportPriority,
    _i2.NestedEnumSupportPriorityFilter
  >?
  not;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
  };
}

class EnumSupportPriorityFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumSupportPriorityFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
  });

  final _i3.SupportPriority? equals;

  final _i1.PrismaUnion<Iterable<_i3.SupportPriority>, _i3.SupportPriority>?
  $in;

  final _i1.PrismaUnion<Iterable<_i3.SupportPriority>, _i3.SupportPriority>?
  notIn;

  final _i1.PrismaUnion<
    _i3.SupportPriority,
    _i2.NestedEnumSupportPriorityFilter
  >?
  not;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
  };
}

class NestedEnumSupportTicketStatusFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedEnumSupportTicketStatusFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
  });

  final _i3.SupportTicketStatus? equals;

  final _i1.PrismaUnion<
    Iterable<_i3.SupportTicketStatus>,
    _i3.SupportTicketStatus
  >?
  $in;

  final _i1.PrismaUnion<
    Iterable<_i3.SupportTicketStatus>,
    _i3.SupportTicketStatus
  >?
  notIn;

  final _i1.PrismaUnion<
    _i3.SupportTicketStatus,
    _i2.NestedEnumSupportTicketStatusFilter
  >?
  not;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
  };
}

class EnumSupportTicketStatusFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumSupportTicketStatusFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
  });

  final _i3.SupportTicketStatus? equals;

  final _i1.PrismaUnion<
    Iterable<_i3.SupportTicketStatus>,
    _i3.SupportTicketStatus
  >?
  $in;

  final _i1.PrismaUnion<
    Iterable<_i3.SupportTicketStatus>,
    _i3.SupportTicketStatus
  >?
  notIn;

  final _i1.PrismaUnion<
    _i3.SupportTicketStatus,
    _i2.NestedEnumSupportTicketStatusFilter
  >?
  not;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
  };
}

class SupportTicketRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportTicketRelationFilter({this.$is, this.isNot});

  final _i1.PrismaUnion<_i2.SupportTicketWhereInput, _i1.PrismaNull>? $is;

  final _i1.PrismaUnion<_i2.SupportTicketWhereInput, _i1.PrismaNull>? isNot;

  @override
  Map<String, dynamic> toJson() => {'is': $is, 'isNot': isNot};
}

class SupportResponseWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.message,
    this.supportTicketId,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.supportTicket,
    this.user,
  });

  final _i1.PrismaUnion<
    _i2.SupportResponseWhereInput,
    Iterable<_i2.SupportResponseWhereInput>
  >?
  AND;

  final Iterable<_i2.SupportResponseWhereInput>? OR;

  final _i1.PrismaUnion<
    _i2.SupportResponseWhereInput,
    Iterable<_i2.SupportResponseWhereInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? message;

  final _i1.PrismaUnion<_i2.StringFilter, String>? supportTicketId;

  final _i1.PrismaUnion<_i2.StringFilter, String>? userId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  final _i1.PrismaUnion<
    _i2.SupportTicketRelationFilter,
    _i2.SupportTicketWhereInput
  >?
  supportTicket;

  final _i1.PrismaUnion<_i2.UserRelationFilter, _i2.UserWhereInput>? user;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'message': message,
    'supportTicketId': supportTicketId,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'supportTicket': supportTicket,
    'user': user,
  };
}

class SupportResponseListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseListRelationFilter({this.every, this.some, this.none});

  final _i2.SupportResponseWhereInput? every;

  final _i2.SupportResponseWhereInput? some;

  final _i2.SupportResponseWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {'every': every, 'some': some, 'none': none};
}

class SupportTicketWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportTicketWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.title,
    this.description,
    this.priority,
    this.status,
    this.category,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.user,
    this.responses,
  });

  final _i1.PrismaUnion<
    _i2.SupportTicketWhereInput,
    Iterable<_i2.SupportTicketWhereInput>
  >?
  AND;

  final Iterable<_i2.SupportTicketWhereInput>? OR;

  final _i1.PrismaUnion<
    _i2.SupportTicketWhereInput,
    Iterable<_i2.SupportTicketWhereInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? title;

  final _i1.PrismaUnion<_i2.StringFilter, String>? description;

  final _i1.PrismaUnion<_i2.EnumSupportPriorityFilter, _i3.SupportPriority>?
  priority;

  final _i1.PrismaUnion<
    _i2.EnumSupportTicketStatusFilter,
    _i3.SupportTicketStatus
  >?
  status;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  category;

  final _i1.PrismaUnion<_i2.StringFilter, String>? userId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  final _i1.PrismaUnion<_i2.UserRelationFilter, _i2.UserWhereInput>? user;

  final _i2.SupportResponseListRelationFilter? responses;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'title': title,
    'description': description,
    'priority': priority,
    'status': status,
    'category': category,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'user': user,
    'responses': responses,
  };
}

class SupportTicketListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportTicketListRelationFilter({this.every, this.some, this.none});

  final _i2.SupportTicketWhereInput? every;

  final _i2.SupportTicketWhereInput? some;

  final _i2.SupportTicketWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {'every': every, 'some': some, 'none': none};
}

class AccountWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AccountWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.userId,
    this.type,
    this.provider,
    this.providerAccountId,
    this.refreshToken,
    this.accessToken,
    this.expiresAt,
    this.tokenType,
    this.scope,
    this.idToken,
    this.sessionState,
    this.user,
  });

  final _i1.PrismaUnion<_i2.AccountWhereInput, Iterable<_i2.AccountWhereInput>>?
  AND;

  final Iterable<_i2.AccountWhereInput>? OR;

  final _i1.PrismaUnion<_i2.AccountWhereInput, Iterable<_i2.AccountWhereInput>>?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? userId;

  final _i1.PrismaUnion<_i2.StringFilter, String>? type;

  final _i1.PrismaUnion<_i2.StringFilter, String>? provider;

  final _i1.PrismaUnion<_i2.StringFilter, String>? providerAccountId;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  refreshToken;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  accessToken;

  final _i1.PrismaUnion<
    _i2.IntNullableFilter,
    _i1.PrismaUnion<int, _i1.PrismaNull>
  >?
  expiresAt;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  tokenType;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  scope;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  idToken;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  sessionState;

  final _i1.PrismaUnion<_i2.UserRelationFilter, _i2.UserWhereInput>? user;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'userId': userId,
    'type': type,
    'provider': provider,
    'providerAccountId': providerAccountId,
    'refresh_token': refreshToken,
    'access_token': accessToken,
    'expires_at': expiresAt,
    'token_type': tokenType,
    'scope': scope,
    'id_token': idToken,
    'session_state': sessionState,
    'user': user,
  };
}

class AccountListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AccountListRelationFilter({this.every, this.some, this.none});

  final _i2.AccountWhereInput? every;

  final _i2.AccountWhereInput? some;

  final _i2.AccountWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {'every': every, 'some': some, 'none': none};
}

class SessionWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SessionWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.sessionToken,
    this.userId,
    this.expires,
    this.user,
  });

  final _i1.PrismaUnion<_i2.SessionWhereInput, Iterable<_i2.SessionWhereInput>>?
  AND;

  final Iterable<_i2.SessionWhereInput>? OR;

  final _i1.PrismaUnion<_i2.SessionWhereInput, Iterable<_i2.SessionWhereInput>>?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? sessionToken;

  final _i1.PrismaUnion<_i2.StringFilter, String>? userId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? expires;

  final _i1.PrismaUnion<_i2.UserRelationFilter, _i2.UserWhereInput>? user;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'sessionToken': sessionToken,
    'userId': userId,
    'expires': expires,
    'user': user,
  };
}

class SessionListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SessionListRelationFilter({this.every, this.some, this.none});

  final _i2.SessionWhereInput? every;

  final _i2.SessionWhereInput? some;

  final _i2.SessionWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {'every': every, 'some': some, 'none': none};
}

class UserWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.cookiePreferences,
    this.notificationPreferences,
    this.payment,
    this.consultantProfile,
    this.consulteeProfile,
    this.staffProfile,
    this.slotsOfAppointment,
    this.waitlist,
    this.feedbacks,
    this.supportTickets,
    this.supportResponses,
    this.accounts,
    this.sessions,
  });

  final _i1.PrismaUnion<_i2.UserWhereInput, Iterable<_i2.UserWhereInput>>? AND;

  final Iterable<_i2.UserWhereInput>? OR;

  final _i1.PrismaUnion<_i2.UserWhereInput, Iterable<_i2.UserWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  name;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  email;

  final _i1.PrismaUnion<
    _i2.DateTimeNullableFilter,
    _i1.PrismaUnion<DateTime, _i1.PrismaNull>
  >?
  emailVerified;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  image;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  phone;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  address;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  password;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  passwordResetToken;

  final _i1.PrismaUnion<
    _i2.DateTimeNullableFilter,
    _i1.PrismaUnion<DateTime, _i1.PrismaNull>
  >?
  passwordResetExpires;

  final _i1.PrismaUnion<_i2.BoolFilter, bool>? onlineStatus;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  currentTimezone;

  final _i1.PrismaUnion<
    _i2.BoolNullableFilter,
    _i1.PrismaUnion<bool, _i1.PrismaNull>
  >?
  onboardingCompleted;

  final _i1.PrismaUnion<
    _i2.EnumUserRoleNullableFilter,
    _i1.PrismaUnion<_i3.UserRole, _i1.PrismaNull>
  >?
  role;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  consultantProfileId;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  consulteeProfileId;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  staffProfileId;

  final _i1.PrismaUnion<
    _i2.CookiePreferenceRelationFilter,
    _i1.PrismaUnion<_i2.CookiePreferenceWhereInput, _i1.PrismaNull>
  >?
  cookiePreferences;

  final _i1.PrismaUnion<
    _i2.NotificationPreferenceRelationFilter,
    _i1.PrismaUnion<_i2.NotificationPreferenceWhereInput, _i1.PrismaNull>
  >?
  notificationPreferences;

  final _i2.PaymentListRelationFilter? payment;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileRelationFilter,
    _i1.PrismaUnion<_i2.ConsultantProfileWhereInput, _i1.PrismaNull>
  >?
  consultantProfile;

  final _i1.PrismaUnion<
    _i2.ConsulteeProfileRelationFilter,
    _i1.PrismaUnion<_i2.ConsulteeProfileWhereInput, _i1.PrismaNull>
  >?
  consulteeProfile;

  final _i1.PrismaUnion<
    _i2.StaffProfileRelationFilter,
    _i1.PrismaUnion<_i2.StaffProfileWhereInput, _i1.PrismaNull>
  >?
  staffProfile;

  final _i2.SlotOfAppointmentListRelationFilter? slotsOfAppointment;

  final _i2.WaitlistListRelationFilter? waitlist;

  final _i2.FeedbackListRelationFilter? feedbacks;

  final _i2.SupportTicketListRelationFilter? supportTickets;

  final _i2.SupportResponseListRelationFilter? supportResponses;

  final _i2.AccountListRelationFilter? accounts;

  final _i2.SessionListRelationFilter? sessions;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'cookiePreferences': cookiePreferences,
    'notificationPreferences': notificationPreferences,
    'Payment': payment,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
    'staffProfile': staffProfile,
    'slotsOfAppointment': slotsOfAppointment,
    'Waitlist': waitlist,
    'feedbacks': feedbacks,
    'supportTickets': supportTickets,
    'supportResponses': supportResponses,
    'accounts': accounts,
    'sessions': sessions,
  };
}

enum SortOrder implements _i1.PrismaEnum {
  asc._('asc'),
  desc._('desc');

  const SortOrder._(this.name);

  @override
  final String name;
}

enum NullsOrder implements _i1.PrismaEnum {
  first._('first'),
  last._('last');

  const NullsOrder._(this.name);

  @override
  final String name;
}

class SortOrderInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SortOrderInput({required this.sort, this.nulls});

  final _i2.SortOrder sort;

  final _i2.NullsOrder? nulls;

  @override
  Map<String, dynamic> toJson() => {'sort': sort, 'nulls': nulls};
}

class CookiePreferenceOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CookiePreferenceOrderByWithRelationInput({
    this.id,
    this.userId,
    this.essential,
    this.analytics,
    this.marketing,
    this.user,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? essential;

  final _i2.SortOrder? analytics;

  final _i2.SortOrder? marketing;

  final _i2.UserOrderByWithRelationInput? user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'essential': essential,
    'analytics': analytics,
    'marketing': marketing,
    'user': user,
  };
}

class NotificationPreferenceOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NotificationPreferenceOrderByWithRelationInput({
    this.id,
    this.userId,
    this.allNotifications,
    this.mentions,
    this.directMessages,
    this.updates,
    this.user,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? allNotifications;

  final _i2.SortOrder? mentions;

  final _i2.SortOrder? directMessages;

  final _i2.SortOrder? updates;

  final _i2.UserOrderByWithRelationInput? user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'allNotifications': allNotifications,
    'mentions': mentions,
    'directMessages': directMessages,
    'updates': updates,
    'user': user,
  };
}

class PaymentOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class SubDomainOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class TagOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class ConsultantProfileOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class DomainOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomainOrderByWithRelationInput({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
    this.subDomains,
    this.tags,
    this.consultantProfiles,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? name;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.SubDomainOrderByRelationAggregateInput? subDomains;

  final _i2.TagOrderByRelationAggregateInput? tags;

  final _i2.ConsultantProfileOrderByRelationAggregateInput? consultantProfiles;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'subDomains': subDomains,
    'tags': tags,
    'consultantProfiles': consultantProfiles,
  };
}

class ConsultantReviewOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class SlotOfAvailabilityWeeklyOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityWeeklyOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class SlotOfAvailabilityCustomOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityCustomOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class ConsultationPlanOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class SubscriptionPlanOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class WebinarPlanOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class ClassPlanOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class ConsultantProfileOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileOrderByWithRelationInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    this.domainId,
    this.scheduleType,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.domain,
    this.subDomains,
    this.tags,
    this.reviews,
    this.slotsOfAvailabilityWeekly,
    this.slotsOfAvailabilityCustom,
    this.consultationPlans,
    this.subscriptionPlans,
    this.webinarPlans,
    this.classPlans,
    this.user,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? description;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? qualifications;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? specialization;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? experience;

  final _i2.SortOrder? rating;

  final _i2.SortOrder? domainId;

  final _i2.SortOrder? scheduleType;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.DomainOrderByWithRelationInput? domain;

  final _i2.SubDomainOrderByRelationAggregateInput? subDomains;

  final _i2.TagOrderByRelationAggregateInput? tags;

  final _i2.ConsultantReviewOrderByRelationAggregateInput? reviews;

  final _i2.SlotOfAvailabilityWeeklyOrderByRelationAggregateInput?
  slotsOfAvailabilityWeekly;

  final _i2.SlotOfAvailabilityCustomOrderByRelationAggregateInput?
  slotsOfAvailabilityCustom;

  final _i2.ConsultationPlanOrderByRelationAggregateInput? consultationPlans;

  final _i2.SubscriptionPlanOrderByRelationAggregateInput? subscriptionPlans;

  final _i2.WebinarPlanOrderByRelationAggregateInput? webinarPlans;

  final _i2.ClassPlanOrderByRelationAggregateInput? classPlans;

  final _i2.UserOrderByWithRelationInput? user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'domainId': domainId,
    'scheduleType': scheduleType,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'domain': domain,
    'subDomains': subDomains,
    'tags': tags,
    'reviews': reviews,
    'slotsOfAvailabilityWeekly': slotsOfAvailabilityWeekly,
    'slotsOfAvailabilityCustom': slotsOfAvailabilityCustom,
    'consultationPlans': consultationPlans,
    'subscriptionPlans': subscriptionPlans,
    'webinarPlans': webinarPlans,
    'classPlans': classPlans,
    'user': user,
  };
}

class ConsultationOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class SubscriptionOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class ConsulteeProfileOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileOrderByWithRelationInput({
    this.id,
    this.education,
    this.occupation,
    this.aboutMe,
    this.preferredCommunicationMethod,
    this.preferredLanguage,
    this.specialRequirements,
    this.interests,
    this.goals,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.consultationRequests,
    this.subscriptionRequests,
    this.consultantReviews,
    this.user,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? education;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? occupation;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? aboutMe;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>?
  preferredCommunicationMethod;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? preferredLanguage;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? specialRequirements;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? interests;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? goals;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.ConsultationOrderByRelationAggregateInput? consultationRequests;

  final _i2.SubscriptionOrderByRelationAggregateInput? subscriptionRequests;

  final _i2.ConsultantReviewOrderByRelationAggregateInput? consultantReviews;

  final _i2.UserOrderByWithRelationInput? user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'education': education,
    'occupation': occupation,
    'aboutMe': aboutMe,
    'preferredCommunicationMethod': preferredCommunicationMethod,
    'preferredLanguage': preferredLanguage,
    'specialRequirements': specialRequirements,
    'interests': interests,
    'goals': goals,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultationRequests': consultationRequests,
    'subscriptionRequests': subscriptionRequests,
    'consultantReviews': consultantReviews,
    'user': user,
  };
}

class StaffProfileOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StaffProfileOrderByWithRelationInput({
    this.id,
    this.department,
    this.position,
    this.permissions,
    this.responsibilities,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.user,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? department;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? position;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? permissions;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? responsibilities;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.UserOrderByWithRelationInput? user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'department': department,
    'position': position,
    'permissions': permissions,
    'responsibilities': responsibilities,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'user': user,
  };
}

class SlotOfAppointmentOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class WaitlistOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class FeedbackOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FeedbackOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class SupportTicketOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportTicketOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class SupportResponseOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class AccountOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AccountOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class SessionOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SessionOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class UserOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserOrderByWithRelationInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.cookiePreferences,
    this.notificationPreferences,
    this.payment,
    this.consultantProfile,
    this.consulteeProfile,
    this.staffProfile,
    this.slotsOfAppointment,
    this.waitlist,
    this.feedbacks,
    this.supportTickets,
    this.supportResponses,
    this.accounts,
    this.sessions,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? name;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? email;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? emailVerified;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? image;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? phone;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? address;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? password;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? passwordResetToken;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>?
  passwordResetExpires;

  final _i2.SortOrder? onlineStatus;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? currentTimezone;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? onboardingCompleted;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? role;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? consultantProfileId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? consulteeProfileId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? staffProfileId;

  final _i2.CookiePreferenceOrderByWithRelationInput? cookiePreferences;

  final _i2.NotificationPreferenceOrderByWithRelationInput?
  notificationPreferences;

  final _i2.PaymentOrderByRelationAggregateInput? payment;

  final _i2.ConsultantProfileOrderByWithRelationInput? consultantProfile;

  final _i2.ConsulteeProfileOrderByWithRelationInput? consulteeProfile;

  final _i2.StaffProfileOrderByWithRelationInput? staffProfile;

  final _i2.SlotOfAppointmentOrderByRelationAggregateInput? slotsOfAppointment;

  final _i2.WaitlistOrderByRelationAggregateInput? waitlist;

  final _i2.FeedbackOrderByRelationAggregateInput? feedbacks;

  final _i2.SupportTicketOrderByRelationAggregateInput? supportTickets;

  final _i2.SupportResponseOrderByRelationAggregateInput? supportResponses;

  final _i2.AccountOrderByRelationAggregateInput? accounts;

  final _i2.SessionOrderByRelationAggregateInput? sessions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'cookiePreferences': cookiePreferences,
    'notificationPreferences': notificationPreferences,
    'Payment': payment,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
    'staffProfile': staffProfile,
    'slotsOfAppointment': slotsOfAppointment,
    'Waitlist': waitlist,
    'feedbacks': feedbacks,
    'supportTickets': supportTickets,
    'supportResponses': supportResponses,
    'accounts': accounts,
    'sessions': sessions,
  };
}

enum UserScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<String>('id', 'User'),
  name$<String>('name', 'User'),
  email<String>('email', 'User'),
  emailVerified<DateTime>('emailVerified', 'User'),
  image<String>('image', 'User'),
  phone<String>('phone', 'User'),
  address<String>('address', 'User'),
  password<String>('password', 'User'),
  passwordResetToken<String>('passwordResetToken', 'User'),
  passwordResetExpires<DateTime>('passwordResetExpires', 'User'),
  onlineStatus<bool>('onlineStatus', 'User'),
  currentTimezone<String>('currentTimezone', 'User'),
  onboardingCompleted<bool>('onboardingCompleted', 'User'),
  role<_i3.UserRole>('role', 'User'),
  consultantProfileId<String>('consultantProfileId', 'User'),
  consulteeProfileId<String>('consulteeProfileId', 'User'),
  staffProfileId<String>('staffProfileId', 'User');

  const UserScalar(this.name, this.model);

  @override
  final String name;

  @override
  final String model;
}

class SlotOfAppointmentUserArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentUserArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.UserWhereInput? where;

  final _i1.PrismaUnion<
    Iterable<_i2.UserOrderByWithRelationInput>,
    _i2.UserOrderByWithRelationInput
  >?
  orderBy;

  final _i2.UserWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.UserScalar, Iterable<_i2.UserScalar>>? distinct;

  final _i2.UserSelect? select;

  final _i2.UserInclude? include;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'orderBy': orderBy,
    'cursor': cursor,
    'take': take,
    'skip': skip,
    'distinct': distinct,
    'select': select,
    'include': include,
  };
}

class SlotOfAppointmentAppointmentArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentAppointmentArgs({this.select, this.include});

  final _i2.AppointmentSelect? select;

  final _i2.AppointmentInclude? include;

  @override
  Map<String, dynamic> toJson() => {'select': select, 'include': include};
}

class RecordingMeetingSessionArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const RecordingMeetingSessionArgs({this.select, this.include});

  final _i2.MeetingSessionSelect? select;

  final _i2.MeetingSessionInclude? include;

  @override
  Map<String, dynamic> toJson() => {'select': select, 'include': include};
}

class RecordingInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const RecordingInclude({this.meetingSession});

  final _i1.PrismaUnion<bool, _i2.RecordingMeetingSessionArgs>? meetingSession;

  @override
  Map<String, dynamic> toJson() => {'meetingSession': meetingSession};
}

class RecordingOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const RecordingOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class UserOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class ConsultationPlanOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanOrderByWithRelationInput({
    this.id,
    this.title,
    this.description,
    this.durationInHours,
    this.price,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.consultantProfile,
    this.consultations,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? title;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? description;

  final _i2.SortOrder? durationInHours;

  final _i2.SortOrder? price;

  final _i2.SortOrder? language;

  final _i2.SortOrder? level;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? prerequisites;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? materialProvided;

  final _i2.SortOrder? learningOutcomes;

  final _i2.SortOrder? consultantProfileId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.ConsultantProfileOrderByWithRelationInput? consultantProfile;

  final _i2.ConsultationOrderByRelationAggregateInput? consultations;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInHours': durationInHours,
    'price': price,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultantProfile': consultantProfile,
    'consultations': consultations,
  };
}

class ConsultationOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationOrderByWithRelationInput({
    this.id,
    this.consultationPlanId,
    this.requestStatus,
    this.requestedById,
    this.requestedAt,
    this.requestNotes,
    this.directlyBooked,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.createdAt,
    this.updatedAt,
    this.consultationPlan,
    this.requestedBy,
    this.appointment,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? consultationPlanId;

  final _i2.SortOrder? requestStatus;

  final _i2.SortOrder? requestedById;

  final _i2.SortOrder? requestedAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? requestNotes;

  final _i2.SortOrder? directlyBooked;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>?
  feedbackFromConsultee;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>?
  feedbackFromConsultant;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? rating;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.ConsultationPlanOrderByWithRelationInput? consultationPlan;

  final _i2.ConsulteeProfileOrderByWithRelationInput? requestedBy;

  final _i2.AppointmentOrderByWithRelationInput? appointment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'consultationPlanId': consultationPlanId,
    'requestStatus': requestStatus,
    'requestedById': requestedById,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'directlyBooked': directlyBooked,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultationPlan': consultationPlan,
    'requestedBy': requestedBy,
    'appointment': appointment,
  };
}

class SubscriptionPlanOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanOrderByWithRelationInput({
    this.id,
    this.title,
    this.description,
    this.durationInMonths,
    this.price,
    this.callsPerWeek,
    this.sessionDurationInHours,
    this.videoMeetings,
    this.emailSupport,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.consultantProfile,
    this.subscriptions,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? title;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? description;

  final _i2.SortOrder? durationInMonths;

  final _i2.SortOrder? price;

  final _i2.SortOrder? callsPerWeek;

  final _i2.SortOrder? sessionDurationInHours;

  final _i2.SortOrder? videoMeetings;

  final _i2.SortOrder? emailSupport;

  final _i2.SortOrder? language;

  final _i2.SortOrder? level;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? prerequisites;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? materialProvided;

  final _i2.SortOrder? learningOutcomes;

  final _i2.SortOrder? consultantProfileId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.ConsultantProfileOrderByWithRelationInput? consultantProfile;

  final _i2.SubscriptionOrderByRelationAggregateInput? subscriptions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInMonths': durationInMonths,
    'price': price,
    'callsPerWeek': callsPerWeek,
    'sessionDurationInHours': sessionDurationInHours,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultantProfile': consultantProfile,
    'subscriptions': subscriptions,
  };
}

class AppointmentOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class SubscriptionOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionOrderByWithRelationInput({
    this.id,
    this.startDate,
    this.endDate,
    this.requestStatus,
    this.requestedById,
    this.requestedAt,
    this.requestNotes,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.subscriptionPlanId,
    this.createdAt,
    this.updatedAt,
    this.requestedBy,
    this.subscriptionPlan,
    this.appointments,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? startDate;

  final _i2.SortOrder? endDate;

  final _i2.SortOrder? requestStatus;

  final _i2.SortOrder? requestedById;

  final _i2.SortOrder? requestedAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? requestNotes;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>?
  feedbackFromConsultee;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>?
  feedbackFromConsultant;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? rating;

  final _i2.SortOrder? subscriptionPlanId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.ConsulteeProfileOrderByWithRelationInput? requestedBy;

  final _i2.SubscriptionPlanOrderByWithRelationInput? subscriptionPlan;

  final _i2.AppointmentOrderByRelationAggregateInput? appointments;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'requestStatus': requestStatus,
    'requestedById': requestedById,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'subscriptionPlanId': subscriptionPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'requestedBy': requestedBy,
    'subscriptionPlan': subscriptionPlan,
    'appointments': appointments,
  };
}

class TopicOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TopicOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class WebinarOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class WebinarPlanOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanOrderByWithRelationInput({
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInHours,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.topics,
    this.consultantProfile,
    this.webinars,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? title;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? description;

  final _i2.SortOrder? price;

  final _i2.SortOrder? priceCurrency;

  final _i2.SortOrder? certificateProvided;

  final _i2.SortOrder? durationInHours;

  final _i2.SortOrder? maxParticipants;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? language;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? level;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? prerequisites;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? materialProvided;

  final _i2.SortOrder? learningOutcomes;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? consultantProfileId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.TopicOrderByRelationAggregateInput? topics;

  final _i2.ConsultantProfileOrderByWithRelationInput? consultantProfile;

  final _i2.WebinarOrderByRelationAggregateInput? webinars;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInHours': durationInHours,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'topics': topics,
    'consultantProfile': consultantProfile,
    'webinars': webinars,
  };
}

class WebinarOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarOrderByWithRelationInput({
    this.id,
    this.status,
    this.feedbackSummary,
    this.webinarPlanId,
    this.createdAt,
    this.updatedAt,
    this.waitlist,
    this.webinarPlan,
    this.appointment,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? status;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? feedbackSummary;

  final _i2.SortOrder? webinarPlanId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.WaitlistOrderByRelationAggregateInput? waitlist;

  final _i2.WebinarPlanOrderByWithRelationInput? webinarPlan;

  final _i2.AppointmentOrderByWithRelationInput? appointment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'status': status,
    'feedbackSummary': feedbackSummary,
    'webinarPlanId': webinarPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'waitlist': waitlist,
    'webinarPlan': webinarPlan,
    'appointment': appointment,
  };
}

class ClassContentOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassContentOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class ClassOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class ClassPlanOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanOrderByWithRelationInput({
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInMonths,
    this.callsPerWeek,
    this.videoMeetings,
    this.emailSupport,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.topics,
    this.classContents,
    this.consultantProfile,
    this.classes,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? title;

  final _i2.SortOrder? description;

  final _i2.SortOrder? price;

  final _i2.SortOrder? priceCurrency;

  final _i2.SortOrder? certificateProvided;

  final _i2.SortOrder? durationInMonths;

  final _i2.SortOrder? callsPerWeek;

  final _i2.SortOrder? videoMeetings;

  final _i2.SortOrder? emailSupport;

  final _i2.SortOrder? maxParticipants;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? language;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? level;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? prerequisites;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? materialProvided;

  final _i2.SortOrder? learningOutcomes;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? consultantProfileId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.TopicOrderByRelationAggregateInput? topics;

  final _i2.ClassContentOrderByRelationAggregateInput? classContents;

  final _i2.ConsultantProfileOrderByWithRelationInput? consultantProfile;

  final _i2.ClassOrderByRelationAggregateInput? classes;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInMonths': durationInMonths,
    'callsPerWeek': callsPerWeek,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'topics': topics,
    'classContents': classContents,
    'consultantProfile': consultantProfile,
    'classes': classes,
  };
}

class ClassOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassOrderByWithRelationInput({
    this.id,
    this.startDate,
    this.endDate,
    this.status,
    this.recordingUrls,
    this.feedbackSummary,
    this.classPlanId,
    this.createdAt,
    this.updatedAt,
    this.waitlist,
    this.classPlan,
    this.appointments,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? startDate;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? endDate;

  final _i2.SortOrder? status;

  final _i2.SortOrder? recordingUrls;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? feedbackSummary;

  final _i2.SortOrder? classPlanId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.WaitlistOrderByRelationAggregateInput? waitlist;

  final _i2.ClassPlanOrderByWithRelationInput? classPlan;

  final _i2.AppointmentOrderByRelationAggregateInput? appointments;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'status': status,
    'recordingUrls': recordingUrls,
    'feedbackSummary': feedbackSummary,
    'classPlanId': classPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'waitlist': waitlist,
    'classPlan': classPlan,
    'appointments': appointments,
  };
}

class AppointmentOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentOrderByWithRelationInput({
    this.id,
    this.appointmentType,
    this.consultationId,
    this.subscriptionId,
    this.webinarId,
    this.classId,
    this.createdAt,
    this.updatedAt,
    this.slotsOfAppointment,
    this.consultation,
    this.subscription,
    this.webinar,
    this.$class,
    this.payment,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? appointmentType;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? consultationId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? subscriptionId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? webinarId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? classId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.SlotOfAppointmentOrderByRelationAggregateInput? slotsOfAppointment;

  final _i2.ConsultationOrderByWithRelationInput? consultation;

  final _i2.SubscriptionOrderByWithRelationInput? subscription;

  final _i2.WebinarOrderByWithRelationInput? webinar;

  final _i2.ClassOrderByWithRelationInput? $class;

  final _i2.PaymentOrderByRelationAggregateInput? payment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'appointmentType': appointmentType,
    'consultationId': consultationId,
    'subscriptionId': subscriptionId,
    'webinarId': webinarId,
    'classId': classId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'slotsOfAppointment': slotsOfAppointment,
    'consultation': consultation,
    'subscription': subscription,
    'webinar': webinar,
    'class': $class,
    'payment': payment,
  };
}

class SlotOfAppointmentOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentOrderByWithRelationInput({
    this.id,
    this.slotStartTimeInUTC,
    this.slotEndTimeInUTC,
    this.isTentative,
    this.appointmentId,
    this.createdAt,
    this.updatedAt,
    this.user,
    this.appointment,
    this.meetingSession,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? slotStartTimeInUTC;

  final _i2.SortOrder? slotEndTimeInUTC;

  final _i2.SortOrder? isTentative;

  final _i2.SortOrder? appointmentId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.UserOrderByRelationAggregateInput? user;

  final _i2.AppointmentOrderByWithRelationInput? appointment;

  final _i2.MeetingSessionOrderByWithRelationInput? meetingSession;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'isTentative': isTentative,
    'appointmentId': appointmentId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'user': user,
    'appointment': appointment,
    'meetingSession': meetingSession,
  };
}

class MeetingSessionOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const MeetingSessionOrderByWithRelationInput({
    this.id,
    this.streamCallId,
    this.platform,
    this.passcode,
    this.hostKeys,
    this.slotOfAppointmentId,
    this.createdAt,
    this.updatedAt,
    this.recordings,
    this.slotOfAppointment,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? streamCallId;

  final _i2.SortOrder? platform;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? passcode;

  final _i2.SortOrder? hostKeys;

  final _i2.SortOrder? slotOfAppointmentId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.RecordingOrderByRelationAggregateInput? recordings;

  final _i2.SlotOfAppointmentOrderByWithRelationInput? slotOfAppointment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'streamCallId': streamCallId,
    'platform': platform,
    'passcode': passcode,
    'hostKeys': hostKeys,
    'slotOfAppointmentId': slotOfAppointmentId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'recordings': recordings,
    'slotOfAppointment': slotOfAppointment,
  };
}

class RecordingOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const RecordingOrderByWithRelationInput({
    this.id,
    this.title,
    this.recordingUrl,
    this.durationInMinutes,
    this.recordedAt,
    this.meetingSessionId,
    this.createdAt,
    this.updatedAt,
    this.meetingSession,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? title;

  final _i2.SortOrder? recordingUrl;

  final _i2.SortOrder? durationInMinutes;

  final _i2.SortOrder? recordedAt;

  final _i2.SortOrder? meetingSessionId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.MeetingSessionOrderByWithRelationInput? meetingSession;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'recordingUrl': recordingUrl,
    'durationInMinutes': durationInMinutes,
    'recordedAt': recordedAt,
    'meetingSessionId': meetingSessionId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'meetingSession': meetingSession,
  };
}

class RecordingWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const RecordingWhereUniqueInput({this.id});

  final String? id;

  @override
  Map<String, dynamic> toJson() => {'id': id};
}

enum RecordingScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<String>('id', 'Recording'),
  title<String>('title', 'Recording'),
  recordingUrl<String>('recordingUrl', 'Recording'),
  durationInMinutes<int>('durationInMinutes', 'Recording'),
  recordedAt<DateTime>('recordedAt', 'Recording'),
  meetingSessionId<String>('meetingSessionId', 'Recording'),
  createdAt<DateTime>('createdAt', 'Recording'),
  updatedAt<DateTime>('updatedAt', 'Recording');

  const RecordingScalar(this.name, this.model);

  @override
  final String name;

  @override
  final String model;
}

class MeetingSessionRecordingsArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const MeetingSessionRecordingsArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.RecordingWhereInput? where;

  final _i1.PrismaUnion<
    Iterable<_i2.RecordingOrderByWithRelationInput>,
    _i2.RecordingOrderByWithRelationInput
  >?
  orderBy;

  final _i2.RecordingWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.RecordingScalar, Iterable<_i2.RecordingScalar>>?
  distinct;

  final _i2.RecordingSelect? select;

  final _i2.RecordingInclude? include;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'orderBy': orderBy,
    'cursor': cursor,
    'take': take,
    'skip': skip,
    'distinct': distinct,
    'select': select,
    'include': include,
  };
}

class MeetingSessionSlotOfAppointmentArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const MeetingSessionSlotOfAppointmentArgs({this.select, this.include});

  final _i2.SlotOfAppointmentSelect? select;

  final _i2.SlotOfAppointmentInclude? include;

  @override
  Map<String, dynamic> toJson() => {'select': select, 'include': include};
}

class MeetingSessionCountOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const MeetingSessionCountOutputTypeSelect({this.recordings});

  final bool? recordings;

  @override
  Map<String, dynamic> toJson() => {'recordings': recordings};
}

class MeetingSessionCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const MeetingSessionCountArgs({this.select});

  final _i2.MeetingSessionCountOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class MeetingSessionInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const MeetingSessionInclude({
    this.recordings,
    this.slotOfAppointment,
    this.$count,
  });

  final _i1.PrismaUnion<bool, _i2.MeetingSessionRecordingsArgs>? recordings;

  final _i1.PrismaUnion<bool, _i2.MeetingSessionSlotOfAppointmentArgs>?
  slotOfAppointment;

  final _i1.PrismaUnion<bool, _i2.MeetingSessionCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
    'recordings': recordings,
    'slotOfAppointment': slotOfAppointment,
    '_count': $count,
  };
}

class RecordingSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const RecordingSelect({
    this.id,
    this.title,
    this.recordingUrl,
    this.durationInMinutes,
    this.recordedAt,
    this.meetingSessionId,
    this.createdAt,
    this.updatedAt,
    this.meetingSession,
  });

  final bool? id;

  final bool? title;

  final bool? recordingUrl;

  final bool? durationInMinutes;

  final bool? recordedAt;

  final bool? meetingSessionId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.RecordingMeetingSessionArgs>? meetingSession;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'recordingUrl': recordingUrl,
    'durationInMinutes': durationInMinutes,
    'recordedAt': recordedAt,
    'meetingSessionId': meetingSessionId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'meetingSession': meetingSession,
  };
}

class MeetingSessionSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const MeetingSessionSelect({
    this.id,
    this.streamCallId,
    this.platform,
    this.passcode,
    this.hostKeys,
    this.slotOfAppointmentId,
    this.createdAt,
    this.updatedAt,
    this.recordings,
    this.slotOfAppointment,
    this.$count,
  });

  final bool? id;

  final bool? streamCallId;

  final bool? platform;

  final bool? passcode;

  final bool? hostKeys;

  final bool? slotOfAppointmentId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.MeetingSessionRecordingsArgs>? recordings;

  final _i1.PrismaUnion<bool, _i2.MeetingSessionSlotOfAppointmentArgs>?
  slotOfAppointment;

  final _i1.PrismaUnion<bool, _i2.MeetingSessionCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'streamCallId': streamCallId,
    'platform': platform,
    'passcode': passcode,
    'hostKeys': hostKeys,
    'slotOfAppointmentId': slotOfAppointmentId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'recordings': recordings,
    'slotOfAppointment': slotOfAppointment,
    '_count': $count,
  };
}

class SlotOfAppointmentMeetingSessionArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentMeetingSessionArgs({this.select, this.include});

  final _i2.MeetingSessionSelect? select;

  final _i2.MeetingSessionInclude? include;

  @override
  Map<String, dynamic> toJson() => {'select': select, 'include': include};
}

class SlotOfAppointmentCountOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentCountOutputTypeSelect({this.user});

  final bool? user;

  @override
  Map<String, dynamic> toJson() => {'user': user};
}

class SlotOfAppointmentCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentCountArgs({this.select});

  final _i2.SlotOfAppointmentCountOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SlotOfAppointmentInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentInclude({
    this.user,
    this.appointment,
    this.meetingSession,
    this.$count,
  });

  final _i1.PrismaUnion<bool, _i2.SlotOfAppointmentUserArgs>? user;

  final _i1.PrismaUnion<bool, _i2.SlotOfAppointmentAppointmentArgs>?
  appointment;

  final _i1.PrismaUnion<bool, _i2.SlotOfAppointmentMeetingSessionArgs>?
  meetingSession;

  final _i1.PrismaUnion<bool, _i2.SlotOfAppointmentCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
    'user': user,
    'appointment': appointment,
    'meetingSession': meetingSession,
    '_count': $count,
  };
}

class SlotOfAppointmentWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentWhereUniqueInput({this.id});

  final String? id;

  @override
  Map<String, dynamic> toJson() => {'id': id};
}

enum SlotOfAppointmentScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<String>('id', 'SlotOfAppointment'),
  slotStartTimeInUTC<DateTime>('slotStartTimeInUTC', 'SlotOfAppointment'),
  slotEndTimeInUTC<DateTime>('slotEndTimeInUTC', 'SlotOfAppointment'),
  isTentative<bool>('isTentative', 'SlotOfAppointment'),
  appointmentId<String>('appointmentId', 'SlotOfAppointment'),
  createdAt<DateTime>('createdAt', 'SlotOfAppointment'),
  updatedAt<DateTime>('updatedAt', 'SlotOfAppointment');

  const SlotOfAppointmentScalar(this.name, this.model);

  @override
  final String name;

  @override
  final String model;
}

class AppointmentSlotsOfAppointmentArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentSlotsOfAppointmentArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.SlotOfAppointmentWhereInput? where;

  final _i1.PrismaUnion<
    Iterable<_i2.SlotOfAppointmentOrderByWithRelationInput>,
    _i2.SlotOfAppointmentOrderByWithRelationInput
  >?
  orderBy;

  final _i2.SlotOfAppointmentWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentScalar,
    Iterable<_i2.SlotOfAppointmentScalar>
  >?
  distinct;

  final _i2.SlotOfAppointmentSelect? select;

  final _i2.SlotOfAppointmentInclude? include;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'orderBy': orderBy,
    'cursor': cursor,
    'take': take,
    'skip': skip,
    'distinct': distinct,
    'select': select,
    'include': include,
  };
}

class SubDomainDomainArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainDomainArgs({this.select, this.include});

  final _i2.DomainSelect? select;

  final _i2.DomainInclude? include;

  @override
  Map<String, dynamic> toJson() => {'select': select, 'include': include};
}

class ConsultantProfileDomainArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileDomainArgs({this.select, this.include});

  final _i2.DomainSelect? select;

  final _i2.DomainInclude? include;

  @override
  Map<String, dynamic> toJson() => {'select': select, 'include': include};
}

class SubDomainOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainOrderByWithRelationInput({
    this.id,
    this.name,
    this.domainId,
    this.createdAt,
    this.updatedAt,
    this.domain,
    this.consultantProfiles,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? name;

  final _i2.SortOrder? domainId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.DomainOrderByWithRelationInput? domain;

  final _i2.ConsultantProfileOrderByRelationAggregateInput? consultantProfiles;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'domainId': domainId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'domain': domain,
    'consultantProfiles': consultantProfiles,
  };
}

class SubDomainNameDomainIdCompoundUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainNameDomainIdCompoundUniqueInput({
    required this.name,
    required this.domainId,
  });

  final String name;

  final String domainId;

  @override
  Map<String, dynamic> toJson() => {'name': name, 'domainId': domainId};
}

class SubDomainWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainWhereUniqueInput({this.id, this.nameDomainId});

  final String? id;

  final _i2.SubDomainNameDomainIdCompoundUniqueInput? nameDomainId;

  @override
  Map<String, dynamic> toJson() => {'id': id, 'name_domainId': nameDomainId};
}

enum SubDomainScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<String>('id', 'SubDomain'),
  name$<String>('name', 'SubDomain'),
  domainId<String>('domainId', 'SubDomain'),
  createdAt<DateTime>('createdAt', 'SubDomain'),
  updatedAt<DateTime>('updatedAt', 'SubDomain');

  const SubDomainScalar(this.name, this.model);

  @override
  final String name;

  @override
  final String model;
}

class ConsultantProfileSubDomainsArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileSubDomainsArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.SubDomainWhereInput? where;

  final _i1.PrismaUnion<
    Iterable<_i2.SubDomainOrderByWithRelationInput>,
    _i2.SubDomainOrderByWithRelationInput
  >?
  orderBy;

  final _i2.SubDomainWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.SubDomainScalar, Iterable<_i2.SubDomainScalar>>?
  distinct;

  final _i2.SubDomainSelect? select;

  final _i2.SubDomainInclude? include;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'orderBy': orderBy,
    'cursor': cursor,
    'take': take,
    'skip': skip,
    'distinct': distinct,
    'select': select,
    'include': include,
  };
}

class TagDomainArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagDomainArgs({this.select, this.include});

  final _i2.DomainSelect? select;

  final _i2.DomainInclude? include;

  @override
  Map<String, dynamic> toJson() => {'select': select, 'include': include};
}

class ConsultantProfileWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileWhereUniqueInput({this.id, this.userId});

  final String? id;

  final String? userId;

  @override
  Map<String, dynamic> toJson() => {'id': id, 'userId': userId};
}

enum ConsultantProfileScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<String>('id', 'ConsultantProfile'),
  description<String>('description', 'ConsultantProfile'),
  qualifications<String>('qualifications', 'ConsultantProfile'),
  specialization<String>('specialization', 'ConsultantProfile'),
  experience<double>('experience', 'ConsultantProfile'),
  rating<double>('rating', 'ConsultantProfile'),
  domainId<String>('domainId', 'ConsultantProfile'),
  scheduleType<_i3.ScheduleType>('scheduleType', 'ConsultantProfile'),
  userId<String>('userId', 'ConsultantProfile'),
  createdAt<DateTime>('createdAt', 'ConsultantProfile'),
  updatedAt<DateTime>('updatedAt', 'ConsultantProfile');

  const ConsultantProfileScalar(this.name, this.model);

  @override
  final String name;

  @override
  final String model;
}

class TagConsultantProfilesArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagConsultantProfilesArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.ConsultantProfileWhereInput? where;

  final _i1.PrismaUnion<
    Iterable<_i2.ConsultantProfileOrderByWithRelationInput>,
    _i2.ConsultantProfileOrderByWithRelationInput
  >?
  orderBy;

  final _i2.ConsultantProfileWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileScalar,
    Iterable<_i2.ConsultantProfileScalar>
  >?
  distinct;

  final _i2.ConsultantProfileSelect? select;

  final _i2.ConsultantProfileInclude? include;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'orderBy': orderBy,
    'cursor': cursor,
    'take': take,
    'skip': skip,
    'distinct': distinct,
    'select': select,
    'include': include,
  };
}

class TagCountOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagCountOutputTypeSelect({this.consultantProfiles});

  final bool? consultantProfiles;

  @override
  Map<String, dynamic> toJson() => {'consultantProfiles': consultantProfiles};
}

class TagCountArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagCountArgs({this.select});

  final _i2.TagCountOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class TagSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagSelect({
    this.id,
    this.name,
    this.domainId,
    this.createdAt,
    this.updatedAt,
    this.domain,
    this.consultantProfiles,
    this.$count,
  });

  final bool? id;

  final bool? name;

  final bool? domainId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.TagDomainArgs>? domain;

  final _i1.PrismaUnion<bool, _i2.TagConsultantProfilesArgs>?
  consultantProfiles;

  final _i1.PrismaUnion<bool, _i2.TagCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'domainId': domainId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'domain': domain,
    'consultantProfiles': consultantProfiles,
    '_count': $count,
  };
}

class TagInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagInclude({this.domain, this.consultantProfiles, this.$count});

  final _i1.PrismaUnion<bool, _i2.TagDomainArgs>? domain;

  final _i1.PrismaUnion<bool, _i2.TagConsultantProfilesArgs>?
  consultantProfiles;

  final _i1.PrismaUnion<bool, _i2.TagCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
    'domain': domain,
    'consultantProfiles': consultantProfiles,
    '_count': $count,
  };
}

class TagOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagOrderByWithRelationInput({
    this.id,
    this.name,
    this.domainId,
    this.createdAt,
    this.updatedAt,
    this.domain,
    this.consultantProfiles,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? name;

  final _i2.SortOrder? domainId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.DomainOrderByWithRelationInput? domain;

  final _i2.ConsultantProfileOrderByRelationAggregateInput? consultantProfiles;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'domainId': domainId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'domain': domain,
    'consultantProfiles': consultantProfiles,
  };
}

class TagNameDomainIdCompoundUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagNameDomainIdCompoundUniqueInput({
    required this.name,
    required this.domainId,
  });

  final String name;

  final String domainId;

  @override
  Map<String, dynamic> toJson() => {'name': name, 'domainId': domainId};
}

class TagWhereUniqueInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagWhereUniqueInput({this.id, this.nameDomainId});

  final String? id;

  final _i2.TagNameDomainIdCompoundUniqueInput? nameDomainId;

  @override
  Map<String, dynamic> toJson() => {'id': id, 'name_domainId': nameDomainId};
}

enum TagScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<String>('id', 'Tag'),
  name$<String>('name', 'Tag'),
  domainId<String>('domainId', 'Tag'),
  createdAt<DateTime>('createdAt', 'Tag'),
  updatedAt<DateTime>('updatedAt', 'Tag');

  const TagScalar(this.name, this.model);

  @override
  final String name;

  @override
  final String model;
}

class ConsultantProfileTagsArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileTagsArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.TagWhereInput? where;

  final _i1.PrismaUnion<
    Iterable<_i2.TagOrderByWithRelationInput>,
    _i2.TagOrderByWithRelationInput
  >?
  orderBy;

  final _i2.TagWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.TagScalar, Iterable<_i2.TagScalar>>? distinct;

  final _i2.TagSelect? select;

  final _i2.TagInclude? include;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'orderBy': orderBy,
    'cursor': cursor,
    'take': take,
    'skip': skip,
    'distinct': distinct,
    'select': select,
    'include': include,
  };
}

class ConsultantReviewConsultantProfileArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewConsultantProfileArgs({this.select, this.include});

  final _i2.ConsultantProfileSelect? select;

  final _i2.ConsultantProfileInclude? include;

  @override
  Map<String, dynamic> toJson() => {'select': select, 'include': include};
}

class ConsultationPlanConsultantProfileArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanConsultantProfileArgs({this.select, this.include});

  final _i2.ConsultantProfileSelect? select;

  final _i2.ConsultantProfileInclude? include;

  @override
  Map<String, dynamic> toJson() => {'select': select, 'include': include};
}

class ConsultationWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationWhereUniqueInput({this.id});

  final String? id;

  @override
  Map<String, dynamic> toJson() => {'id': id};
}

enum ConsultationScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<String>('id', 'Consultation'),
  consultationPlanId<String>('consultationPlanId', 'Consultation'),
  requestStatus<_i3.RequestStatus>('requestStatus', 'Consultation'),
  requestedById<String>('requestedById', 'Consultation'),
  requestedAt<DateTime>('requestedAt', 'Consultation'),
  requestNotes<String>('requestNotes', 'Consultation'),
  directlyBooked<bool>('directlyBooked', 'Consultation'),
  feedbackFromConsultee<String>('feedbackFromConsultee', 'Consultation'),
  feedbackFromConsultant<String>('feedbackFromConsultant', 'Consultation'),
  rating<double>('rating', 'Consultation'),
  createdAt<DateTime>('createdAt', 'Consultation'),
  updatedAt<DateTime>('updatedAt', 'Consultation');

  const ConsultationScalar(this.name, this.model);

  @override
  final String name;

  @override
  final String model;
}

class ConsultationPlanConsultationsArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanConsultationsArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.ConsultationWhereInput? where;

  final _i1.PrismaUnion<
    Iterable<_i2.ConsultationOrderByWithRelationInput>,
    _i2.ConsultationOrderByWithRelationInput
  >?
  orderBy;

  final _i2.ConsultationWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<
    _i2.ConsultationScalar,
    Iterable<_i2.ConsultationScalar>
  >?
  distinct;

  final _i2.ConsultationSelect? select;

  final _i2.ConsultationInclude? include;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'orderBy': orderBy,
    'cursor': cursor,
    'take': take,
    'skip': skip,
    'distinct': distinct,
    'select': select,
    'include': include,
  };
}

class ConsultationPlanCountOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanCountOutputTypeSelect({this.consultations});

  final bool? consultations;

  @override
  Map<String, dynamic> toJson() => {'consultations': consultations};
}

class ConsultationPlanCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanCountArgs({this.select});

  final _i2.ConsultationPlanCountOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ConsultationPlanInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanInclude({
    this.consultantProfile,
    this.consultations,
    this.$count,
  });

  final _i1.PrismaUnion<bool, _i2.ConsultationPlanConsultantProfileArgs>?
  consultantProfile;

  final _i1.PrismaUnion<bool, _i2.ConsultationPlanConsultationsArgs>?
  consultations;

  final _i1.PrismaUnion<bool, _i2.ConsultationPlanCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
    'consultantProfile': consultantProfile,
    'consultations': consultations,
    '_count': $count,
  };
}

class ConsultationConsultationPlanArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationConsultationPlanArgs({this.select, this.include});

  final _i2.ConsultationPlanSelect? select;

  final _i2.ConsultationPlanInclude? include;

  @override
  Map<String, dynamic> toJson() => {'select': select, 'include': include};
}

class ConsulteeProfileConsultationRequestsArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileConsultationRequestsArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.ConsultationWhereInput? where;

  final _i1.PrismaUnion<
    Iterable<_i2.ConsultationOrderByWithRelationInput>,
    _i2.ConsultationOrderByWithRelationInput
  >?
  orderBy;

  final _i2.ConsultationWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<
    _i2.ConsultationScalar,
    Iterable<_i2.ConsultationScalar>
  >?
  distinct;

  final _i2.ConsultationSelect? select;

  final _i2.ConsultationInclude? include;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'orderBy': orderBy,
    'cursor': cursor,
    'take': take,
    'skip': skip,
    'distinct': distinct,
    'select': select,
    'include': include,
  };
}

class SubscriptionRequestedByArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionRequestedByArgs({this.select, this.include});

  final _i2.ConsulteeProfileSelect? select;

  final _i2.ConsulteeProfileInclude? include;

  @override
  Map<String, dynamic> toJson() => {'select': select, 'include': include};
}

class SubscriptionPlanConsultantProfileArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanConsultantProfileArgs({this.select, this.include});

  final _i2.ConsultantProfileSelect? select;

  final _i2.ConsultantProfileInclude? include;

  @override
  Map<String, dynamic> toJson() => {'select': select, 'include': include};
}

class SubscriptionWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionWhereUniqueInput({this.id});

  final String? id;

  @override
  Map<String, dynamic> toJson() => {'id': id};
}

enum SubscriptionScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<String>('id', 'Subscription'),
  startDate<DateTime>('startDate', 'Subscription'),
  endDate<DateTime>('endDate', 'Subscription'),
  requestStatus<_i3.RequestStatus>('requestStatus', 'Subscription'),
  requestedById<String>('requestedById', 'Subscription'),
  requestedAt<DateTime>('requestedAt', 'Subscription'),
  requestNotes<String>('requestNotes', 'Subscription'),
  feedbackFromConsultee<String>('feedbackFromConsultee', 'Subscription'),
  feedbackFromConsultant<String>('feedbackFromConsultant', 'Subscription'),
  rating<double>('rating', 'Subscription'),
  subscriptionPlanId<String>('subscriptionPlanId', 'Subscription'),
  createdAt<DateTime>('createdAt', 'Subscription'),
  updatedAt<DateTime>('updatedAt', 'Subscription');

  const SubscriptionScalar(this.name, this.model);

  @override
  final String name;

  @override
  final String model;
}

class SubscriptionPlanSubscriptionsArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanSubscriptionsArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.SubscriptionWhereInput? where;

  final _i1.PrismaUnion<
    Iterable<_i2.SubscriptionOrderByWithRelationInput>,
    _i2.SubscriptionOrderByWithRelationInput
  >?
  orderBy;

  final _i2.SubscriptionWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<
    _i2.SubscriptionScalar,
    Iterable<_i2.SubscriptionScalar>
  >?
  distinct;

  final _i2.SubscriptionSelect? select;

  final _i2.SubscriptionInclude? include;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'orderBy': orderBy,
    'cursor': cursor,
    'take': take,
    'skip': skip,
    'distinct': distinct,
    'select': select,
    'include': include,
  };
}

class SubscriptionPlanCountOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanCountOutputTypeSelect({this.subscriptions});

  final bool? subscriptions;

  @override
  Map<String, dynamic> toJson() => {'subscriptions': subscriptions};
}

class SubscriptionPlanCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanCountArgs({this.select});

  final _i2.SubscriptionPlanCountOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SubscriptionPlanInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanInclude({
    this.consultantProfile,
    this.subscriptions,
    this.$count,
  });

  final _i1.PrismaUnion<bool, _i2.SubscriptionPlanConsultantProfileArgs>?
  consultantProfile;

  final _i1.PrismaUnion<bool, _i2.SubscriptionPlanSubscriptionsArgs>?
  subscriptions;

  final _i1.PrismaUnion<bool, _i2.SubscriptionPlanCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
    'consultantProfile': consultantProfile,
    'subscriptions': subscriptions,
    '_count': $count,
  };
}

class SubscriptionSubscriptionPlanArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionSubscriptionPlanArgs({this.select, this.include});

  final _i2.SubscriptionPlanSelect? select;

  final _i2.SubscriptionPlanInclude? include;

  @override
  Map<String, dynamic> toJson() => {'select': select, 'include': include};
}

class AppointmentWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentWhereUniqueInput({
    this.id,
    this.consultationId,
    this.webinarId,
  });

  final String? id;

  final String? consultationId;

  final String? webinarId;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'consultationId': consultationId,
    'webinarId': webinarId,
  };
}

enum AppointmentScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<String>('id', 'Appointment'),
  appointmentType<_i3.AppointmentsType>('appointmentType', 'Appointment'),
  consultationId<String>('consultationId', 'Appointment'),
  subscriptionId<String>('subscriptionId', 'Appointment'),
  webinarId<String>('webinarId', 'Appointment'),
  classId<String>('classId', 'Appointment'),
  createdAt<DateTime>('createdAt', 'Appointment'),
  updatedAt<DateTime>('updatedAt', 'Appointment');

  const AppointmentScalar(this.name, this.model);

  @override
  final String name;

  @override
  final String model;
}

class SubscriptionAppointmentsArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionAppointmentsArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.AppointmentWhereInput? where;

  final _i1.PrismaUnion<
    Iterable<_i2.AppointmentOrderByWithRelationInput>,
    _i2.AppointmentOrderByWithRelationInput
  >?
  orderBy;

  final _i2.AppointmentWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.AppointmentScalar, Iterable<_i2.AppointmentScalar>>?
  distinct;

  final _i2.AppointmentSelect? select;

  final _i2.AppointmentInclude? include;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'orderBy': orderBy,
    'cursor': cursor,
    'take': take,
    'skip': skip,
    'distinct': distinct,
    'select': select,
    'include': include,
  };
}

class SubscriptionCountOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionCountOutputTypeSelect({this.appointments});

  final bool? appointments;

  @override
  Map<String, dynamic> toJson() => {'appointments': appointments};
}

class SubscriptionCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionCountArgs({this.select});

  final _i2.SubscriptionCountOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SubscriptionInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionInclude({
    this.requestedBy,
    this.subscriptionPlan,
    this.appointments,
    this.$count,
  });

  final _i1.PrismaUnion<bool, _i2.SubscriptionRequestedByArgs>? requestedBy;

  final _i1.PrismaUnion<bool, _i2.SubscriptionSubscriptionPlanArgs>?
  subscriptionPlan;

  final _i1.PrismaUnion<bool, _i2.SubscriptionAppointmentsArgs>? appointments;

  final _i1.PrismaUnion<bool, _i2.SubscriptionCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
    'requestedBy': requestedBy,
    'subscriptionPlan': subscriptionPlan,
    'appointments': appointments,
    '_count': $count,
  };
}

class SubscriptionPlanSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanSelect({
    this.id,
    this.title,
    this.description,
    this.durationInMonths,
    this.price,
    this.callsPerWeek,
    this.sessionDurationInHours,
    this.videoMeetings,
    this.emailSupport,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.consultantProfile,
    this.subscriptions,
    this.$count,
  });

  final bool? id;

  final bool? title;

  final bool? description;

  final bool? durationInMonths;

  final bool? price;

  final bool? callsPerWeek;

  final bool? sessionDurationInHours;

  final bool? videoMeetings;

  final bool? emailSupport;

  final bool? language;

  final bool? level;

  final bool? prerequisites;

  final bool? materialProvided;

  final bool? learningOutcomes;

  final bool? consultantProfileId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.SubscriptionPlanConsultantProfileArgs>?
  consultantProfile;

  final _i1.PrismaUnion<bool, _i2.SubscriptionPlanSubscriptionsArgs>?
  subscriptions;

  final _i1.PrismaUnion<bool, _i2.SubscriptionPlanCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInMonths': durationInMonths,
    'price': price,
    'callsPerWeek': callsPerWeek,
    'sessionDurationInHours': sessionDurationInHours,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultantProfile': consultantProfile,
    'subscriptions': subscriptions,
    '_count': $count,
  };
}

class SubscriptionSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionSelect({
    this.id,
    this.startDate,
    this.endDate,
    this.requestStatus,
    this.requestedById,
    this.requestedAt,
    this.requestNotes,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.subscriptionPlanId,
    this.createdAt,
    this.updatedAt,
    this.requestedBy,
    this.subscriptionPlan,
    this.appointments,
    this.$count,
  });

  final bool? id;

  final bool? startDate;

  final bool? endDate;

  final bool? requestStatus;

  final bool? requestedById;

  final bool? requestedAt;

  final bool? requestNotes;

  final bool? feedbackFromConsultee;

  final bool? feedbackFromConsultant;

  final bool? rating;

  final bool? subscriptionPlanId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.SubscriptionRequestedByArgs>? requestedBy;

  final _i1.PrismaUnion<bool, _i2.SubscriptionSubscriptionPlanArgs>?
  subscriptionPlan;

  final _i1.PrismaUnion<bool, _i2.SubscriptionAppointmentsArgs>? appointments;

  final _i1.PrismaUnion<bool, _i2.SubscriptionCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'requestStatus': requestStatus,
    'requestedById': requestedById,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'subscriptionPlanId': subscriptionPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'requestedBy': requestedBy,
    'subscriptionPlan': subscriptionPlan,
    'appointments': appointments,
    '_count': $count,
  };
}

class ConsulteeProfileSubscriptionRequestsArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileSubscriptionRequestsArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.SubscriptionWhereInput? where;

  final _i1.PrismaUnion<
    Iterable<_i2.SubscriptionOrderByWithRelationInput>,
    _i2.SubscriptionOrderByWithRelationInput
  >?
  orderBy;

  final _i2.SubscriptionWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<
    _i2.SubscriptionScalar,
    Iterable<_i2.SubscriptionScalar>
  >?
  distinct;

  final _i2.SubscriptionSelect? select;

  final _i2.SubscriptionInclude? include;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'orderBy': orderBy,
    'cursor': cursor,
    'take': take,
    'skip': skip,
    'distinct': distinct,
    'select': select,
    'include': include,
  };
}

class ConsultantReviewConsulteeProfileArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewConsulteeProfileArgs({this.select, this.include});

  final _i2.ConsulteeProfileSelect? select;

  final _i2.ConsulteeProfileInclude? include;

  @override
  Map<String, dynamic> toJson() => {'select': select, 'include': include};
}

class ConsultantReviewInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewInclude({
    this.consultantProfile,
    this.consulteeProfile,
  });

  final _i1.PrismaUnion<bool, _i2.ConsultantReviewConsultantProfileArgs>?
  consultantProfile;

  final _i1.PrismaUnion<bool, _i2.ConsultantReviewConsulteeProfileArgs>?
  consulteeProfile;

  @override
  Map<String, dynamic> toJson() => {
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
  };
}

class ConsultantReviewOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewOrderByWithRelationInput({
    this.id,
    this.rating,
    this.reviewDescription,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.createdAt,
    this.updatedAt,
    this.consultantProfile,
    this.consulteeProfile,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? rating;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? reviewDescription;

  final _i2.SortOrder? consultantProfileId;

  final _i2.SortOrder? consulteeProfileId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.ConsultantProfileOrderByWithRelationInput? consultantProfile;

  final _i2.ConsulteeProfileOrderByWithRelationInput? consulteeProfile;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'rating': rating,
    'reviewDescription': reviewDescription,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
  };
}

class ConsultantReviewWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewWhereUniqueInput({this.id});

  final String? id;

  @override
  Map<String, dynamic> toJson() => {'id': id};
}

enum ConsultantReviewScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<String>('id', 'ConsultantReview'),
  rating<int>('rating', 'ConsultantReview'),
  reviewDescription<String>('reviewDescription', 'ConsultantReview'),
  consultantProfileId<String>('consultantProfileId', 'ConsultantReview'),
  consulteeProfileId<String>('consulteeProfileId', 'ConsultantReview'),
  createdAt<DateTime>('createdAt', 'ConsultantReview'),
  updatedAt<DateTime>('updatedAt', 'ConsultantReview');

  const ConsultantReviewScalar(this.name, this.model);

  @override
  final String name;

  @override
  final String model;
}

class ConsulteeProfileConsultantReviewsArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileConsultantReviewsArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.ConsultantReviewWhereInput? where;

  final _i1.PrismaUnion<
    Iterable<_i2.ConsultantReviewOrderByWithRelationInput>,
    _i2.ConsultantReviewOrderByWithRelationInput
  >?
  orderBy;

  final _i2.ConsultantReviewWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewScalar,
    Iterable<_i2.ConsultantReviewScalar>
  >?
  distinct;

  final _i2.ConsultantReviewSelect? select;

  final _i2.ConsultantReviewInclude? include;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'orderBy': orderBy,
    'cursor': cursor,
    'take': take,
    'skip': skip,
    'distinct': distinct,
    'select': select,
    'include': include,
  };
}

class ConsulteeProfileUserArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileUserArgs({this.select, this.include});

  final _i2.UserSelect? select;

  final _i2.UserInclude? include;

  @override
  Map<String, dynamic> toJson() => {'select': select, 'include': include};
}

class ConsulteeProfileCountOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileCountOutputTypeSelect({
    this.consultationRequests,
    this.subscriptionRequests,
    this.consultantReviews,
  });

  final bool? consultationRequests;

  final bool? subscriptionRequests;

  final bool? consultantReviews;

  @override
  Map<String, dynamic> toJson() => {
    'consultationRequests': consultationRequests,
    'subscriptionRequests': subscriptionRequests,
    'consultantReviews': consultantReviews,
  };
}

class ConsulteeProfileCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileCountArgs({this.select});

  final _i2.ConsulteeProfileCountOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ConsulteeProfileInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileInclude({
    this.consultationRequests,
    this.subscriptionRequests,
    this.consultantReviews,
    this.user,
    this.$count,
  });

  final _i1.PrismaUnion<bool, _i2.ConsulteeProfileConsultationRequestsArgs>?
  consultationRequests;

  final _i1.PrismaUnion<bool, _i2.ConsulteeProfileSubscriptionRequestsArgs>?
  subscriptionRequests;

  final _i1.PrismaUnion<bool, _i2.ConsulteeProfileConsultantReviewsArgs>?
  consultantReviews;

  final _i1.PrismaUnion<bool, _i2.ConsulteeProfileUserArgs>? user;

  final _i1.PrismaUnion<bool, _i2.ConsulteeProfileCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
    'consultationRequests': consultationRequests,
    'subscriptionRequests': subscriptionRequests,
    'consultantReviews': consultantReviews,
    'user': user,
    '_count': $count,
  };
}

class ConsultationRequestedByArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationRequestedByArgs({this.select, this.include});

  final _i2.ConsulteeProfileSelect? select;

  final _i2.ConsulteeProfileInclude? include;

  @override
  Map<String, dynamic> toJson() => {'select': select, 'include': include};
}

class ConsultationAppointmentArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationAppointmentArgs({this.select, this.include});

  final _i2.AppointmentSelect? select;

  final _i2.AppointmentInclude? include;

  @override
  Map<String, dynamic> toJson() => {'select': select, 'include': include};
}

class ConsultationInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationInclude({
    this.consultationPlan,
    this.requestedBy,
    this.appointment,
  });

  final _i1.PrismaUnion<bool, _i2.ConsultationConsultationPlanArgs>?
  consultationPlan;

  final _i1.PrismaUnion<bool, _i2.ConsultationRequestedByArgs>? requestedBy;

  final _i1.PrismaUnion<bool, _i2.ConsultationAppointmentArgs>? appointment;

  @override
  Map<String, dynamic> toJson() => {
    'consultationPlan': consultationPlan,
    'requestedBy': requestedBy,
    'appointment': appointment,
  };
}

class ConsulteeProfileSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileSelect({
    this.id,
    this.education,
    this.occupation,
    this.aboutMe,
    this.preferredCommunicationMethod,
    this.preferredLanguage,
    this.specialRequirements,
    this.interests,
    this.goals,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.consultationRequests,
    this.subscriptionRequests,
    this.consultantReviews,
    this.user,
    this.$count,
  });

  final bool? id;

  final bool? education;

  final bool? occupation;

  final bool? aboutMe;

  final bool? preferredCommunicationMethod;

  final bool? preferredLanguage;

  final bool? specialRequirements;

  final bool? interests;

  final bool? goals;

  final bool? userId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.ConsulteeProfileConsultationRequestsArgs>?
  consultationRequests;

  final _i1.PrismaUnion<bool, _i2.ConsulteeProfileSubscriptionRequestsArgs>?
  subscriptionRequests;

  final _i1.PrismaUnion<bool, _i2.ConsulteeProfileConsultantReviewsArgs>?
  consultantReviews;

  final _i1.PrismaUnion<bool, _i2.ConsulteeProfileUserArgs>? user;

  final _i1.PrismaUnion<bool, _i2.ConsulteeProfileCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'education': education,
    'occupation': occupation,
    'aboutMe': aboutMe,
    'preferredCommunicationMethod': preferredCommunicationMethod,
    'preferredLanguage': preferredLanguage,
    'specialRequirements': specialRequirements,
    'interests': interests,
    'goals': goals,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultationRequests': consultationRequests,
    'subscriptionRequests': subscriptionRequests,
    'consultantReviews': consultantReviews,
    'user': user,
    '_count': $count,
  };
}

class ConsultantReviewSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewSelect({
    this.id,
    this.rating,
    this.reviewDescription,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.createdAt,
    this.updatedAt,
    this.consultantProfile,
    this.consulteeProfile,
  });

  final bool? id;

  final bool? rating;

  final bool? reviewDescription;

  final bool? consultantProfileId;

  final bool? consulteeProfileId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.ConsultantReviewConsultantProfileArgs>?
  consultantProfile;

  final _i1.PrismaUnion<bool, _i2.ConsultantReviewConsulteeProfileArgs>?
  consulteeProfile;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'rating': rating,
    'reviewDescription': reviewDescription,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
  };
}

class ConsultantProfileReviewsArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileReviewsArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.ConsultantReviewWhereInput? where;

  final _i1.PrismaUnion<
    Iterable<_i2.ConsultantReviewOrderByWithRelationInput>,
    _i2.ConsultantReviewOrderByWithRelationInput
  >?
  orderBy;

  final _i2.ConsultantReviewWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewScalar,
    Iterable<_i2.ConsultantReviewScalar>
  >?
  distinct;

  final _i2.ConsultantReviewSelect? select;

  final _i2.ConsultantReviewInclude? include;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'orderBy': orderBy,
    'cursor': cursor,
    'take': take,
    'skip': skip,
    'distinct': distinct,
    'select': select,
    'include': include,
  };
}

class SlotOfAvailabilityWeeklyConsultantProfileArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityWeeklyConsultantProfileArgs({
    this.select,
    this.include,
  });

  final _i2.ConsultantProfileSelect? select;

  final _i2.ConsultantProfileInclude? include;

  @override
  Map<String, dynamic> toJson() => {'select': select, 'include': include};
}

class SlotOfAvailabilityWeeklySelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityWeeklySelect({
    this.id,
    this.dayOfWeekforStartTimeInUTC,
    this.slotStartTimeInUTC,
    this.dayOfWeekforEndTimeInUTC,
    this.slotEndTimeInUTC,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.consultantProfile,
  });

  final bool? id;

  final bool? dayOfWeekforStartTimeInUTC;

  final bool? slotStartTimeInUTC;

  final bool? dayOfWeekforEndTimeInUTC;

  final bool? slotEndTimeInUTC;

  final bool? consultantProfileId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<
    bool,
    _i2.SlotOfAvailabilityWeeklyConsultantProfileArgs
  >?
  consultantProfile;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'dayOfWeekforStartTimeInUTC': dayOfWeekforStartTimeInUTC,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'dayOfWeekforEndTimeInUTC': dayOfWeekforEndTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultantProfile': consultantProfile,
  };
}

class SlotOfAvailabilityWeeklyInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityWeeklyInclude({this.consultantProfile});

  final _i1.PrismaUnion<
    bool,
    _i2.SlotOfAvailabilityWeeklyConsultantProfileArgs
  >?
  consultantProfile;

  @override
  Map<String, dynamic> toJson() => {'consultantProfile': consultantProfile};
}

class SlotOfAvailabilityWeeklyOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityWeeklyOrderByWithRelationInput({
    this.id,
    this.dayOfWeekforStartTimeInUTC,
    this.slotStartTimeInUTC,
    this.dayOfWeekforEndTimeInUTC,
    this.slotEndTimeInUTC,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.consultantProfile,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? dayOfWeekforStartTimeInUTC;

  final _i2.SortOrder? slotStartTimeInUTC;

  final _i2.SortOrder? dayOfWeekforEndTimeInUTC;

  final _i2.SortOrder? slotEndTimeInUTC;

  final _i2.SortOrder? consultantProfileId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.ConsultantProfileOrderByWithRelationInput? consultantProfile;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'dayOfWeekforStartTimeInUTC': dayOfWeekforStartTimeInUTC,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'dayOfWeekforEndTimeInUTC': dayOfWeekforEndTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultantProfile': consultantProfile,
  };
}

class SlotOfAvailabilityWeeklyWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityWeeklyWhereUniqueInput({this.id});

  final String? id;

  @override
  Map<String, dynamic> toJson() => {'id': id};
}

enum SlotOfAvailabilityWeeklyScalar<T>
    implements _i1.PrismaEnum, _i1.Reference<T> {
  id<String>('id', 'SlotOfAvailabilityWeekly'),
  dayOfWeekforStartTimeInUTC<_i3.DayOfWeek>(
    'dayOfWeekforStartTimeInUTC',
    'SlotOfAvailabilityWeekly',
  ),
  slotStartTimeInUTC<DateTime>(
    'slotStartTimeInUTC',
    'SlotOfAvailabilityWeekly',
  ),
  dayOfWeekforEndTimeInUTC<_i3.DayOfWeek>(
    'dayOfWeekforEndTimeInUTC',
    'SlotOfAvailabilityWeekly',
  ),
  slotEndTimeInUTC<DateTime>('slotEndTimeInUTC', 'SlotOfAvailabilityWeekly'),
  consultantProfileId<String>(
    'consultantProfileId',
    'SlotOfAvailabilityWeekly',
  ),
  createdAt<DateTime>('createdAt', 'SlotOfAvailabilityWeekly'),
  updatedAt<DateTime>('updatedAt', 'SlotOfAvailabilityWeekly');

  const SlotOfAvailabilityWeeklyScalar(this.name, this.model);

  @override
  final String name;

  @override
  final String model;
}

class ConsultantProfileSlotsOfAvailabilityWeeklyArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileSlotsOfAvailabilityWeeklyArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.SlotOfAvailabilityWeeklyWhereInput? where;

  final _i1.PrismaUnion<
    Iterable<_i2.SlotOfAvailabilityWeeklyOrderByWithRelationInput>,
    _i2.SlotOfAvailabilityWeeklyOrderByWithRelationInput
  >?
  orderBy;

  final _i2.SlotOfAvailabilityWeeklyWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityWeeklyScalar,
    Iterable<_i2.SlotOfAvailabilityWeeklyScalar>
  >?
  distinct;

  final _i2.SlotOfAvailabilityWeeklySelect? select;

  final _i2.SlotOfAvailabilityWeeklyInclude? include;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'orderBy': orderBy,
    'cursor': cursor,
    'take': take,
    'skip': skip,
    'distinct': distinct,
    'select': select,
    'include': include,
  };
}

class SlotOfAvailabilityCustomConsultantProfileArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityCustomConsultantProfileArgs({
    this.select,
    this.include,
  });

  final _i2.ConsultantProfileSelect? select;

  final _i2.ConsultantProfileInclude? include;

  @override
  Map<String, dynamic> toJson() => {'select': select, 'include': include};
}

class SlotOfAvailabilityCustomSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityCustomSelect({
    this.id,
    this.slotStartTimeInUTC,
    this.slotEndTimeInUTC,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.consultantProfile,
  });

  final bool? id;

  final bool? slotStartTimeInUTC;

  final bool? slotEndTimeInUTC;

  final bool? consultantProfileId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<
    bool,
    _i2.SlotOfAvailabilityCustomConsultantProfileArgs
  >?
  consultantProfile;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultantProfile': consultantProfile,
  };
}

class SlotOfAvailabilityCustomInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityCustomInclude({this.consultantProfile});

  final _i1.PrismaUnion<
    bool,
    _i2.SlotOfAvailabilityCustomConsultantProfileArgs
  >?
  consultantProfile;

  @override
  Map<String, dynamic> toJson() => {'consultantProfile': consultantProfile};
}

class SlotOfAvailabilityCustomOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityCustomOrderByWithRelationInput({
    this.id,
    this.slotStartTimeInUTC,
    this.slotEndTimeInUTC,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.consultantProfile,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? slotStartTimeInUTC;

  final _i2.SortOrder? slotEndTimeInUTC;

  final _i2.SortOrder? consultantProfileId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.ConsultantProfileOrderByWithRelationInput? consultantProfile;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultantProfile': consultantProfile,
  };
}

class SlotOfAvailabilityCustomWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityCustomWhereUniqueInput({this.id});

  final String? id;

  @override
  Map<String, dynamic> toJson() => {'id': id};
}

enum SlotOfAvailabilityCustomScalar<T>
    implements _i1.PrismaEnum, _i1.Reference<T> {
  id<String>('id', 'SlotOfAvailabilityCustom'),
  slotStartTimeInUTC<DateTime>(
    'slotStartTimeInUTC',
    'SlotOfAvailabilityCustom',
  ),
  slotEndTimeInUTC<DateTime>('slotEndTimeInUTC', 'SlotOfAvailabilityCustom'),
  consultantProfileId<String>(
    'consultantProfileId',
    'SlotOfAvailabilityCustom',
  ),
  createdAt<DateTime>('createdAt', 'SlotOfAvailabilityCustom'),
  updatedAt<DateTime>('updatedAt', 'SlotOfAvailabilityCustom');

  const SlotOfAvailabilityCustomScalar(this.name, this.model);

  @override
  final String name;

  @override
  final String model;
}

class ConsultantProfileSlotsOfAvailabilityCustomArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileSlotsOfAvailabilityCustomArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.SlotOfAvailabilityCustomWhereInput? where;

  final _i1.PrismaUnion<
    Iterable<_i2.SlotOfAvailabilityCustomOrderByWithRelationInput>,
    _i2.SlotOfAvailabilityCustomOrderByWithRelationInput
  >?
  orderBy;

  final _i2.SlotOfAvailabilityCustomWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityCustomScalar,
    Iterable<_i2.SlotOfAvailabilityCustomScalar>
  >?
  distinct;

  final _i2.SlotOfAvailabilityCustomSelect? select;

  final _i2.SlotOfAvailabilityCustomInclude? include;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'orderBy': orderBy,
    'cursor': cursor,
    'take': take,
    'skip': skip,
    'distinct': distinct,
    'select': select,
    'include': include,
  };
}

class ConsultationPlanWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanWhereUniqueInput({this.id});

  final String? id;

  @override
  Map<String, dynamic> toJson() => {'id': id};
}

enum ConsultationPlanScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<String>('id', 'ConsultationPlan'),
  title<String>('title', 'ConsultationPlan'),
  description<String>('description', 'ConsultationPlan'),
  durationInHours<double>('durationInHours', 'ConsultationPlan'),
  price<int>('price', 'ConsultationPlan'),
  language<String>('language', 'ConsultationPlan'),
  level<String>('level', 'ConsultationPlan'),
  prerequisites<String>('prerequisites', 'ConsultationPlan'),
  materialProvided<String>('materialProvided', 'ConsultationPlan'),
  learningOutcomes<String>('learningOutcomes', 'ConsultationPlan'),
  consultantProfileId<String>('consultantProfileId', 'ConsultationPlan'),
  createdAt<DateTime>('createdAt', 'ConsultationPlan'),
  updatedAt<DateTime>('updatedAt', 'ConsultationPlan');

  const ConsultationPlanScalar(this.name, this.model);

  @override
  final String name;

  @override
  final String model;
}

class ConsultantProfileConsultationPlansArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileConsultationPlansArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.ConsultationPlanWhereInput? where;

  final _i1.PrismaUnion<
    Iterable<_i2.ConsultationPlanOrderByWithRelationInput>,
    _i2.ConsultationPlanOrderByWithRelationInput
  >?
  orderBy;

  final _i2.ConsultationPlanWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<
    _i2.ConsultationPlanScalar,
    Iterable<_i2.ConsultationPlanScalar>
  >?
  distinct;

  final _i2.ConsultationPlanSelect? select;

  final _i2.ConsultationPlanInclude? include;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'orderBy': orderBy,
    'cursor': cursor,
    'take': take,
    'skip': skip,
    'distinct': distinct,
    'select': select,
    'include': include,
  };
}

class SubscriptionPlanWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanWhereUniqueInput({this.id});

  final String? id;

  @override
  Map<String, dynamic> toJson() => {'id': id};
}

enum SubscriptionPlanScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<String>('id', 'SubscriptionPlan'),
  title<String>('title', 'SubscriptionPlan'),
  description<String>('description', 'SubscriptionPlan'),
  durationInMonths<int>('durationInMonths', 'SubscriptionPlan'),
  price<int>('price', 'SubscriptionPlan'),
  callsPerWeek<int>('callsPerWeek', 'SubscriptionPlan'),
  sessionDurationInHours<double>('sessionDurationInHours', 'SubscriptionPlan'),
  videoMeetings<int>('videoMeetings', 'SubscriptionPlan'),
  emailSupport<_i3.PlanEmailSupport>('emailSupport', 'SubscriptionPlan'),
  language<String>('language', 'SubscriptionPlan'),
  level<String>('level', 'SubscriptionPlan'),
  prerequisites<String>('prerequisites', 'SubscriptionPlan'),
  materialProvided<String>('materialProvided', 'SubscriptionPlan'),
  learningOutcomes<String>('learningOutcomes', 'SubscriptionPlan'),
  consultantProfileId<String>('consultantProfileId', 'SubscriptionPlan'),
  createdAt<DateTime>('createdAt', 'SubscriptionPlan'),
  updatedAt<DateTime>('updatedAt', 'SubscriptionPlan');

  const SubscriptionPlanScalar(this.name, this.model);

  @override
  final String name;

  @override
  final String model;
}

class ConsultantProfileSubscriptionPlansArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileSubscriptionPlansArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.SubscriptionPlanWhereInput? where;

  final _i1.PrismaUnion<
    Iterable<_i2.SubscriptionPlanOrderByWithRelationInput>,
    _i2.SubscriptionPlanOrderByWithRelationInput
  >?
  orderBy;

  final _i2.SubscriptionPlanWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanScalar,
    Iterable<_i2.SubscriptionPlanScalar>
  >?
  distinct;

  final _i2.SubscriptionPlanSelect? select;

  final _i2.SubscriptionPlanInclude? include;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'orderBy': orderBy,
    'cursor': cursor,
    'take': take,
    'skip': skip,
    'distinct': distinct,
    'select': select,
    'include': include,
  };
}

class WebinarPlanWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanWhereUniqueInput({this.id});

  final String? id;

  @override
  Map<String, dynamic> toJson() => {'id': id};
}

enum WebinarPlanScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<String>('id', 'WebinarPlan'),
  title<String>('title', 'WebinarPlan'),
  description<String>('description', 'WebinarPlan'),
  price<int>('price', 'WebinarPlan'),
  priceCurrency<String>('priceCurrency', 'WebinarPlan'),
  certificateProvided<bool>('certificateProvided', 'WebinarPlan'),
  durationInHours<double>('durationInHours', 'WebinarPlan'),
  maxParticipants<int>('maxParticipants', 'WebinarPlan'),
  language<String>('language', 'WebinarPlan'),
  level<String>('level', 'WebinarPlan'),
  prerequisites<String>('prerequisites', 'WebinarPlan'),
  materialProvided<String>('materialProvided', 'WebinarPlan'),
  learningOutcomes<String>('learningOutcomes', 'WebinarPlan'),
  consultantProfileId<String>('consultantProfileId', 'WebinarPlan'),
  createdAt<DateTime>('createdAt', 'WebinarPlan'),
  updatedAt<DateTime>('updatedAt', 'WebinarPlan');

  const WebinarPlanScalar(this.name, this.model);

  @override
  final String name;

  @override
  final String model;
}

class TopicWebinarPlansArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TopicWebinarPlansArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.WebinarPlanWhereInput? where;

  final _i1.PrismaUnion<
    Iterable<_i2.WebinarPlanOrderByWithRelationInput>,
    _i2.WebinarPlanOrderByWithRelationInput
  >?
  orderBy;

  final _i2.WebinarPlanWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.WebinarPlanScalar, Iterable<_i2.WebinarPlanScalar>>?
  distinct;

  final _i2.WebinarPlanSelect? select;

  final _i2.WebinarPlanInclude? include;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'orderBy': orderBy,
    'cursor': cursor,
    'take': take,
    'skip': skip,
    'distinct': distinct,
    'select': select,
    'include': include,
  };
}

class TopicOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TopicOrderByWithRelationInput({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
    this.webinarPlans,
    this.classPlans,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? name;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.WebinarPlanOrderByRelationAggregateInput? webinarPlans;

  final _i2.ClassPlanOrderByRelationAggregateInput? classPlans;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'webinarPlans': webinarPlans,
    'classPlans': classPlans,
  };
}

class TopicWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TopicWhereUniqueInput({this.id, this.name});

  final String? id;

  final String? name;

  @override
  Map<String, dynamic> toJson() => {'id': id, 'name': name};
}

enum TopicScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<String>('id', 'Topic'),
  name$<String>('name', 'Topic'),
  createdAt<DateTime>('createdAt', 'Topic'),
  updatedAt<DateTime>('updatedAt', 'Topic');

  const TopicScalar(this.name, this.model);

  @override
  final String name;

  @override
  final String model;
}

class ClassPlanTopicsArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanTopicsArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.TopicWhereInput? where;

  final _i1.PrismaUnion<
    Iterable<_i2.TopicOrderByWithRelationInput>,
    _i2.TopicOrderByWithRelationInput
  >?
  orderBy;

  final _i2.TopicWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.TopicScalar, Iterable<_i2.TopicScalar>>? distinct;

  final _i2.TopicSelect? select;

  final _i2.TopicInclude? include;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'orderBy': orderBy,
    'cursor': cursor,
    'take': take,
    'skip': skip,
    'distinct': distinct,
    'select': select,
    'include': include,
  };
}

class ClassContentClassPlanArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassContentClassPlanArgs({this.select, this.include});

  final _i2.ClassPlanSelect? select;

  final _i2.ClassPlanInclude? include;

  @override
  Map<String, dynamic> toJson() => {'select': select, 'include': include};
}

class ClassContentInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassContentInclude({this.classPlan});

  final _i1.PrismaUnion<bool, _i2.ClassContentClassPlanArgs>? classPlan;

  @override
  Map<String, dynamic> toJson() => {'classPlan': classPlan};
}

class ClassContentOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassContentOrderByWithRelationInput({
    this.id,
    this.title,
    this.description,
    this.contentType,
    this.contentUrl,
    this.order,
    this.hoursAllotted,
    this.classPlanId,
    this.createdAt,
    this.updatedAt,
    this.classPlan,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? title;

  final _i2.SortOrder? description;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? contentType;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? contentUrl;

  final _i2.SortOrder? order;

  final _i2.SortOrder? hoursAllotted;

  final _i2.SortOrder? classPlanId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.ClassPlanOrderByWithRelationInput? classPlan;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'contentType': contentType,
    'contentUrl': contentUrl,
    'order': order,
    'hoursAllotted': hoursAllotted,
    'classPlanId': classPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'classPlan': classPlan,
  };
}

class ClassContentWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassContentWhereUniqueInput({this.id});

  final String? id;

  @override
  Map<String, dynamic> toJson() => {'id': id};
}

enum ClassContentScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<String>('id', 'ClassContent'),
  title<String>('title', 'ClassContent'),
  description<String>('description', 'ClassContent'),
  contentType<String>('contentType', 'ClassContent'),
  contentUrl<String>('contentUrl', 'ClassContent'),
  order<int>('order', 'ClassContent'),
  hoursAllotted<double>('hoursAllotted', 'ClassContent'),
  classPlanId<String>('classPlanId', 'ClassContent'),
  createdAt<DateTime>('createdAt', 'ClassContent'),
  updatedAt<DateTime>('updatedAt', 'ClassContent');

  const ClassContentScalar(this.name, this.model);

  @override
  final String name;

  @override
  final String model;
}

class ClassPlanClassContentsArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanClassContentsArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.ClassContentWhereInput? where;

  final _i1.PrismaUnion<
    Iterable<_i2.ClassContentOrderByWithRelationInput>,
    _i2.ClassContentOrderByWithRelationInput
  >?
  orderBy;

  final _i2.ClassContentWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<
    _i2.ClassContentScalar,
    Iterable<_i2.ClassContentScalar>
  >?
  distinct;

  final _i2.ClassContentSelect? select;

  final _i2.ClassContentInclude? include;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'orderBy': orderBy,
    'cursor': cursor,
    'take': take,
    'skip': skip,
    'distinct': distinct,
    'select': select,
    'include': include,
  };
}

class ClassPlanConsultantProfileArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanConsultantProfileArgs({this.select, this.include});

  final _i2.ConsultantProfileSelect? select;

  final _i2.ConsultantProfileInclude? include;

  @override
  Map<String, dynamic> toJson() => {'select': select, 'include': include};
}

class WaitlistUserArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistUserArgs({this.select, this.include});

  final _i2.UserSelect? select;

  final _i2.UserInclude? include;

  @override
  Map<String, dynamic> toJson() => {'select': select, 'include': include};
}

class WaitlistOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistOrderByWithRelationInput({
    this.id,
    this.joinedAt,
    this.userId,
    this.webinarId,
    this.classId,
    this.user,
    this.webinar,
    this.$class,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? joinedAt;

  final _i2.SortOrder? userId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? webinarId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? classId;

  final _i2.UserOrderByWithRelationInput? user;

  final _i2.WebinarOrderByWithRelationInput? webinar;

  final _i2.ClassOrderByWithRelationInput? $class;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'joinedAt': joinedAt,
    'userId': userId,
    'webinarId': webinarId,
    'classId': classId,
    'user': user,
    'webinar': webinar,
    'class': $class,
  };
}

class WaitlistUserIdWebinarIdCompoundUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistUserIdWebinarIdCompoundUniqueInput({
    required this.userId,
    required this.webinarId,
  });

  final String userId;

  final String webinarId;

  @override
  Map<String, dynamic> toJson() => {'userId': userId, 'webinarId': webinarId};
}

class WaitlistUserIdClassIdCompoundUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistUserIdClassIdCompoundUniqueInput({
    required this.userId,
    required this.classId,
  });

  final String userId;

  final String classId;

  @override
  Map<String, dynamic> toJson() => {'userId': userId, 'classId': classId};
}

class WaitlistWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistWhereUniqueInput({
    this.id,
    this.userIdWebinarId,
    this.userIdClassId,
  });

  final String? id;

  final _i2.WaitlistUserIdWebinarIdCompoundUniqueInput? userIdWebinarId;

  final _i2.WaitlistUserIdClassIdCompoundUniqueInput? userIdClassId;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'userId_webinarId': userIdWebinarId,
    'userId_classId': userIdClassId,
  };
}

enum WaitlistScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<String>('id', 'Waitlist'),
  joinedAt<DateTime>('joinedAt', 'Waitlist'),
  userId<String>('userId', 'Waitlist'),
  webinarId<String>('webinarId', 'Waitlist'),
  classId<String>('classId', 'Waitlist');

  const WaitlistScalar(this.name, this.model);

  @override
  final String name;

  @override
  final String model;
}

class WebinarWaitlistArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarWaitlistArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.WaitlistWhereInput? where;

  final _i1.PrismaUnion<
    Iterable<_i2.WaitlistOrderByWithRelationInput>,
    _i2.WaitlistOrderByWithRelationInput
  >?
  orderBy;

  final _i2.WaitlistWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.WaitlistScalar, Iterable<_i2.WaitlistScalar>>?
  distinct;

  final _i2.WaitlistSelect? select;

  final _i2.WaitlistInclude? include;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'orderBy': orderBy,
    'cursor': cursor,
    'take': take,
    'skip': skip,
    'distinct': distinct,
    'select': select,
    'include': include,
  };
}

class WebinarWebinarPlanArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarWebinarPlanArgs({this.select, this.include});

  final _i2.WebinarPlanSelect? select;

  final _i2.WebinarPlanInclude? include;

  @override
  Map<String, dynamic> toJson() => {'select': select, 'include': include};
}

class WebinarAppointmentArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarAppointmentArgs({this.select, this.include});

  final _i2.AppointmentSelect? select;

  final _i2.AppointmentInclude? include;

  @override
  Map<String, dynamic> toJson() => {'select': select, 'include': include};
}

class WebinarCountOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarCountOutputTypeSelect({this.waitlist});

  final bool? waitlist;

  @override
  Map<String, dynamic> toJson() => {'waitlist': waitlist};
}

class WebinarCountArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarCountArgs({this.select});

  final _i2.WebinarCountOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class WebinarInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarInclude({
    this.waitlist,
    this.webinarPlan,
    this.appointment,
    this.$count,
  });

  final _i1.PrismaUnion<bool, _i2.WebinarWaitlistArgs>? waitlist;

  final _i1.PrismaUnion<bool, _i2.WebinarWebinarPlanArgs>? webinarPlan;

  final _i1.PrismaUnion<bool, _i2.WebinarAppointmentArgs>? appointment;

  final _i1.PrismaUnion<bool, _i2.WebinarCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
    'waitlist': waitlist,
    'webinarPlan': webinarPlan,
    'appointment': appointment,
    '_count': $count,
  };
}

class WaitlistWebinarArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistWebinarArgs({this.select, this.include});

  final _i2.WebinarSelect? select;

  final _i2.WebinarInclude? include;

  @override
  Map<String, dynamic> toJson() => {'select': select, 'include': include};
}

class ClassWaitlistArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassWaitlistArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.WaitlistWhereInput? where;

  final _i1.PrismaUnion<
    Iterable<_i2.WaitlistOrderByWithRelationInput>,
    _i2.WaitlistOrderByWithRelationInput
  >?
  orderBy;

  final _i2.WaitlistWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.WaitlistScalar, Iterable<_i2.WaitlistScalar>>?
  distinct;

  final _i2.WaitlistSelect? select;

  final _i2.WaitlistInclude? include;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'orderBy': orderBy,
    'cursor': cursor,
    'take': take,
    'skip': skip,
    'distinct': distinct,
    'select': select,
    'include': include,
  };
}

class ClassClassPlanArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassClassPlanArgs({this.select, this.include});

  final _i2.ClassPlanSelect? select;

  final _i2.ClassPlanInclude? include;

  @override
  Map<String, dynamic> toJson() => {'select': select, 'include': include};
}

class ClassAppointmentsArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassAppointmentsArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.AppointmentWhereInput? where;

  final _i1.PrismaUnion<
    Iterable<_i2.AppointmentOrderByWithRelationInput>,
    _i2.AppointmentOrderByWithRelationInput
  >?
  orderBy;

  final _i2.AppointmentWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.AppointmentScalar, Iterable<_i2.AppointmentScalar>>?
  distinct;

  final _i2.AppointmentSelect? select;

  final _i2.AppointmentInclude? include;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'orderBy': orderBy,
    'cursor': cursor,
    'take': take,
    'skip': skip,
    'distinct': distinct,
    'select': select,
    'include': include,
  };
}

class ClassCountOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassCountOutputTypeSelect({this.waitlist, this.appointments});

  final bool? waitlist;

  final bool? appointments;

  @override
  Map<String, dynamic> toJson() => {
    'waitlist': waitlist,
    'appointments': appointments,
  };
}

class ClassCountArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassCountArgs({this.select});

  final _i2.ClassCountOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ClassInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassInclude({
    this.waitlist,
    this.classPlan,
    this.appointments,
    this.$count,
  });

  final _i1.PrismaUnion<bool, _i2.ClassWaitlistArgs>? waitlist;

  final _i1.PrismaUnion<bool, _i2.ClassClassPlanArgs>? classPlan;

  final _i1.PrismaUnion<bool, _i2.ClassAppointmentsArgs>? appointments;

  final _i1.PrismaUnion<bool, _i2.ClassCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
    'waitlist': waitlist,
    'classPlan': classPlan,
    'appointments': appointments,
    '_count': $count,
  };
}

class WaitlistClassArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistClassArgs({this.select, this.include});

  final _i2.ClassSelect? select;

  final _i2.ClassInclude? include;

  @override
  Map<String, dynamic> toJson() => {'select': select, 'include': include};
}

class WaitlistInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistInclude({this.user, this.webinar, this.$class});

  final _i1.PrismaUnion<bool, _i2.WaitlistUserArgs>? user;

  final _i1.PrismaUnion<bool, _i2.WaitlistWebinarArgs>? webinar;

  final _i1.PrismaUnion<bool, _i2.WaitlistClassArgs>? $class;

  @override
  Map<String, dynamic> toJson() => {
    'user': user,
    'webinar': webinar,
    'class': $class,
  };
}

class WebinarSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarSelect({
    this.id,
    this.status,
    this.feedbackSummary,
    this.webinarPlanId,
    this.createdAt,
    this.updatedAt,
    this.waitlist,
    this.webinarPlan,
    this.appointment,
    this.$count,
  });

  final bool? id;

  final bool? status;

  final bool? feedbackSummary;

  final bool? webinarPlanId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.WebinarWaitlistArgs>? waitlist;

  final _i1.PrismaUnion<bool, _i2.WebinarWebinarPlanArgs>? webinarPlan;

  final _i1.PrismaUnion<bool, _i2.WebinarAppointmentArgs>? appointment;

  final _i1.PrismaUnion<bool, _i2.WebinarCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'status': status,
    'feedbackSummary': feedbackSummary,
    'webinarPlanId': webinarPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'waitlist': waitlist,
    'webinarPlan': webinarPlan,
    'appointment': appointment,
    '_count': $count,
  };
}

class WaitlistSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistSelect({
    this.id,
    this.joinedAt,
    this.userId,
    this.webinarId,
    this.classId,
    this.user,
    this.webinar,
    this.$class,
  });

  final bool? id;

  final bool? joinedAt;

  final bool? userId;

  final bool? webinarId;

  final bool? classId;

  final _i1.PrismaUnion<bool, _i2.WaitlistUserArgs>? user;

  final _i1.PrismaUnion<bool, _i2.WaitlistWebinarArgs>? webinar;

  final _i1.PrismaUnion<bool, _i2.WaitlistClassArgs>? $class;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'joinedAt': joinedAt,
    'userId': userId,
    'webinarId': webinarId,
    'classId': classId,
    'user': user,
    'webinar': webinar,
    'class': $class,
  };
}

class ClassSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassSelect({
    this.id,
    this.startDate,
    this.endDate,
    this.status,
    this.recordingUrls,
    this.feedbackSummary,
    this.classPlanId,
    this.createdAt,
    this.updatedAt,
    this.waitlist,
    this.classPlan,
    this.appointments,
    this.$count,
  });

  final bool? id;

  final bool? startDate;

  final bool? endDate;

  final bool? status;

  final bool? recordingUrls;

  final bool? feedbackSummary;

  final bool? classPlanId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.ClassWaitlistArgs>? waitlist;

  final _i1.PrismaUnion<bool, _i2.ClassClassPlanArgs>? classPlan;

  final _i1.PrismaUnion<bool, _i2.ClassAppointmentsArgs>? appointments;

  final _i1.PrismaUnion<bool, _i2.ClassCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'status': status,
    'recordingUrls': recordingUrls,
    'feedbackSummary': feedbackSummary,
    'classPlanId': classPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'waitlist': waitlist,
    'classPlan': classPlan,
    'appointments': appointments,
    '_count': $count,
  };
}

class ClassWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassWhereUniqueInput({this.id});

  final String? id;

  @override
  Map<String, dynamic> toJson() => {'id': id};
}

enum ClassScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<String>('id', 'Class'),
  startDate<DateTime>('startDate', 'Class'),
  endDate<DateTime>('endDate', 'Class'),
  status<_i3.ClassStatus>('status', 'Class'),
  recordingUrls<String>('recordingUrls', 'Class'),
  feedbackSummary<String>('feedbackSummary', 'Class'),
  classPlanId<String>('classPlanId', 'Class'),
  createdAt<DateTime>('createdAt', 'Class'),
  updatedAt<DateTime>('updatedAt', 'Class');

  const ClassScalar(this.name, this.model);

  @override
  final String name;

  @override
  final String model;
}

class ClassPlanClassesArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanClassesArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.ClassWhereInput? where;

  final _i1.PrismaUnion<
    Iterable<_i2.ClassOrderByWithRelationInput>,
    _i2.ClassOrderByWithRelationInput
  >?
  orderBy;

  final _i2.ClassWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.ClassScalar, Iterable<_i2.ClassScalar>>? distinct;

  final _i2.ClassSelect? select;

  final _i2.ClassInclude? include;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'orderBy': orderBy,
    'cursor': cursor,
    'take': take,
    'skip': skip,
    'distinct': distinct,
    'select': select,
    'include': include,
  };
}

class ClassPlanCountOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanCountOutputTypeSelect({
    this.topics,
    this.classContents,
    this.classes,
  });

  final bool? topics;

  final bool? classContents;

  final bool? classes;

  @override
  Map<String, dynamic> toJson() => {
    'topics': topics,
    'classContents': classContents,
    'classes': classes,
  };
}

class ClassPlanCountArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanCountArgs({this.select});

  final _i2.ClassPlanCountOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ClassPlanInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanInclude({
    this.topics,
    this.classContents,
    this.consultantProfile,
    this.classes,
    this.$count,
  });

  final _i1.PrismaUnion<bool, _i2.ClassPlanTopicsArgs>? topics;

  final _i1.PrismaUnion<bool, _i2.ClassPlanClassContentsArgs>? classContents;

  final _i1.PrismaUnion<bool, _i2.ClassPlanConsultantProfileArgs>?
  consultantProfile;

  final _i1.PrismaUnion<bool, _i2.ClassPlanClassesArgs>? classes;

  final _i1.PrismaUnion<bool, _i2.ClassPlanCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
    'topics': topics,
    'classContents': classContents,
    'consultantProfile': consultantProfile,
    'classes': classes,
    '_count': $count,
  };
}

class ClassContentSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassContentSelect({
    this.id,
    this.title,
    this.description,
    this.contentType,
    this.contentUrl,
    this.order,
    this.hoursAllotted,
    this.classPlanId,
    this.createdAt,
    this.updatedAt,
    this.classPlan,
  });

  final bool? id;

  final bool? title;

  final bool? description;

  final bool? contentType;

  final bool? contentUrl;

  final bool? order;

  final bool? hoursAllotted;

  final bool? classPlanId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.ClassContentClassPlanArgs>? classPlan;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'contentType': contentType,
    'contentUrl': contentUrl,
    'order': order,
    'hoursAllotted': hoursAllotted,
    'classPlanId': classPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'classPlan': classPlan,
  };
}

class ClassPlanSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanSelect({
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInMonths,
    this.callsPerWeek,
    this.videoMeetings,
    this.emailSupport,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.topics,
    this.classContents,
    this.consultantProfile,
    this.classes,
    this.$count,
  });

  final bool? id;

  final bool? title;

  final bool? description;

  final bool? price;

  final bool? priceCurrency;

  final bool? certificateProvided;

  final bool? durationInMonths;

  final bool? callsPerWeek;

  final bool? videoMeetings;

  final bool? emailSupport;

  final bool? maxParticipants;

  final bool? language;

  final bool? level;

  final bool? prerequisites;

  final bool? materialProvided;

  final bool? learningOutcomes;

  final bool? consultantProfileId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.ClassPlanTopicsArgs>? topics;

  final _i1.PrismaUnion<bool, _i2.ClassPlanClassContentsArgs>? classContents;

  final _i1.PrismaUnion<bool, _i2.ClassPlanConsultantProfileArgs>?
  consultantProfile;

  final _i1.PrismaUnion<bool, _i2.ClassPlanClassesArgs>? classes;

  final _i1.PrismaUnion<bool, _i2.ClassPlanCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInMonths': durationInMonths,
    'callsPerWeek': callsPerWeek,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'topics': topics,
    'classContents': classContents,
    'consultantProfile': consultantProfile,
    'classes': classes,
    '_count': $count,
  };
}

class ClassPlanWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanWhereUniqueInput({this.id});

  final String? id;

  @override
  Map<String, dynamic> toJson() => {'id': id};
}

enum ClassPlanScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<String>('id', 'ClassPlan'),
  title<String>('title', 'ClassPlan'),
  description<String>('description', 'ClassPlan'),
  price<int>('price', 'ClassPlan'),
  priceCurrency<String>('priceCurrency', 'ClassPlan'),
  certificateProvided<bool>('certificateProvided', 'ClassPlan'),
  durationInMonths<int>('durationInMonths', 'ClassPlan'),
  callsPerWeek<int>('callsPerWeek', 'ClassPlan'),
  videoMeetings<int>('videoMeetings', 'ClassPlan'),
  emailSupport<_i3.PlanEmailSupport>('emailSupport', 'ClassPlan'),
  maxParticipants<int>('maxParticipants', 'ClassPlan'),
  language<String>('language', 'ClassPlan'),
  level<String>('level', 'ClassPlan'),
  prerequisites<String>('prerequisites', 'ClassPlan'),
  materialProvided<String>('materialProvided', 'ClassPlan'),
  learningOutcomes<String>('learningOutcomes', 'ClassPlan'),
  consultantProfileId<String>('consultantProfileId', 'ClassPlan'),
  createdAt<DateTime>('createdAt', 'ClassPlan'),
  updatedAt<DateTime>('updatedAt', 'ClassPlan');

  const ClassPlanScalar(this.name, this.model);

  @override
  final String name;

  @override
  final String model;
}

class TopicClassPlansArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TopicClassPlansArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.ClassPlanWhereInput? where;

  final _i1.PrismaUnion<
    Iterable<_i2.ClassPlanOrderByWithRelationInput>,
    _i2.ClassPlanOrderByWithRelationInput
  >?
  orderBy;

  final _i2.ClassPlanWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.ClassPlanScalar, Iterable<_i2.ClassPlanScalar>>?
  distinct;

  final _i2.ClassPlanSelect? select;

  final _i2.ClassPlanInclude? include;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'orderBy': orderBy,
    'cursor': cursor,
    'take': take,
    'skip': skip,
    'distinct': distinct,
    'select': select,
    'include': include,
  };
}

class TopicCountOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TopicCountOutputTypeSelect({this.webinarPlans, this.classPlans});

  final bool? webinarPlans;

  final bool? classPlans;

  @override
  Map<String, dynamic> toJson() => {
    'webinarPlans': webinarPlans,
    'classPlans': classPlans,
  };
}

class TopicCountArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TopicCountArgs({this.select});

  final _i2.TopicCountOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class TopicInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TopicInclude({this.webinarPlans, this.classPlans, this.$count});

  final _i1.PrismaUnion<bool, _i2.TopicWebinarPlansArgs>? webinarPlans;

  final _i1.PrismaUnion<bool, _i2.TopicClassPlansArgs>? classPlans;

  final _i1.PrismaUnion<bool, _i2.TopicCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
    'webinarPlans': webinarPlans,
    'classPlans': classPlans,
    '_count': $count,
  };
}

class WebinarPlanTopicsArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanTopicsArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.TopicWhereInput? where;

  final _i1.PrismaUnion<
    Iterable<_i2.TopicOrderByWithRelationInput>,
    _i2.TopicOrderByWithRelationInput
  >?
  orderBy;

  final _i2.TopicWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.TopicScalar, Iterable<_i2.TopicScalar>>? distinct;

  final _i2.TopicSelect? select;

  final _i2.TopicInclude? include;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'orderBy': orderBy,
    'cursor': cursor,
    'take': take,
    'skip': skip,
    'distinct': distinct,
    'select': select,
    'include': include,
  };
}

class WebinarPlanConsultantProfileArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanConsultantProfileArgs({this.select, this.include});

  final _i2.ConsultantProfileSelect? select;

  final _i2.ConsultantProfileInclude? include;

  @override
  Map<String, dynamic> toJson() => {'select': select, 'include': include};
}

class WebinarWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarWhereUniqueInput({this.id});

  final String? id;

  @override
  Map<String, dynamic> toJson() => {'id': id};
}

enum WebinarScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<String>('id', 'Webinar'),
  status<_i3.WebinarStatus>('status', 'Webinar'),
  feedbackSummary<String>('feedbackSummary', 'Webinar'),
  webinarPlanId<String>('webinarPlanId', 'Webinar'),
  createdAt<DateTime>('createdAt', 'Webinar'),
  updatedAt<DateTime>('updatedAt', 'Webinar');

  const WebinarScalar(this.name, this.model);

  @override
  final String name;

  @override
  final String model;
}

class WebinarPlanWebinarsArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanWebinarsArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.WebinarWhereInput? where;

  final _i1.PrismaUnion<
    Iterable<_i2.WebinarOrderByWithRelationInput>,
    _i2.WebinarOrderByWithRelationInput
  >?
  orderBy;

  final _i2.WebinarWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.WebinarScalar, Iterable<_i2.WebinarScalar>>?
  distinct;

  final _i2.WebinarSelect? select;

  final _i2.WebinarInclude? include;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'orderBy': orderBy,
    'cursor': cursor,
    'take': take,
    'skip': skip,
    'distinct': distinct,
    'select': select,
    'include': include,
  };
}

class WebinarPlanCountOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanCountOutputTypeSelect({this.topics, this.webinars});

  final bool? topics;

  final bool? webinars;

  @override
  Map<String, dynamic> toJson() => {'topics': topics, 'webinars': webinars};
}

class WebinarPlanCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanCountArgs({this.select});

  final _i2.WebinarPlanCountOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class WebinarPlanInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanInclude({
    this.topics,
    this.consultantProfile,
    this.webinars,
    this.$count,
  });

  final _i1.PrismaUnion<bool, _i2.WebinarPlanTopicsArgs>? topics;

  final _i1.PrismaUnion<bool, _i2.WebinarPlanConsultantProfileArgs>?
  consultantProfile;

  final _i1.PrismaUnion<bool, _i2.WebinarPlanWebinarsArgs>? webinars;

  final _i1.PrismaUnion<bool, _i2.WebinarPlanCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
    'topics': topics,
    'consultantProfile': consultantProfile,
    'webinars': webinars,
    '_count': $count,
  };
}

class TopicSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TopicSelect({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
    this.webinarPlans,
    this.classPlans,
    this.$count,
  });

  final bool? id;

  final bool? name;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.TopicWebinarPlansArgs>? webinarPlans;

  final _i1.PrismaUnion<bool, _i2.TopicClassPlansArgs>? classPlans;

  final _i1.PrismaUnion<bool, _i2.TopicCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'webinarPlans': webinarPlans,
    'classPlans': classPlans,
    '_count': $count,
  };
}

class WebinarPlanSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanSelect({
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInHours,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.topics,
    this.consultantProfile,
    this.webinars,
    this.$count,
  });

  final bool? id;

  final bool? title;

  final bool? description;

  final bool? price;

  final bool? priceCurrency;

  final bool? certificateProvided;

  final bool? durationInHours;

  final bool? maxParticipants;

  final bool? language;

  final bool? level;

  final bool? prerequisites;

  final bool? materialProvided;

  final bool? learningOutcomes;

  final bool? consultantProfileId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.WebinarPlanTopicsArgs>? topics;

  final _i1.PrismaUnion<bool, _i2.WebinarPlanConsultantProfileArgs>?
  consultantProfile;

  final _i1.PrismaUnion<bool, _i2.WebinarPlanWebinarsArgs>? webinars;

  final _i1.PrismaUnion<bool, _i2.WebinarPlanCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInHours': durationInHours,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'topics': topics,
    'consultantProfile': consultantProfile,
    'webinars': webinars,
    '_count': $count,
  };
}

class ConsultantProfileWebinarPlansArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileWebinarPlansArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.WebinarPlanWhereInput? where;

  final _i1.PrismaUnion<
    Iterable<_i2.WebinarPlanOrderByWithRelationInput>,
    _i2.WebinarPlanOrderByWithRelationInput
  >?
  orderBy;

  final _i2.WebinarPlanWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.WebinarPlanScalar, Iterable<_i2.WebinarPlanScalar>>?
  distinct;

  final _i2.WebinarPlanSelect? select;

  final _i2.WebinarPlanInclude? include;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'orderBy': orderBy,
    'cursor': cursor,
    'take': take,
    'skip': skip,
    'distinct': distinct,
    'select': select,
    'include': include,
  };
}

class ConsultantProfileClassPlansArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileClassPlansArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.ClassPlanWhereInput? where;

  final _i1.PrismaUnion<
    Iterable<_i2.ClassPlanOrderByWithRelationInput>,
    _i2.ClassPlanOrderByWithRelationInput
  >?
  orderBy;

  final _i2.ClassPlanWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.ClassPlanScalar, Iterable<_i2.ClassPlanScalar>>?
  distinct;

  final _i2.ClassPlanSelect? select;

  final _i2.ClassPlanInclude? include;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'orderBy': orderBy,
    'cursor': cursor,
    'take': take,
    'skip': skip,
    'distinct': distinct,
    'select': select,
    'include': include,
  };
}

class ConsultantProfileUserArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUserArgs({this.select, this.include});

  final _i2.UserSelect? select;

  final _i2.UserInclude? include;

  @override
  Map<String, dynamic> toJson() => {'select': select, 'include': include};
}

class ConsultantProfileCountOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileCountOutputTypeSelect({
    this.subDomains,
    this.tags,
    this.reviews,
    this.slotsOfAvailabilityWeekly,
    this.slotsOfAvailabilityCustom,
    this.consultationPlans,
    this.subscriptionPlans,
    this.webinarPlans,
    this.classPlans,
  });

  final bool? subDomains;

  final bool? tags;

  final bool? reviews;

  final bool? slotsOfAvailabilityWeekly;

  final bool? slotsOfAvailabilityCustom;

  final bool? consultationPlans;

  final bool? subscriptionPlans;

  final bool? webinarPlans;

  final bool? classPlans;

  @override
  Map<String, dynamic> toJson() => {
    'subDomains': subDomains,
    'tags': tags,
    'reviews': reviews,
    'slotsOfAvailabilityWeekly': slotsOfAvailabilityWeekly,
    'slotsOfAvailabilityCustom': slotsOfAvailabilityCustom,
    'consultationPlans': consultationPlans,
    'subscriptionPlans': subscriptionPlans,
    'webinarPlans': webinarPlans,
    'classPlans': classPlans,
  };
}

class ConsultantProfileCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileCountArgs({this.select});

  final _i2.ConsultantProfileCountOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ConsultantProfileInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileInclude({
    this.domain,
    this.subDomains,
    this.tags,
    this.reviews,
    this.slotsOfAvailabilityWeekly,
    this.slotsOfAvailabilityCustom,
    this.consultationPlans,
    this.subscriptionPlans,
    this.webinarPlans,
    this.classPlans,
    this.user,
    this.$count,
  });

  final _i1.PrismaUnion<bool, _i2.ConsultantProfileDomainArgs>? domain;

  final _i1.PrismaUnion<bool, _i2.ConsultantProfileSubDomainsArgs>? subDomains;

  final _i1.PrismaUnion<bool, _i2.ConsultantProfileTagsArgs>? tags;

  final _i1.PrismaUnion<bool, _i2.ConsultantProfileReviewsArgs>? reviews;

  final _i1.PrismaUnion<
    bool,
    _i2.ConsultantProfileSlotsOfAvailabilityWeeklyArgs
  >?
  slotsOfAvailabilityWeekly;

  final _i1.PrismaUnion<
    bool,
    _i2.ConsultantProfileSlotsOfAvailabilityCustomArgs
  >?
  slotsOfAvailabilityCustom;

  final _i1.PrismaUnion<bool, _i2.ConsultantProfileConsultationPlansArgs>?
  consultationPlans;

  final _i1.PrismaUnion<bool, _i2.ConsultantProfileSubscriptionPlansArgs>?
  subscriptionPlans;

  final _i1.PrismaUnion<bool, _i2.ConsultantProfileWebinarPlansArgs>?
  webinarPlans;

  final _i1.PrismaUnion<bool, _i2.ConsultantProfileClassPlansArgs>? classPlans;

  final _i1.PrismaUnion<bool, _i2.ConsultantProfileUserArgs>? user;

  final _i1.PrismaUnion<bool, _i2.ConsultantProfileCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
    'domain': domain,
    'subDomains': subDomains,
    'tags': tags,
    'reviews': reviews,
    'slotsOfAvailabilityWeekly': slotsOfAvailabilityWeekly,
    'slotsOfAvailabilityCustom': slotsOfAvailabilityCustom,
    'consultationPlans': consultationPlans,
    'subscriptionPlans': subscriptionPlans,
    'webinarPlans': webinarPlans,
    'classPlans': classPlans,
    'user': user,
    '_count': $count,
  };
}

class SubDomainConsultantProfilesArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainConsultantProfilesArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.ConsultantProfileWhereInput? where;

  final _i1.PrismaUnion<
    Iterable<_i2.ConsultantProfileOrderByWithRelationInput>,
    _i2.ConsultantProfileOrderByWithRelationInput
  >?
  orderBy;

  final _i2.ConsultantProfileWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileScalar,
    Iterable<_i2.ConsultantProfileScalar>
  >?
  distinct;

  final _i2.ConsultantProfileSelect? select;

  final _i2.ConsultantProfileInclude? include;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'orderBy': orderBy,
    'cursor': cursor,
    'take': take,
    'skip': skip,
    'distinct': distinct,
    'select': select,
    'include': include,
  };
}

class SubDomainCountOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainCountOutputTypeSelect({this.consultantProfiles});

  final bool? consultantProfiles;

  @override
  Map<String, dynamic> toJson() => {'consultantProfiles': consultantProfiles};
}

class SubDomainCountArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainCountArgs({this.select});

  final _i2.SubDomainCountOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SubDomainInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainInclude({this.domain, this.consultantProfiles, this.$count});

  final _i1.PrismaUnion<bool, _i2.SubDomainDomainArgs>? domain;

  final _i1.PrismaUnion<bool, _i2.SubDomainConsultantProfilesArgs>?
  consultantProfiles;

  final _i1.PrismaUnion<bool, _i2.SubDomainCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
    'domain': domain,
    'consultantProfiles': consultantProfiles,
    '_count': $count,
  };
}

class DomainSubDomainsArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomainSubDomainsArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.SubDomainWhereInput? where;

  final _i1.PrismaUnion<
    Iterable<_i2.SubDomainOrderByWithRelationInput>,
    _i2.SubDomainOrderByWithRelationInput
  >?
  orderBy;

  final _i2.SubDomainWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.SubDomainScalar, Iterable<_i2.SubDomainScalar>>?
  distinct;

  final _i2.SubDomainSelect? select;

  final _i2.SubDomainInclude? include;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'orderBy': orderBy,
    'cursor': cursor,
    'take': take,
    'skip': skip,
    'distinct': distinct,
    'select': select,
    'include': include,
  };
}

class DomainTagsArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomainTagsArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.TagWhereInput? where;

  final _i1.PrismaUnion<
    Iterable<_i2.TagOrderByWithRelationInput>,
    _i2.TagOrderByWithRelationInput
  >?
  orderBy;

  final _i2.TagWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.TagScalar, Iterable<_i2.TagScalar>>? distinct;

  final _i2.TagSelect? select;

  final _i2.TagInclude? include;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'orderBy': orderBy,
    'cursor': cursor,
    'take': take,
    'skip': skip,
    'distinct': distinct,
    'select': select,
    'include': include,
  };
}

class DomainConsultantProfilesArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomainConsultantProfilesArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.ConsultantProfileWhereInput? where;

  final _i1.PrismaUnion<
    Iterable<_i2.ConsultantProfileOrderByWithRelationInput>,
    _i2.ConsultantProfileOrderByWithRelationInput
  >?
  orderBy;

  final _i2.ConsultantProfileWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileScalar,
    Iterable<_i2.ConsultantProfileScalar>
  >?
  distinct;

  final _i2.ConsultantProfileSelect? select;

  final _i2.ConsultantProfileInclude? include;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'orderBy': orderBy,
    'cursor': cursor,
    'take': take,
    'skip': skip,
    'distinct': distinct,
    'select': select,
    'include': include,
  };
}

class DomainCountOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomainCountOutputTypeSelect({
    this.subDomains,
    this.tags,
    this.consultantProfiles,
  });

  final bool? subDomains;

  final bool? tags;

  final bool? consultantProfiles;

  @override
  Map<String, dynamic> toJson() => {
    'subDomains': subDomains,
    'tags': tags,
    'consultantProfiles': consultantProfiles,
  };
}

class DomainCountArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomainCountArgs({this.select});

  final _i2.DomainCountOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class DomainInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomainInclude({
    this.subDomains,
    this.tags,
    this.consultantProfiles,
    this.$count,
  });

  final _i1.PrismaUnion<bool, _i2.DomainSubDomainsArgs>? subDomains;

  final _i1.PrismaUnion<bool, _i2.DomainTagsArgs>? tags;

  final _i1.PrismaUnion<bool, _i2.DomainConsultantProfilesArgs>?
  consultantProfiles;

  final _i1.PrismaUnion<bool, _i2.DomainCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
    'subDomains': subDomains,
    'tags': tags,
    'consultantProfiles': consultantProfiles,
    '_count': $count,
  };
}

class SubDomainSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainSelect({
    this.id,
    this.name,
    this.domainId,
    this.createdAt,
    this.updatedAt,
    this.domain,
    this.consultantProfiles,
    this.$count,
  });

  final bool? id;

  final bool? name;

  final bool? domainId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.SubDomainDomainArgs>? domain;

  final _i1.PrismaUnion<bool, _i2.SubDomainConsultantProfilesArgs>?
  consultantProfiles;

  final _i1.PrismaUnion<bool, _i2.SubDomainCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'domainId': domainId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'domain': domain,
    'consultantProfiles': consultantProfiles,
    '_count': $count,
  };
}

class DomainSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomainSelect({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
    this.subDomains,
    this.tags,
    this.consultantProfiles,
    this.$count,
  });

  final bool? id;

  final bool? name;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.DomainSubDomainsArgs>? subDomains;

  final _i1.PrismaUnion<bool, _i2.DomainTagsArgs>? tags;

  final _i1.PrismaUnion<bool, _i2.DomainConsultantProfilesArgs>?
  consultantProfiles;

  final _i1.PrismaUnion<bool, _i2.DomainCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'subDomains': subDomains,
    'tags': tags,
    'consultantProfiles': consultantProfiles,
    '_count': $count,
  };
}

class ConsultantProfileSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileSelect({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    this.domainId,
    this.scheduleType,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.domain,
    this.subDomains,
    this.tags,
    this.reviews,
    this.slotsOfAvailabilityWeekly,
    this.slotsOfAvailabilityCustom,
    this.consultationPlans,
    this.subscriptionPlans,
    this.webinarPlans,
    this.classPlans,
    this.user,
    this.$count,
  });

  final bool? id;

  final bool? description;

  final bool? qualifications;

  final bool? specialization;

  final bool? experience;

  final bool? rating;

  final bool? domainId;

  final bool? scheduleType;

  final bool? userId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.ConsultantProfileDomainArgs>? domain;

  final _i1.PrismaUnion<bool, _i2.ConsultantProfileSubDomainsArgs>? subDomains;

  final _i1.PrismaUnion<bool, _i2.ConsultantProfileTagsArgs>? tags;

  final _i1.PrismaUnion<bool, _i2.ConsultantProfileReviewsArgs>? reviews;

  final _i1.PrismaUnion<
    bool,
    _i2.ConsultantProfileSlotsOfAvailabilityWeeklyArgs
  >?
  slotsOfAvailabilityWeekly;

  final _i1.PrismaUnion<
    bool,
    _i2.ConsultantProfileSlotsOfAvailabilityCustomArgs
  >?
  slotsOfAvailabilityCustom;

  final _i1.PrismaUnion<bool, _i2.ConsultantProfileConsultationPlansArgs>?
  consultationPlans;

  final _i1.PrismaUnion<bool, _i2.ConsultantProfileSubscriptionPlansArgs>?
  subscriptionPlans;

  final _i1.PrismaUnion<bool, _i2.ConsultantProfileWebinarPlansArgs>?
  webinarPlans;

  final _i1.PrismaUnion<bool, _i2.ConsultantProfileClassPlansArgs>? classPlans;

  final _i1.PrismaUnion<bool, _i2.ConsultantProfileUserArgs>? user;

  final _i1.PrismaUnion<bool, _i2.ConsultantProfileCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'domainId': domainId,
    'scheduleType': scheduleType,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'domain': domain,
    'subDomains': subDomains,
    'tags': tags,
    'reviews': reviews,
    'slotsOfAvailabilityWeekly': slotsOfAvailabilityWeekly,
    'slotsOfAvailabilityCustom': slotsOfAvailabilityCustom,
    'consultationPlans': consultationPlans,
    'subscriptionPlans': subscriptionPlans,
    'webinarPlans': webinarPlans,
    'classPlans': classPlans,
    'user': user,
    '_count': $count,
  };
}

class ConsultationPlanSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanSelect({
    this.id,
    this.title,
    this.description,
    this.durationInHours,
    this.price,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.consultantProfile,
    this.consultations,
    this.$count,
  });

  final bool? id;

  final bool? title;

  final bool? description;

  final bool? durationInHours;

  final bool? price;

  final bool? language;

  final bool? level;

  final bool? prerequisites;

  final bool? materialProvided;

  final bool? learningOutcomes;

  final bool? consultantProfileId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.ConsultationPlanConsultantProfileArgs>?
  consultantProfile;

  final _i1.PrismaUnion<bool, _i2.ConsultationPlanConsultationsArgs>?
  consultations;

  final _i1.PrismaUnion<bool, _i2.ConsultationPlanCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInHours': durationInHours,
    'price': price,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultantProfile': consultantProfile,
    'consultations': consultations,
    '_count': $count,
  };
}

class ConsultationSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationSelect({
    this.id,
    this.consultationPlanId,
    this.requestStatus,
    this.requestedById,
    this.requestedAt,
    this.requestNotes,
    this.directlyBooked,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.createdAt,
    this.updatedAt,
    this.consultationPlan,
    this.requestedBy,
    this.appointment,
  });

  final bool? id;

  final bool? consultationPlanId;

  final bool? requestStatus;

  final bool? requestedById;

  final bool? requestedAt;

  final bool? requestNotes;

  final bool? directlyBooked;

  final bool? feedbackFromConsultee;

  final bool? feedbackFromConsultant;

  final bool? rating;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.ConsultationConsultationPlanArgs>?
  consultationPlan;

  final _i1.PrismaUnion<bool, _i2.ConsultationRequestedByArgs>? requestedBy;

  final _i1.PrismaUnion<bool, _i2.ConsultationAppointmentArgs>? appointment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'consultationPlanId': consultationPlanId,
    'requestStatus': requestStatus,
    'requestedById': requestedById,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'directlyBooked': directlyBooked,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultationPlan': consultationPlan,
    'requestedBy': requestedBy,
    'appointment': appointment,
  };
}

class AppointmentConsultationArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentConsultationArgs({this.select, this.include});

  final _i2.ConsultationSelect? select;

  final _i2.ConsultationInclude? include;

  @override
  Map<String, dynamic> toJson() => {'select': select, 'include': include};
}

class AppointmentSubscriptionArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentSubscriptionArgs({this.select, this.include});

  final _i2.SubscriptionSelect? select;

  final _i2.SubscriptionInclude? include;

  @override
  Map<String, dynamic> toJson() => {'select': select, 'include': include};
}

class AppointmentWebinarArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentWebinarArgs({this.select, this.include});

  final _i2.WebinarSelect? select;

  final _i2.WebinarInclude? include;

  @override
  Map<String, dynamic> toJson() => {'select': select, 'include': include};
}

class AppointmentClassArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentClassArgs({this.select, this.include});

  final _i2.ClassSelect? select;

  final _i2.ClassInclude? include;

  @override
  Map<String, dynamic> toJson() => {'select': select, 'include': include};
}

class PaymentAppointmentArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentAppointmentArgs({this.select, this.include});

  final _i2.AppointmentSelect? select;

  final _i2.AppointmentInclude? include;

  @override
  Map<String, dynamic> toJson() => {'select': select, 'include': include};
}

class DiscountCodeOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountCodeOrderByWithRelationInput({
    this.id,
    this.code,
    this.description,
    this.discountType,
    this.discountValue,
    this.createdAt,
    this.updatedAt,
    this.payment,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? code;

  final _i2.SortOrder? description;

  final _i2.SortOrder? discountType;

  final _i2.SortOrder? discountValue;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.PaymentOrderByRelationAggregateInput? payment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'code': code,
    'description': description,
    'discountType': discountType,
    'discountValue': discountValue,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'Payment': payment,
  };
}

class PaymentOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentOrderByWithRelationInput({
    this.id,
    this.amount,
    this.currency,
    this.description,
    this.receiptUrl,
    this.paymentMethod,
    this.paymentIntent,
    this.paymentGateway,
    this.paymentStatus,
    this.expiresAt,
    this.userId,
    this.appointmentId,
    this.discountCodeId,
    this.createdAt,
    this.updatedAt,
    this.user,
    this.appointment,
    this.discountCode,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? amount;

  final _i2.SortOrder? currency;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? description;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? receiptUrl;

  final _i2.SortOrder? paymentMethod;

  final _i2.SortOrder? paymentIntent;

  final _i2.SortOrder? paymentGateway;

  final _i2.SortOrder? paymentStatus;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? expiresAt;

  final _i2.SortOrder? userId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? appointmentId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? discountCodeId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.UserOrderByWithRelationInput? user;

  final _i2.AppointmentOrderByWithRelationInput? appointment;

  final _i2.DiscountCodeOrderByWithRelationInput? discountCode;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'amount': amount,
    'currency': currency,
    'description': description,
    'receiptUrl': receiptUrl,
    'paymentMethod': paymentMethod,
    'paymentIntent': paymentIntent,
    'paymentGateway': paymentGateway,
    'paymentStatus': paymentStatus,
    'expiresAt': expiresAt,
    'userId': userId,
    'appointmentId': appointmentId,
    'discountCodeId': discountCodeId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'user': user,
    'appointment': appointment,
    'discountCode': discountCode,
  };
}

class PaymentWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentWhereUniqueInput({
    this.id,
    this.paymentIntent,
    this.appointmentId,
  });

  final String? id;

  final String? paymentIntent;

  final String? appointmentId;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'paymentIntent': paymentIntent,
    'appointmentId': appointmentId,
  };
}

enum PaymentScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<String>('id', 'Payment'),
  amount<int>('amount', 'Payment'),
  currency<String>('currency', 'Payment'),
  description<String>('description', 'Payment'),
  receiptUrl<String>('receiptUrl', 'Payment'),
  paymentMethod<String>('paymentMethod', 'Payment'),
  paymentIntent<String>('paymentIntent', 'Payment'),
  paymentGateway<_i3.PaymentGateway>('paymentGateway', 'Payment'),
  paymentStatus<_i3.PaymentStatus>('paymentStatus', 'Payment'),
  expiresAt<DateTime>('expiresAt', 'Payment'),
  userId<String>('userId', 'Payment'),
  appointmentId<String>('appointmentId', 'Payment'),
  discountCodeId<String>('discountCodeId', 'Payment'),
  createdAt<DateTime>('createdAt', 'Payment'),
  updatedAt<DateTime>('updatedAt', 'Payment');

  const PaymentScalar(this.name, this.model);

  @override
  final String name;

  @override
  final String model;
}

class DiscountCodePaymentArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountCodePaymentArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.PaymentWhereInput? where;

  final _i1.PrismaUnion<
    Iterable<_i2.PaymentOrderByWithRelationInput>,
    _i2.PaymentOrderByWithRelationInput
  >?
  orderBy;

  final _i2.PaymentWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.PaymentScalar, Iterable<_i2.PaymentScalar>>?
  distinct;

  final _i2.PaymentSelect? select;

  final _i2.PaymentInclude? include;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'orderBy': orderBy,
    'cursor': cursor,
    'take': take,
    'skip': skip,
    'distinct': distinct,
    'select': select,
    'include': include,
  };
}

class DiscountCodeCountOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountCodeCountOutputTypeSelect({this.payment});

  final bool? payment;

  @override
  Map<String, dynamic> toJson() => {'Payment': payment};
}

class DiscountCodeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountCodeCountArgs({this.select});

  final _i2.DiscountCodeCountOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class DiscountCodeSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountCodeSelect({
    this.id,
    this.code,
    this.description,
    this.discountType,
    this.discountValue,
    this.createdAt,
    this.updatedAt,
    this.payment,
    this.$count,
  });

  final bool? id;

  final bool? code;

  final bool? description;

  final bool? discountType;

  final bool? discountValue;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.DiscountCodePaymentArgs>? payment;

  final _i1.PrismaUnion<bool, _i2.DiscountCodeCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'code': code,
    'description': description,
    'discountType': discountType,
    'discountValue': discountValue,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'Payment': payment,
    '_count': $count,
  };
}

class DiscountCodeInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountCodeInclude({this.payment, this.$count});

  final _i1.PrismaUnion<bool, _i2.DiscountCodePaymentArgs>? payment;

  final _i1.PrismaUnion<bool, _i2.DiscountCodeCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {'Payment': payment, '_count': $count};
}

class PaymentDiscountCodeArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentDiscountCodeArgs({this.select, this.include});

  final _i2.DiscountCodeSelect? select;

  final _i2.DiscountCodeInclude? include;

  @override
  Map<String, dynamic> toJson() => {'select': select, 'include': include};
}

class PaymentInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentInclude({this.user, this.appointment, this.discountCode});

  final _i1.PrismaUnion<bool, _i2.PaymentUserArgs>? user;

  final _i1.PrismaUnion<bool, _i2.PaymentAppointmentArgs>? appointment;

  final _i1.PrismaUnion<bool, _i2.PaymentDiscountCodeArgs>? discountCode;

  @override
  Map<String, dynamic> toJson() => {
    'user': user,
    'appointment': appointment,
    'discountCode': discountCode,
  };
}

class AppointmentPaymentArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentPaymentArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.PaymentWhereInput? where;

  final _i1.PrismaUnion<
    Iterable<_i2.PaymentOrderByWithRelationInput>,
    _i2.PaymentOrderByWithRelationInput
  >?
  orderBy;

  final _i2.PaymentWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.PaymentScalar, Iterable<_i2.PaymentScalar>>?
  distinct;

  final _i2.PaymentSelect? select;

  final _i2.PaymentInclude? include;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'orderBy': orderBy,
    'cursor': cursor,
    'take': take,
    'skip': skip,
    'distinct': distinct,
    'select': select,
    'include': include,
  };
}

class AppointmentCountOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentCountOutputTypeSelect({
    this.slotsOfAppointment,
    this.payment,
  });

  final bool? slotsOfAppointment;

  final bool? payment;

  @override
  Map<String, dynamic> toJson() => {
    'slotsOfAppointment': slotsOfAppointment,
    'payment': payment,
  };
}

class AppointmentCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentCountArgs({this.select});

  final _i2.AppointmentCountOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AppointmentInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentInclude({
    this.slotsOfAppointment,
    this.consultation,
    this.subscription,
    this.webinar,
    this.$class,
    this.payment,
    this.$count,
  });

  final _i1.PrismaUnion<bool, _i2.AppointmentSlotsOfAppointmentArgs>?
  slotsOfAppointment;

  final _i1.PrismaUnion<bool, _i2.AppointmentConsultationArgs>? consultation;

  final _i1.PrismaUnion<bool, _i2.AppointmentSubscriptionArgs>? subscription;

  final _i1.PrismaUnion<bool, _i2.AppointmentWebinarArgs>? webinar;

  final _i1.PrismaUnion<bool, _i2.AppointmentClassArgs>? $class;

  final _i1.PrismaUnion<bool, _i2.AppointmentPaymentArgs>? payment;

  final _i1.PrismaUnion<bool, _i2.AppointmentCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
    'slotsOfAppointment': slotsOfAppointment,
    'consultation': consultation,
    'subscription': subscription,
    'webinar': webinar,
    'class': $class,
    'payment': payment,
    '_count': $count,
  };
}

class SlotOfAppointmentSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentSelect({
    this.id,
    this.slotStartTimeInUTC,
    this.slotEndTimeInUTC,
    this.isTentative,
    this.appointmentId,
    this.createdAt,
    this.updatedAt,
    this.user,
    this.appointment,
    this.meetingSession,
    this.$count,
  });

  final bool? id;

  final bool? slotStartTimeInUTC;

  final bool? slotEndTimeInUTC;

  final bool? isTentative;

  final bool? appointmentId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.SlotOfAppointmentUserArgs>? user;

  final _i1.PrismaUnion<bool, _i2.SlotOfAppointmentAppointmentArgs>?
  appointment;

  final _i1.PrismaUnion<bool, _i2.SlotOfAppointmentMeetingSessionArgs>?
  meetingSession;

  final _i1.PrismaUnion<bool, _i2.SlotOfAppointmentCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'isTentative': isTentative,
    'appointmentId': appointmentId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'user': user,
    'appointment': appointment,
    'meetingSession': meetingSession,
    '_count': $count,
  };
}

class AppointmentSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentSelect({
    this.id,
    this.appointmentType,
    this.consultationId,
    this.subscriptionId,
    this.webinarId,
    this.classId,
    this.createdAt,
    this.updatedAt,
    this.slotsOfAppointment,
    this.consultation,
    this.subscription,
    this.webinar,
    this.$class,
    this.payment,
    this.$count,
  });

  final bool? id;

  final bool? appointmentType;

  final bool? consultationId;

  final bool? subscriptionId;

  final bool? webinarId;

  final bool? classId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.AppointmentSlotsOfAppointmentArgs>?
  slotsOfAppointment;

  final _i1.PrismaUnion<bool, _i2.AppointmentConsultationArgs>? consultation;

  final _i1.PrismaUnion<bool, _i2.AppointmentSubscriptionArgs>? subscription;

  final _i1.PrismaUnion<bool, _i2.AppointmentWebinarArgs>? webinar;

  final _i1.PrismaUnion<bool, _i2.AppointmentClassArgs>? $class;

  final _i1.PrismaUnion<bool, _i2.AppointmentPaymentArgs>? payment;

  final _i1.PrismaUnion<bool, _i2.AppointmentCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'appointmentType': appointmentType,
    'consultationId': consultationId,
    'subscriptionId': subscriptionId,
    'webinarId': webinarId,
    'classId': classId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'slotsOfAppointment': slotsOfAppointment,
    'consultation': consultation,
    'subscription': subscription,
    'webinar': webinar,
    'class': $class,
    'payment': payment,
    '_count': $count,
  };
}

class PaymentSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentSelect({
    this.id,
    this.amount,
    this.currency,
    this.description,
    this.receiptUrl,
    this.paymentMethod,
    this.paymentIntent,
    this.paymentGateway,
    this.paymentStatus,
    this.expiresAt,
    this.userId,
    this.appointmentId,
    this.discountCodeId,
    this.createdAt,
    this.updatedAt,
    this.user,
    this.appointment,
    this.discountCode,
  });

  final bool? id;

  final bool? amount;

  final bool? currency;

  final bool? description;

  final bool? receiptUrl;

  final bool? paymentMethod;

  final bool? paymentIntent;

  final bool? paymentGateway;

  final bool? paymentStatus;

  final bool? expiresAt;

  final bool? userId;

  final bool? appointmentId;

  final bool? discountCodeId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.PaymentUserArgs>? user;

  final _i1.PrismaUnion<bool, _i2.PaymentAppointmentArgs>? appointment;

  final _i1.PrismaUnion<bool, _i2.PaymentDiscountCodeArgs>? discountCode;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'amount': amount,
    'currency': currency,
    'description': description,
    'receiptUrl': receiptUrl,
    'paymentMethod': paymentMethod,
    'paymentIntent': paymentIntent,
    'paymentGateway': paymentGateway,
    'paymentStatus': paymentStatus,
    'expiresAt': expiresAt,
    'userId': userId,
    'appointmentId': appointmentId,
    'discountCodeId': discountCodeId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'user': user,
    'appointment': appointment,
    'discountCode': discountCode,
  };
}

class UserPaymentArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserPaymentArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.PaymentWhereInput? where;

  final _i1.PrismaUnion<
    Iterable<_i2.PaymentOrderByWithRelationInput>,
    _i2.PaymentOrderByWithRelationInput
  >?
  orderBy;

  final _i2.PaymentWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.PaymentScalar, Iterable<_i2.PaymentScalar>>?
  distinct;

  final _i2.PaymentSelect? select;

  final _i2.PaymentInclude? include;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'orderBy': orderBy,
    'cursor': cursor,
    'take': take,
    'skip': skip,
    'distinct': distinct,
    'select': select,
    'include': include,
  };
}

class UserConsultantProfileArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserConsultantProfileArgs({this.select, this.include});

  final _i2.ConsultantProfileSelect? select;

  final _i2.ConsultantProfileInclude? include;

  @override
  Map<String, dynamic> toJson() => {'select': select, 'include': include};
}

class UserConsulteeProfileArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserConsulteeProfileArgs({this.select, this.include});

  final _i2.ConsulteeProfileSelect? select;

  final _i2.ConsulteeProfileInclude? include;

  @override
  Map<String, dynamic> toJson() => {'select': select, 'include': include};
}

class StaffProfileUserArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StaffProfileUserArgs({this.select, this.include});

  final _i2.UserSelect? select;

  final _i2.UserInclude? include;

  @override
  Map<String, dynamic> toJson() => {'select': select, 'include': include};
}

class StaffProfileSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StaffProfileSelect({
    this.id,
    this.department,
    this.position,
    this.permissions,
    this.responsibilities,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.user,
  });

  final bool? id;

  final bool? department;

  final bool? position;

  final bool? permissions;

  final bool? responsibilities;

  final bool? userId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.StaffProfileUserArgs>? user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'department': department,
    'position': position,
    'permissions': permissions,
    'responsibilities': responsibilities,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'user': user,
  };
}

class StaffProfileInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StaffProfileInclude({this.user});

  final _i1.PrismaUnion<bool, _i2.StaffProfileUserArgs>? user;

  @override
  Map<String, dynamic> toJson() => {'user': user};
}

class UserStaffProfileArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserStaffProfileArgs({this.select, this.include});

  final _i2.StaffProfileSelect? select;

  final _i2.StaffProfileInclude? include;

  @override
  Map<String, dynamic> toJson() => {'select': select, 'include': include};
}

class UserSlotsOfAppointmentArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserSlotsOfAppointmentArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.SlotOfAppointmentWhereInput? where;

  final _i1.PrismaUnion<
    Iterable<_i2.SlotOfAppointmentOrderByWithRelationInput>,
    _i2.SlotOfAppointmentOrderByWithRelationInput
  >?
  orderBy;

  final _i2.SlotOfAppointmentWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentScalar,
    Iterable<_i2.SlotOfAppointmentScalar>
  >?
  distinct;

  final _i2.SlotOfAppointmentSelect? select;

  final _i2.SlotOfAppointmentInclude? include;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'orderBy': orderBy,
    'cursor': cursor,
    'take': take,
    'skip': skip,
    'distinct': distinct,
    'select': select,
    'include': include,
  };
}

class UserWaitlistArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserWaitlistArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.WaitlistWhereInput? where;

  final _i1.PrismaUnion<
    Iterable<_i2.WaitlistOrderByWithRelationInput>,
    _i2.WaitlistOrderByWithRelationInput
  >?
  orderBy;

  final _i2.WaitlistWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.WaitlistScalar, Iterable<_i2.WaitlistScalar>>?
  distinct;

  final _i2.WaitlistSelect? select;

  final _i2.WaitlistInclude? include;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'orderBy': orderBy,
    'cursor': cursor,
    'take': take,
    'skip': skip,
    'distinct': distinct,
    'select': select,
    'include': include,
  };
}

class FeedbackUserArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FeedbackUserArgs({this.select, this.include});

  final _i2.UserSelect? select;

  final _i2.UserInclude? include;

  @override
  Map<String, dynamic> toJson() => {'select': select, 'include': include};
}

class FeedbackSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FeedbackSelect({
    this.id,
    this.title,
    this.description,
    this.rating,
    this.category,
    this.status,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.user,
  });

  final bool? id;

  final bool? title;

  final bool? description;

  final bool? rating;

  final bool? category;

  final bool? status;

  final bool? userId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.FeedbackUserArgs>? user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'rating': rating,
    'category': category,
    'status': status,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'user': user,
  };
}

class FeedbackInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FeedbackInclude({this.user});

  final _i1.PrismaUnion<bool, _i2.FeedbackUserArgs>? user;

  @override
  Map<String, dynamic> toJson() => {'user': user};
}

class FeedbackOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FeedbackOrderByWithRelationInput({
    this.id,
    this.title,
    this.description,
    this.rating,
    this.category,
    this.status,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.user,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? title;

  final _i2.SortOrder? description;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? rating;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? category;

  final _i2.SortOrder? status;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.UserOrderByWithRelationInput? user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'rating': rating,
    'category': category,
    'status': status,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'user': user,
  };
}

class FeedbackWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FeedbackWhereUniqueInput({this.id});

  final String? id;

  @override
  Map<String, dynamic> toJson() => {'id': id};
}

enum FeedbackScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<String>('id', 'Feedback'),
  title<String>('title', 'Feedback'),
  description<String>('description', 'Feedback'),
  rating<int>('rating', 'Feedback'),
  category<String>('category', 'Feedback'),
  status<_i3.FeedbackStatus>('status', 'Feedback'),
  userId<String>('userId', 'Feedback'),
  createdAt<DateTime>('createdAt', 'Feedback'),
  updatedAt<DateTime>('updatedAt', 'Feedback');

  const FeedbackScalar(this.name, this.model);

  @override
  final String name;

  @override
  final String model;
}

class UserFeedbacksArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserFeedbacksArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.FeedbackWhereInput? where;

  final _i1.PrismaUnion<
    Iterable<_i2.FeedbackOrderByWithRelationInput>,
    _i2.FeedbackOrderByWithRelationInput
  >?
  orderBy;

  final _i2.FeedbackWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.FeedbackScalar, Iterable<_i2.FeedbackScalar>>?
  distinct;

  final _i2.FeedbackSelect? select;

  final _i2.FeedbackInclude? include;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'orderBy': orderBy,
    'cursor': cursor,
    'take': take,
    'skip': skip,
    'distinct': distinct,
    'select': select,
    'include': include,
  };
}

class SupportTicketUserArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportTicketUserArgs({this.select, this.include});

  final _i2.UserSelect? select;

  final _i2.UserInclude? include;

  @override
  Map<String, dynamic> toJson() => {'select': select, 'include': include};
}

class SupportResponseSupportTicketArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseSupportTicketArgs({this.select, this.include});

  final _i2.SupportTicketSelect? select;

  final _i2.SupportTicketInclude? include;

  @override
  Map<String, dynamic> toJson() => {'select': select, 'include': include};
}

class SupportResponseUserArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseUserArgs({this.select, this.include});

  final _i2.UserSelect? select;

  final _i2.UserInclude? include;

  @override
  Map<String, dynamic> toJson() => {'select': select, 'include': include};
}

class SupportResponseInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseInclude({this.supportTicket, this.user});

  final _i1.PrismaUnion<bool, _i2.SupportResponseSupportTicketArgs>?
  supportTicket;

  final _i1.PrismaUnion<bool, _i2.SupportResponseUserArgs>? user;

  @override
  Map<String, dynamic> toJson() => {
    'supportTicket': supportTicket,
    'user': user,
  };
}

class SupportTicketOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportTicketOrderByWithRelationInput({
    this.id,
    this.title,
    this.description,
    this.priority,
    this.status,
    this.category,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.user,
    this.responses,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? title;

  final _i2.SortOrder? description;

  final _i2.SortOrder? priority;

  final _i2.SortOrder? status;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? category;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.UserOrderByWithRelationInput? user;

  final _i2.SupportResponseOrderByRelationAggregateInput? responses;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'priority': priority,
    'status': status,
    'category': category,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'user': user,
    'responses': responses,
  };
}

class SupportResponseOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseOrderByWithRelationInput({
    this.id,
    this.message,
    this.supportTicketId,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.supportTicket,
    this.user,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? message;

  final _i2.SortOrder? supportTicketId;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.SupportTicketOrderByWithRelationInput? supportTicket;

  final _i2.UserOrderByWithRelationInput? user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'message': message,
    'supportTicketId': supportTicketId,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'supportTicket': supportTicket,
    'user': user,
  };
}

class SupportResponseWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseWhereUniqueInput({this.id});

  final String? id;

  @override
  Map<String, dynamic> toJson() => {'id': id};
}

enum SupportResponseScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<String>('id', 'SupportResponse'),
  message<String>('message', 'SupportResponse'),
  supportTicketId<String>('supportTicketId', 'SupportResponse'),
  userId<String>('userId', 'SupportResponse'),
  createdAt<DateTime>('createdAt', 'SupportResponse'),
  updatedAt<DateTime>('updatedAt', 'SupportResponse');

  const SupportResponseScalar(this.name, this.model);

  @override
  final String name;

  @override
  final String model;
}

class SupportTicketResponsesArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportTicketResponsesArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.SupportResponseWhereInput? where;

  final _i1.PrismaUnion<
    Iterable<_i2.SupportResponseOrderByWithRelationInput>,
    _i2.SupportResponseOrderByWithRelationInput
  >?
  orderBy;

  final _i2.SupportResponseWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<
    _i2.SupportResponseScalar,
    Iterable<_i2.SupportResponseScalar>
  >?
  distinct;

  final _i2.SupportResponseSelect? select;

  final _i2.SupportResponseInclude? include;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'orderBy': orderBy,
    'cursor': cursor,
    'take': take,
    'skip': skip,
    'distinct': distinct,
    'select': select,
    'include': include,
  };
}

class SupportTicketCountOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportTicketCountOutputTypeSelect({this.responses});

  final bool? responses;

  @override
  Map<String, dynamic> toJson() => {'responses': responses};
}

class SupportTicketCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportTicketCountArgs({this.select});

  final _i2.SupportTicketCountOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SupportTicketInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportTicketInclude({this.user, this.responses, this.$count});

  final _i1.PrismaUnion<bool, _i2.SupportTicketUserArgs>? user;

  final _i1.PrismaUnion<bool, _i2.SupportTicketResponsesArgs>? responses;

  final _i1.PrismaUnion<bool, _i2.SupportTicketCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
    'user': user,
    'responses': responses,
    '_count': $count,
  };
}

class SupportResponseSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseSelect({
    this.id,
    this.message,
    this.supportTicketId,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.supportTicket,
    this.user,
  });

  final bool? id;

  final bool? message;

  final bool? supportTicketId;

  final bool? userId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.SupportResponseSupportTicketArgs>?
  supportTicket;

  final _i1.PrismaUnion<bool, _i2.SupportResponseUserArgs>? user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'message': message,
    'supportTicketId': supportTicketId,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'supportTicket': supportTicket,
    'user': user,
  };
}

class SupportTicketSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportTicketSelect({
    this.id,
    this.title,
    this.description,
    this.priority,
    this.status,
    this.category,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.user,
    this.responses,
    this.$count,
  });

  final bool? id;

  final bool? title;

  final bool? description;

  final bool? priority;

  final bool? status;

  final bool? category;

  final bool? userId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.SupportTicketUserArgs>? user;

  final _i1.PrismaUnion<bool, _i2.SupportTicketResponsesArgs>? responses;

  final _i1.PrismaUnion<bool, _i2.SupportTicketCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'priority': priority,
    'status': status,
    'category': category,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'user': user,
    'responses': responses,
    '_count': $count,
  };
}

class SupportTicketWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportTicketWhereUniqueInput({this.id});

  final String? id;

  @override
  Map<String, dynamic> toJson() => {'id': id};
}

enum SupportTicketScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<String>('id', 'SupportTicket'),
  title<String>('title', 'SupportTicket'),
  description<String>('description', 'SupportTicket'),
  priority<_i3.SupportPriority>('priority', 'SupportTicket'),
  status<_i3.SupportTicketStatus>('status', 'SupportTicket'),
  category<String>('category', 'SupportTicket'),
  userId<String>('userId', 'SupportTicket'),
  createdAt<DateTime>('createdAt', 'SupportTicket'),
  updatedAt<DateTime>('updatedAt', 'SupportTicket');

  const SupportTicketScalar(this.name, this.model);

  @override
  final String name;

  @override
  final String model;
}

class UserSupportTicketsArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserSupportTicketsArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.SupportTicketWhereInput? where;

  final _i1.PrismaUnion<
    Iterable<_i2.SupportTicketOrderByWithRelationInput>,
    _i2.SupportTicketOrderByWithRelationInput
  >?
  orderBy;

  final _i2.SupportTicketWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<
    _i2.SupportTicketScalar,
    Iterable<_i2.SupportTicketScalar>
  >?
  distinct;

  final _i2.SupportTicketSelect? select;

  final _i2.SupportTicketInclude? include;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'orderBy': orderBy,
    'cursor': cursor,
    'take': take,
    'skip': skip,
    'distinct': distinct,
    'select': select,
    'include': include,
  };
}

class UserSupportResponsesArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserSupportResponsesArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.SupportResponseWhereInput? where;

  final _i1.PrismaUnion<
    Iterable<_i2.SupportResponseOrderByWithRelationInput>,
    _i2.SupportResponseOrderByWithRelationInput
  >?
  orderBy;

  final _i2.SupportResponseWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<
    _i2.SupportResponseScalar,
    Iterable<_i2.SupportResponseScalar>
  >?
  distinct;

  final _i2.SupportResponseSelect? select;

  final _i2.SupportResponseInclude? include;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'orderBy': orderBy,
    'cursor': cursor,
    'take': take,
    'skip': skip,
    'distinct': distinct,
    'select': select,
    'include': include,
  };
}

class AccountUserArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AccountUserArgs({this.select, this.include});

  final _i2.UserSelect? select;

  final _i2.UserInclude? include;

  @override
  Map<String, dynamic> toJson() => {'select': select, 'include': include};
}

class AccountSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AccountSelect({
    this.id,
    this.userId,
    this.type,
    this.provider,
    this.providerAccountId,
    this.refreshToken,
    this.accessToken,
    this.expiresAt,
    this.tokenType,
    this.scope,
    this.idToken,
    this.sessionState,
    this.user,
  });

  final bool? id;

  final bool? userId;

  final bool? type;

  final bool? provider;

  final bool? providerAccountId;

  final bool? refreshToken;

  final bool? accessToken;

  final bool? expiresAt;

  final bool? tokenType;

  final bool? scope;

  final bool? idToken;

  final bool? sessionState;

  final _i1.PrismaUnion<bool, _i2.AccountUserArgs>? user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'type': type,
    'provider': provider,
    'providerAccountId': providerAccountId,
    'refresh_token': refreshToken,
    'access_token': accessToken,
    'expires_at': expiresAt,
    'token_type': tokenType,
    'scope': scope,
    'id_token': idToken,
    'session_state': sessionState,
    'user': user,
  };
}

class AccountInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AccountInclude({this.user});

  final _i1.PrismaUnion<bool, _i2.AccountUserArgs>? user;

  @override
  Map<String, dynamic> toJson() => {'user': user};
}

class AccountOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AccountOrderByWithRelationInput({
    this.id,
    this.userId,
    this.type,
    this.provider,
    this.providerAccountId,
    this.refreshToken,
    this.accessToken,
    this.expiresAt,
    this.tokenType,
    this.scope,
    this.idToken,
    this.sessionState,
    this.user,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? type;

  final _i2.SortOrder? provider;

  final _i2.SortOrder? providerAccountId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? refreshToken;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? accessToken;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? expiresAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? tokenType;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? scope;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? idToken;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? sessionState;

  final _i2.UserOrderByWithRelationInput? user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'type': type,
    'provider': provider,
    'providerAccountId': providerAccountId,
    'refresh_token': refreshToken,
    'access_token': accessToken,
    'expires_at': expiresAt,
    'token_type': tokenType,
    'scope': scope,
    'id_token': idToken,
    'session_state': sessionState,
    'user': user,
  };
}

class AccountProviderProviderAccountIdCompoundUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AccountProviderProviderAccountIdCompoundUniqueInput({
    required this.provider,
    required this.providerAccountId,
  });

  final String provider;

  final String providerAccountId;

  @override
  Map<String, dynamic> toJson() => {
    'provider': provider,
    'providerAccountId': providerAccountId,
  };
}

class AccountWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AccountWhereUniqueInput({this.id, this.providerProviderAccountId});

  final String? id;

  final _i2.AccountProviderProviderAccountIdCompoundUniqueInput?
  providerProviderAccountId;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'provider_providerAccountId': providerProviderAccountId,
  };
}

enum AccountScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<String>('id', 'Account'),
  userId<String>('userId', 'Account'),
  type<String>('type', 'Account'),
  provider<String>('provider', 'Account'),
  providerAccountId<String>('providerAccountId', 'Account'),
  refreshToken<String>('refresh_token', 'Account'),
  accessToken<String>('access_token', 'Account'),
  expiresAt<int>('expires_at', 'Account'),
  tokenType<String>('token_type', 'Account'),
  scope<String>('scope', 'Account'),
  idToken<String>('id_token', 'Account'),
  sessionState<String>('session_state', 'Account');

  const AccountScalar(this.name, this.model);

  @override
  final String name;

  @override
  final String model;
}

class UserAccountsArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserAccountsArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.AccountWhereInput? where;

  final _i1.PrismaUnion<
    Iterable<_i2.AccountOrderByWithRelationInput>,
    _i2.AccountOrderByWithRelationInput
  >?
  orderBy;

  final _i2.AccountWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.AccountScalar, Iterable<_i2.AccountScalar>>?
  distinct;

  final _i2.AccountSelect? select;

  final _i2.AccountInclude? include;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'orderBy': orderBy,
    'cursor': cursor,
    'take': take,
    'skip': skip,
    'distinct': distinct,
    'select': select,
    'include': include,
  };
}

class SessionUserArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SessionUserArgs({this.select, this.include});

  final _i2.UserSelect? select;

  final _i2.UserInclude? include;

  @override
  Map<String, dynamic> toJson() => {'select': select, 'include': include};
}

class SessionSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SessionSelect({
    this.id,
    this.sessionToken,
    this.userId,
    this.expires,
    this.user,
  });

  final bool? id;

  final bool? sessionToken;

  final bool? userId;

  final bool? expires;

  final _i1.PrismaUnion<bool, _i2.SessionUserArgs>? user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'sessionToken': sessionToken,
    'userId': userId,
    'expires': expires,
    'user': user,
  };
}

class SessionInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SessionInclude({this.user});

  final _i1.PrismaUnion<bool, _i2.SessionUserArgs>? user;

  @override
  Map<String, dynamic> toJson() => {'user': user};
}

class SessionOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SessionOrderByWithRelationInput({
    this.id,
    this.sessionToken,
    this.userId,
    this.expires,
    this.user,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? sessionToken;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? expires;

  final _i2.UserOrderByWithRelationInput? user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'sessionToken': sessionToken,
    'userId': userId,
    'expires': expires,
    'user': user,
  };
}

class SessionWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SessionWhereUniqueInput({this.id, this.sessionToken});

  final String? id;

  final String? sessionToken;

  @override
  Map<String, dynamic> toJson() => {'id': id, 'sessionToken': sessionToken};
}

enum SessionScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<String>('id', 'Session'),
  sessionToken<String>('sessionToken', 'Session'),
  userId<String>('userId', 'Session'),
  expires<DateTime>('expires', 'Session');

  const SessionScalar(this.name, this.model);

  @override
  final String name;

  @override
  final String model;
}

class UserSessionsArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserSessionsArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.SessionWhereInput? where;

  final _i1.PrismaUnion<
    Iterable<_i2.SessionOrderByWithRelationInput>,
    _i2.SessionOrderByWithRelationInput
  >?
  orderBy;

  final _i2.SessionWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.SessionScalar, Iterable<_i2.SessionScalar>>?
  distinct;

  final _i2.SessionSelect? select;

  final _i2.SessionInclude? include;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'orderBy': orderBy,
    'cursor': cursor,
    'take': take,
    'skip': skip,
    'distinct': distinct,
    'select': select,
    'include': include,
  };
}

class UserCountOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCountOutputTypeSelect({
    this.payment,
    this.slotsOfAppointment,
    this.waitlist,
    this.feedbacks,
    this.supportTickets,
    this.supportResponses,
    this.accounts,
    this.sessions,
  });

  final bool? payment;

  final bool? slotsOfAppointment;

  final bool? waitlist;

  final bool? feedbacks;

  final bool? supportTickets;

  final bool? supportResponses;

  final bool? accounts;

  final bool? sessions;

  @override
  Map<String, dynamic> toJson() => {
    'Payment': payment,
    'slotsOfAppointment': slotsOfAppointment,
    'Waitlist': waitlist,
    'feedbacks': feedbacks,
    'supportTickets': supportTickets,
    'supportResponses': supportResponses,
    'accounts': accounts,
    'sessions': sessions,
  };
}

class UserCountArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCountArgs({this.select});

  final _i2.UserCountOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class UserInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserInclude({
    this.cookiePreferences,
    this.notificationPreferences,
    this.payment,
    this.consultantProfile,
    this.consulteeProfile,
    this.staffProfile,
    this.slotsOfAppointment,
    this.waitlist,
    this.feedbacks,
    this.supportTickets,
    this.supportResponses,
    this.accounts,
    this.sessions,
    this.$count,
  });

  final _i1.PrismaUnion<bool, _i2.UserCookiePreferencesArgs>? cookiePreferences;

  final _i1.PrismaUnion<bool, _i2.UserNotificationPreferencesArgs>?
  notificationPreferences;

  final _i1.PrismaUnion<bool, _i2.UserPaymentArgs>? payment;

  final _i1.PrismaUnion<bool, _i2.UserConsultantProfileArgs>? consultantProfile;

  final _i1.PrismaUnion<bool, _i2.UserConsulteeProfileArgs>? consulteeProfile;

  final _i1.PrismaUnion<bool, _i2.UserStaffProfileArgs>? staffProfile;

  final _i1.PrismaUnion<bool, _i2.UserSlotsOfAppointmentArgs>?
  slotsOfAppointment;

  final _i1.PrismaUnion<bool, _i2.UserWaitlistArgs>? waitlist;

  final _i1.PrismaUnion<bool, _i2.UserFeedbacksArgs>? feedbacks;

  final _i1.PrismaUnion<bool, _i2.UserSupportTicketsArgs>? supportTickets;

  final _i1.PrismaUnion<bool, _i2.UserSupportResponsesArgs>? supportResponses;

  final _i1.PrismaUnion<bool, _i2.UserAccountsArgs>? accounts;

  final _i1.PrismaUnion<bool, _i2.UserSessionsArgs>? sessions;

  final _i1.PrismaUnion<bool, _i2.UserCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
    'cookiePreferences': cookiePreferences,
    'notificationPreferences': notificationPreferences,
    'Payment': payment,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
    'staffProfile': staffProfile,
    'slotsOfAppointment': slotsOfAppointment,
    'Waitlist': waitlist,
    'feedbacks': feedbacks,
    'supportTickets': supportTickets,
    'supportResponses': supportResponses,
    'accounts': accounts,
    'sessions': sessions,
    '_count': $count,
  };
}

class CookiePreferenceSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CookiePreferenceSelect({
    this.id,
    this.userId,
    this.essential,
    this.analytics,
    this.marketing,
    this.user,
  });

  final bool? id;

  final bool? userId;

  final bool? essential;

  final bool? analytics;

  final bool? marketing;

  final _i1.PrismaUnion<bool, _i2.CookiePreferenceUserArgs>? user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'essential': essential,
    'analytics': analytics,
    'marketing': marketing,
    'user': user,
  };
}

class UserSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserSelect({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.cookiePreferences,
    this.notificationPreferences,
    this.payment,
    this.consultantProfile,
    this.consulteeProfile,
    this.staffProfile,
    this.slotsOfAppointment,
    this.waitlist,
    this.feedbacks,
    this.supportTickets,
    this.supportResponses,
    this.accounts,
    this.sessions,
    this.$count,
  });

  final bool? id;

  final bool? name;

  final bool? email;

  final bool? emailVerified;

  final bool? image;

  final bool? phone;

  final bool? address;

  final bool? password;

  final bool? passwordResetToken;

  final bool? passwordResetExpires;

  final bool? onlineStatus;

  final bool? currentTimezone;

  final bool? onboardingCompleted;

  final bool? role;

  final bool? consultantProfileId;

  final bool? consulteeProfileId;

  final bool? staffProfileId;

  final _i1.PrismaUnion<bool, _i2.UserCookiePreferencesArgs>? cookiePreferences;

  final _i1.PrismaUnion<bool, _i2.UserNotificationPreferencesArgs>?
  notificationPreferences;

  final _i1.PrismaUnion<bool, _i2.UserPaymentArgs>? payment;

  final _i1.PrismaUnion<bool, _i2.UserConsultantProfileArgs>? consultantProfile;

  final _i1.PrismaUnion<bool, _i2.UserConsulteeProfileArgs>? consulteeProfile;

  final _i1.PrismaUnion<bool, _i2.UserStaffProfileArgs>? staffProfile;

  final _i1.PrismaUnion<bool, _i2.UserSlotsOfAppointmentArgs>?
  slotsOfAppointment;

  final _i1.PrismaUnion<bool, _i2.UserWaitlistArgs>? waitlist;

  final _i1.PrismaUnion<bool, _i2.UserFeedbacksArgs>? feedbacks;

  final _i1.PrismaUnion<bool, _i2.UserSupportTicketsArgs>? supportTickets;

  final _i1.PrismaUnion<bool, _i2.UserSupportResponsesArgs>? supportResponses;

  final _i1.PrismaUnion<bool, _i2.UserAccountsArgs>? accounts;

  final _i1.PrismaUnion<bool, _i2.UserSessionsArgs>? sessions;

  final _i1.PrismaUnion<bool, _i2.UserCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'cookiePreferences': cookiePreferences,
    'notificationPreferences': notificationPreferences,
    'Payment': payment,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
    'staffProfile': staffProfile,
    'slotsOfAppointment': slotsOfAppointment,
    'Waitlist': waitlist,
    'feedbacks': feedbacks,
    'supportTickets': supportTickets,
    'supportResponses': supportResponses,
    'accounts': accounts,
    'sessions': sessions,
    '_count': $count,
  };
}

class CookiePreferenceCreateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CookiePreferenceCreateWithoutUserInput({
    this.id,
    this.essential,
    this.analytics,
    this.marketing,
  });

  final String? id;

  final bool? essential;

  final bool? analytics;

  final bool? marketing;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'essential': essential,
    'analytics': analytics,
    'marketing': marketing,
  };
}

class CookiePreferenceUncheckedCreateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CookiePreferenceUncheckedCreateWithoutUserInput({
    this.id,
    this.essential,
    this.analytics,
    this.marketing,
  });

  final String? id;

  final bool? essential;

  final bool? analytics;

  final bool? marketing;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'essential': essential,
    'analytics': analytics,
    'marketing': marketing,
  };
}

class CookiePreferenceWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CookiePreferenceWhereUniqueInput({this.id, this.userId});

  final String? id;

  final String? userId;

  @override
  Map<String, dynamic> toJson() => {'id': id, 'userId': userId};
}

class CookiePreferenceCreateOrConnectWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CookiePreferenceCreateOrConnectWithoutUserInput({
    required this.where,
    required this.create,
  });

  final _i2.CookiePreferenceWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.CookiePreferenceCreateWithoutUserInput,
    _i2.CookiePreferenceUncheckedCreateWithoutUserInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class CookiePreferenceCreateNestedOneWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CookiePreferenceCreateNestedOneWithoutUserInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.CookiePreferenceCreateWithoutUserInput,
    _i2.CookiePreferenceUncheckedCreateWithoutUserInput
  >?
  create;

  final _i2.CookiePreferenceCreateOrConnectWithoutUserInput? connectOrCreate;

  final _i2.CookiePreferenceWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class NotificationPreferenceCreateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NotificationPreferenceCreateWithoutUserInput({
    this.id,
    this.allNotifications,
    this.mentions,
    this.directMessages,
    this.updates,
  });

  final String? id;

  final bool? allNotifications;

  final bool? mentions;

  final bool? directMessages;

  final bool? updates;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'allNotifications': allNotifications,
    'mentions': mentions,
    'directMessages': directMessages,
    'updates': updates,
  };
}

class NotificationPreferenceUncheckedCreateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NotificationPreferenceUncheckedCreateWithoutUserInput({
    this.id,
    this.allNotifications,
    this.mentions,
    this.directMessages,
    this.updates,
  });

  final String? id;

  final bool? allNotifications;

  final bool? mentions;

  final bool? directMessages;

  final bool? updates;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'allNotifications': allNotifications,
    'mentions': mentions,
    'directMessages': directMessages,
    'updates': updates,
  };
}

class NotificationPreferenceWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NotificationPreferenceWhereUniqueInput({this.id, this.userId});

  final String? id;

  final String? userId;

  @override
  Map<String, dynamic> toJson() => {'id': id, 'userId': userId};
}

class NotificationPreferenceCreateOrConnectWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NotificationPreferenceCreateOrConnectWithoutUserInput({
    required this.where,
    required this.create,
  });

  final _i2.NotificationPreferenceWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.NotificationPreferenceCreateWithoutUserInput,
    _i2.NotificationPreferenceUncheckedCreateWithoutUserInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class NotificationPreferenceCreateNestedOneWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NotificationPreferenceCreateNestedOneWithoutUserInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.NotificationPreferenceCreateWithoutUserInput,
    _i2.NotificationPreferenceUncheckedCreateWithoutUserInput
  >?
  create;

  final _i2.NotificationPreferenceCreateOrConnectWithoutUserInput?
  connectOrCreate;

  final _i2.NotificationPreferenceWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class ConsultationPlanCreatelearningOutcomesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanCreatelearningOutcomesInput({required this.set});

  final Iterable<String> set;

  @override
  Map<String, dynamic> toJson() => {'set': set};
}

class SlotOfAvailabilityWeeklyCreateWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityWeeklyCreateWithoutConsultantProfileInput({
    this.id,
    required this.dayOfWeekforStartTimeInUTC,
    required this.slotStartTimeInUTC,
    required this.dayOfWeekforEndTimeInUTC,
    required this.slotEndTimeInUTC,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final _i3.DayOfWeek dayOfWeekforStartTimeInUTC;

  final DateTime slotStartTimeInUTC;

  final _i3.DayOfWeek dayOfWeekforEndTimeInUTC;

  final DateTime slotEndTimeInUTC;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'dayOfWeekforStartTimeInUTC': dayOfWeekforStartTimeInUTC,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'dayOfWeekforEndTimeInUTC': dayOfWeekforEndTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SlotOfAvailabilityWeeklyUncheckedCreateWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityWeeklyUncheckedCreateWithoutConsultantProfileInput({
    this.id,
    required this.dayOfWeekforStartTimeInUTC,
    required this.slotStartTimeInUTC,
    required this.dayOfWeekforEndTimeInUTC,
    required this.slotEndTimeInUTC,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final _i3.DayOfWeek dayOfWeekforStartTimeInUTC;

  final DateTime slotStartTimeInUTC;

  final _i3.DayOfWeek dayOfWeekforEndTimeInUTC;

  final DateTime slotEndTimeInUTC;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'dayOfWeekforStartTimeInUTC': dayOfWeekforStartTimeInUTC,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'dayOfWeekforEndTimeInUTC': dayOfWeekforEndTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SlotOfAvailabilityWeeklyCreateOrConnectWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityWeeklyCreateOrConnectWithoutConsultantProfileInput({
    required this.where,
    required this.create,
  });

  final _i2.SlotOfAvailabilityWeeklyWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityWeeklyCreateWithoutConsultantProfileInput,
    _i2.SlotOfAvailabilityWeeklyUncheckedCreateWithoutConsultantProfileInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class SlotOfAvailabilityWeeklyCreateManyConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityWeeklyCreateManyConsultantProfileInput({
    this.id,
    required this.dayOfWeekforStartTimeInUTC,
    required this.slotStartTimeInUTC,
    required this.dayOfWeekforEndTimeInUTC,
    required this.slotEndTimeInUTC,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final _i3.DayOfWeek dayOfWeekforStartTimeInUTC;

  final DateTime slotStartTimeInUTC;

  final _i3.DayOfWeek dayOfWeekforEndTimeInUTC;

  final DateTime slotEndTimeInUTC;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'dayOfWeekforStartTimeInUTC': dayOfWeekforStartTimeInUTC,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'dayOfWeekforEndTimeInUTC': dayOfWeekforEndTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SlotOfAvailabilityWeeklyCreateManyConsultantProfileInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityWeeklyCreateManyConsultantProfileInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityWeeklyCreateManyConsultantProfileInput,
    Iterable<_i2.SlotOfAvailabilityWeeklyCreateManyConsultantProfileInput>
  >
  data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
    'data': data,
    'skipDuplicates': skipDuplicates,
  };
}

class SlotOfAvailabilityWeeklyCreateNestedManyWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityWeeklyCreateNestedManyWithoutConsultantProfileInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityWeeklyCreateWithoutConsultantProfileInput,
    _i1.PrismaUnion<
      Iterable<_i2.SlotOfAvailabilityWeeklyCreateWithoutConsultantProfileInput>,
      _i1.PrismaUnion<
        _i2.SlotOfAvailabilityWeeklyUncheckedCreateWithoutConsultantProfileInput,
        Iterable<
          _i2.SlotOfAvailabilityWeeklyUncheckedCreateWithoutConsultantProfileInput
        >
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityWeeklyCreateOrConnectWithoutConsultantProfileInput,
    Iterable<
      _i2.SlotOfAvailabilityWeeklyCreateOrConnectWithoutConsultantProfileInput
    >
  >?
  connectOrCreate;

  final _i2.SlotOfAvailabilityWeeklyCreateManyConsultantProfileInputEnvelope?
  createMany;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityWeeklyWhereUniqueInput,
    Iterable<_i2.SlotOfAvailabilityWeeklyWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class SlotOfAvailabilityCustomCreateWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityCustomCreateWithoutConsultantProfileInput({
    this.id,
    required this.slotStartTimeInUTC,
    required this.slotEndTimeInUTC,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final DateTime slotStartTimeInUTC;

  final DateTime slotEndTimeInUTC;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SlotOfAvailabilityCustomUncheckedCreateWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityCustomUncheckedCreateWithoutConsultantProfileInput({
    this.id,
    required this.slotStartTimeInUTC,
    required this.slotEndTimeInUTC,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final DateTime slotStartTimeInUTC;

  final DateTime slotEndTimeInUTC;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SlotOfAvailabilityCustomCreateOrConnectWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityCustomCreateOrConnectWithoutConsultantProfileInput({
    required this.where,
    required this.create,
  });

  final _i2.SlotOfAvailabilityCustomWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityCustomCreateWithoutConsultantProfileInput,
    _i2.SlotOfAvailabilityCustomUncheckedCreateWithoutConsultantProfileInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class SlotOfAvailabilityCustomCreateManyConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityCustomCreateManyConsultantProfileInput({
    this.id,
    required this.slotStartTimeInUTC,
    required this.slotEndTimeInUTC,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final DateTime slotStartTimeInUTC;

  final DateTime slotEndTimeInUTC;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SlotOfAvailabilityCustomCreateManyConsultantProfileInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityCustomCreateManyConsultantProfileInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityCustomCreateManyConsultantProfileInput,
    Iterable<_i2.SlotOfAvailabilityCustomCreateManyConsultantProfileInput>
  >
  data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
    'data': data,
    'skipDuplicates': skipDuplicates,
  };
}

class SlotOfAvailabilityCustomCreateNestedManyWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityCustomCreateNestedManyWithoutConsultantProfileInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityCustomCreateWithoutConsultantProfileInput,
    _i1.PrismaUnion<
      Iterable<_i2.SlotOfAvailabilityCustomCreateWithoutConsultantProfileInput>,
      _i1.PrismaUnion<
        _i2.SlotOfAvailabilityCustomUncheckedCreateWithoutConsultantProfileInput,
        Iterable<
          _i2.SlotOfAvailabilityCustomUncheckedCreateWithoutConsultantProfileInput
        >
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityCustomCreateOrConnectWithoutConsultantProfileInput,
    Iterable<
      _i2.SlotOfAvailabilityCustomCreateOrConnectWithoutConsultantProfileInput
    >
  >?
  connectOrCreate;

  final _i2.SlotOfAvailabilityCustomCreateManyConsultantProfileInputEnvelope?
  createMany;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityCustomWhereUniqueInput,
    Iterable<_i2.SlotOfAvailabilityCustomWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class SubscriptionPlanCreatelearningOutcomesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanCreatelearningOutcomesInput({required this.set});

  final Iterable<String> set;

  @override
  Map<String, dynamic> toJson() => {'set': set};
}

class WebinarPlanCreatelearningOutcomesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanCreatelearningOutcomesInput({required this.set});

  final Iterable<String> set;

  @override
  Map<String, dynamic> toJson() => {'set': set};
}

class ClassPlanCreatelearningOutcomesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanCreatelearningOutcomesInput({required this.set});

  final Iterable<String> set;

  @override
  Map<String, dynamic> toJson() => {'set': set};
}

class ClassContentCreateWithoutClassPlanInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassContentCreateWithoutClassPlanInput({
    this.id,
    required this.title,
    required this.description,
    this.contentType,
    this.contentUrl,
    required this.order,
    required this.hoursAllotted,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final String title;

  final String description;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? contentType;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? contentUrl;

  final int order;

  final double hoursAllotted;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'contentType': contentType,
    'contentUrl': contentUrl,
    'order': order,
    'hoursAllotted': hoursAllotted,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ClassContentUncheckedCreateWithoutClassPlanInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassContentUncheckedCreateWithoutClassPlanInput({
    this.id,
    required this.title,
    required this.description,
    this.contentType,
    this.contentUrl,
    required this.order,
    required this.hoursAllotted,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final String title;

  final String description;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? contentType;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? contentUrl;

  final int order;

  final double hoursAllotted;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'contentType': contentType,
    'contentUrl': contentUrl,
    'order': order,
    'hoursAllotted': hoursAllotted,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ClassContentCreateOrConnectWithoutClassPlanInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassContentCreateOrConnectWithoutClassPlanInput({
    required this.where,
    required this.create,
  });

  final _i2.ClassContentWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.ClassContentCreateWithoutClassPlanInput,
    _i2.ClassContentUncheckedCreateWithoutClassPlanInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class ClassContentCreateManyClassPlanInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassContentCreateManyClassPlanInput({
    this.id,
    required this.title,
    required this.description,
    this.contentType,
    this.contentUrl,
    required this.order,
    required this.hoursAllotted,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final String title;

  final String description;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? contentType;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? contentUrl;

  final int order;

  final double hoursAllotted;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'contentType': contentType,
    'contentUrl': contentUrl,
    'order': order,
    'hoursAllotted': hoursAllotted,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ClassContentCreateManyClassPlanInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassContentCreateManyClassPlanInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<
    _i2.ClassContentCreateManyClassPlanInput,
    Iterable<_i2.ClassContentCreateManyClassPlanInput>
  >
  data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
    'data': data,
    'skipDuplicates': skipDuplicates,
  };
}

class ClassContentCreateNestedManyWithoutClassPlanInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassContentCreateNestedManyWithoutClassPlanInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.ClassContentCreateWithoutClassPlanInput,
    _i1.PrismaUnion<
      Iterable<_i2.ClassContentCreateWithoutClassPlanInput>,
      _i1.PrismaUnion<
        _i2.ClassContentUncheckedCreateWithoutClassPlanInput,
        Iterable<_i2.ClassContentUncheckedCreateWithoutClassPlanInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.ClassContentCreateOrConnectWithoutClassPlanInput,
    Iterable<_i2.ClassContentCreateOrConnectWithoutClassPlanInput>
  >?
  connectOrCreate;

  final _i2.ClassContentCreateManyClassPlanInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.ClassContentWhereUniqueInput,
    Iterable<_i2.ClassContentWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class ConsulteeProfileCreateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileCreateWithoutUserInput({
    this.id,
    this.education,
    this.occupation,
    this.aboutMe,
    this.preferredCommunicationMethod,
    this.preferredLanguage,
    this.specialRequirements,
    this.interests,
    this.goals,
    this.createdAt,
    this.updatedAt,
    this.consultationRequests,
    this.subscriptionRequests,
    this.consultantReviews,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? education;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? occupation;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? aboutMe;

  final _i1.PrismaUnion<_i3.ConsultationMode, _i1.PrismaNull>?
  preferredCommunicationMethod;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? preferredLanguage;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? specialRequirements;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? interests;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? goals;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ConsultationCreateNestedManyWithoutRequestedByInput?
  consultationRequests;

  final _i2.SubscriptionCreateNestedManyWithoutRequestedByInput?
  subscriptionRequests;

  final _i2.ConsultantReviewCreateNestedManyWithoutConsulteeProfileInput?
  consultantReviews;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'education': education,
    'occupation': occupation,
    'aboutMe': aboutMe,
    'preferredCommunicationMethod': preferredCommunicationMethod,
    'preferredLanguage': preferredLanguage,
    'specialRequirements': specialRequirements,
    'interests': interests,
    'goals': goals,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultationRequests': consultationRequests,
    'subscriptionRequests': subscriptionRequests,
    'consultantReviews': consultantReviews,
  };
}

class SubscriptionCreateWithoutAppointmentsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionCreateWithoutAppointmentsInput({
    this.id,
    this.startDate,
    required this.endDate,
    this.requestStatus,
    this.requestedAt,
    this.requestNotes,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.createdAt,
    this.updatedAt,
    required this.requestedBy,
    required this.subscriptionPlan,
  });

  final String? id;

  final DateTime? startDate;

  final DateTime endDate;

  final _i3.RequestStatus? requestStatus;

  final DateTime? requestedAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? requestNotes;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackFromConsultee;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackFromConsultant;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? rating;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ConsulteeProfileCreateNestedOneWithoutSubscriptionRequestsInput
  requestedBy;

  final _i2.SubscriptionPlanCreateNestedOneWithoutSubscriptionsInput
  subscriptionPlan;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'requestStatus': requestStatus,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'requestedBy': requestedBy,
    'subscriptionPlan': subscriptionPlan,
  };
}

class SubscriptionUncheckedCreateWithoutAppointmentsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionUncheckedCreateWithoutAppointmentsInput({
    this.id,
    this.startDate,
    required this.endDate,
    this.requestStatus,
    required this.requestedById,
    this.requestedAt,
    this.requestNotes,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    required this.subscriptionPlanId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final DateTime? startDate;

  final DateTime endDate;

  final _i3.RequestStatus? requestStatus;

  final String requestedById;

  final DateTime? requestedAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? requestNotes;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackFromConsultee;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackFromConsultant;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? rating;

  final String subscriptionPlanId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'requestStatus': requestStatus,
    'requestedById': requestedById,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'subscriptionPlanId': subscriptionPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SubscriptionCreateOrConnectWithoutAppointmentsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionCreateOrConnectWithoutAppointmentsInput({
    required this.where,
    required this.create,
  });

  final _i2.SubscriptionWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.SubscriptionCreateWithoutAppointmentsInput,
    _i2.SubscriptionUncheckedCreateWithoutAppointmentsInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class SubscriptionCreateNestedOneWithoutAppointmentsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionCreateNestedOneWithoutAppointmentsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.SubscriptionCreateWithoutAppointmentsInput,
    _i2.SubscriptionUncheckedCreateWithoutAppointmentsInput
  >?
  create;

  final _i2.SubscriptionCreateOrConnectWithoutAppointmentsInput?
  connectOrCreate;

  final _i2.SubscriptionWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

enum NullableJsonNullValueInput implements _i1.PrismaEnum {
  dbNull._('DbNull'),
  jsonNull._('JsonNull');

  const NullableJsonNullValueInput._(this.name);

  @override
  final String name;
}

class StaffProfileCreateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StaffProfileCreateWithoutUserInput({
    this.id,
    this.department,
    this.position,
    this.permissions,
    this.responsibilities,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? department;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? position;

  final _i1.PrismaUnion<_i2.NullableJsonNullValueInput, _i1.PrismaJson>?
  permissions;

  final _i1.PrismaUnion<_i2.NullableJsonNullValueInput, _i1.PrismaJson>?
  responsibilities;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'department': department,
    'position': position,
    'permissions': permissions,
    'responsibilities': responsibilities,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class StaffProfileUncheckedCreateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StaffProfileUncheckedCreateWithoutUserInput({
    this.id,
    this.department,
    this.position,
    this.permissions,
    this.responsibilities,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? department;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? position;

  final _i1.PrismaUnion<_i2.NullableJsonNullValueInput, _i1.PrismaJson>?
  permissions;

  final _i1.PrismaUnion<_i2.NullableJsonNullValueInput, _i1.PrismaJson>?
  responsibilities;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'department': department,
    'position': position,
    'permissions': permissions,
    'responsibilities': responsibilities,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class StaffProfileWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StaffProfileWhereUniqueInput({this.id, this.userId});

  final String? id;

  final String? userId;

  @override
  Map<String, dynamic> toJson() => {'id': id, 'userId': userId};
}

class StaffProfileCreateOrConnectWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StaffProfileCreateOrConnectWithoutUserInput({
    required this.where,
    required this.create,
  });

  final _i2.StaffProfileWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.StaffProfileCreateWithoutUserInput,
    _i2.StaffProfileUncheckedCreateWithoutUserInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class StaffProfileCreateNestedOneWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StaffProfileCreateNestedOneWithoutUserInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.StaffProfileCreateWithoutUserInput,
    _i2.StaffProfileUncheckedCreateWithoutUserInput
  >?
  create;

  final _i2.StaffProfileCreateOrConnectWithoutUserInput? connectOrCreate;

  final _i2.StaffProfileWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class ConsultationCreateWithoutAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationCreateWithoutAppointmentInput({
    this.id,
    this.requestStatus,
    this.requestedAt,
    this.requestNotes,
    this.directlyBooked,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.createdAt,
    this.updatedAt,
    required this.consultationPlan,
    required this.requestedBy,
  });

  final String? id;

  final _i3.RequestStatus? requestStatus;

  final DateTime? requestedAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? requestNotes;

  final bool? directlyBooked;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackFromConsultee;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackFromConsultant;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? rating;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ConsultationPlanCreateNestedOneWithoutConsultationsInput
  consultationPlan;

  final _i2.ConsulteeProfileCreateNestedOneWithoutConsultationRequestsInput
  requestedBy;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'requestStatus': requestStatus,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'directlyBooked': directlyBooked,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultationPlan': consultationPlan,
    'requestedBy': requestedBy,
  };
}

class ConsultationUncheckedCreateWithoutAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationUncheckedCreateWithoutAppointmentInput({
    this.id,
    required this.consultationPlanId,
    this.requestStatus,
    required this.requestedById,
    this.requestedAt,
    this.requestNotes,
    this.directlyBooked,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final String consultationPlanId;

  final _i3.RequestStatus? requestStatus;

  final String requestedById;

  final DateTime? requestedAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? requestNotes;

  final bool? directlyBooked;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackFromConsultee;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackFromConsultant;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? rating;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'consultationPlanId': consultationPlanId,
    'requestStatus': requestStatus,
    'requestedById': requestedById,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'directlyBooked': directlyBooked,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultationCreateOrConnectWithoutAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationCreateOrConnectWithoutAppointmentInput({
    required this.where,
    required this.create,
  });

  final _i2.ConsultationWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.ConsultationCreateWithoutAppointmentInput,
    _i2.ConsultationUncheckedCreateWithoutAppointmentInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class ConsultationCreateNestedOneWithoutAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationCreateNestedOneWithoutAppointmentInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.ConsultationCreateWithoutAppointmentInput,
    _i2.ConsultationUncheckedCreateWithoutAppointmentInput
  >?
  create;

  final _i2.ConsultationCreateOrConnectWithoutAppointmentInput? connectOrCreate;

  final _i2.ConsultationWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class ClassCreaterecordingUrlsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassCreaterecordingUrlsInput({required this.set});

  final Iterable<String> set;

  @override
  Map<String, dynamic> toJson() => {'set': set};
}

class ClassPlanCreateWithoutClassesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanCreateWithoutClassesInput({
    this.id,
    required this.title,
    required this.description,
    required this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInMonths,
    this.callsPerWeek,
    this.videoMeetings,
    this.emailSupport,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.createdAt,
    this.updatedAt,
    this.topics,
    this.classContents,
    this.consultantProfile,
  });

  final String? id;

  final String title;

  final String description;

  final int price;

  final String? priceCurrency;

  final bool? certificateProvided;

  final int? durationInMonths;

  final int? callsPerWeek;

  final int? videoMeetings;

  final _i3.PlanEmailSupport? emailSupport;

  final int? maxParticipants;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? language;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? level;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? prerequisites;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? materialProvided;

  final _i1.PrismaUnion<
    _i2.ClassPlanCreatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.TopicCreateNestedManyWithoutClassPlansInput? topics;

  final _i2.ClassContentCreateNestedManyWithoutClassPlanInput? classContents;

  final _i2.ConsultantProfileCreateNestedOneWithoutClassPlansInput?
  consultantProfile;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInMonths': durationInMonths,
    'callsPerWeek': callsPerWeek,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'topics': topics,
    'classContents': classContents,
    'consultantProfile': consultantProfile,
  };
}

class WaitlistUncheckedCreateWithoutWebinarInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistUncheckedCreateWithoutWebinarInput({
    this.id,
    this.joinedAt,
    required this.userId,
    this.classId,
  });

  final String? id;

  final DateTime? joinedAt;

  final String userId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? classId;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'joinedAt': joinedAt,
    'userId': userId,
    'classId': classId,
  };
}

class WaitlistCreateOrConnectWithoutWebinarInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistCreateOrConnectWithoutWebinarInput({
    required this.where,
    required this.create,
  });

  final _i2.WaitlistWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.WaitlistCreateWithoutWebinarInput,
    _i2.WaitlistUncheckedCreateWithoutWebinarInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class WaitlistCreateManyWebinarInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistCreateManyWebinarInput({
    this.id,
    this.joinedAt,
    required this.userId,
    this.classId,
  });

  final String? id;

  final DateTime? joinedAt;

  final String userId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? classId;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'joinedAt': joinedAt,
    'userId': userId,
    'classId': classId,
  };
}

class WaitlistCreateManyWebinarInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistCreateManyWebinarInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<
    _i2.WaitlistCreateManyWebinarInput,
    Iterable<_i2.WaitlistCreateManyWebinarInput>
  >
  data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
    'data': data,
    'skipDuplicates': skipDuplicates,
  };
}

class WaitlistUncheckedCreateNestedManyWithoutWebinarInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistUncheckedCreateNestedManyWithoutWebinarInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.WaitlistCreateWithoutWebinarInput,
    _i1.PrismaUnion<
      Iterable<_i2.WaitlistCreateWithoutWebinarInput>,
      _i1.PrismaUnion<
        _i2.WaitlistUncheckedCreateWithoutWebinarInput,
        Iterable<_i2.WaitlistUncheckedCreateWithoutWebinarInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.WaitlistCreateOrConnectWithoutWebinarInput,
    Iterable<_i2.WaitlistCreateOrConnectWithoutWebinarInput>
  >?
  connectOrCreate;

  final _i2.WaitlistCreateManyWebinarInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.WaitlistWhereUniqueInput,
    Iterable<_i2.WaitlistWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class CookiePreferenceUncheckedCreateNestedOneWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CookiePreferenceUncheckedCreateNestedOneWithoutUserInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.CookiePreferenceCreateWithoutUserInput,
    _i2.CookiePreferenceUncheckedCreateWithoutUserInput
  >?
  create;

  final _i2.CookiePreferenceCreateOrConnectWithoutUserInput? connectOrCreate;

  final _i2.CookiePreferenceWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.NotificationPreferenceCreateWithoutUserInput,
    _i2.NotificationPreferenceUncheckedCreateWithoutUserInput
  >?
  create;

  final _i2.NotificationPreferenceCreateOrConnectWithoutUserInput?
  connectOrCreate;

  final _i2.NotificationPreferenceWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class PaymentUncheckedCreateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentUncheckedCreateWithoutUserInput({
    this.id,
    required this.amount,
    required this.currency,
    this.description,
    this.receiptUrl,
    required this.paymentMethod,
    required this.paymentIntent,
    required this.paymentGateway,
    required this.paymentStatus,
    this.expiresAt,
    this.appointmentId,
    this.discountCodeId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final int amount;

  final String currency;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? receiptUrl;

  final String paymentMethod;

  final String paymentIntent;

  final _i3.PaymentGateway paymentGateway;

  final _i3.PaymentStatus paymentStatus;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? expiresAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? appointmentId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? discountCodeId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'amount': amount,
    'currency': currency,
    'description': description,
    'receiptUrl': receiptUrl,
    'paymentMethod': paymentMethod,
    'paymentIntent': paymentIntent,
    'paymentGateway': paymentGateway,
    'paymentStatus': paymentStatus,
    'expiresAt': expiresAt,
    'appointmentId': appointmentId,
    'discountCodeId': discountCodeId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class PaymentCreateOrConnectWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentCreateOrConnectWithoutUserInput({
    required this.where,
    required this.create,
  });

  final _i2.PaymentWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.PaymentCreateWithoutUserInput,
    _i2.PaymentUncheckedCreateWithoutUserInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class PaymentCreateManyUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentCreateManyUserInput({
    this.id,
    required this.amount,
    required this.currency,
    this.description,
    this.receiptUrl,
    required this.paymentMethod,
    required this.paymentIntent,
    required this.paymentGateway,
    required this.paymentStatus,
    this.expiresAt,
    this.appointmentId,
    this.discountCodeId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final int amount;

  final String currency;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? receiptUrl;

  final String paymentMethod;

  final String paymentIntent;

  final _i3.PaymentGateway paymentGateway;

  final _i3.PaymentStatus paymentStatus;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? expiresAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? appointmentId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? discountCodeId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'amount': amount,
    'currency': currency,
    'description': description,
    'receiptUrl': receiptUrl,
    'paymentMethod': paymentMethod,
    'paymentIntent': paymentIntent,
    'paymentGateway': paymentGateway,
    'paymentStatus': paymentStatus,
    'expiresAt': expiresAt,
    'appointmentId': appointmentId,
    'discountCodeId': discountCodeId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class PaymentCreateManyUserInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentCreateManyUserInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<
    _i2.PaymentCreateManyUserInput,
    Iterable<_i2.PaymentCreateManyUserInput>
  >
  data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
    'data': data,
    'skipDuplicates': skipDuplicates,
  };
}

class PaymentUncheckedCreateNestedManyWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentUncheckedCreateNestedManyWithoutUserInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.PaymentCreateWithoutUserInput,
    _i1.PrismaUnion<
      Iterable<_i2.PaymentCreateWithoutUserInput>,
      _i1.PrismaUnion<
        _i2.PaymentUncheckedCreateWithoutUserInput,
        Iterable<_i2.PaymentUncheckedCreateWithoutUserInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.PaymentCreateOrConnectWithoutUserInput,
    Iterable<_i2.PaymentCreateOrConnectWithoutUserInput>
  >?
  connectOrCreate;

  final _i2.PaymentCreateManyUserInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.PaymentWhereUniqueInput,
    Iterable<_i2.PaymentWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class SubDomainUncheckedCreateWithoutConsultantProfilesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainUncheckedCreateWithoutConsultantProfilesInput({
    this.id,
    required this.name,
    required this.domainId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final String name;

  final String domainId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'domainId': domainId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SubDomainCreateOrConnectWithoutConsultantProfilesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainCreateOrConnectWithoutConsultantProfilesInput({
    required this.where,
    required this.create,
  });

  final _i2.SubDomainWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.SubDomainCreateWithoutConsultantProfilesInput,
    _i2.SubDomainUncheckedCreateWithoutConsultantProfilesInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class SubDomainUncheckedCreateNestedManyWithoutConsultantProfilesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainUncheckedCreateNestedManyWithoutConsultantProfilesInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.SubDomainCreateWithoutConsultantProfilesInput,
    _i1.PrismaUnion<
      Iterable<_i2.SubDomainCreateWithoutConsultantProfilesInput>,
      _i1.PrismaUnion<
        _i2.SubDomainUncheckedCreateWithoutConsultantProfilesInput,
        Iterable<_i2.SubDomainUncheckedCreateWithoutConsultantProfilesInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.SubDomainCreateOrConnectWithoutConsultantProfilesInput,
    Iterable<_i2.SubDomainCreateOrConnectWithoutConsultantProfilesInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.SubDomainWhereUniqueInput,
    Iterable<_i2.SubDomainWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class TagUncheckedCreateWithoutConsultantProfilesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagUncheckedCreateWithoutConsultantProfilesInput({
    this.id,
    required this.name,
    required this.domainId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final String name;

  final String domainId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'domainId': domainId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class TagCreateOrConnectWithoutConsultantProfilesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagCreateOrConnectWithoutConsultantProfilesInput({
    required this.where,
    required this.create,
  });

  final _i2.TagWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.TagCreateWithoutConsultantProfilesInput,
    _i2.TagUncheckedCreateWithoutConsultantProfilesInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class TagUncheckedCreateNestedManyWithoutConsultantProfilesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagUncheckedCreateNestedManyWithoutConsultantProfilesInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.TagCreateWithoutConsultantProfilesInput,
    _i1.PrismaUnion<
      Iterable<_i2.TagCreateWithoutConsultantProfilesInput>,
      _i1.PrismaUnion<
        _i2.TagUncheckedCreateWithoutConsultantProfilesInput,
        Iterable<_i2.TagUncheckedCreateWithoutConsultantProfilesInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.TagCreateOrConnectWithoutConsultantProfilesInput,
    Iterable<_i2.TagCreateOrConnectWithoutConsultantProfilesInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.TagWhereUniqueInput,
    Iterable<_i2.TagWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class ConsultantReviewUncheckedCreateWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewUncheckedCreateWithoutConsultantProfileInput({
    this.id,
    this.rating,
    this.reviewDescription,
    required this.consulteeProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final int? rating;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? reviewDescription;

  final String consulteeProfileId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'rating': rating,
    'reviewDescription': reviewDescription,
    'consulteeProfileId': consulteeProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultantReviewCreateOrConnectWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewCreateOrConnectWithoutConsultantProfileInput({
    required this.where,
    required this.create,
  });

  final _i2.ConsultantReviewWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewCreateWithoutConsultantProfileInput,
    _i2.ConsultantReviewUncheckedCreateWithoutConsultantProfileInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class ConsultantReviewCreateManyConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewCreateManyConsultantProfileInput({
    this.id,
    this.rating,
    this.reviewDescription,
    required this.consulteeProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final int? rating;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? reviewDescription;

  final String consulteeProfileId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'rating': rating,
    'reviewDescription': reviewDescription,
    'consulteeProfileId': consulteeProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultantReviewCreateManyConsultantProfileInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewCreateManyConsultantProfileInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<
    _i2.ConsultantReviewCreateManyConsultantProfileInput,
    Iterable<_i2.ConsultantReviewCreateManyConsultantProfileInput>
  >
  data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
    'data': data,
    'skipDuplicates': skipDuplicates,
  };
}

class ConsultantReviewUncheckedCreateNestedManyWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewUncheckedCreateNestedManyWithoutConsultantProfileInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.ConsultantReviewCreateWithoutConsultantProfileInput,
    _i1.PrismaUnion<
      Iterable<_i2.ConsultantReviewCreateWithoutConsultantProfileInput>,
      _i1.PrismaUnion<
        _i2.ConsultantReviewUncheckedCreateWithoutConsultantProfileInput,
        Iterable<
          _i2.ConsultantReviewUncheckedCreateWithoutConsultantProfileInput
        >
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewCreateOrConnectWithoutConsultantProfileInput,
    Iterable<_i2.ConsultantReviewCreateOrConnectWithoutConsultantProfileInput>
  >?
  connectOrCreate;

  final _i2.ConsultantReviewCreateManyConsultantProfileInputEnvelope?
  createMany;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewWhereUniqueInput,
    Iterable<_i2.ConsultantReviewWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class SlotOfAvailabilityWeeklyUncheckedCreateNestedManyWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityWeeklyUncheckedCreateNestedManyWithoutConsultantProfileInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityWeeklyCreateWithoutConsultantProfileInput,
    _i1.PrismaUnion<
      Iterable<_i2.SlotOfAvailabilityWeeklyCreateWithoutConsultantProfileInput>,
      _i1.PrismaUnion<
        _i2.SlotOfAvailabilityWeeklyUncheckedCreateWithoutConsultantProfileInput,
        Iterable<
          _i2.SlotOfAvailabilityWeeklyUncheckedCreateWithoutConsultantProfileInput
        >
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityWeeklyCreateOrConnectWithoutConsultantProfileInput,
    Iterable<
      _i2.SlotOfAvailabilityWeeklyCreateOrConnectWithoutConsultantProfileInput
    >
  >?
  connectOrCreate;

  final _i2.SlotOfAvailabilityWeeklyCreateManyConsultantProfileInputEnvelope?
  createMany;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityWeeklyWhereUniqueInput,
    Iterable<_i2.SlotOfAvailabilityWeeklyWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class SlotOfAvailabilityCustomUncheckedCreateNestedManyWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityCustomUncheckedCreateNestedManyWithoutConsultantProfileInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityCustomCreateWithoutConsultantProfileInput,
    _i1.PrismaUnion<
      Iterable<_i2.SlotOfAvailabilityCustomCreateWithoutConsultantProfileInput>,
      _i1.PrismaUnion<
        _i2.SlotOfAvailabilityCustomUncheckedCreateWithoutConsultantProfileInput,
        Iterable<
          _i2.SlotOfAvailabilityCustomUncheckedCreateWithoutConsultantProfileInput
        >
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityCustomCreateOrConnectWithoutConsultantProfileInput,
    Iterable<
      _i2.SlotOfAvailabilityCustomCreateOrConnectWithoutConsultantProfileInput
    >
  >?
  connectOrCreate;

  final _i2.SlotOfAvailabilityCustomCreateManyConsultantProfileInputEnvelope?
  createMany;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityCustomWhereUniqueInput,
    Iterable<_i2.SlotOfAvailabilityCustomWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class ConsultationUncheckedCreateWithoutConsultationPlanInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationUncheckedCreateWithoutConsultationPlanInput({
    this.id,
    this.requestStatus,
    required this.requestedById,
    this.requestedAt,
    this.requestNotes,
    this.directlyBooked,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.createdAt,
    this.updatedAt,
    this.appointment,
  });

  final String? id;

  final _i3.RequestStatus? requestStatus;

  final String requestedById;

  final DateTime? requestedAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? requestNotes;

  final bool? directlyBooked;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackFromConsultee;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackFromConsultant;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? rating;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.AppointmentUncheckedCreateNestedOneWithoutConsultationInput?
  appointment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'requestStatus': requestStatus,
    'requestedById': requestedById,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'directlyBooked': directlyBooked,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'appointment': appointment,
  };
}

class ConsultationCreateOrConnectWithoutConsultationPlanInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationCreateOrConnectWithoutConsultationPlanInput({
    required this.where,
    required this.create,
  });

  final _i2.ConsultationWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.ConsultationCreateWithoutConsultationPlanInput,
    _i2.ConsultationUncheckedCreateWithoutConsultationPlanInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class ConsultationCreateManyConsultationPlanInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationCreateManyConsultationPlanInput({
    this.id,
    this.requestStatus,
    required this.requestedById,
    this.requestedAt,
    this.requestNotes,
    this.directlyBooked,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final _i3.RequestStatus? requestStatus;

  final String requestedById;

  final DateTime? requestedAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? requestNotes;

  final bool? directlyBooked;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackFromConsultee;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackFromConsultant;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? rating;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'requestStatus': requestStatus,
    'requestedById': requestedById,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'directlyBooked': directlyBooked,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultationCreateManyConsultationPlanInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationCreateManyConsultationPlanInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<
    _i2.ConsultationCreateManyConsultationPlanInput,
    Iterable<_i2.ConsultationCreateManyConsultationPlanInput>
  >
  data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
    'data': data,
    'skipDuplicates': skipDuplicates,
  };
}

class ConsultationUncheckedCreateNestedManyWithoutConsultationPlanInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationUncheckedCreateNestedManyWithoutConsultationPlanInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.ConsultationCreateWithoutConsultationPlanInput,
    _i1.PrismaUnion<
      Iterable<_i2.ConsultationCreateWithoutConsultationPlanInput>,
      _i1.PrismaUnion<
        _i2.ConsultationUncheckedCreateWithoutConsultationPlanInput,
        Iterable<_i2.ConsultationUncheckedCreateWithoutConsultationPlanInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.ConsultationCreateOrConnectWithoutConsultationPlanInput,
    Iterable<_i2.ConsultationCreateOrConnectWithoutConsultationPlanInput>
  >?
  connectOrCreate;

  final _i2.ConsultationCreateManyConsultationPlanInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.ConsultationWhereUniqueInput,
    Iterable<_i2.ConsultationWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class ConsultationPlanUncheckedCreateWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanUncheckedCreateWithoutConsultantProfileInput({
    this.id,
    required this.title,
    this.description,
    this.durationInHours,
    required this.price,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.createdAt,
    this.updatedAt,
    this.consultations,
  });

  final String? id;

  final String title;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final double? durationInHours;

  final int price;

  final String? language;

  final String? level;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? prerequisites;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? materialProvided;

  final _i1.PrismaUnion<
    _i2.ConsultationPlanCreatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ConsultationUncheckedCreateNestedManyWithoutConsultationPlanInput?
  consultations;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInHours': durationInHours,
    'price': price,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultations': consultations,
  };
}

class ConsultationPlanCreateOrConnectWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanCreateOrConnectWithoutConsultantProfileInput({
    required this.where,
    required this.create,
  });

  final _i2.ConsultationPlanWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.ConsultationPlanCreateWithoutConsultantProfileInput,
    _i2.ConsultationPlanUncheckedCreateWithoutConsultantProfileInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class ConsultationPlanCreateManyConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanCreateManyConsultantProfileInput({
    this.id,
    required this.title,
    this.description,
    this.durationInHours,
    required this.price,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final String title;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final double? durationInHours;

  final int price;

  final String? language;

  final String? level;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? prerequisites;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? materialProvided;

  final _i1.PrismaUnion<
    _i2.ConsultationPlanCreatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInHours': durationInHours,
    'price': price,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultationPlanCreateManyConsultantProfileInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanCreateManyConsultantProfileInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<
    _i2.ConsultationPlanCreateManyConsultantProfileInput,
    Iterable<_i2.ConsultationPlanCreateManyConsultantProfileInput>
  >
  data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
    'data': data,
    'skipDuplicates': skipDuplicates,
  };
}

class ConsultationPlanUncheckedCreateNestedManyWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanUncheckedCreateNestedManyWithoutConsultantProfileInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.ConsultationPlanCreateWithoutConsultantProfileInput,
    _i1.PrismaUnion<
      Iterable<_i2.ConsultationPlanCreateWithoutConsultantProfileInput>,
      _i1.PrismaUnion<
        _i2.ConsultationPlanUncheckedCreateWithoutConsultantProfileInput,
        Iterable<
          _i2.ConsultationPlanUncheckedCreateWithoutConsultantProfileInput
        >
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.ConsultationPlanCreateOrConnectWithoutConsultantProfileInput,
    Iterable<_i2.ConsultationPlanCreateOrConnectWithoutConsultantProfileInput>
  >?
  connectOrCreate;

  final _i2.ConsultationPlanCreateManyConsultantProfileInputEnvelope?
  createMany;

  final _i1.PrismaUnion<
    _i2.ConsultationPlanWhereUniqueInput,
    Iterable<_i2.ConsultationPlanWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class AppointmentCreateWithoutSubscriptionInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentCreateWithoutSubscriptionInput({
    this.id,
    required this.appointmentType,
    this.createdAt,
    this.updatedAt,
    this.slotsOfAppointment,
    this.consultation,
    this.webinar,
    this.$class,
    this.payment,
  });

  final String? id;

  final _i3.AppointmentsType appointmentType;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.SlotOfAppointmentCreateNestedManyWithoutAppointmentInput?
  slotsOfAppointment;

  final _i2.ConsultationCreateNestedOneWithoutAppointmentInput? consultation;

  final _i2.WebinarCreateNestedOneWithoutAppointmentInput? webinar;

  final _i2.ClassCreateNestedOneWithoutAppointmentsInput? $class;

  final _i2.PaymentCreateNestedManyWithoutAppointmentInput? payment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'appointmentType': appointmentType,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'slotsOfAppointment': slotsOfAppointment,
    'consultation': consultation,
    'webinar': webinar,
    'class': $class,
    'payment': payment,
  };
}

class PaymentUncheckedCreateWithoutAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentUncheckedCreateWithoutAppointmentInput({
    this.id,
    required this.amount,
    required this.currency,
    this.description,
    this.receiptUrl,
    required this.paymentMethod,
    required this.paymentIntent,
    required this.paymentGateway,
    required this.paymentStatus,
    this.expiresAt,
    required this.userId,
    this.discountCodeId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final int amount;

  final String currency;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? receiptUrl;

  final String paymentMethod;

  final String paymentIntent;

  final _i3.PaymentGateway paymentGateway;

  final _i3.PaymentStatus paymentStatus;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? expiresAt;

  final String userId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? discountCodeId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'amount': amount,
    'currency': currency,
    'description': description,
    'receiptUrl': receiptUrl,
    'paymentMethod': paymentMethod,
    'paymentIntent': paymentIntent,
    'paymentGateway': paymentGateway,
    'paymentStatus': paymentStatus,
    'expiresAt': expiresAt,
    'userId': userId,
    'discountCodeId': discountCodeId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class PaymentCreateOrConnectWithoutAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentCreateOrConnectWithoutAppointmentInput({
    required this.where,
    required this.create,
  });

  final _i2.PaymentWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.PaymentCreateWithoutAppointmentInput,
    _i2.PaymentUncheckedCreateWithoutAppointmentInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class PaymentCreateManyAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentCreateManyAppointmentInput({
    this.id,
    required this.amount,
    required this.currency,
    this.description,
    this.receiptUrl,
    required this.paymentMethod,
    required this.paymentIntent,
    required this.paymentGateway,
    required this.paymentStatus,
    this.expiresAt,
    required this.userId,
    this.discountCodeId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final int amount;

  final String currency;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? receiptUrl;

  final String paymentMethod;

  final String paymentIntent;

  final _i3.PaymentGateway paymentGateway;

  final _i3.PaymentStatus paymentStatus;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? expiresAt;

  final String userId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? discountCodeId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'amount': amount,
    'currency': currency,
    'description': description,
    'receiptUrl': receiptUrl,
    'paymentMethod': paymentMethod,
    'paymentIntent': paymentIntent,
    'paymentGateway': paymentGateway,
    'paymentStatus': paymentStatus,
    'expiresAt': expiresAt,
    'userId': userId,
    'discountCodeId': discountCodeId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class PaymentCreateManyAppointmentInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentCreateManyAppointmentInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<
    _i2.PaymentCreateManyAppointmentInput,
    Iterable<_i2.PaymentCreateManyAppointmentInput>
  >
  data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
    'data': data,
    'skipDuplicates': skipDuplicates,
  };
}

class PaymentUncheckedCreateNestedManyWithoutAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentUncheckedCreateNestedManyWithoutAppointmentInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.PaymentCreateWithoutAppointmentInput,
    _i1.PrismaUnion<
      Iterable<_i2.PaymentCreateWithoutAppointmentInput>,
      _i1.PrismaUnion<
        _i2.PaymentUncheckedCreateWithoutAppointmentInput,
        Iterable<_i2.PaymentUncheckedCreateWithoutAppointmentInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.PaymentCreateOrConnectWithoutAppointmentInput,
    Iterable<_i2.PaymentCreateOrConnectWithoutAppointmentInput>
  >?
  connectOrCreate;

  final _i2.PaymentCreateManyAppointmentInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.PaymentWhereUniqueInput,
    Iterable<_i2.PaymentWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class AppointmentUncheckedCreateWithoutSubscriptionInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentUncheckedCreateWithoutSubscriptionInput({
    this.id,
    required this.appointmentType,
    this.consultationId,
    this.webinarId,
    this.classId,
    this.createdAt,
    this.updatedAt,
    this.slotsOfAppointment,
    this.payment,
  });

  final String? id;

  final _i3.AppointmentsType appointmentType;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consultationId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? webinarId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? classId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.SlotOfAppointmentUncheckedCreateNestedManyWithoutAppointmentInput?
  slotsOfAppointment;

  final _i2.PaymentUncheckedCreateNestedManyWithoutAppointmentInput? payment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'appointmentType': appointmentType,
    'consultationId': consultationId,
    'webinarId': webinarId,
    'classId': classId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'slotsOfAppointment': slotsOfAppointment,
    'payment': payment,
  };
}

class AppointmentCreateOrConnectWithoutSubscriptionInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentCreateOrConnectWithoutSubscriptionInput({
    required this.where,
    required this.create,
  });

  final _i2.AppointmentWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.AppointmentCreateWithoutSubscriptionInput,
    _i2.AppointmentUncheckedCreateWithoutSubscriptionInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class AppointmentCreateManySubscriptionInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentCreateManySubscriptionInput({
    this.id,
    required this.appointmentType,
    this.consultationId,
    this.webinarId,
    this.classId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final _i3.AppointmentsType appointmentType;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consultationId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? webinarId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? classId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'appointmentType': appointmentType,
    'consultationId': consultationId,
    'webinarId': webinarId,
    'classId': classId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class AppointmentCreateManySubscriptionInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentCreateManySubscriptionInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<
    _i2.AppointmentCreateManySubscriptionInput,
    Iterable<_i2.AppointmentCreateManySubscriptionInput>
  >
  data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
    'data': data,
    'skipDuplicates': skipDuplicates,
  };
}

class AppointmentUncheckedCreateNestedManyWithoutSubscriptionInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentUncheckedCreateNestedManyWithoutSubscriptionInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.AppointmentCreateWithoutSubscriptionInput,
    _i1.PrismaUnion<
      Iterable<_i2.AppointmentCreateWithoutSubscriptionInput>,
      _i1.PrismaUnion<
        _i2.AppointmentUncheckedCreateWithoutSubscriptionInput,
        Iterable<_i2.AppointmentUncheckedCreateWithoutSubscriptionInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.AppointmentCreateOrConnectWithoutSubscriptionInput,
    Iterable<_i2.AppointmentCreateOrConnectWithoutSubscriptionInput>
  >?
  connectOrCreate;

  final _i2.AppointmentCreateManySubscriptionInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.AppointmentWhereUniqueInput,
    Iterable<_i2.AppointmentWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class SubscriptionUncheckedCreateWithoutSubscriptionPlanInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionUncheckedCreateWithoutSubscriptionPlanInput({
    this.id,
    this.startDate,
    required this.endDate,
    this.requestStatus,
    required this.requestedById,
    this.requestedAt,
    this.requestNotes,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.createdAt,
    this.updatedAt,
    this.appointments,
  });

  final String? id;

  final DateTime? startDate;

  final DateTime endDate;

  final _i3.RequestStatus? requestStatus;

  final String requestedById;

  final DateTime? requestedAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? requestNotes;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackFromConsultee;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackFromConsultant;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? rating;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.AppointmentUncheckedCreateNestedManyWithoutSubscriptionInput?
  appointments;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'requestStatus': requestStatus,
    'requestedById': requestedById,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'appointments': appointments,
  };
}

class SubscriptionCreateOrConnectWithoutSubscriptionPlanInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionCreateOrConnectWithoutSubscriptionPlanInput({
    required this.where,
    required this.create,
  });

  final _i2.SubscriptionWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.SubscriptionCreateWithoutSubscriptionPlanInput,
    _i2.SubscriptionUncheckedCreateWithoutSubscriptionPlanInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class SubscriptionCreateManySubscriptionPlanInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionCreateManySubscriptionPlanInput({
    this.id,
    this.startDate,
    required this.endDate,
    this.requestStatus,
    required this.requestedById,
    this.requestedAt,
    this.requestNotes,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final DateTime? startDate;

  final DateTime endDate;

  final _i3.RequestStatus? requestStatus;

  final String requestedById;

  final DateTime? requestedAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? requestNotes;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackFromConsultee;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackFromConsultant;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? rating;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'requestStatus': requestStatus,
    'requestedById': requestedById,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SubscriptionCreateManySubscriptionPlanInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionCreateManySubscriptionPlanInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<
    _i2.SubscriptionCreateManySubscriptionPlanInput,
    Iterable<_i2.SubscriptionCreateManySubscriptionPlanInput>
  >
  data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
    'data': data,
    'skipDuplicates': skipDuplicates,
  };
}

class SubscriptionUncheckedCreateNestedManyWithoutSubscriptionPlanInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionUncheckedCreateNestedManyWithoutSubscriptionPlanInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.SubscriptionCreateWithoutSubscriptionPlanInput,
    _i1.PrismaUnion<
      Iterable<_i2.SubscriptionCreateWithoutSubscriptionPlanInput>,
      _i1.PrismaUnion<
        _i2.SubscriptionUncheckedCreateWithoutSubscriptionPlanInput,
        Iterable<_i2.SubscriptionUncheckedCreateWithoutSubscriptionPlanInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.SubscriptionCreateOrConnectWithoutSubscriptionPlanInput,
    Iterable<_i2.SubscriptionCreateOrConnectWithoutSubscriptionPlanInput>
  >?
  connectOrCreate;

  final _i2.SubscriptionCreateManySubscriptionPlanInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.SubscriptionWhereUniqueInput,
    Iterable<_i2.SubscriptionWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class SubscriptionPlanUncheckedCreateWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanUncheckedCreateWithoutConsultantProfileInput({
    this.id,
    required this.title,
    this.description,
    this.durationInMonths,
    required this.price,
    this.callsPerWeek,
    this.sessionDurationInHours,
    this.videoMeetings,
    this.emailSupport,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.createdAt,
    this.updatedAt,
    this.subscriptions,
  });

  final String? id;

  final String title;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final int? durationInMonths;

  final int price;

  final int? callsPerWeek;

  final double? sessionDurationInHours;

  final int? videoMeetings;

  final _i3.PlanEmailSupport? emailSupport;

  final String? language;

  final String? level;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? prerequisites;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? materialProvided;

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanCreatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.SubscriptionUncheckedCreateNestedManyWithoutSubscriptionPlanInput?
  subscriptions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInMonths': durationInMonths,
    'price': price,
    'callsPerWeek': callsPerWeek,
    'sessionDurationInHours': sessionDurationInHours,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'subscriptions': subscriptions,
  };
}

class SubscriptionPlanCreateOrConnectWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanCreateOrConnectWithoutConsultantProfileInput({
    required this.where,
    required this.create,
  });

  final _i2.SubscriptionPlanWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanCreateWithoutConsultantProfileInput,
    _i2.SubscriptionPlanUncheckedCreateWithoutConsultantProfileInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class SubscriptionPlanCreateManyConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanCreateManyConsultantProfileInput({
    this.id,
    required this.title,
    this.description,
    this.durationInMonths,
    required this.price,
    this.callsPerWeek,
    this.sessionDurationInHours,
    this.videoMeetings,
    this.emailSupport,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final String title;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final int? durationInMonths;

  final int price;

  final int? callsPerWeek;

  final double? sessionDurationInHours;

  final int? videoMeetings;

  final _i3.PlanEmailSupport? emailSupport;

  final String? language;

  final String? level;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? prerequisites;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? materialProvided;

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanCreatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInMonths': durationInMonths,
    'price': price,
    'callsPerWeek': callsPerWeek,
    'sessionDurationInHours': sessionDurationInHours,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SubscriptionPlanCreateManyConsultantProfileInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanCreateManyConsultantProfileInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanCreateManyConsultantProfileInput,
    Iterable<_i2.SubscriptionPlanCreateManyConsultantProfileInput>
  >
  data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
    'data': data,
    'skipDuplicates': skipDuplicates,
  };
}

class SubscriptionPlanUncheckedCreateNestedManyWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanUncheckedCreateNestedManyWithoutConsultantProfileInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanCreateWithoutConsultantProfileInput,
    _i1.PrismaUnion<
      Iterable<_i2.SubscriptionPlanCreateWithoutConsultantProfileInput>,
      _i1.PrismaUnion<
        _i2.SubscriptionPlanUncheckedCreateWithoutConsultantProfileInput,
        Iterable<
          _i2.SubscriptionPlanUncheckedCreateWithoutConsultantProfileInput
        >
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanCreateOrConnectWithoutConsultantProfileInput,
    Iterable<_i2.SubscriptionPlanCreateOrConnectWithoutConsultantProfileInput>
  >?
  connectOrCreate;

  final _i2.SubscriptionPlanCreateManyConsultantProfileInputEnvelope?
  createMany;

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanWhereUniqueInput,
    Iterable<_i2.SubscriptionPlanWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class ClassContentUncheckedCreateNestedManyWithoutClassPlanInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassContentUncheckedCreateNestedManyWithoutClassPlanInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.ClassContentCreateWithoutClassPlanInput,
    _i1.PrismaUnion<
      Iterable<_i2.ClassContentCreateWithoutClassPlanInput>,
      _i1.PrismaUnion<
        _i2.ClassContentUncheckedCreateWithoutClassPlanInput,
        Iterable<_i2.ClassContentUncheckedCreateWithoutClassPlanInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.ClassContentCreateOrConnectWithoutClassPlanInput,
    Iterable<_i2.ClassContentCreateOrConnectWithoutClassPlanInput>
  >?
  connectOrCreate;

  final _i2.ClassContentCreateManyClassPlanInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.ClassContentWhereUniqueInput,
    Iterable<_i2.ClassContentWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class AppointmentCreateWithoutClassInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentCreateWithoutClassInput({
    this.id,
    required this.appointmentType,
    this.createdAt,
    this.updatedAt,
    this.slotsOfAppointment,
    this.consultation,
    this.subscription,
    this.webinar,
    this.payment,
  });

  final String? id;

  final _i3.AppointmentsType appointmentType;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.SlotOfAppointmentCreateNestedManyWithoutAppointmentInput?
  slotsOfAppointment;

  final _i2.ConsultationCreateNestedOneWithoutAppointmentInput? consultation;

  final _i2.SubscriptionCreateNestedOneWithoutAppointmentsInput? subscription;

  final _i2.WebinarCreateNestedOneWithoutAppointmentInput? webinar;

  final _i2.PaymentCreateNestedManyWithoutAppointmentInput? payment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'appointmentType': appointmentType,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'slotsOfAppointment': slotsOfAppointment,
    'consultation': consultation,
    'subscription': subscription,
    'webinar': webinar,
    'payment': payment,
  };
}

class AppointmentUncheckedCreateWithoutClassInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentUncheckedCreateWithoutClassInput({
    this.id,
    required this.appointmentType,
    this.consultationId,
    this.subscriptionId,
    this.webinarId,
    this.createdAt,
    this.updatedAt,
    this.slotsOfAppointment,
    this.payment,
  });

  final String? id;

  final _i3.AppointmentsType appointmentType;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consultationId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? subscriptionId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? webinarId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.SlotOfAppointmentUncheckedCreateNestedManyWithoutAppointmentInput?
  slotsOfAppointment;

  final _i2.PaymentUncheckedCreateNestedManyWithoutAppointmentInput? payment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'appointmentType': appointmentType,
    'consultationId': consultationId,
    'subscriptionId': subscriptionId,
    'webinarId': webinarId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'slotsOfAppointment': slotsOfAppointment,
    'payment': payment,
  };
}

class AppointmentCreateOrConnectWithoutClassInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentCreateOrConnectWithoutClassInput({
    required this.where,
    required this.create,
  });

  final _i2.AppointmentWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.AppointmentCreateWithoutClassInput,
    _i2.AppointmentUncheckedCreateWithoutClassInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class AppointmentCreateManyClassInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentCreateManyClassInput({
    this.id,
    required this.appointmentType,
    this.consultationId,
    this.subscriptionId,
    this.webinarId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final _i3.AppointmentsType appointmentType;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consultationId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? subscriptionId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? webinarId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'appointmentType': appointmentType,
    'consultationId': consultationId,
    'subscriptionId': subscriptionId,
    'webinarId': webinarId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class AppointmentCreateManyClassInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentCreateManyClassInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<
    _i2.AppointmentCreateManyClassInput,
    Iterable<_i2.AppointmentCreateManyClassInput>
  >
  data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
    'data': data,
    'skipDuplicates': skipDuplicates,
  };
}

class AppointmentCreateNestedManyWithoutClassInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentCreateNestedManyWithoutClassInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.AppointmentCreateWithoutClassInput,
    _i1.PrismaUnion<
      Iterable<_i2.AppointmentCreateWithoutClassInput>,
      _i1.PrismaUnion<
        _i2.AppointmentUncheckedCreateWithoutClassInput,
        Iterable<_i2.AppointmentUncheckedCreateWithoutClassInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.AppointmentCreateOrConnectWithoutClassInput,
    Iterable<_i2.AppointmentCreateOrConnectWithoutClassInput>
  >?
  connectOrCreate;

  final _i2.AppointmentCreateManyClassInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.AppointmentWhereUniqueInput,
    Iterable<_i2.AppointmentWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class ClassCreateWithoutClassPlanInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassCreateWithoutClassPlanInput({
    this.id,
    this.startDate,
    this.endDate,
    this.status,
    this.recordingUrls,
    this.feedbackSummary,
    this.createdAt,
    this.updatedAt,
    this.waitlist,
    this.appointments,
  });

  final String? id;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? startDate;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? endDate;

  final _i3.ClassStatus? status;

  final _i1.PrismaUnion<_i2.ClassCreaterecordingUrlsInput, Iterable<String>>?
  recordingUrls;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackSummary;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.WaitlistCreateNestedManyWithoutClassInput? waitlist;

  final _i2.AppointmentCreateNestedManyWithoutClassInput? appointments;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'status': status,
    'recordingUrls': recordingUrls,
    'feedbackSummary': feedbackSummary,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'waitlist': waitlist,
    'appointments': appointments,
  };
}

class WaitlistUncheckedCreateWithoutClassInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistUncheckedCreateWithoutClassInput({
    this.id,
    this.joinedAt,
    required this.userId,
    this.webinarId,
  });

  final String? id;

  final DateTime? joinedAt;

  final String userId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? webinarId;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'joinedAt': joinedAt,
    'userId': userId,
    'webinarId': webinarId,
  };
}

class WaitlistCreateOrConnectWithoutClassInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistCreateOrConnectWithoutClassInput({
    required this.where,
    required this.create,
  });

  final _i2.WaitlistWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.WaitlistCreateWithoutClassInput,
    _i2.WaitlistUncheckedCreateWithoutClassInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class WaitlistCreateManyClassInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistCreateManyClassInput({
    this.id,
    this.joinedAt,
    required this.userId,
    this.webinarId,
  });

  final String? id;

  final DateTime? joinedAt;

  final String userId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? webinarId;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'joinedAt': joinedAt,
    'userId': userId,
    'webinarId': webinarId,
  };
}

class WaitlistCreateManyClassInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistCreateManyClassInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<
    _i2.WaitlistCreateManyClassInput,
    Iterable<_i2.WaitlistCreateManyClassInput>
  >
  data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
    'data': data,
    'skipDuplicates': skipDuplicates,
  };
}

class WaitlistUncheckedCreateNestedManyWithoutClassInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistUncheckedCreateNestedManyWithoutClassInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.WaitlistCreateWithoutClassInput,
    _i1.PrismaUnion<
      Iterable<_i2.WaitlistCreateWithoutClassInput>,
      _i1.PrismaUnion<
        _i2.WaitlistUncheckedCreateWithoutClassInput,
        Iterable<_i2.WaitlistUncheckedCreateWithoutClassInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.WaitlistCreateOrConnectWithoutClassInput,
    Iterable<_i2.WaitlistCreateOrConnectWithoutClassInput>
  >?
  connectOrCreate;

  final _i2.WaitlistCreateManyClassInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.WaitlistWhereUniqueInput,
    Iterable<_i2.WaitlistWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class AppointmentUncheckedCreateNestedManyWithoutClassInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentUncheckedCreateNestedManyWithoutClassInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.AppointmentCreateWithoutClassInput,
    _i1.PrismaUnion<
      Iterable<_i2.AppointmentCreateWithoutClassInput>,
      _i1.PrismaUnion<
        _i2.AppointmentUncheckedCreateWithoutClassInput,
        Iterable<_i2.AppointmentUncheckedCreateWithoutClassInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.AppointmentCreateOrConnectWithoutClassInput,
    Iterable<_i2.AppointmentCreateOrConnectWithoutClassInput>
  >?
  connectOrCreate;

  final _i2.AppointmentCreateManyClassInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.AppointmentWhereUniqueInput,
    Iterable<_i2.AppointmentWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class ClassUncheckedCreateWithoutClassPlanInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassUncheckedCreateWithoutClassPlanInput({
    this.id,
    this.startDate,
    this.endDate,
    this.status,
    this.recordingUrls,
    this.feedbackSummary,
    this.createdAt,
    this.updatedAt,
    this.waitlist,
    this.appointments,
  });

  final String? id;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? startDate;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? endDate;

  final _i3.ClassStatus? status;

  final _i1.PrismaUnion<_i2.ClassCreaterecordingUrlsInput, Iterable<String>>?
  recordingUrls;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackSummary;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.WaitlistUncheckedCreateNestedManyWithoutClassInput? waitlist;

  final _i2.AppointmentUncheckedCreateNestedManyWithoutClassInput? appointments;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'status': status,
    'recordingUrls': recordingUrls,
    'feedbackSummary': feedbackSummary,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'waitlist': waitlist,
    'appointments': appointments,
  };
}

class ClassCreateOrConnectWithoutClassPlanInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassCreateOrConnectWithoutClassPlanInput({
    required this.where,
    required this.create,
  });

  final _i2.ClassWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.ClassCreateWithoutClassPlanInput,
    _i2.ClassUncheckedCreateWithoutClassPlanInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class ClassCreateManyClassPlanInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassCreateManyClassPlanInput({
    this.id,
    this.startDate,
    this.endDate,
    this.status,
    this.recordingUrls,
    this.feedbackSummary,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? startDate;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? endDate;

  final _i3.ClassStatus? status;

  final _i1.PrismaUnion<_i2.ClassCreaterecordingUrlsInput, Iterable<String>>?
  recordingUrls;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackSummary;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'status': status,
    'recordingUrls': recordingUrls,
    'feedbackSummary': feedbackSummary,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ClassCreateManyClassPlanInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassCreateManyClassPlanInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<
    _i2.ClassCreateManyClassPlanInput,
    Iterable<_i2.ClassCreateManyClassPlanInput>
  >
  data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
    'data': data,
    'skipDuplicates': skipDuplicates,
  };
}

class ClassUncheckedCreateNestedManyWithoutClassPlanInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassUncheckedCreateNestedManyWithoutClassPlanInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.ClassCreateWithoutClassPlanInput,
    _i1.PrismaUnion<
      Iterable<_i2.ClassCreateWithoutClassPlanInput>,
      _i1.PrismaUnion<
        _i2.ClassUncheckedCreateWithoutClassPlanInput,
        Iterable<_i2.ClassUncheckedCreateWithoutClassPlanInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.ClassCreateOrConnectWithoutClassPlanInput,
    Iterable<_i2.ClassCreateOrConnectWithoutClassPlanInput>
  >?
  connectOrCreate;

  final _i2.ClassCreateManyClassPlanInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.ClassWhereUniqueInput,
    Iterable<_i2.ClassWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class ClassPlanUncheckedCreateWithoutTopicsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanUncheckedCreateWithoutTopicsInput({
    this.id,
    required this.title,
    required this.description,
    required this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInMonths,
    this.callsPerWeek,
    this.videoMeetings,
    this.emailSupport,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.classContents,
    this.classes,
  });

  final String? id;

  final String title;

  final String description;

  final int price;

  final String? priceCurrency;

  final bool? certificateProvided;

  final int? durationInMonths;

  final int? callsPerWeek;

  final int? videoMeetings;

  final _i3.PlanEmailSupport? emailSupport;

  final int? maxParticipants;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? language;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? level;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? prerequisites;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? materialProvided;

  final _i1.PrismaUnion<
    _i2.ClassPlanCreatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consultantProfileId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ClassContentUncheckedCreateNestedManyWithoutClassPlanInput?
  classContents;

  final _i2.ClassUncheckedCreateNestedManyWithoutClassPlanInput? classes;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInMonths': durationInMonths,
    'callsPerWeek': callsPerWeek,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'classContents': classContents,
    'classes': classes,
  };
}

class ClassPlanCreateOrConnectWithoutTopicsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanCreateOrConnectWithoutTopicsInput({
    required this.where,
    required this.create,
  });

  final _i2.ClassPlanWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.ClassPlanCreateWithoutTopicsInput,
    _i2.ClassPlanUncheckedCreateWithoutTopicsInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class ClassPlanUncheckedCreateNestedManyWithoutTopicsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanUncheckedCreateNestedManyWithoutTopicsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.ClassPlanCreateWithoutTopicsInput,
    _i1.PrismaUnion<
      Iterable<_i2.ClassPlanCreateWithoutTopicsInput>,
      _i1.PrismaUnion<
        _i2.ClassPlanUncheckedCreateWithoutTopicsInput,
        Iterable<_i2.ClassPlanUncheckedCreateWithoutTopicsInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.ClassPlanCreateOrConnectWithoutTopicsInput,
    Iterable<_i2.ClassPlanCreateOrConnectWithoutTopicsInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.ClassPlanWhereUniqueInput,
    Iterable<_i2.ClassPlanWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class TopicUncheckedCreateWithoutWebinarPlansInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TopicUncheckedCreateWithoutWebinarPlansInput({
    this.id,
    required this.name,
    this.createdAt,
    this.updatedAt,
    this.classPlans,
  });

  final String? id;

  final String name;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ClassPlanUncheckedCreateNestedManyWithoutTopicsInput? classPlans;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'classPlans': classPlans,
  };
}

class TopicCreateOrConnectWithoutWebinarPlansInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TopicCreateOrConnectWithoutWebinarPlansInput({
    required this.where,
    required this.create,
  });

  final _i2.TopicWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.TopicCreateWithoutWebinarPlansInput,
    _i2.TopicUncheckedCreateWithoutWebinarPlansInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class TopicUncheckedCreateNestedManyWithoutWebinarPlansInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TopicUncheckedCreateNestedManyWithoutWebinarPlansInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.TopicCreateWithoutWebinarPlansInput,
    _i1.PrismaUnion<
      Iterable<_i2.TopicCreateWithoutWebinarPlansInput>,
      _i1.PrismaUnion<
        _i2.TopicUncheckedCreateWithoutWebinarPlansInput,
        Iterable<_i2.TopicUncheckedCreateWithoutWebinarPlansInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.TopicCreateOrConnectWithoutWebinarPlansInput,
    Iterable<_i2.TopicCreateOrConnectWithoutWebinarPlansInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.TopicWhereUniqueInput,
    Iterable<_i2.TopicWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class WebinarPlanUncheckedCreateWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanUncheckedCreateWithoutConsultantProfileInput({
    this.id,
    required this.title,
    this.description,
    required this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInHours,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.createdAt,
    this.updatedAt,
    this.topics,
    this.webinars,
  });

  final String? id;

  final String title;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final int price;

  final String? priceCurrency;

  final bool? certificateProvided;

  final double? durationInHours;

  final int? maxParticipants;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? language;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? level;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? prerequisites;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? materialProvided;

  final _i1.PrismaUnion<
    _i2.WebinarPlanCreatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.TopicUncheckedCreateNestedManyWithoutWebinarPlansInput? topics;

  final _i2.WebinarUncheckedCreateNestedManyWithoutWebinarPlanInput? webinars;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInHours': durationInHours,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'topics': topics,
    'webinars': webinars,
  };
}

class WebinarPlanCreateOrConnectWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanCreateOrConnectWithoutConsultantProfileInput({
    required this.where,
    required this.create,
  });

  final _i2.WebinarPlanWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.WebinarPlanCreateWithoutConsultantProfileInput,
    _i2.WebinarPlanUncheckedCreateWithoutConsultantProfileInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class WebinarPlanCreateManyConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanCreateManyConsultantProfileInput({
    this.id,
    required this.title,
    this.description,
    required this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInHours,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final String title;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final int price;

  final String? priceCurrency;

  final bool? certificateProvided;

  final double? durationInHours;

  final int? maxParticipants;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? language;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? level;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? prerequisites;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? materialProvided;

  final _i1.PrismaUnion<
    _i2.WebinarPlanCreatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInHours': durationInHours,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class WebinarPlanCreateManyConsultantProfileInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanCreateManyConsultantProfileInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<
    _i2.WebinarPlanCreateManyConsultantProfileInput,
    Iterable<_i2.WebinarPlanCreateManyConsultantProfileInput>
  >
  data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
    'data': data,
    'skipDuplicates': skipDuplicates,
  };
}

class WebinarPlanUncheckedCreateNestedManyWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanUncheckedCreateNestedManyWithoutConsultantProfileInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.WebinarPlanCreateWithoutConsultantProfileInput,
    _i1.PrismaUnion<
      Iterable<_i2.WebinarPlanCreateWithoutConsultantProfileInput>,
      _i1.PrismaUnion<
        _i2.WebinarPlanUncheckedCreateWithoutConsultantProfileInput,
        Iterable<_i2.WebinarPlanUncheckedCreateWithoutConsultantProfileInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.WebinarPlanCreateOrConnectWithoutConsultantProfileInput,
    Iterable<_i2.WebinarPlanCreateOrConnectWithoutConsultantProfileInput>
  >?
  connectOrCreate;

  final _i2.WebinarPlanCreateManyConsultantProfileInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.WebinarPlanWhereUniqueInput,
    Iterable<_i2.WebinarPlanWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class ClassPlanUncheckedCreateWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanUncheckedCreateWithoutConsultantProfileInput({
    this.id,
    required this.title,
    required this.description,
    required this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInMonths,
    this.callsPerWeek,
    this.videoMeetings,
    this.emailSupport,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.createdAt,
    this.updatedAt,
    this.topics,
    this.classContents,
    this.classes,
  });

  final String? id;

  final String title;

  final String description;

  final int price;

  final String? priceCurrency;

  final bool? certificateProvided;

  final int? durationInMonths;

  final int? callsPerWeek;

  final int? videoMeetings;

  final _i3.PlanEmailSupport? emailSupport;

  final int? maxParticipants;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? language;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? level;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? prerequisites;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? materialProvided;

  final _i1.PrismaUnion<
    _i2.ClassPlanCreatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.TopicUncheckedCreateNestedManyWithoutClassPlansInput? topics;

  final _i2.ClassContentUncheckedCreateNestedManyWithoutClassPlanInput?
  classContents;

  final _i2.ClassUncheckedCreateNestedManyWithoutClassPlanInput? classes;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInMonths': durationInMonths,
    'callsPerWeek': callsPerWeek,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'topics': topics,
    'classContents': classContents,
    'classes': classes,
  };
}

class ClassPlanCreateOrConnectWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanCreateOrConnectWithoutConsultantProfileInput({
    required this.where,
    required this.create,
  });

  final _i2.ClassPlanWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.ClassPlanCreateWithoutConsultantProfileInput,
    _i2.ClassPlanUncheckedCreateWithoutConsultantProfileInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class ClassPlanCreateManyConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanCreateManyConsultantProfileInput({
    this.id,
    required this.title,
    required this.description,
    required this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInMonths,
    this.callsPerWeek,
    this.videoMeetings,
    this.emailSupport,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final String title;

  final String description;

  final int price;

  final String? priceCurrency;

  final bool? certificateProvided;

  final int? durationInMonths;

  final int? callsPerWeek;

  final int? videoMeetings;

  final _i3.PlanEmailSupport? emailSupport;

  final int? maxParticipants;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? language;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? level;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? prerequisites;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? materialProvided;

  final _i1.PrismaUnion<
    _i2.ClassPlanCreatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInMonths': durationInMonths,
    'callsPerWeek': callsPerWeek,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ClassPlanCreateManyConsultantProfileInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanCreateManyConsultantProfileInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<
    _i2.ClassPlanCreateManyConsultantProfileInput,
    Iterable<_i2.ClassPlanCreateManyConsultantProfileInput>
  >
  data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
    'data': data,
    'skipDuplicates': skipDuplicates,
  };
}

class ClassPlanUncheckedCreateNestedManyWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanUncheckedCreateNestedManyWithoutConsultantProfileInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.ClassPlanCreateWithoutConsultantProfileInput,
    _i1.PrismaUnion<
      Iterable<_i2.ClassPlanCreateWithoutConsultantProfileInput>,
      _i1.PrismaUnion<
        _i2.ClassPlanUncheckedCreateWithoutConsultantProfileInput,
        Iterable<_i2.ClassPlanUncheckedCreateWithoutConsultantProfileInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.ClassPlanCreateOrConnectWithoutConsultantProfileInput,
    Iterable<_i2.ClassPlanCreateOrConnectWithoutConsultantProfileInput>
  >?
  connectOrCreate;

  final _i2.ClassPlanCreateManyConsultantProfileInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.ClassPlanWhereUniqueInput,
    Iterable<_i2.ClassPlanWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class ConsultantProfileUncheckedCreateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUncheckedCreateWithoutUserInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    required this.domainId,
    required this.scheduleType,
    this.createdAt,
    this.updatedAt,
    this.subDomains,
    this.tags,
    this.reviews,
    this.slotsOfAvailabilityWeekly,
    this.slotsOfAvailabilityCustom,
    this.consultationPlans,
    this.subscriptionPlans,
    this.webinarPlans,
    this.classPlans,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? qualifications;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? specialization;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? experience;

  final double? rating;

  final String domainId;

  final _i3.ScheduleType scheduleType;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.SubDomainUncheckedCreateNestedManyWithoutConsultantProfilesInput?
  subDomains;

  final _i2.TagUncheckedCreateNestedManyWithoutConsultantProfilesInput? tags;

  final _i2.ConsultantReviewUncheckedCreateNestedManyWithoutConsultantProfileInput?
  reviews;

  final _i2.SlotOfAvailabilityWeeklyUncheckedCreateNestedManyWithoutConsultantProfileInput?
  slotsOfAvailabilityWeekly;

  final _i2.SlotOfAvailabilityCustomUncheckedCreateNestedManyWithoutConsultantProfileInput?
  slotsOfAvailabilityCustom;

  final _i2.ConsultationPlanUncheckedCreateNestedManyWithoutConsultantProfileInput?
  consultationPlans;

  final _i2.SubscriptionPlanUncheckedCreateNestedManyWithoutConsultantProfileInput?
  subscriptionPlans;

  final _i2.WebinarPlanUncheckedCreateNestedManyWithoutConsultantProfileInput?
  webinarPlans;

  final _i2.ClassPlanUncheckedCreateNestedManyWithoutConsultantProfileInput?
  classPlans;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'domainId': domainId,
    'scheduleType': scheduleType,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'subDomains': subDomains,
    'tags': tags,
    'reviews': reviews,
    'slotsOfAvailabilityWeekly': slotsOfAvailabilityWeekly,
    'slotsOfAvailabilityCustom': slotsOfAvailabilityCustom,
    'consultationPlans': consultationPlans,
    'subscriptionPlans': subscriptionPlans,
    'webinarPlans': webinarPlans,
    'classPlans': classPlans,
  };
}

class ConsultantProfileCreateOrConnectWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileCreateOrConnectWithoutUserInput({
    required this.where,
    required this.create,
  });

  final _i2.ConsultantProfileWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateWithoutUserInput,
    _i2.ConsultantProfileUncheckedCreateWithoutUserInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class ConsultantProfileUncheckedCreateNestedOneWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUncheckedCreateNestedOneWithoutUserInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateWithoutUserInput,
    _i2.ConsultantProfileUncheckedCreateWithoutUserInput
  >?
  create;

  final _i2.ConsultantProfileCreateOrConnectWithoutUserInput? connectOrCreate;

  final _i2.ConsultantProfileWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class ConsulteeProfileWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileWhereUniqueInput({this.id, this.userId});

  final String? id;

  final String? userId;

  @override
  Map<String, dynamic> toJson() => {'id': id, 'userId': userId};
}

class ConsulteeProfileCreateOrConnectWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileCreateOrConnectWithoutUserInput({
    required this.where,
    required this.create,
  });

  final _i2.ConsulteeProfileWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.ConsulteeProfileCreateWithoutUserInput,
    _i2.ConsulteeProfileUncheckedCreateWithoutUserInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class ConsulteeProfileUncheckedCreateNestedOneWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileUncheckedCreateNestedOneWithoutUserInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.ConsulteeProfileCreateWithoutUserInput,
    _i2.ConsulteeProfileUncheckedCreateWithoutUserInput
  >?
  create;

  final _i2.ConsulteeProfileCreateOrConnectWithoutUserInput? connectOrCreate;

  final _i2.ConsulteeProfileWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class StaffProfileUncheckedCreateNestedOneWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StaffProfileUncheckedCreateNestedOneWithoutUserInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.StaffProfileCreateWithoutUserInput,
    _i2.StaffProfileUncheckedCreateWithoutUserInput
  >?
  create;

  final _i2.StaffProfileCreateOrConnectWithoutUserInput? connectOrCreate;

  final _i2.StaffProfileWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class WaitlistUncheckedCreateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistUncheckedCreateWithoutUserInput({
    this.id,
    this.joinedAt,
    this.webinarId,
    this.classId,
  });

  final String? id;

  final DateTime? joinedAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? webinarId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? classId;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'joinedAt': joinedAt,
    'webinarId': webinarId,
    'classId': classId,
  };
}

class WaitlistCreateOrConnectWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistCreateOrConnectWithoutUserInput({
    required this.where,
    required this.create,
  });

  final _i2.WaitlistWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.WaitlistCreateWithoutUserInput,
    _i2.WaitlistUncheckedCreateWithoutUserInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class WaitlistCreateManyUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistCreateManyUserInput({
    this.id,
    this.joinedAt,
    this.webinarId,
    this.classId,
  });

  final String? id;

  final DateTime? joinedAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? webinarId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? classId;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'joinedAt': joinedAt,
    'webinarId': webinarId,
    'classId': classId,
  };
}

class WaitlistCreateManyUserInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistCreateManyUserInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<
    _i2.WaitlistCreateManyUserInput,
    Iterable<_i2.WaitlistCreateManyUserInput>
  >
  data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
    'data': data,
    'skipDuplicates': skipDuplicates,
  };
}

class WaitlistUncheckedCreateNestedManyWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistUncheckedCreateNestedManyWithoutUserInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.WaitlistCreateWithoutUserInput,
    _i1.PrismaUnion<
      Iterable<_i2.WaitlistCreateWithoutUserInput>,
      _i1.PrismaUnion<
        _i2.WaitlistUncheckedCreateWithoutUserInput,
        Iterable<_i2.WaitlistUncheckedCreateWithoutUserInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.WaitlistCreateOrConnectWithoutUserInput,
    Iterable<_i2.WaitlistCreateOrConnectWithoutUserInput>
  >?
  connectOrCreate;

  final _i2.WaitlistCreateManyUserInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.WaitlistWhereUniqueInput,
    Iterable<_i2.WaitlistWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class FeedbackCreateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FeedbackCreateWithoutUserInput({
    this.id,
    required this.title,
    required this.description,
    this.rating,
    this.category,
    this.status,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final String title;

  final String description;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? rating;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? category;

  final _i3.FeedbackStatus? status;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'rating': rating,
    'category': category,
    'status': status,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class FeedbackUncheckedCreateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FeedbackUncheckedCreateWithoutUserInput({
    this.id,
    required this.title,
    required this.description,
    this.rating,
    this.category,
    this.status,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final String title;

  final String description;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? rating;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? category;

  final _i3.FeedbackStatus? status;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'rating': rating,
    'category': category,
    'status': status,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class FeedbackCreateOrConnectWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FeedbackCreateOrConnectWithoutUserInput({
    required this.where,
    required this.create,
  });

  final _i2.FeedbackWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.FeedbackCreateWithoutUserInput,
    _i2.FeedbackUncheckedCreateWithoutUserInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class FeedbackCreateManyUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FeedbackCreateManyUserInput({
    this.id,
    required this.title,
    required this.description,
    this.rating,
    this.category,
    this.status,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final String title;

  final String description;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? rating;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? category;

  final _i3.FeedbackStatus? status;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'rating': rating,
    'category': category,
    'status': status,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class FeedbackCreateManyUserInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FeedbackCreateManyUserInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<
    _i2.FeedbackCreateManyUserInput,
    Iterable<_i2.FeedbackCreateManyUserInput>
  >
  data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
    'data': data,
    'skipDuplicates': skipDuplicates,
  };
}

class FeedbackUncheckedCreateNestedManyWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FeedbackUncheckedCreateNestedManyWithoutUserInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.FeedbackCreateWithoutUserInput,
    _i1.PrismaUnion<
      Iterable<_i2.FeedbackCreateWithoutUserInput>,
      _i1.PrismaUnion<
        _i2.FeedbackUncheckedCreateWithoutUserInput,
        Iterable<_i2.FeedbackUncheckedCreateWithoutUserInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.FeedbackCreateOrConnectWithoutUserInput,
    Iterable<_i2.FeedbackCreateOrConnectWithoutUserInput>
  >?
  connectOrCreate;

  final _i2.FeedbackCreateManyUserInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.FeedbackWhereUniqueInput,
    Iterable<_i2.FeedbackWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class FeedbackCreateNestedManyWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FeedbackCreateNestedManyWithoutUserInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.FeedbackCreateWithoutUserInput,
    _i1.PrismaUnion<
      Iterable<_i2.FeedbackCreateWithoutUserInput>,
      _i1.PrismaUnion<
        _i2.FeedbackUncheckedCreateWithoutUserInput,
        Iterable<_i2.FeedbackUncheckedCreateWithoutUserInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.FeedbackCreateOrConnectWithoutUserInput,
    Iterable<_i2.FeedbackCreateOrConnectWithoutUserInput>
  >?
  connectOrCreate;

  final _i2.FeedbackCreateManyUserInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.FeedbackWhereUniqueInput,
    Iterable<_i2.FeedbackWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class SupportResponseUncheckedCreateWithoutSupportTicketInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseUncheckedCreateWithoutSupportTicketInput({
    this.id,
    required this.message,
    required this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final String message;

  final String userId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'message': message,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SupportResponseCreateOrConnectWithoutSupportTicketInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseCreateOrConnectWithoutSupportTicketInput({
    required this.where,
    required this.create,
  });

  final _i2.SupportResponseWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.SupportResponseCreateWithoutSupportTicketInput,
    _i2.SupportResponseUncheckedCreateWithoutSupportTicketInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class SupportResponseCreateManySupportTicketInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseCreateManySupportTicketInput({
    this.id,
    required this.message,
    required this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final String message;

  final String userId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'message': message,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SupportResponseCreateManySupportTicketInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseCreateManySupportTicketInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<
    _i2.SupportResponseCreateManySupportTicketInput,
    Iterable<_i2.SupportResponseCreateManySupportTicketInput>
  >
  data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
    'data': data,
    'skipDuplicates': skipDuplicates,
  };
}

class SupportResponseUncheckedCreateNestedManyWithoutSupportTicketInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseUncheckedCreateNestedManyWithoutSupportTicketInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.SupportResponseCreateWithoutSupportTicketInput,
    _i1.PrismaUnion<
      Iterable<_i2.SupportResponseCreateWithoutSupportTicketInput>,
      _i1.PrismaUnion<
        _i2.SupportResponseUncheckedCreateWithoutSupportTicketInput,
        Iterable<_i2.SupportResponseUncheckedCreateWithoutSupportTicketInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.SupportResponseCreateOrConnectWithoutSupportTicketInput,
    Iterable<_i2.SupportResponseCreateOrConnectWithoutSupportTicketInput>
  >?
  connectOrCreate;

  final _i2.SupportResponseCreateManySupportTicketInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.SupportResponseWhereUniqueInput,
    Iterable<_i2.SupportResponseWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class SupportTicketUncheckedCreateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportTicketUncheckedCreateWithoutUserInput({
    this.id,
    required this.title,
    required this.description,
    this.priority,
    this.status,
    this.category,
    this.createdAt,
    this.updatedAt,
    this.responses,
  });

  final String? id;

  final String title;

  final String description;

  final _i3.SupportPriority? priority;

  final _i3.SupportTicketStatus? status;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? category;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.SupportResponseUncheckedCreateNestedManyWithoutSupportTicketInput?
  responses;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'priority': priority,
    'status': status,
    'category': category,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'responses': responses,
  };
}

class SupportTicketCreateOrConnectWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportTicketCreateOrConnectWithoutUserInput({
    required this.where,
    required this.create,
  });

  final _i2.SupportTicketWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.SupportTicketCreateWithoutUserInput,
    _i2.SupportTicketUncheckedCreateWithoutUserInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class SupportTicketCreateManyUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportTicketCreateManyUserInput({
    this.id,
    required this.title,
    required this.description,
    this.priority,
    this.status,
    this.category,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final String title;

  final String description;

  final _i3.SupportPriority? priority;

  final _i3.SupportTicketStatus? status;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? category;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'priority': priority,
    'status': status,
    'category': category,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SupportTicketCreateManyUserInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportTicketCreateManyUserInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<
    _i2.SupportTicketCreateManyUserInput,
    Iterable<_i2.SupportTicketCreateManyUserInput>
  >
  data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
    'data': data,
    'skipDuplicates': skipDuplicates,
  };
}

class SupportTicketCreateNestedManyWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportTicketCreateNestedManyWithoutUserInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.SupportTicketCreateWithoutUserInput,
    _i1.PrismaUnion<
      Iterable<_i2.SupportTicketCreateWithoutUserInput>,
      _i1.PrismaUnion<
        _i2.SupportTicketUncheckedCreateWithoutUserInput,
        Iterable<_i2.SupportTicketUncheckedCreateWithoutUserInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.SupportTicketCreateOrConnectWithoutUserInput,
    Iterable<_i2.SupportTicketCreateOrConnectWithoutUserInput>
  >?
  connectOrCreate;

  final _i2.SupportTicketCreateManyUserInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.SupportTicketWhereUniqueInput,
    Iterable<_i2.SupportTicketWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class AccountCreateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AccountCreateWithoutUserInput({
    this.id,
    required this.type,
    required this.provider,
    required this.providerAccountId,
    this.refreshToken,
    this.accessToken,
    this.expiresAt,
    this.tokenType,
    this.scope,
    this.idToken,
    this.sessionState,
  });

  final String? id;

  final String type;

  final String provider;

  final String providerAccountId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? refreshToken;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? accessToken;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? expiresAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? tokenType;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? scope;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? idToken;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? sessionState;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'type': type,
    'provider': provider,
    'providerAccountId': providerAccountId,
    'refresh_token': refreshToken,
    'access_token': accessToken,
    'expires_at': expiresAt,
    'token_type': tokenType,
    'scope': scope,
    'id_token': idToken,
    'session_state': sessionState,
  };
}

class AccountUncheckedCreateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AccountUncheckedCreateWithoutUserInput({
    this.id,
    required this.type,
    required this.provider,
    required this.providerAccountId,
    this.refreshToken,
    this.accessToken,
    this.expiresAt,
    this.tokenType,
    this.scope,
    this.idToken,
    this.sessionState,
  });

  final String? id;

  final String type;

  final String provider;

  final String providerAccountId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? refreshToken;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? accessToken;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? expiresAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? tokenType;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? scope;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? idToken;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? sessionState;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'type': type,
    'provider': provider,
    'providerAccountId': providerAccountId,
    'refresh_token': refreshToken,
    'access_token': accessToken,
    'expires_at': expiresAt,
    'token_type': tokenType,
    'scope': scope,
    'id_token': idToken,
    'session_state': sessionState,
  };
}

class AccountCreateOrConnectWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AccountCreateOrConnectWithoutUserInput({
    required this.where,
    required this.create,
  });

  final _i2.AccountWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.AccountCreateWithoutUserInput,
    _i2.AccountUncheckedCreateWithoutUserInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class AccountCreateManyUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AccountCreateManyUserInput({
    this.id,
    required this.type,
    required this.provider,
    required this.providerAccountId,
    this.refreshToken,
    this.accessToken,
    this.expiresAt,
    this.tokenType,
    this.scope,
    this.idToken,
    this.sessionState,
  });

  final String? id;

  final String type;

  final String provider;

  final String providerAccountId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? refreshToken;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? accessToken;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? expiresAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? tokenType;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? scope;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? idToken;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? sessionState;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'type': type,
    'provider': provider,
    'providerAccountId': providerAccountId,
    'refresh_token': refreshToken,
    'access_token': accessToken,
    'expires_at': expiresAt,
    'token_type': tokenType,
    'scope': scope,
    'id_token': idToken,
    'session_state': sessionState,
  };
}

class AccountCreateManyUserInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AccountCreateManyUserInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<
    _i2.AccountCreateManyUserInput,
    Iterable<_i2.AccountCreateManyUserInput>
  >
  data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
    'data': data,
    'skipDuplicates': skipDuplicates,
  };
}

class AccountCreateNestedManyWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AccountCreateNestedManyWithoutUserInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.AccountCreateWithoutUserInput,
    _i1.PrismaUnion<
      Iterable<_i2.AccountCreateWithoutUserInput>,
      _i1.PrismaUnion<
        _i2.AccountUncheckedCreateWithoutUserInput,
        Iterable<_i2.AccountUncheckedCreateWithoutUserInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.AccountCreateOrConnectWithoutUserInput,
    Iterable<_i2.AccountCreateOrConnectWithoutUserInput>
  >?
  connectOrCreate;

  final _i2.AccountCreateManyUserInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.AccountWhereUniqueInput,
    Iterable<_i2.AccountWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class SessionCreateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SessionCreateWithoutUserInput({
    this.id,
    required this.sessionToken,
    required this.expires,
  });

  final String? id;

  final String sessionToken;

  final DateTime expires;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'sessionToken': sessionToken,
    'expires': expires,
  };
}

class SessionUncheckedCreateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SessionUncheckedCreateWithoutUserInput({
    this.id,
    required this.sessionToken,
    required this.expires,
  });

  final String? id;

  final String sessionToken;

  final DateTime expires;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'sessionToken': sessionToken,
    'expires': expires,
  };
}

class SessionCreateOrConnectWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SessionCreateOrConnectWithoutUserInput({
    required this.where,
    required this.create,
  });

  final _i2.SessionWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.SessionCreateWithoutUserInput,
    _i2.SessionUncheckedCreateWithoutUserInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class SessionCreateManyUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SessionCreateManyUserInput({
    this.id,
    required this.sessionToken,
    required this.expires,
  });

  final String? id;

  final String sessionToken;

  final DateTime expires;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'sessionToken': sessionToken,
    'expires': expires,
  };
}

class SessionCreateManyUserInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SessionCreateManyUserInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<
    _i2.SessionCreateManyUserInput,
    Iterable<_i2.SessionCreateManyUserInput>
  >
  data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
    'data': data,
    'skipDuplicates': skipDuplicates,
  };
}

class SessionCreateNestedManyWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SessionCreateNestedManyWithoutUserInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.SessionCreateWithoutUserInput,
    _i1.PrismaUnion<
      Iterable<_i2.SessionCreateWithoutUserInput>,
      _i1.PrismaUnion<
        _i2.SessionUncheckedCreateWithoutUserInput,
        Iterable<_i2.SessionUncheckedCreateWithoutUserInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.SessionCreateOrConnectWithoutUserInput,
    Iterable<_i2.SessionCreateOrConnectWithoutUserInput>
  >?
  connectOrCreate;

  final _i2.SessionCreateManyUserInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.SessionWhereUniqueInput,
    Iterable<_i2.SessionWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class UserCreateWithoutSupportResponsesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateWithoutSupportResponsesInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.cookiePreferences,
    this.notificationPreferences,
    this.payment,
    this.consultantProfile,
    this.consulteeProfile,
    this.staffProfile,
    this.slotsOfAppointment,
    this.waitlist,
    this.feedbacks,
    this.supportTickets,
    this.accounts,
    this.sessions,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? email;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? emailVerified;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? image;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? address;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? password;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? passwordResetToken;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? passwordResetExpires;

  final bool? onlineStatus;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? currentTimezone;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? onboardingCompleted;

  final _i1.PrismaUnion<_i3.UserRole, _i1.PrismaNull>? role;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consultantProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consulteeProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? staffProfileId;

  final _i2.CookiePreferenceCreateNestedOneWithoutUserInput? cookiePreferences;

  final _i2.NotificationPreferenceCreateNestedOneWithoutUserInput?
  notificationPreferences;

  final _i2.PaymentCreateNestedManyWithoutUserInput? payment;

  final _i2.ConsultantProfileCreateNestedOneWithoutUserInput? consultantProfile;

  final _i2.ConsulteeProfileCreateNestedOneWithoutUserInput? consulteeProfile;

  final _i2.StaffProfileCreateNestedOneWithoutUserInput? staffProfile;

  final _i2.SlotOfAppointmentCreateNestedManyWithoutUserInput?
  slotsOfAppointment;

  final _i2.WaitlistCreateNestedManyWithoutUserInput? waitlist;

  final _i2.FeedbackCreateNestedManyWithoutUserInput? feedbacks;

  final _i2.SupportTicketCreateNestedManyWithoutUserInput? supportTickets;

  final _i2.AccountCreateNestedManyWithoutUserInput? accounts;

  final _i2.SessionCreateNestedManyWithoutUserInput? sessions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'cookiePreferences': cookiePreferences,
    'notificationPreferences': notificationPreferences,
    'Payment': payment,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
    'staffProfile': staffProfile,
    'slotsOfAppointment': slotsOfAppointment,
    'Waitlist': waitlist,
    'feedbacks': feedbacks,
    'supportTickets': supportTickets,
    'accounts': accounts,
    'sessions': sessions,
  };
}

class MeetingSessionCreatehostKeysInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const MeetingSessionCreatehostKeysInput({required this.set});

  final Iterable<String> set;

  @override
  Map<String, dynamic> toJson() => {'set': set};
}

class RecordingCreateWithoutMeetingSessionInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const RecordingCreateWithoutMeetingSessionInput({
    this.id,
    required this.title,
    required this.recordingUrl,
    required this.durationInMinutes,
    required this.recordedAt,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final String title;

  final String recordingUrl;

  final int durationInMinutes;

  final DateTime recordedAt;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'recordingUrl': recordingUrl,
    'durationInMinutes': durationInMinutes,
    'recordedAt': recordedAt,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class RecordingUncheckedCreateWithoutMeetingSessionInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const RecordingUncheckedCreateWithoutMeetingSessionInput({
    this.id,
    required this.title,
    required this.recordingUrl,
    required this.durationInMinutes,
    required this.recordedAt,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final String title;

  final String recordingUrl;

  final int durationInMinutes;

  final DateTime recordedAt;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'recordingUrl': recordingUrl,
    'durationInMinutes': durationInMinutes,
    'recordedAt': recordedAt,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class RecordingCreateOrConnectWithoutMeetingSessionInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const RecordingCreateOrConnectWithoutMeetingSessionInput({
    required this.where,
    required this.create,
  });

  final _i2.RecordingWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.RecordingCreateWithoutMeetingSessionInput,
    _i2.RecordingUncheckedCreateWithoutMeetingSessionInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class RecordingCreateManyMeetingSessionInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const RecordingCreateManyMeetingSessionInput({
    this.id,
    required this.title,
    required this.recordingUrl,
    required this.durationInMinutes,
    required this.recordedAt,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final String title;

  final String recordingUrl;

  final int durationInMinutes;

  final DateTime recordedAt;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'recordingUrl': recordingUrl,
    'durationInMinutes': durationInMinutes,
    'recordedAt': recordedAt,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class RecordingCreateManyMeetingSessionInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const RecordingCreateManyMeetingSessionInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<
    _i2.RecordingCreateManyMeetingSessionInput,
    Iterable<_i2.RecordingCreateManyMeetingSessionInput>
  >
  data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
    'data': data,
    'skipDuplicates': skipDuplicates,
  };
}

class RecordingCreateNestedManyWithoutMeetingSessionInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const RecordingCreateNestedManyWithoutMeetingSessionInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.RecordingCreateWithoutMeetingSessionInput,
    _i1.PrismaUnion<
      Iterable<_i2.RecordingCreateWithoutMeetingSessionInput>,
      _i1.PrismaUnion<
        _i2.RecordingUncheckedCreateWithoutMeetingSessionInput,
        Iterable<_i2.RecordingUncheckedCreateWithoutMeetingSessionInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.RecordingCreateOrConnectWithoutMeetingSessionInput,
    Iterable<_i2.RecordingCreateOrConnectWithoutMeetingSessionInput>
  >?
  connectOrCreate;

  final _i2.RecordingCreateManyMeetingSessionInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.RecordingWhereUniqueInput,
    Iterable<_i2.RecordingWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class MeetingSessionCreateWithoutSlotOfAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const MeetingSessionCreateWithoutSlotOfAppointmentInput({
    this.id,
    required this.streamCallId,
    this.platform,
    this.passcode,
    this.hostKeys,
    this.createdAt,
    this.updatedAt,
    this.recordings,
  });

  final String? id;

  final String streamCallId;

  final _i3.Platform? platform;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? passcode;

  final _i1.PrismaUnion<
    _i2.MeetingSessionCreatehostKeysInput,
    Iterable<String>
  >?
  hostKeys;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.RecordingCreateNestedManyWithoutMeetingSessionInput? recordings;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'streamCallId': streamCallId,
    'platform': platform,
    'passcode': passcode,
    'hostKeys': hostKeys,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'recordings': recordings,
  };
}

class RecordingUncheckedCreateNestedManyWithoutMeetingSessionInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const RecordingUncheckedCreateNestedManyWithoutMeetingSessionInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.RecordingCreateWithoutMeetingSessionInput,
    _i1.PrismaUnion<
      Iterable<_i2.RecordingCreateWithoutMeetingSessionInput>,
      _i1.PrismaUnion<
        _i2.RecordingUncheckedCreateWithoutMeetingSessionInput,
        Iterable<_i2.RecordingUncheckedCreateWithoutMeetingSessionInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.RecordingCreateOrConnectWithoutMeetingSessionInput,
    Iterable<_i2.RecordingCreateOrConnectWithoutMeetingSessionInput>
  >?
  connectOrCreate;

  final _i2.RecordingCreateManyMeetingSessionInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.RecordingWhereUniqueInput,
    Iterable<_i2.RecordingWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class MeetingSessionUncheckedCreateWithoutSlotOfAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const MeetingSessionUncheckedCreateWithoutSlotOfAppointmentInput({
    this.id,
    required this.streamCallId,
    this.platform,
    this.passcode,
    this.hostKeys,
    this.createdAt,
    this.updatedAt,
    this.recordings,
  });

  final String? id;

  final String streamCallId;

  final _i3.Platform? platform;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? passcode;

  final _i1.PrismaUnion<
    _i2.MeetingSessionCreatehostKeysInput,
    Iterable<String>
  >?
  hostKeys;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.RecordingUncheckedCreateNestedManyWithoutMeetingSessionInput?
  recordings;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'streamCallId': streamCallId,
    'platform': platform,
    'passcode': passcode,
    'hostKeys': hostKeys,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'recordings': recordings,
  };
}

class MeetingSessionWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const MeetingSessionWhereUniqueInput({
    this.id,
    this.streamCallId,
    this.slotOfAppointmentId,
  });

  final String? id;

  final String? streamCallId;

  final String? slotOfAppointmentId;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'streamCallId': streamCallId,
    'slotOfAppointmentId': slotOfAppointmentId,
  };
}

class MeetingSessionCreateOrConnectWithoutSlotOfAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const MeetingSessionCreateOrConnectWithoutSlotOfAppointmentInput({
    required this.where,
    required this.create,
  });

  final _i2.MeetingSessionWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.MeetingSessionCreateWithoutSlotOfAppointmentInput,
    _i2.MeetingSessionUncheckedCreateWithoutSlotOfAppointmentInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class MeetingSessionUncheckedCreateNestedOneWithoutSlotOfAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const MeetingSessionUncheckedCreateNestedOneWithoutSlotOfAppointmentInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.MeetingSessionCreateWithoutSlotOfAppointmentInput,
    _i2.MeetingSessionUncheckedCreateWithoutSlotOfAppointmentInput
  >?
  create;

  final _i2.MeetingSessionCreateOrConnectWithoutSlotOfAppointmentInput?
  connectOrCreate;

  final _i2.MeetingSessionWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class SlotOfAppointmentUncheckedCreateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentUncheckedCreateWithoutUserInput({
    this.id,
    required this.slotStartTimeInUTC,
    required this.slotEndTimeInUTC,
    this.isTentative,
    required this.appointmentId,
    this.createdAt,
    this.updatedAt,
    this.meetingSession,
  });

  final String? id;

  final DateTime slotStartTimeInUTC;

  final DateTime slotEndTimeInUTC;

  final bool? isTentative;

  final String appointmentId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.MeetingSessionUncheckedCreateNestedOneWithoutSlotOfAppointmentInput?
  meetingSession;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'isTentative': isTentative,
    'appointmentId': appointmentId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'meetingSession': meetingSession,
  };
}

class SlotOfAppointmentCreateOrConnectWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentCreateOrConnectWithoutUserInput({
    required this.where,
    required this.create,
  });

  final _i2.SlotOfAppointmentWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentCreateWithoutUserInput,
    _i2.SlotOfAppointmentUncheckedCreateWithoutUserInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class SlotOfAppointmentUncheckedCreateNestedManyWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentUncheckedCreateNestedManyWithoutUserInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentCreateWithoutUserInput,
    _i1.PrismaUnion<
      Iterable<_i2.SlotOfAppointmentCreateWithoutUserInput>,
      _i1.PrismaUnion<
        _i2.SlotOfAppointmentUncheckedCreateWithoutUserInput,
        Iterable<_i2.SlotOfAppointmentUncheckedCreateWithoutUserInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentCreateOrConnectWithoutUserInput,
    Iterable<_i2.SlotOfAppointmentCreateOrConnectWithoutUserInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentWhereUniqueInput,
    Iterable<_i2.SlotOfAppointmentWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class AccountUncheckedCreateNestedManyWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AccountUncheckedCreateNestedManyWithoutUserInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.AccountCreateWithoutUserInput,
    _i1.PrismaUnion<
      Iterable<_i2.AccountCreateWithoutUserInput>,
      _i1.PrismaUnion<
        _i2.AccountUncheckedCreateWithoutUserInput,
        Iterable<_i2.AccountUncheckedCreateWithoutUserInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.AccountCreateOrConnectWithoutUserInput,
    Iterable<_i2.AccountCreateOrConnectWithoutUserInput>
  >?
  connectOrCreate;

  final _i2.AccountCreateManyUserInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.AccountWhereUniqueInput,
    Iterable<_i2.AccountWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class SessionUncheckedCreateNestedManyWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SessionUncheckedCreateNestedManyWithoutUserInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.SessionCreateWithoutUserInput,
    _i1.PrismaUnion<
      Iterable<_i2.SessionCreateWithoutUserInput>,
      _i1.PrismaUnion<
        _i2.SessionUncheckedCreateWithoutUserInput,
        Iterable<_i2.SessionUncheckedCreateWithoutUserInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.SessionCreateOrConnectWithoutUserInput,
    Iterable<_i2.SessionCreateOrConnectWithoutUserInput>
  >?
  connectOrCreate;

  final _i2.SessionCreateManyUserInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.SessionWhereUniqueInput,
    Iterable<_i2.SessionWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class UserUncheckedCreateWithoutSupportResponsesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUncheckedCreateWithoutSupportResponsesInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.cookiePreferences,
    this.notificationPreferences,
    this.payment,
    this.consultantProfile,
    this.consulteeProfile,
    this.staffProfile,
    this.slotsOfAppointment,
    this.waitlist,
    this.feedbacks,
    this.supportTickets,
    this.accounts,
    this.sessions,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? email;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? emailVerified;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? image;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? address;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? password;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? passwordResetToken;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? passwordResetExpires;

  final bool? onlineStatus;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? currentTimezone;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? onboardingCompleted;

  final _i1.PrismaUnion<_i3.UserRole, _i1.PrismaNull>? role;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consultantProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consulteeProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? staffProfileId;

  final _i2.CookiePreferenceUncheckedCreateNestedOneWithoutUserInput?
  cookiePreferences;

  final _i2.NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput?
  notificationPreferences;

  final _i2.PaymentUncheckedCreateNestedManyWithoutUserInput? payment;

  final _i2.ConsultantProfileUncheckedCreateNestedOneWithoutUserInput?
  consultantProfile;

  final _i2.ConsulteeProfileUncheckedCreateNestedOneWithoutUserInput?
  consulteeProfile;

  final _i2.StaffProfileUncheckedCreateNestedOneWithoutUserInput? staffProfile;

  final _i2.SlotOfAppointmentUncheckedCreateNestedManyWithoutUserInput?
  slotsOfAppointment;

  final _i2.WaitlistUncheckedCreateNestedManyWithoutUserInput? waitlist;

  final _i2.FeedbackUncheckedCreateNestedManyWithoutUserInput? feedbacks;

  final _i2.SupportTicketUncheckedCreateNestedManyWithoutUserInput?
  supportTickets;

  final _i2.AccountUncheckedCreateNestedManyWithoutUserInput? accounts;

  final _i2.SessionUncheckedCreateNestedManyWithoutUserInput? sessions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'cookiePreferences': cookiePreferences,
    'notificationPreferences': notificationPreferences,
    'Payment': payment,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
    'staffProfile': staffProfile,
    'slotsOfAppointment': slotsOfAppointment,
    'Waitlist': waitlist,
    'feedbacks': feedbacks,
    'supportTickets': supportTickets,
    'accounts': accounts,
    'sessions': sessions,
  };
}

class UserCreateOrConnectWithoutSupportResponsesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateOrConnectWithoutSupportResponsesInput({
    required this.where,
    required this.create,
  });

  final _i2.UserWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.UserCreateWithoutSupportResponsesInput,
    _i2.UserUncheckedCreateWithoutSupportResponsesInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class UserCreateNestedOneWithoutSupportResponsesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateNestedOneWithoutSupportResponsesInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.UserCreateWithoutSupportResponsesInput,
    _i2.UserUncheckedCreateWithoutSupportResponsesInput
  >?
  create;

  final _i2.UserCreateOrConnectWithoutSupportResponsesInput? connectOrCreate;

  final _i2.UserWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class SupportResponseCreateWithoutSupportTicketInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseCreateWithoutSupportTicketInput({
    this.id,
    required this.message,
    this.createdAt,
    this.updatedAt,
    required this.user,
  });

  final String? id;

  final String message;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.UserCreateNestedOneWithoutSupportResponsesInput user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'message': message,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'user': user,
  };
}

class SupportResponseCreateNestedManyWithoutSupportTicketInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseCreateNestedManyWithoutSupportTicketInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.SupportResponseCreateWithoutSupportTicketInput,
    _i1.PrismaUnion<
      Iterable<_i2.SupportResponseCreateWithoutSupportTicketInput>,
      _i1.PrismaUnion<
        _i2.SupportResponseUncheckedCreateWithoutSupportTicketInput,
        Iterable<_i2.SupportResponseUncheckedCreateWithoutSupportTicketInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.SupportResponseCreateOrConnectWithoutSupportTicketInput,
    Iterable<_i2.SupportResponseCreateOrConnectWithoutSupportTicketInput>
  >?
  connectOrCreate;

  final _i2.SupportResponseCreateManySupportTicketInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.SupportResponseWhereUniqueInput,
    Iterable<_i2.SupportResponseWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class SupportTicketCreateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportTicketCreateWithoutUserInput({
    this.id,
    required this.title,
    required this.description,
    this.priority,
    this.status,
    this.category,
    this.createdAt,
    this.updatedAt,
    this.responses,
  });

  final String? id;

  final String title;

  final String description;

  final _i3.SupportPriority? priority;

  final _i3.SupportTicketStatus? status;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? category;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.SupportResponseCreateNestedManyWithoutSupportTicketInput? responses;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'priority': priority,
    'status': status,
    'category': category,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'responses': responses,
  };
}

class SupportTicketUncheckedCreateNestedManyWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportTicketUncheckedCreateNestedManyWithoutUserInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.SupportTicketCreateWithoutUserInput,
    _i1.PrismaUnion<
      Iterable<_i2.SupportTicketCreateWithoutUserInput>,
      _i1.PrismaUnion<
        _i2.SupportTicketUncheckedCreateWithoutUserInput,
        Iterable<_i2.SupportTicketUncheckedCreateWithoutUserInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.SupportTicketCreateOrConnectWithoutUserInput,
    Iterable<_i2.SupportTicketCreateOrConnectWithoutUserInput>
  >?
  connectOrCreate;

  final _i2.SupportTicketCreateManyUserInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.SupportTicketWhereUniqueInput,
    Iterable<_i2.SupportTicketWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class SupportResponseUncheckedCreateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseUncheckedCreateWithoutUserInput({
    this.id,
    required this.message,
    required this.supportTicketId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final String message;

  final String supportTicketId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'message': message,
    'supportTicketId': supportTicketId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SupportResponseCreateOrConnectWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseCreateOrConnectWithoutUserInput({
    required this.where,
    required this.create,
  });

  final _i2.SupportResponseWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.SupportResponseCreateWithoutUserInput,
    _i2.SupportResponseUncheckedCreateWithoutUserInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class SupportResponseCreateManyUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseCreateManyUserInput({
    this.id,
    required this.message,
    required this.supportTicketId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final String message;

  final String supportTicketId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'message': message,
    'supportTicketId': supportTicketId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SupportResponseCreateManyUserInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseCreateManyUserInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<
    _i2.SupportResponseCreateManyUserInput,
    Iterable<_i2.SupportResponseCreateManyUserInput>
  >
  data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
    'data': data,
    'skipDuplicates': skipDuplicates,
  };
}

class SupportResponseCreateNestedManyWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseCreateNestedManyWithoutUserInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.SupportResponseCreateWithoutUserInput,
    _i1.PrismaUnion<
      Iterable<_i2.SupportResponseCreateWithoutUserInput>,
      _i1.PrismaUnion<
        _i2.SupportResponseUncheckedCreateWithoutUserInput,
        Iterable<_i2.SupportResponseUncheckedCreateWithoutUserInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.SupportResponseCreateOrConnectWithoutUserInput,
    Iterable<_i2.SupportResponseCreateOrConnectWithoutUserInput>
  >?
  connectOrCreate;

  final _i2.SupportResponseCreateManyUserInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.SupportResponseWhereUniqueInput,
    Iterable<_i2.SupportResponseWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class UserCreateWithoutSupportTicketsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateWithoutSupportTicketsInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.cookiePreferences,
    this.notificationPreferences,
    this.payment,
    this.consultantProfile,
    this.consulteeProfile,
    this.staffProfile,
    this.slotsOfAppointment,
    this.waitlist,
    this.feedbacks,
    this.supportResponses,
    this.accounts,
    this.sessions,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? email;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? emailVerified;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? image;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? address;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? password;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? passwordResetToken;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? passwordResetExpires;

  final bool? onlineStatus;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? currentTimezone;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? onboardingCompleted;

  final _i1.PrismaUnion<_i3.UserRole, _i1.PrismaNull>? role;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consultantProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consulteeProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? staffProfileId;

  final _i2.CookiePreferenceCreateNestedOneWithoutUserInput? cookiePreferences;

  final _i2.NotificationPreferenceCreateNestedOneWithoutUserInput?
  notificationPreferences;

  final _i2.PaymentCreateNestedManyWithoutUserInput? payment;

  final _i2.ConsultantProfileCreateNestedOneWithoutUserInput? consultantProfile;

  final _i2.ConsulteeProfileCreateNestedOneWithoutUserInput? consulteeProfile;

  final _i2.StaffProfileCreateNestedOneWithoutUserInput? staffProfile;

  final _i2.SlotOfAppointmentCreateNestedManyWithoutUserInput?
  slotsOfAppointment;

  final _i2.WaitlistCreateNestedManyWithoutUserInput? waitlist;

  final _i2.FeedbackCreateNestedManyWithoutUserInput? feedbacks;

  final _i2.SupportResponseCreateNestedManyWithoutUserInput? supportResponses;

  final _i2.AccountCreateNestedManyWithoutUserInput? accounts;

  final _i2.SessionCreateNestedManyWithoutUserInput? sessions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'cookiePreferences': cookiePreferences,
    'notificationPreferences': notificationPreferences,
    'Payment': payment,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
    'staffProfile': staffProfile,
    'slotsOfAppointment': slotsOfAppointment,
    'Waitlist': waitlist,
    'feedbacks': feedbacks,
    'supportResponses': supportResponses,
    'accounts': accounts,
    'sessions': sessions,
  };
}

class UserUncheckedCreateWithoutSupportTicketsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUncheckedCreateWithoutSupportTicketsInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.cookiePreferences,
    this.notificationPreferences,
    this.payment,
    this.consultantProfile,
    this.consulteeProfile,
    this.staffProfile,
    this.slotsOfAppointment,
    this.waitlist,
    this.feedbacks,
    this.supportResponses,
    this.accounts,
    this.sessions,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? email;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? emailVerified;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? image;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? address;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? password;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? passwordResetToken;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? passwordResetExpires;

  final bool? onlineStatus;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? currentTimezone;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? onboardingCompleted;

  final _i1.PrismaUnion<_i3.UserRole, _i1.PrismaNull>? role;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consultantProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consulteeProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? staffProfileId;

  final _i2.CookiePreferenceUncheckedCreateNestedOneWithoutUserInput?
  cookiePreferences;

  final _i2.NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput?
  notificationPreferences;

  final _i2.PaymentUncheckedCreateNestedManyWithoutUserInput? payment;

  final _i2.ConsultantProfileUncheckedCreateNestedOneWithoutUserInput?
  consultantProfile;

  final _i2.ConsulteeProfileUncheckedCreateNestedOneWithoutUserInput?
  consulteeProfile;

  final _i2.StaffProfileUncheckedCreateNestedOneWithoutUserInput? staffProfile;

  final _i2.SlotOfAppointmentUncheckedCreateNestedManyWithoutUserInput?
  slotsOfAppointment;

  final _i2.WaitlistUncheckedCreateNestedManyWithoutUserInput? waitlist;

  final _i2.FeedbackUncheckedCreateNestedManyWithoutUserInput? feedbacks;

  final _i2.SupportResponseUncheckedCreateNestedManyWithoutUserInput?
  supportResponses;

  final _i2.AccountUncheckedCreateNestedManyWithoutUserInput? accounts;

  final _i2.SessionUncheckedCreateNestedManyWithoutUserInput? sessions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'cookiePreferences': cookiePreferences,
    'notificationPreferences': notificationPreferences,
    'Payment': payment,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
    'staffProfile': staffProfile,
    'slotsOfAppointment': slotsOfAppointment,
    'Waitlist': waitlist,
    'feedbacks': feedbacks,
    'supportResponses': supportResponses,
    'accounts': accounts,
    'sessions': sessions,
  };
}

class UserCreateOrConnectWithoutSupportTicketsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateOrConnectWithoutSupportTicketsInput({
    required this.where,
    required this.create,
  });

  final _i2.UserWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.UserCreateWithoutSupportTicketsInput,
    _i2.UserUncheckedCreateWithoutSupportTicketsInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class UserCreateNestedOneWithoutSupportTicketsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateNestedOneWithoutSupportTicketsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.UserCreateWithoutSupportTicketsInput,
    _i2.UserUncheckedCreateWithoutSupportTicketsInput
  >?
  create;

  final _i2.UserCreateOrConnectWithoutSupportTicketsInput? connectOrCreate;

  final _i2.UserWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class SupportTicketCreateWithoutResponsesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportTicketCreateWithoutResponsesInput({
    this.id,
    required this.title,
    required this.description,
    this.priority,
    this.status,
    this.category,
    this.createdAt,
    this.updatedAt,
    required this.user,
  });

  final String? id;

  final String title;

  final String description;

  final _i3.SupportPriority? priority;

  final _i3.SupportTicketStatus? status;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? category;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.UserCreateNestedOneWithoutSupportTicketsInput user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'priority': priority,
    'status': status,
    'category': category,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'user': user,
  };
}

class SupportTicketUncheckedCreateWithoutResponsesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportTicketUncheckedCreateWithoutResponsesInput({
    this.id,
    required this.title,
    required this.description,
    this.priority,
    this.status,
    this.category,
    required this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final String title;

  final String description;

  final _i3.SupportPriority? priority;

  final _i3.SupportTicketStatus? status;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? category;

  final String userId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'priority': priority,
    'status': status,
    'category': category,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SupportTicketCreateOrConnectWithoutResponsesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportTicketCreateOrConnectWithoutResponsesInput({
    required this.where,
    required this.create,
  });

  final _i2.SupportTicketWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.SupportTicketCreateWithoutResponsesInput,
    _i2.SupportTicketUncheckedCreateWithoutResponsesInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class SupportTicketCreateNestedOneWithoutResponsesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportTicketCreateNestedOneWithoutResponsesInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.SupportTicketCreateWithoutResponsesInput,
    _i2.SupportTicketUncheckedCreateWithoutResponsesInput
  >?
  create;

  final _i2.SupportTicketCreateOrConnectWithoutResponsesInput? connectOrCreate;

  final _i2.SupportTicketWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class SupportResponseCreateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseCreateWithoutUserInput({
    this.id,
    required this.message,
    this.createdAt,
    this.updatedAt,
    required this.supportTicket,
  });

  final String? id;

  final String message;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.SupportTicketCreateNestedOneWithoutResponsesInput supportTicket;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'message': message,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'supportTicket': supportTicket,
  };
}

class SupportResponseUncheckedCreateNestedManyWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseUncheckedCreateNestedManyWithoutUserInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.SupportResponseCreateWithoutUserInput,
    _i1.PrismaUnion<
      Iterable<_i2.SupportResponseCreateWithoutUserInput>,
      _i1.PrismaUnion<
        _i2.SupportResponseUncheckedCreateWithoutUserInput,
        Iterable<_i2.SupportResponseUncheckedCreateWithoutUserInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.SupportResponseCreateOrConnectWithoutUserInput,
    Iterable<_i2.SupportResponseCreateOrConnectWithoutUserInput>
  >?
  connectOrCreate;

  final _i2.SupportResponseCreateManyUserInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.SupportResponseWhereUniqueInput,
    Iterable<_i2.SupportResponseWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class UserUncheckedCreateWithoutSlotsOfAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUncheckedCreateWithoutSlotsOfAppointmentInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.cookiePreferences,
    this.notificationPreferences,
    this.payment,
    this.consultantProfile,
    this.consulteeProfile,
    this.staffProfile,
    this.waitlist,
    this.feedbacks,
    this.supportTickets,
    this.supportResponses,
    this.accounts,
    this.sessions,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? email;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? emailVerified;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? image;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? address;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? password;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? passwordResetToken;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? passwordResetExpires;

  final bool? onlineStatus;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? currentTimezone;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? onboardingCompleted;

  final _i1.PrismaUnion<_i3.UserRole, _i1.PrismaNull>? role;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consultantProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consulteeProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? staffProfileId;

  final _i2.CookiePreferenceUncheckedCreateNestedOneWithoutUserInput?
  cookiePreferences;

  final _i2.NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput?
  notificationPreferences;

  final _i2.PaymentUncheckedCreateNestedManyWithoutUserInput? payment;

  final _i2.ConsultantProfileUncheckedCreateNestedOneWithoutUserInput?
  consultantProfile;

  final _i2.ConsulteeProfileUncheckedCreateNestedOneWithoutUserInput?
  consulteeProfile;

  final _i2.StaffProfileUncheckedCreateNestedOneWithoutUserInput? staffProfile;

  final _i2.WaitlistUncheckedCreateNestedManyWithoutUserInput? waitlist;

  final _i2.FeedbackUncheckedCreateNestedManyWithoutUserInput? feedbacks;

  final _i2.SupportTicketUncheckedCreateNestedManyWithoutUserInput?
  supportTickets;

  final _i2.SupportResponseUncheckedCreateNestedManyWithoutUserInput?
  supportResponses;

  final _i2.AccountUncheckedCreateNestedManyWithoutUserInput? accounts;

  final _i2.SessionUncheckedCreateNestedManyWithoutUserInput? sessions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'cookiePreferences': cookiePreferences,
    'notificationPreferences': notificationPreferences,
    'Payment': payment,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
    'staffProfile': staffProfile,
    'Waitlist': waitlist,
    'feedbacks': feedbacks,
    'supportTickets': supportTickets,
    'supportResponses': supportResponses,
    'accounts': accounts,
    'sessions': sessions,
  };
}

class UserCreateOrConnectWithoutSlotsOfAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateOrConnectWithoutSlotsOfAppointmentInput({
    required this.where,
    required this.create,
  });

  final _i2.UserWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.UserCreateWithoutSlotsOfAppointmentInput,
    _i2.UserUncheckedCreateWithoutSlotsOfAppointmentInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class UserUncheckedCreateNestedManyWithoutSlotsOfAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUncheckedCreateNestedManyWithoutSlotsOfAppointmentInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.UserCreateWithoutSlotsOfAppointmentInput,
    _i1.PrismaUnion<
      Iterable<_i2.UserCreateWithoutSlotsOfAppointmentInput>,
      _i1.PrismaUnion<
        _i2.UserUncheckedCreateWithoutSlotsOfAppointmentInput,
        Iterable<_i2.UserUncheckedCreateWithoutSlotsOfAppointmentInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.UserCreateOrConnectWithoutSlotsOfAppointmentInput,
    Iterable<_i2.UserCreateOrConnectWithoutSlotsOfAppointmentInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.UserWhereUniqueInput,
    Iterable<_i2.UserWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class SlotOfAppointmentUncheckedCreateWithoutAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentUncheckedCreateWithoutAppointmentInput({
    this.id,
    required this.slotStartTimeInUTC,
    required this.slotEndTimeInUTC,
    this.isTentative,
    this.createdAt,
    this.updatedAt,
    this.user,
    this.meetingSession,
  });

  final String? id;

  final DateTime slotStartTimeInUTC;

  final DateTime slotEndTimeInUTC;

  final bool? isTentative;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.UserUncheckedCreateNestedManyWithoutSlotsOfAppointmentInput? user;

  final _i2.MeetingSessionUncheckedCreateNestedOneWithoutSlotOfAppointmentInput?
  meetingSession;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'isTentative': isTentative,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'user': user,
    'meetingSession': meetingSession,
  };
}

class SlotOfAppointmentCreateOrConnectWithoutAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentCreateOrConnectWithoutAppointmentInput({
    required this.where,
    required this.create,
  });

  final _i2.SlotOfAppointmentWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentCreateWithoutAppointmentInput,
    _i2.SlotOfAppointmentUncheckedCreateWithoutAppointmentInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class SlotOfAppointmentCreateManyAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentCreateManyAppointmentInput({
    this.id,
    required this.slotStartTimeInUTC,
    required this.slotEndTimeInUTC,
    this.isTentative,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final DateTime slotStartTimeInUTC;

  final DateTime slotEndTimeInUTC;

  final bool? isTentative;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'isTentative': isTentative,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SlotOfAppointmentCreateManyAppointmentInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentCreateManyAppointmentInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentCreateManyAppointmentInput,
    Iterable<_i2.SlotOfAppointmentCreateManyAppointmentInput>
  >
  data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
    'data': data,
    'skipDuplicates': skipDuplicates,
  };
}

class SlotOfAppointmentUncheckedCreateNestedManyWithoutAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentUncheckedCreateNestedManyWithoutAppointmentInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentCreateWithoutAppointmentInput,
    _i1.PrismaUnion<
      Iterable<_i2.SlotOfAppointmentCreateWithoutAppointmentInput>,
      _i1.PrismaUnion<
        _i2.SlotOfAppointmentUncheckedCreateWithoutAppointmentInput,
        Iterable<_i2.SlotOfAppointmentUncheckedCreateWithoutAppointmentInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentCreateOrConnectWithoutAppointmentInput,
    Iterable<_i2.SlotOfAppointmentCreateOrConnectWithoutAppointmentInput>
  >?
  connectOrCreate;

  final _i2.SlotOfAppointmentCreateManyAppointmentInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentWhereUniqueInput,
    Iterable<_i2.SlotOfAppointmentWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class AppointmentUncheckedCreateWithoutWebinarInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentUncheckedCreateWithoutWebinarInput({
    this.id,
    required this.appointmentType,
    this.consultationId,
    this.subscriptionId,
    this.classId,
    this.createdAt,
    this.updatedAt,
    this.slotsOfAppointment,
    this.payment,
  });

  final String? id;

  final _i3.AppointmentsType appointmentType;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consultationId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? subscriptionId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? classId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.SlotOfAppointmentUncheckedCreateNestedManyWithoutAppointmentInput?
  slotsOfAppointment;

  final _i2.PaymentUncheckedCreateNestedManyWithoutAppointmentInput? payment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'appointmentType': appointmentType,
    'consultationId': consultationId,
    'subscriptionId': subscriptionId,
    'classId': classId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'slotsOfAppointment': slotsOfAppointment,
    'payment': payment,
  };
}

class AppointmentCreateOrConnectWithoutWebinarInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentCreateOrConnectWithoutWebinarInput({
    required this.where,
    required this.create,
  });

  final _i2.AppointmentWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.AppointmentCreateWithoutWebinarInput,
    _i2.AppointmentUncheckedCreateWithoutWebinarInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class AppointmentUncheckedCreateNestedOneWithoutWebinarInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentUncheckedCreateNestedOneWithoutWebinarInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.AppointmentCreateWithoutWebinarInput,
    _i2.AppointmentUncheckedCreateWithoutWebinarInput
  >?
  create;

  final _i2.AppointmentCreateOrConnectWithoutWebinarInput? connectOrCreate;

  final _i2.AppointmentWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class WebinarUncheckedCreateWithoutWebinarPlanInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarUncheckedCreateWithoutWebinarPlanInput({
    this.id,
    this.status,
    this.feedbackSummary,
    this.createdAt,
    this.updatedAt,
    this.waitlist,
    this.appointment,
  });

  final String? id;

  final _i3.WebinarStatus? status;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackSummary;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.WaitlistUncheckedCreateNestedManyWithoutWebinarInput? waitlist;

  final _i2.AppointmentUncheckedCreateNestedOneWithoutWebinarInput? appointment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'status': status,
    'feedbackSummary': feedbackSummary,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'waitlist': waitlist,
    'appointment': appointment,
  };
}

class WebinarCreateOrConnectWithoutWebinarPlanInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarCreateOrConnectWithoutWebinarPlanInput({
    required this.where,
    required this.create,
  });

  final _i2.WebinarWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.WebinarCreateWithoutWebinarPlanInput,
    _i2.WebinarUncheckedCreateWithoutWebinarPlanInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class WebinarCreateManyWebinarPlanInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarCreateManyWebinarPlanInput({
    this.id,
    this.status,
    this.feedbackSummary,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final _i3.WebinarStatus? status;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackSummary;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'status': status,
    'feedbackSummary': feedbackSummary,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class WebinarCreateManyWebinarPlanInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarCreateManyWebinarPlanInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<
    _i2.WebinarCreateManyWebinarPlanInput,
    Iterable<_i2.WebinarCreateManyWebinarPlanInput>
  >
  data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
    'data': data,
    'skipDuplicates': skipDuplicates,
  };
}

class WebinarUncheckedCreateNestedManyWithoutWebinarPlanInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarUncheckedCreateNestedManyWithoutWebinarPlanInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.WebinarCreateWithoutWebinarPlanInput,
    _i1.PrismaUnion<
      Iterable<_i2.WebinarCreateWithoutWebinarPlanInput>,
      _i1.PrismaUnion<
        _i2.WebinarUncheckedCreateWithoutWebinarPlanInput,
        Iterable<_i2.WebinarUncheckedCreateWithoutWebinarPlanInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.WebinarCreateOrConnectWithoutWebinarPlanInput,
    Iterable<_i2.WebinarCreateOrConnectWithoutWebinarPlanInput>
  >?
  connectOrCreate;

  final _i2.WebinarCreateManyWebinarPlanInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.WebinarWhereUniqueInput,
    Iterable<_i2.WebinarWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class WebinarPlanUncheckedCreateWithoutTopicsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanUncheckedCreateWithoutTopicsInput({
    this.id,
    required this.title,
    this.description,
    required this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInHours,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.webinars,
  });

  final String? id;

  final String title;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final int price;

  final String? priceCurrency;

  final bool? certificateProvided;

  final double? durationInHours;

  final int? maxParticipants;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? language;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? level;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? prerequisites;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? materialProvided;

  final _i1.PrismaUnion<
    _i2.WebinarPlanCreatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consultantProfileId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.WebinarUncheckedCreateNestedManyWithoutWebinarPlanInput? webinars;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInHours': durationInHours,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'webinars': webinars,
  };
}

class WebinarPlanCreateOrConnectWithoutTopicsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanCreateOrConnectWithoutTopicsInput({
    required this.where,
    required this.create,
  });

  final _i2.WebinarPlanWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.WebinarPlanCreateWithoutTopicsInput,
    _i2.WebinarPlanUncheckedCreateWithoutTopicsInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class WebinarPlanUncheckedCreateNestedManyWithoutTopicsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanUncheckedCreateNestedManyWithoutTopicsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.WebinarPlanCreateWithoutTopicsInput,
    _i1.PrismaUnion<
      Iterable<_i2.WebinarPlanCreateWithoutTopicsInput>,
      _i1.PrismaUnion<
        _i2.WebinarPlanUncheckedCreateWithoutTopicsInput,
        Iterable<_i2.WebinarPlanUncheckedCreateWithoutTopicsInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.WebinarPlanCreateOrConnectWithoutTopicsInput,
    Iterable<_i2.WebinarPlanCreateOrConnectWithoutTopicsInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.WebinarPlanWhereUniqueInput,
    Iterable<_i2.WebinarPlanWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class TopicUncheckedCreateWithoutClassPlansInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TopicUncheckedCreateWithoutClassPlansInput({
    this.id,
    required this.name,
    this.createdAt,
    this.updatedAt,
    this.webinarPlans,
  });

  final String? id;

  final String name;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.WebinarPlanUncheckedCreateNestedManyWithoutTopicsInput?
  webinarPlans;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'webinarPlans': webinarPlans,
  };
}

class TopicCreateOrConnectWithoutClassPlansInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TopicCreateOrConnectWithoutClassPlansInput({
    required this.where,
    required this.create,
  });

  final _i2.TopicWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.TopicCreateWithoutClassPlansInput,
    _i2.TopicUncheckedCreateWithoutClassPlansInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class TopicUncheckedCreateNestedManyWithoutClassPlansInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TopicUncheckedCreateNestedManyWithoutClassPlansInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.TopicCreateWithoutClassPlansInput,
    _i1.PrismaUnion<
      Iterable<_i2.TopicCreateWithoutClassPlansInput>,
      _i1.PrismaUnion<
        _i2.TopicUncheckedCreateWithoutClassPlansInput,
        Iterable<_i2.TopicUncheckedCreateWithoutClassPlansInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.TopicCreateOrConnectWithoutClassPlansInput,
    Iterable<_i2.TopicCreateOrConnectWithoutClassPlansInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.TopicWhereUniqueInput,
    Iterable<_i2.TopicWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class ClassPlanUncheckedCreateWithoutClassesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanUncheckedCreateWithoutClassesInput({
    this.id,
    required this.title,
    required this.description,
    required this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInMonths,
    this.callsPerWeek,
    this.videoMeetings,
    this.emailSupport,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.topics,
    this.classContents,
  });

  final String? id;

  final String title;

  final String description;

  final int price;

  final String? priceCurrency;

  final bool? certificateProvided;

  final int? durationInMonths;

  final int? callsPerWeek;

  final int? videoMeetings;

  final _i3.PlanEmailSupport? emailSupport;

  final int? maxParticipants;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? language;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? level;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? prerequisites;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? materialProvided;

  final _i1.PrismaUnion<
    _i2.ClassPlanCreatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consultantProfileId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.TopicUncheckedCreateNestedManyWithoutClassPlansInput? topics;

  final _i2.ClassContentUncheckedCreateNestedManyWithoutClassPlanInput?
  classContents;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInMonths': durationInMonths,
    'callsPerWeek': callsPerWeek,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'topics': topics,
    'classContents': classContents,
  };
}

class ClassPlanCreateOrConnectWithoutClassesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanCreateOrConnectWithoutClassesInput({
    required this.where,
    required this.create,
  });

  final _i2.ClassPlanWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.ClassPlanCreateWithoutClassesInput,
    _i2.ClassPlanUncheckedCreateWithoutClassesInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class ClassPlanCreateNestedOneWithoutClassesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanCreateNestedOneWithoutClassesInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.ClassPlanCreateWithoutClassesInput,
    _i2.ClassPlanUncheckedCreateWithoutClassesInput
  >?
  create;

  final _i2.ClassPlanCreateOrConnectWithoutClassesInput? connectOrCreate;

  final _i2.ClassPlanWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class ClassCreateWithoutWaitlistInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassCreateWithoutWaitlistInput({
    this.id,
    this.startDate,
    this.endDate,
    this.status,
    this.recordingUrls,
    this.feedbackSummary,
    this.createdAt,
    this.updatedAt,
    required this.classPlan,
    this.appointments,
  });

  final String? id;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? startDate;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? endDate;

  final _i3.ClassStatus? status;

  final _i1.PrismaUnion<_i2.ClassCreaterecordingUrlsInput, Iterable<String>>?
  recordingUrls;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackSummary;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ClassPlanCreateNestedOneWithoutClassesInput classPlan;

  final _i2.AppointmentCreateNestedManyWithoutClassInput? appointments;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'status': status,
    'recordingUrls': recordingUrls,
    'feedbackSummary': feedbackSummary,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'classPlan': classPlan,
    'appointments': appointments,
  };
}

class ClassUncheckedCreateWithoutWaitlistInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassUncheckedCreateWithoutWaitlistInput({
    this.id,
    this.startDate,
    this.endDate,
    this.status,
    this.recordingUrls,
    this.feedbackSummary,
    required this.classPlanId,
    this.createdAt,
    this.updatedAt,
    this.appointments,
  });

  final String? id;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? startDate;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? endDate;

  final _i3.ClassStatus? status;

  final _i1.PrismaUnion<_i2.ClassCreaterecordingUrlsInput, Iterable<String>>?
  recordingUrls;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackSummary;

  final String classPlanId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.AppointmentUncheckedCreateNestedManyWithoutClassInput? appointments;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'status': status,
    'recordingUrls': recordingUrls,
    'feedbackSummary': feedbackSummary,
    'classPlanId': classPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'appointments': appointments,
  };
}

class ClassCreateOrConnectWithoutWaitlistInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassCreateOrConnectWithoutWaitlistInput({
    required this.where,
    required this.create,
  });

  final _i2.ClassWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.ClassCreateWithoutWaitlistInput,
    _i2.ClassUncheckedCreateWithoutWaitlistInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class ClassCreateNestedOneWithoutWaitlistInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassCreateNestedOneWithoutWaitlistInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.ClassCreateWithoutWaitlistInput,
    _i2.ClassUncheckedCreateWithoutWaitlistInput
  >?
  create;

  final _i2.ClassCreateOrConnectWithoutWaitlistInput? connectOrCreate;

  final _i2.ClassWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class WaitlistCreateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistCreateWithoutUserInput({
    this.id,
    this.joinedAt,
    this.webinar,
    this.$class,
  });

  final String? id;

  final DateTime? joinedAt;

  final _i2.WebinarCreateNestedOneWithoutWaitlistInput? webinar;

  final _i2.ClassCreateNestedOneWithoutWaitlistInput? $class;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'joinedAt': joinedAt,
    'webinar': webinar,
    'class': $class,
  };
}

class WaitlistCreateNestedManyWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistCreateNestedManyWithoutUserInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.WaitlistCreateWithoutUserInput,
    _i1.PrismaUnion<
      Iterable<_i2.WaitlistCreateWithoutUserInput>,
      _i1.PrismaUnion<
        _i2.WaitlistUncheckedCreateWithoutUserInput,
        Iterable<_i2.WaitlistUncheckedCreateWithoutUserInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.WaitlistCreateOrConnectWithoutUserInput,
    Iterable<_i2.WaitlistCreateOrConnectWithoutUserInput>
  >?
  connectOrCreate;

  final _i2.WaitlistCreateManyUserInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.WaitlistWhereUniqueInput,
    Iterable<_i2.WaitlistWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class UserCreateWithoutPaymentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateWithoutPaymentInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.cookiePreferences,
    this.notificationPreferences,
    this.consultantProfile,
    this.consulteeProfile,
    this.staffProfile,
    this.slotsOfAppointment,
    this.waitlist,
    this.feedbacks,
    this.supportTickets,
    this.supportResponses,
    this.accounts,
    this.sessions,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? email;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? emailVerified;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? image;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? address;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? password;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? passwordResetToken;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? passwordResetExpires;

  final bool? onlineStatus;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? currentTimezone;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? onboardingCompleted;

  final _i1.PrismaUnion<_i3.UserRole, _i1.PrismaNull>? role;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consultantProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consulteeProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? staffProfileId;

  final _i2.CookiePreferenceCreateNestedOneWithoutUserInput? cookiePreferences;

  final _i2.NotificationPreferenceCreateNestedOneWithoutUserInput?
  notificationPreferences;

  final _i2.ConsultantProfileCreateNestedOneWithoutUserInput? consultantProfile;

  final _i2.ConsulteeProfileCreateNestedOneWithoutUserInput? consulteeProfile;

  final _i2.StaffProfileCreateNestedOneWithoutUserInput? staffProfile;

  final _i2.SlotOfAppointmentCreateNestedManyWithoutUserInput?
  slotsOfAppointment;

  final _i2.WaitlistCreateNestedManyWithoutUserInput? waitlist;

  final _i2.FeedbackCreateNestedManyWithoutUserInput? feedbacks;

  final _i2.SupportTicketCreateNestedManyWithoutUserInput? supportTickets;

  final _i2.SupportResponseCreateNestedManyWithoutUserInput? supportResponses;

  final _i2.AccountCreateNestedManyWithoutUserInput? accounts;

  final _i2.SessionCreateNestedManyWithoutUserInput? sessions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'cookiePreferences': cookiePreferences,
    'notificationPreferences': notificationPreferences,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
    'staffProfile': staffProfile,
    'slotsOfAppointment': slotsOfAppointment,
    'Waitlist': waitlist,
    'feedbacks': feedbacks,
    'supportTickets': supportTickets,
    'supportResponses': supportResponses,
    'accounts': accounts,
    'sessions': sessions,
  };
}

class UserUncheckedCreateWithoutPaymentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUncheckedCreateWithoutPaymentInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.cookiePreferences,
    this.notificationPreferences,
    this.consultantProfile,
    this.consulteeProfile,
    this.staffProfile,
    this.slotsOfAppointment,
    this.waitlist,
    this.feedbacks,
    this.supportTickets,
    this.supportResponses,
    this.accounts,
    this.sessions,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? email;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? emailVerified;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? image;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? address;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? password;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? passwordResetToken;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? passwordResetExpires;

  final bool? onlineStatus;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? currentTimezone;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? onboardingCompleted;

  final _i1.PrismaUnion<_i3.UserRole, _i1.PrismaNull>? role;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consultantProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consulteeProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? staffProfileId;

  final _i2.CookiePreferenceUncheckedCreateNestedOneWithoutUserInput?
  cookiePreferences;

  final _i2.NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput?
  notificationPreferences;

  final _i2.ConsultantProfileUncheckedCreateNestedOneWithoutUserInput?
  consultantProfile;

  final _i2.ConsulteeProfileUncheckedCreateNestedOneWithoutUserInput?
  consulteeProfile;

  final _i2.StaffProfileUncheckedCreateNestedOneWithoutUserInput? staffProfile;

  final _i2.SlotOfAppointmentUncheckedCreateNestedManyWithoutUserInput?
  slotsOfAppointment;

  final _i2.WaitlistUncheckedCreateNestedManyWithoutUserInput? waitlist;

  final _i2.FeedbackUncheckedCreateNestedManyWithoutUserInput? feedbacks;

  final _i2.SupportTicketUncheckedCreateNestedManyWithoutUserInput?
  supportTickets;

  final _i2.SupportResponseUncheckedCreateNestedManyWithoutUserInput?
  supportResponses;

  final _i2.AccountUncheckedCreateNestedManyWithoutUserInput? accounts;

  final _i2.SessionUncheckedCreateNestedManyWithoutUserInput? sessions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'cookiePreferences': cookiePreferences,
    'notificationPreferences': notificationPreferences,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
    'staffProfile': staffProfile,
    'slotsOfAppointment': slotsOfAppointment,
    'Waitlist': waitlist,
    'feedbacks': feedbacks,
    'supportTickets': supportTickets,
    'supportResponses': supportResponses,
    'accounts': accounts,
    'sessions': sessions,
  };
}

class UserCreateOrConnectWithoutPaymentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateOrConnectWithoutPaymentInput({
    required this.where,
    required this.create,
  });

  final _i2.UserWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.UserCreateWithoutPaymentInput,
    _i2.UserUncheckedCreateWithoutPaymentInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class UserCreateNestedOneWithoutPaymentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateNestedOneWithoutPaymentInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.UserCreateWithoutPaymentInput,
    _i2.UserUncheckedCreateWithoutPaymentInput
  >?
  create;

  final _i2.UserCreateOrConnectWithoutPaymentInput? connectOrCreate;

  final _i2.UserWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class DiscountCodeCreateWithoutPaymentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountCodeCreateWithoutPaymentInput({
    this.id,
    required this.code,
    required this.description,
    required this.discountType,
    required this.discountValue,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final String code;

  final String description;

  final _i3.DiscountType discountType;

  final double discountValue;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'code': code,
    'description': description,
    'discountType': discountType,
    'discountValue': discountValue,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class DiscountCodeUncheckedCreateWithoutPaymentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountCodeUncheckedCreateWithoutPaymentInput({
    this.id,
    required this.code,
    required this.description,
    required this.discountType,
    required this.discountValue,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final String code;

  final String description;

  final _i3.DiscountType discountType;

  final double discountValue;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'code': code,
    'description': description,
    'discountType': discountType,
    'discountValue': discountValue,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class DiscountCodeWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountCodeWhereUniqueInput({this.id, this.code});

  final String? id;

  final String? code;

  @override
  Map<String, dynamic> toJson() => {'id': id, 'code': code};
}

class DiscountCodeCreateOrConnectWithoutPaymentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountCodeCreateOrConnectWithoutPaymentInput({
    required this.where,
    required this.create,
  });

  final _i2.DiscountCodeWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.DiscountCodeCreateWithoutPaymentInput,
    _i2.DiscountCodeUncheckedCreateWithoutPaymentInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class DiscountCodeCreateNestedOneWithoutPaymentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountCodeCreateNestedOneWithoutPaymentInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.DiscountCodeCreateWithoutPaymentInput,
    _i2.DiscountCodeUncheckedCreateWithoutPaymentInput
  >?
  create;

  final _i2.DiscountCodeCreateOrConnectWithoutPaymentInput? connectOrCreate;

  final _i2.DiscountCodeWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class PaymentCreateWithoutAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentCreateWithoutAppointmentInput({
    this.id,
    required this.amount,
    required this.currency,
    this.description,
    this.receiptUrl,
    required this.paymentMethod,
    required this.paymentIntent,
    required this.paymentGateway,
    required this.paymentStatus,
    this.expiresAt,
    this.createdAt,
    this.updatedAt,
    required this.user,
    this.discountCode,
  });

  final String? id;

  final int amount;

  final String currency;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? receiptUrl;

  final String paymentMethod;

  final String paymentIntent;

  final _i3.PaymentGateway paymentGateway;

  final _i3.PaymentStatus paymentStatus;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? expiresAt;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.UserCreateNestedOneWithoutPaymentInput user;

  final _i2.DiscountCodeCreateNestedOneWithoutPaymentInput? discountCode;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'amount': amount,
    'currency': currency,
    'description': description,
    'receiptUrl': receiptUrl,
    'paymentMethod': paymentMethod,
    'paymentIntent': paymentIntent,
    'paymentGateway': paymentGateway,
    'paymentStatus': paymentStatus,
    'expiresAt': expiresAt,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'user': user,
    'discountCode': discountCode,
  };
}

class PaymentCreateNestedManyWithoutAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentCreateNestedManyWithoutAppointmentInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.PaymentCreateWithoutAppointmentInput,
    _i1.PrismaUnion<
      Iterable<_i2.PaymentCreateWithoutAppointmentInput>,
      _i1.PrismaUnion<
        _i2.PaymentUncheckedCreateWithoutAppointmentInput,
        Iterable<_i2.PaymentUncheckedCreateWithoutAppointmentInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.PaymentCreateOrConnectWithoutAppointmentInput,
    Iterable<_i2.PaymentCreateOrConnectWithoutAppointmentInput>
  >?
  connectOrCreate;

  final _i2.PaymentCreateManyAppointmentInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.PaymentWhereUniqueInput,
    Iterable<_i2.PaymentWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class AppointmentCreateWithoutWebinarInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentCreateWithoutWebinarInput({
    this.id,
    required this.appointmentType,
    this.createdAt,
    this.updatedAt,
    this.slotsOfAppointment,
    this.consultation,
    this.subscription,
    this.$class,
    this.payment,
  });

  final String? id;

  final _i3.AppointmentsType appointmentType;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.SlotOfAppointmentCreateNestedManyWithoutAppointmentInput?
  slotsOfAppointment;

  final _i2.ConsultationCreateNestedOneWithoutAppointmentInput? consultation;

  final _i2.SubscriptionCreateNestedOneWithoutAppointmentsInput? subscription;

  final _i2.ClassCreateNestedOneWithoutAppointmentsInput? $class;

  final _i2.PaymentCreateNestedManyWithoutAppointmentInput? payment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'appointmentType': appointmentType,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'slotsOfAppointment': slotsOfAppointment,
    'consultation': consultation,
    'subscription': subscription,
    'class': $class,
    'payment': payment,
  };
}

class AppointmentCreateNestedOneWithoutWebinarInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentCreateNestedOneWithoutWebinarInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.AppointmentCreateWithoutWebinarInput,
    _i2.AppointmentUncheckedCreateWithoutWebinarInput
  >?
  create;

  final _i2.AppointmentCreateOrConnectWithoutWebinarInput? connectOrCreate;

  final _i2.AppointmentWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class WebinarCreateWithoutWebinarPlanInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarCreateWithoutWebinarPlanInput({
    this.id,
    this.status,
    this.feedbackSummary,
    this.createdAt,
    this.updatedAt,
    this.waitlist,
    this.appointment,
  });

  final String? id;

  final _i3.WebinarStatus? status;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackSummary;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.WaitlistCreateNestedManyWithoutWebinarInput? waitlist;

  final _i2.AppointmentCreateNestedOneWithoutWebinarInput? appointment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'status': status,
    'feedbackSummary': feedbackSummary,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'waitlist': waitlist,
    'appointment': appointment,
  };
}

class WebinarCreateNestedManyWithoutWebinarPlanInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarCreateNestedManyWithoutWebinarPlanInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.WebinarCreateWithoutWebinarPlanInput,
    _i1.PrismaUnion<
      Iterable<_i2.WebinarCreateWithoutWebinarPlanInput>,
      _i1.PrismaUnion<
        _i2.WebinarUncheckedCreateWithoutWebinarPlanInput,
        Iterable<_i2.WebinarUncheckedCreateWithoutWebinarPlanInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.WebinarCreateOrConnectWithoutWebinarPlanInput,
    Iterable<_i2.WebinarCreateOrConnectWithoutWebinarPlanInput>
  >?
  connectOrCreate;

  final _i2.WebinarCreateManyWebinarPlanInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.WebinarWhereUniqueInput,
    Iterable<_i2.WebinarWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class WebinarPlanCreateWithoutTopicsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanCreateWithoutTopicsInput({
    this.id,
    required this.title,
    this.description,
    required this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInHours,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.createdAt,
    this.updatedAt,
    this.consultantProfile,
    this.webinars,
  });

  final String? id;

  final String title;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final int price;

  final String? priceCurrency;

  final bool? certificateProvided;

  final double? durationInHours;

  final int? maxParticipants;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? language;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? level;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? prerequisites;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? materialProvided;

  final _i1.PrismaUnion<
    _i2.WebinarPlanCreatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ConsultantProfileCreateNestedOneWithoutWebinarPlansInput?
  consultantProfile;

  final _i2.WebinarCreateNestedManyWithoutWebinarPlanInput? webinars;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInHours': durationInHours,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultantProfile': consultantProfile,
    'webinars': webinars,
  };
}

class WebinarPlanCreateNestedManyWithoutTopicsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanCreateNestedManyWithoutTopicsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.WebinarPlanCreateWithoutTopicsInput,
    _i1.PrismaUnion<
      Iterable<_i2.WebinarPlanCreateWithoutTopicsInput>,
      _i1.PrismaUnion<
        _i2.WebinarPlanUncheckedCreateWithoutTopicsInput,
        Iterable<_i2.WebinarPlanUncheckedCreateWithoutTopicsInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.WebinarPlanCreateOrConnectWithoutTopicsInput,
    Iterable<_i2.WebinarPlanCreateOrConnectWithoutTopicsInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.WebinarPlanWhereUniqueInput,
    Iterable<_i2.WebinarPlanWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class TopicCreateWithoutClassPlansInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TopicCreateWithoutClassPlansInput({
    this.id,
    required this.name,
    this.createdAt,
    this.updatedAt,
    this.webinarPlans,
  });

  final String? id;

  final String name;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.WebinarPlanCreateNestedManyWithoutTopicsInput? webinarPlans;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'webinarPlans': webinarPlans,
  };
}

class TopicCreateNestedManyWithoutClassPlansInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TopicCreateNestedManyWithoutClassPlansInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.TopicCreateWithoutClassPlansInput,
    _i1.PrismaUnion<
      Iterable<_i2.TopicCreateWithoutClassPlansInput>,
      _i1.PrismaUnion<
        _i2.TopicUncheckedCreateWithoutClassPlansInput,
        Iterable<_i2.TopicUncheckedCreateWithoutClassPlansInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.TopicCreateOrConnectWithoutClassPlansInput,
    Iterable<_i2.TopicCreateOrConnectWithoutClassPlansInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.TopicWhereUniqueInput,
    Iterable<_i2.TopicWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class ClassCreateNestedManyWithoutClassPlanInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassCreateNestedManyWithoutClassPlanInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.ClassCreateWithoutClassPlanInput,
    _i1.PrismaUnion<
      Iterable<_i2.ClassCreateWithoutClassPlanInput>,
      _i1.PrismaUnion<
        _i2.ClassUncheckedCreateWithoutClassPlanInput,
        Iterable<_i2.ClassUncheckedCreateWithoutClassPlanInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.ClassCreateOrConnectWithoutClassPlanInput,
    Iterable<_i2.ClassCreateOrConnectWithoutClassPlanInput>
  >?
  connectOrCreate;

  final _i2.ClassCreateManyClassPlanInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.ClassWhereUniqueInput,
    Iterable<_i2.ClassWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class ClassPlanCreateWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanCreateWithoutConsultantProfileInput({
    this.id,
    required this.title,
    required this.description,
    required this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInMonths,
    this.callsPerWeek,
    this.videoMeetings,
    this.emailSupport,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.createdAt,
    this.updatedAt,
    this.topics,
    this.classContents,
    this.classes,
  });

  final String? id;

  final String title;

  final String description;

  final int price;

  final String? priceCurrency;

  final bool? certificateProvided;

  final int? durationInMonths;

  final int? callsPerWeek;

  final int? videoMeetings;

  final _i3.PlanEmailSupport? emailSupport;

  final int? maxParticipants;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? language;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? level;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? prerequisites;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? materialProvided;

  final _i1.PrismaUnion<
    _i2.ClassPlanCreatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.TopicCreateNestedManyWithoutClassPlansInput? topics;

  final _i2.ClassContentCreateNestedManyWithoutClassPlanInput? classContents;

  final _i2.ClassCreateNestedManyWithoutClassPlanInput? classes;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInMonths': durationInMonths,
    'callsPerWeek': callsPerWeek,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'topics': topics,
    'classContents': classContents,
    'classes': classes,
  };
}

class ClassPlanCreateNestedManyWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanCreateNestedManyWithoutConsultantProfileInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.ClassPlanCreateWithoutConsultantProfileInput,
    _i1.PrismaUnion<
      Iterable<_i2.ClassPlanCreateWithoutConsultantProfileInput>,
      _i1.PrismaUnion<
        _i2.ClassPlanUncheckedCreateWithoutConsultantProfileInput,
        Iterable<_i2.ClassPlanUncheckedCreateWithoutConsultantProfileInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.ClassPlanCreateOrConnectWithoutConsultantProfileInput,
    Iterable<_i2.ClassPlanCreateOrConnectWithoutConsultantProfileInput>
  >?
  connectOrCreate;

  final _i2.ClassPlanCreateManyConsultantProfileInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.ClassPlanWhereUniqueInput,
    Iterable<_i2.ClassPlanWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class ConsultantProfileCreateWithoutWebinarPlansInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileCreateWithoutWebinarPlansInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    required this.scheduleType,
    this.createdAt,
    this.updatedAt,
    required this.domain,
    this.subDomains,
    this.tags,
    this.reviews,
    this.slotsOfAvailabilityWeekly,
    this.slotsOfAvailabilityCustom,
    this.consultationPlans,
    this.subscriptionPlans,
    this.classPlans,
    required this.user,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? qualifications;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? specialization;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? experience;

  final double? rating;

  final _i3.ScheduleType scheduleType;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.DomainCreateNestedOneWithoutConsultantProfilesInput domain;

  final _i2.SubDomainCreateNestedManyWithoutConsultantProfilesInput? subDomains;

  final _i2.TagCreateNestedManyWithoutConsultantProfilesInput? tags;

  final _i2.ConsultantReviewCreateNestedManyWithoutConsultantProfileInput?
  reviews;

  final _i2.SlotOfAvailabilityWeeklyCreateNestedManyWithoutConsultantProfileInput?
  slotsOfAvailabilityWeekly;

  final _i2.SlotOfAvailabilityCustomCreateNestedManyWithoutConsultantProfileInput?
  slotsOfAvailabilityCustom;

  final _i2.ConsultationPlanCreateNestedManyWithoutConsultantProfileInput?
  consultationPlans;

  final _i2.SubscriptionPlanCreateNestedManyWithoutConsultantProfileInput?
  subscriptionPlans;

  final _i2.ClassPlanCreateNestedManyWithoutConsultantProfileInput? classPlans;

  final _i2.UserCreateNestedOneWithoutConsultantProfileInput user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'scheduleType': scheduleType,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'domain': domain,
    'subDomains': subDomains,
    'tags': tags,
    'reviews': reviews,
    'slotsOfAvailabilityWeekly': slotsOfAvailabilityWeekly,
    'slotsOfAvailabilityCustom': slotsOfAvailabilityCustom,
    'consultationPlans': consultationPlans,
    'subscriptionPlans': subscriptionPlans,
    'classPlans': classPlans,
    'user': user,
  };
}

class ConsultantProfileUncheckedCreateWithoutWebinarPlansInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUncheckedCreateWithoutWebinarPlansInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    required this.domainId,
    required this.scheduleType,
    required this.userId,
    this.createdAt,
    this.updatedAt,
    this.subDomains,
    this.tags,
    this.reviews,
    this.slotsOfAvailabilityWeekly,
    this.slotsOfAvailabilityCustom,
    this.consultationPlans,
    this.subscriptionPlans,
    this.classPlans,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? qualifications;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? specialization;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? experience;

  final double? rating;

  final String domainId;

  final _i3.ScheduleType scheduleType;

  final String userId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.SubDomainUncheckedCreateNestedManyWithoutConsultantProfilesInput?
  subDomains;

  final _i2.TagUncheckedCreateNestedManyWithoutConsultantProfilesInput? tags;

  final _i2.ConsultantReviewUncheckedCreateNestedManyWithoutConsultantProfileInput?
  reviews;

  final _i2.SlotOfAvailabilityWeeklyUncheckedCreateNestedManyWithoutConsultantProfileInput?
  slotsOfAvailabilityWeekly;

  final _i2.SlotOfAvailabilityCustomUncheckedCreateNestedManyWithoutConsultantProfileInput?
  slotsOfAvailabilityCustom;

  final _i2.ConsultationPlanUncheckedCreateNestedManyWithoutConsultantProfileInput?
  consultationPlans;

  final _i2.SubscriptionPlanUncheckedCreateNestedManyWithoutConsultantProfileInput?
  subscriptionPlans;

  final _i2.ClassPlanUncheckedCreateNestedManyWithoutConsultantProfileInput?
  classPlans;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'domainId': domainId,
    'scheduleType': scheduleType,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'subDomains': subDomains,
    'tags': tags,
    'reviews': reviews,
    'slotsOfAvailabilityWeekly': slotsOfAvailabilityWeekly,
    'slotsOfAvailabilityCustom': slotsOfAvailabilityCustom,
    'consultationPlans': consultationPlans,
    'subscriptionPlans': subscriptionPlans,
    'classPlans': classPlans,
  };
}

class ConsultantProfileCreateOrConnectWithoutWebinarPlansInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileCreateOrConnectWithoutWebinarPlansInput({
    required this.where,
    required this.create,
  });

  final _i2.ConsultantProfileWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateWithoutWebinarPlansInput,
    _i2.ConsultantProfileUncheckedCreateWithoutWebinarPlansInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class ConsultantProfileCreateNestedOneWithoutWebinarPlansInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileCreateNestedOneWithoutWebinarPlansInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateWithoutWebinarPlansInput,
    _i2.ConsultantProfileUncheckedCreateWithoutWebinarPlansInput
  >?
  create;

  final _i2.ConsultantProfileCreateOrConnectWithoutWebinarPlansInput?
  connectOrCreate;

  final _i2.ConsultantProfileWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class WebinarPlanCreateWithoutWebinarsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanCreateWithoutWebinarsInput({
    this.id,
    required this.title,
    this.description,
    required this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInHours,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.createdAt,
    this.updatedAt,
    this.topics,
    this.consultantProfile,
  });

  final String? id;

  final String title;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final int price;

  final String? priceCurrency;

  final bool? certificateProvided;

  final double? durationInHours;

  final int? maxParticipants;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? language;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? level;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? prerequisites;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? materialProvided;

  final _i1.PrismaUnion<
    _i2.WebinarPlanCreatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.TopicCreateNestedManyWithoutWebinarPlansInput? topics;

  final _i2.ConsultantProfileCreateNestedOneWithoutWebinarPlansInput?
  consultantProfile;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInHours': durationInHours,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'topics': topics,
    'consultantProfile': consultantProfile,
  };
}

class WebinarPlanUncheckedCreateWithoutWebinarsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanUncheckedCreateWithoutWebinarsInput({
    this.id,
    required this.title,
    this.description,
    required this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInHours,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.topics,
  });

  final String? id;

  final String title;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final int price;

  final String? priceCurrency;

  final bool? certificateProvided;

  final double? durationInHours;

  final int? maxParticipants;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? language;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? level;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? prerequisites;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? materialProvided;

  final _i1.PrismaUnion<
    _i2.WebinarPlanCreatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consultantProfileId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.TopicUncheckedCreateNestedManyWithoutWebinarPlansInput? topics;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInHours': durationInHours,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'topics': topics,
  };
}

class WebinarPlanCreateOrConnectWithoutWebinarsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanCreateOrConnectWithoutWebinarsInput({
    required this.where,
    required this.create,
  });

  final _i2.WebinarPlanWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.WebinarPlanCreateWithoutWebinarsInput,
    _i2.WebinarPlanUncheckedCreateWithoutWebinarsInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class WebinarPlanCreateNestedOneWithoutWebinarsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanCreateNestedOneWithoutWebinarsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.WebinarPlanCreateWithoutWebinarsInput,
    _i2.WebinarPlanUncheckedCreateWithoutWebinarsInput
  >?
  create;

  final _i2.WebinarPlanCreateOrConnectWithoutWebinarsInput? connectOrCreate;

  final _i2.WebinarPlanWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class WebinarCreateWithoutWaitlistInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarCreateWithoutWaitlistInput({
    this.id,
    this.status,
    this.feedbackSummary,
    this.createdAt,
    this.updatedAt,
    required this.webinarPlan,
    this.appointment,
  });

  final String? id;

  final _i3.WebinarStatus? status;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackSummary;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.WebinarPlanCreateNestedOneWithoutWebinarsInput webinarPlan;

  final _i2.AppointmentCreateNestedOneWithoutWebinarInput? appointment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'status': status,
    'feedbackSummary': feedbackSummary,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'webinarPlan': webinarPlan,
    'appointment': appointment,
  };
}

class WebinarUncheckedCreateWithoutWaitlistInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarUncheckedCreateWithoutWaitlistInput({
    this.id,
    this.status,
    this.feedbackSummary,
    required this.webinarPlanId,
    this.createdAt,
    this.updatedAt,
    this.appointment,
  });

  final String? id;

  final _i3.WebinarStatus? status;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackSummary;

  final String webinarPlanId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.AppointmentUncheckedCreateNestedOneWithoutWebinarInput? appointment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'status': status,
    'feedbackSummary': feedbackSummary,
    'webinarPlanId': webinarPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'appointment': appointment,
  };
}

class WebinarCreateOrConnectWithoutWaitlistInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarCreateOrConnectWithoutWaitlistInput({
    required this.where,
    required this.create,
  });

  final _i2.WebinarWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.WebinarCreateWithoutWaitlistInput,
    _i2.WebinarUncheckedCreateWithoutWaitlistInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class WebinarCreateNestedOneWithoutWaitlistInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarCreateNestedOneWithoutWaitlistInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.WebinarCreateWithoutWaitlistInput,
    _i2.WebinarUncheckedCreateWithoutWaitlistInput
  >?
  create;

  final _i2.WebinarCreateOrConnectWithoutWaitlistInput? connectOrCreate;

  final _i2.WebinarWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class WaitlistCreateWithoutClassInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistCreateWithoutClassInput({
    this.id,
    this.joinedAt,
    required this.user,
    this.webinar,
  });

  final String? id;

  final DateTime? joinedAt;

  final _i2.UserCreateNestedOneWithoutWaitlistInput user;

  final _i2.WebinarCreateNestedOneWithoutWaitlistInput? webinar;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'joinedAt': joinedAt,
    'user': user,
    'webinar': webinar,
  };
}

class WaitlistCreateNestedManyWithoutClassInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistCreateNestedManyWithoutClassInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.WaitlistCreateWithoutClassInput,
    _i1.PrismaUnion<
      Iterable<_i2.WaitlistCreateWithoutClassInput>,
      _i1.PrismaUnion<
        _i2.WaitlistUncheckedCreateWithoutClassInput,
        Iterable<_i2.WaitlistUncheckedCreateWithoutClassInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.WaitlistCreateOrConnectWithoutClassInput,
    Iterable<_i2.WaitlistCreateOrConnectWithoutClassInput>
  >?
  connectOrCreate;

  final _i2.WaitlistCreateManyClassInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.WaitlistWhereUniqueInput,
    Iterable<_i2.WaitlistWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class ClassCreateWithoutAppointmentsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassCreateWithoutAppointmentsInput({
    this.id,
    this.startDate,
    this.endDate,
    this.status,
    this.recordingUrls,
    this.feedbackSummary,
    this.createdAt,
    this.updatedAt,
    this.waitlist,
    required this.classPlan,
  });

  final String? id;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? startDate;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? endDate;

  final _i3.ClassStatus? status;

  final _i1.PrismaUnion<_i2.ClassCreaterecordingUrlsInput, Iterable<String>>?
  recordingUrls;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackSummary;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.WaitlistCreateNestedManyWithoutClassInput? waitlist;

  final _i2.ClassPlanCreateNestedOneWithoutClassesInput classPlan;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'status': status,
    'recordingUrls': recordingUrls,
    'feedbackSummary': feedbackSummary,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'waitlist': waitlist,
    'classPlan': classPlan,
  };
}

class ClassUncheckedCreateWithoutAppointmentsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassUncheckedCreateWithoutAppointmentsInput({
    this.id,
    this.startDate,
    this.endDate,
    this.status,
    this.recordingUrls,
    this.feedbackSummary,
    required this.classPlanId,
    this.createdAt,
    this.updatedAt,
    this.waitlist,
  });

  final String? id;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? startDate;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? endDate;

  final _i3.ClassStatus? status;

  final _i1.PrismaUnion<_i2.ClassCreaterecordingUrlsInput, Iterable<String>>?
  recordingUrls;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackSummary;

  final String classPlanId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.WaitlistUncheckedCreateNestedManyWithoutClassInput? waitlist;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'status': status,
    'recordingUrls': recordingUrls,
    'feedbackSummary': feedbackSummary,
    'classPlanId': classPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'waitlist': waitlist,
  };
}

class ClassCreateOrConnectWithoutAppointmentsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassCreateOrConnectWithoutAppointmentsInput({
    required this.where,
    required this.create,
  });

  final _i2.ClassWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.ClassCreateWithoutAppointmentsInput,
    _i2.ClassUncheckedCreateWithoutAppointmentsInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class ClassCreateNestedOneWithoutAppointmentsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassCreateNestedOneWithoutAppointmentsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.ClassCreateWithoutAppointmentsInput,
    _i2.ClassUncheckedCreateWithoutAppointmentsInput
  >?
  create;

  final _i2.ClassCreateOrConnectWithoutAppointmentsInput? connectOrCreate;

  final _i2.ClassWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class AppointmentCreateWithoutSlotsOfAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentCreateWithoutSlotsOfAppointmentInput({
    this.id,
    required this.appointmentType,
    this.createdAt,
    this.updatedAt,
    this.consultation,
    this.subscription,
    this.webinar,
    this.$class,
    this.payment,
  });

  final String? id;

  final _i3.AppointmentsType appointmentType;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ConsultationCreateNestedOneWithoutAppointmentInput? consultation;

  final _i2.SubscriptionCreateNestedOneWithoutAppointmentsInput? subscription;

  final _i2.WebinarCreateNestedOneWithoutAppointmentInput? webinar;

  final _i2.ClassCreateNestedOneWithoutAppointmentsInput? $class;

  final _i2.PaymentCreateNestedManyWithoutAppointmentInput? payment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'appointmentType': appointmentType,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultation': consultation,
    'subscription': subscription,
    'webinar': webinar,
    'class': $class,
    'payment': payment,
  };
}

class AppointmentUncheckedCreateWithoutSlotsOfAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentUncheckedCreateWithoutSlotsOfAppointmentInput({
    this.id,
    required this.appointmentType,
    this.consultationId,
    this.subscriptionId,
    this.webinarId,
    this.classId,
    this.createdAt,
    this.updatedAt,
    this.payment,
  });

  final String? id;

  final _i3.AppointmentsType appointmentType;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consultationId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? subscriptionId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? webinarId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? classId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.PaymentUncheckedCreateNestedManyWithoutAppointmentInput? payment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'appointmentType': appointmentType,
    'consultationId': consultationId,
    'subscriptionId': subscriptionId,
    'webinarId': webinarId,
    'classId': classId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'payment': payment,
  };
}

class AppointmentCreateOrConnectWithoutSlotsOfAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentCreateOrConnectWithoutSlotsOfAppointmentInput({
    required this.where,
    required this.create,
  });

  final _i2.AppointmentWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.AppointmentCreateWithoutSlotsOfAppointmentInput,
    _i2.AppointmentUncheckedCreateWithoutSlotsOfAppointmentInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class AppointmentCreateNestedOneWithoutSlotsOfAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentCreateNestedOneWithoutSlotsOfAppointmentInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.AppointmentCreateWithoutSlotsOfAppointmentInput,
    _i2.AppointmentUncheckedCreateWithoutSlotsOfAppointmentInput
  >?
  create;

  final _i2.AppointmentCreateOrConnectWithoutSlotsOfAppointmentInput?
  connectOrCreate;

  final _i2.AppointmentWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class MeetingSessionCreateNestedOneWithoutSlotOfAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const MeetingSessionCreateNestedOneWithoutSlotOfAppointmentInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.MeetingSessionCreateWithoutSlotOfAppointmentInput,
    _i2.MeetingSessionUncheckedCreateWithoutSlotOfAppointmentInput
  >?
  create;

  final _i2.MeetingSessionCreateOrConnectWithoutSlotOfAppointmentInput?
  connectOrCreate;

  final _i2.MeetingSessionWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class SlotOfAppointmentCreateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentCreateWithoutUserInput({
    this.id,
    required this.slotStartTimeInUTC,
    required this.slotEndTimeInUTC,
    this.isTentative,
    this.createdAt,
    this.updatedAt,
    required this.appointment,
    this.meetingSession,
  });

  final String? id;

  final DateTime slotStartTimeInUTC;

  final DateTime slotEndTimeInUTC;

  final bool? isTentative;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.AppointmentCreateNestedOneWithoutSlotsOfAppointmentInput
  appointment;

  final _i2.MeetingSessionCreateNestedOneWithoutSlotOfAppointmentInput?
  meetingSession;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'isTentative': isTentative,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'appointment': appointment,
    'meetingSession': meetingSession,
  };
}

class SlotOfAppointmentCreateNestedManyWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentCreateNestedManyWithoutUserInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentCreateWithoutUserInput,
    _i1.PrismaUnion<
      Iterable<_i2.SlotOfAppointmentCreateWithoutUserInput>,
      _i1.PrismaUnion<
        _i2.SlotOfAppointmentUncheckedCreateWithoutUserInput,
        Iterable<_i2.SlotOfAppointmentUncheckedCreateWithoutUserInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentCreateOrConnectWithoutUserInput,
    Iterable<_i2.SlotOfAppointmentCreateOrConnectWithoutUserInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentWhereUniqueInput,
    Iterable<_i2.SlotOfAppointmentWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class UserCreateWithoutWaitlistInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateWithoutWaitlistInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.cookiePreferences,
    this.notificationPreferences,
    this.payment,
    this.consultantProfile,
    this.consulteeProfile,
    this.staffProfile,
    this.slotsOfAppointment,
    this.feedbacks,
    this.supportTickets,
    this.supportResponses,
    this.accounts,
    this.sessions,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? email;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? emailVerified;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? image;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? address;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? password;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? passwordResetToken;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? passwordResetExpires;

  final bool? onlineStatus;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? currentTimezone;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? onboardingCompleted;

  final _i1.PrismaUnion<_i3.UserRole, _i1.PrismaNull>? role;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consultantProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consulteeProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? staffProfileId;

  final _i2.CookiePreferenceCreateNestedOneWithoutUserInput? cookiePreferences;

  final _i2.NotificationPreferenceCreateNestedOneWithoutUserInput?
  notificationPreferences;

  final _i2.PaymentCreateNestedManyWithoutUserInput? payment;

  final _i2.ConsultantProfileCreateNestedOneWithoutUserInput? consultantProfile;

  final _i2.ConsulteeProfileCreateNestedOneWithoutUserInput? consulteeProfile;

  final _i2.StaffProfileCreateNestedOneWithoutUserInput? staffProfile;

  final _i2.SlotOfAppointmentCreateNestedManyWithoutUserInput?
  slotsOfAppointment;

  final _i2.FeedbackCreateNestedManyWithoutUserInput? feedbacks;

  final _i2.SupportTicketCreateNestedManyWithoutUserInput? supportTickets;

  final _i2.SupportResponseCreateNestedManyWithoutUserInput? supportResponses;

  final _i2.AccountCreateNestedManyWithoutUserInput? accounts;

  final _i2.SessionCreateNestedManyWithoutUserInput? sessions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'cookiePreferences': cookiePreferences,
    'notificationPreferences': notificationPreferences,
    'Payment': payment,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
    'staffProfile': staffProfile,
    'slotsOfAppointment': slotsOfAppointment,
    'feedbacks': feedbacks,
    'supportTickets': supportTickets,
    'supportResponses': supportResponses,
    'accounts': accounts,
    'sessions': sessions,
  };
}

class UserUncheckedCreateWithoutWaitlistInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUncheckedCreateWithoutWaitlistInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.cookiePreferences,
    this.notificationPreferences,
    this.payment,
    this.consultantProfile,
    this.consulteeProfile,
    this.staffProfile,
    this.slotsOfAppointment,
    this.feedbacks,
    this.supportTickets,
    this.supportResponses,
    this.accounts,
    this.sessions,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? email;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? emailVerified;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? image;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? address;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? password;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? passwordResetToken;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? passwordResetExpires;

  final bool? onlineStatus;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? currentTimezone;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? onboardingCompleted;

  final _i1.PrismaUnion<_i3.UserRole, _i1.PrismaNull>? role;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consultantProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consulteeProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? staffProfileId;

  final _i2.CookiePreferenceUncheckedCreateNestedOneWithoutUserInput?
  cookiePreferences;

  final _i2.NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput?
  notificationPreferences;

  final _i2.PaymentUncheckedCreateNestedManyWithoutUserInput? payment;

  final _i2.ConsultantProfileUncheckedCreateNestedOneWithoutUserInput?
  consultantProfile;

  final _i2.ConsulteeProfileUncheckedCreateNestedOneWithoutUserInput?
  consulteeProfile;

  final _i2.StaffProfileUncheckedCreateNestedOneWithoutUserInput? staffProfile;

  final _i2.SlotOfAppointmentUncheckedCreateNestedManyWithoutUserInput?
  slotsOfAppointment;

  final _i2.FeedbackUncheckedCreateNestedManyWithoutUserInput? feedbacks;

  final _i2.SupportTicketUncheckedCreateNestedManyWithoutUserInput?
  supportTickets;

  final _i2.SupportResponseUncheckedCreateNestedManyWithoutUserInput?
  supportResponses;

  final _i2.AccountUncheckedCreateNestedManyWithoutUserInput? accounts;

  final _i2.SessionUncheckedCreateNestedManyWithoutUserInput? sessions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'cookiePreferences': cookiePreferences,
    'notificationPreferences': notificationPreferences,
    'Payment': payment,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
    'staffProfile': staffProfile,
    'slotsOfAppointment': slotsOfAppointment,
    'feedbacks': feedbacks,
    'supportTickets': supportTickets,
    'supportResponses': supportResponses,
    'accounts': accounts,
    'sessions': sessions,
  };
}

class UserCreateOrConnectWithoutWaitlistInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateOrConnectWithoutWaitlistInput({
    required this.where,
    required this.create,
  });

  final _i2.UserWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.UserCreateWithoutWaitlistInput,
    _i2.UserUncheckedCreateWithoutWaitlistInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class UserCreateNestedOneWithoutWaitlistInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateNestedOneWithoutWaitlistInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.UserCreateWithoutWaitlistInput,
    _i2.UserUncheckedCreateWithoutWaitlistInput
  >?
  create;

  final _i2.UserCreateOrConnectWithoutWaitlistInput? connectOrCreate;

  final _i2.UserWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class WaitlistCreateWithoutWebinarInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistCreateWithoutWebinarInput({
    this.id,
    this.joinedAt,
    required this.user,
    this.$class,
  });

  final String? id;

  final DateTime? joinedAt;

  final _i2.UserCreateNestedOneWithoutWaitlistInput user;

  final _i2.ClassCreateNestedOneWithoutWaitlistInput? $class;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'joinedAt': joinedAt,
    'user': user,
    'class': $class,
  };
}

class WaitlistCreateNestedManyWithoutWebinarInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistCreateNestedManyWithoutWebinarInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.WaitlistCreateWithoutWebinarInput,
    _i1.PrismaUnion<
      Iterable<_i2.WaitlistCreateWithoutWebinarInput>,
      _i1.PrismaUnion<
        _i2.WaitlistUncheckedCreateWithoutWebinarInput,
        Iterable<_i2.WaitlistUncheckedCreateWithoutWebinarInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.WaitlistCreateOrConnectWithoutWebinarInput,
    Iterable<_i2.WaitlistCreateOrConnectWithoutWebinarInput>
  >?
  connectOrCreate;

  final _i2.WaitlistCreateManyWebinarInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.WaitlistWhereUniqueInput,
    Iterable<_i2.WaitlistWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class WebinarCreateWithoutAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarCreateWithoutAppointmentInput({
    this.id,
    this.status,
    this.feedbackSummary,
    this.createdAt,
    this.updatedAt,
    this.waitlist,
    required this.webinarPlan,
  });

  final String? id;

  final _i3.WebinarStatus? status;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackSummary;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.WaitlistCreateNestedManyWithoutWebinarInput? waitlist;

  final _i2.WebinarPlanCreateNestedOneWithoutWebinarsInput webinarPlan;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'status': status,
    'feedbackSummary': feedbackSummary,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'waitlist': waitlist,
    'webinarPlan': webinarPlan,
  };
}

class WebinarUncheckedCreateWithoutAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarUncheckedCreateWithoutAppointmentInput({
    this.id,
    this.status,
    this.feedbackSummary,
    required this.webinarPlanId,
    this.createdAt,
    this.updatedAt,
    this.waitlist,
  });

  final String? id;

  final _i3.WebinarStatus? status;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackSummary;

  final String webinarPlanId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.WaitlistUncheckedCreateNestedManyWithoutWebinarInput? waitlist;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'status': status,
    'feedbackSummary': feedbackSummary,
    'webinarPlanId': webinarPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'waitlist': waitlist,
  };
}

class WebinarCreateOrConnectWithoutAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarCreateOrConnectWithoutAppointmentInput({
    required this.where,
    required this.create,
  });

  final _i2.WebinarWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.WebinarCreateWithoutAppointmentInput,
    _i2.WebinarUncheckedCreateWithoutAppointmentInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class WebinarCreateNestedOneWithoutAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarCreateNestedOneWithoutAppointmentInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.WebinarCreateWithoutAppointmentInput,
    _i2.WebinarUncheckedCreateWithoutAppointmentInput
  >?
  create;

  final _i2.WebinarCreateOrConnectWithoutAppointmentInput? connectOrCreate;

  final _i2.WebinarWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class AppointmentCreateWithoutConsultationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentCreateWithoutConsultationInput({
    this.id,
    required this.appointmentType,
    this.createdAt,
    this.updatedAt,
    this.slotsOfAppointment,
    this.subscription,
    this.webinar,
    this.$class,
    this.payment,
  });

  final String? id;

  final _i3.AppointmentsType appointmentType;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.SlotOfAppointmentCreateNestedManyWithoutAppointmentInput?
  slotsOfAppointment;

  final _i2.SubscriptionCreateNestedOneWithoutAppointmentsInput? subscription;

  final _i2.WebinarCreateNestedOneWithoutAppointmentInput? webinar;

  final _i2.ClassCreateNestedOneWithoutAppointmentsInput? $class;

  final _i2.PaymentCreateNestedManyWithoutAppointmentInput? payment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'appointmentType': appointmentType,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'slotsOfAppointment': slotsOfAppointment,
    'subscription': subscription,
    'webinar': webinar,
    'class': $class,
    'payment': payment,
  };
}

class AppointmentUncheckedCreateWithoutConsultationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentUncheckedCreateWithoutConsultationInput({
    this.id,
    required this.appointmentType,
    this.subscriptionId,
    this.webinarId,
    this.classId,
    this.createdAt,
    this.updatedAt,
    this.slotsOfAppointment,
    this.payment,
  });

  final String? id;

  final _i3.AppointmentsType appointmentType;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? subscriptionId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? webinarId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? classId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.SlotOfAppointmentUncheckedCreateNestedManyWithoutAppointmentInput?
  slotsOfAppointment;

  final _i2.PaymentUncheckedCreateNestedManyWithoutAppointmentInput? payment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'appointmentType': appointmentType,
    'subscriptionId': subscriptionId,
    'webinarId': webinarId,
    'classId': classId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'slotsOfAppointment': slotsOfAppointment,
    'payment': payment,
  };
}

class AppointmentCreateOrConnectWithoutConsultationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentCreateOrConnectWithoutConsultationInput({
    required this.where,
    required this.create,
  });

  final _i2.AppointmentWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.AppointmentCreateWithoutConsultationInput,
    _i2.AppointmentUncheckedCreateWithoutConsultationInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class AppointmentUncheckedCreateNestedOneWithoutConsultationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentUncheckedCreateNestedOneWithoutConsultationInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.AppointmentCreateWithoutConsultationInput,
    _i2.AppointmentUncheckedCreateWithoutConsultationInput
  >?
  create;

  final _i2.AppointmentCreateOrConnectWithoutConsultationInput? connectOrCreate;

  final _i2.AppointmentWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class ConsultationUncheckedCreateWithoutRequestedByInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationUncheckedCreateWithoutRequestedByInput({
    this.id,
    required this.consultationPlanId,
    this.requestStatus,
    this.requestedAt,
    this.requestNotes,
    this.directlyBooked,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.createdAt,
    this.updatedAt,
    this.appointment,
  });

  final String? id;

  final String consultationPlanId;

  final _i3.RequestStatus? requestStatus;

  final DateTime? requestedAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? requestNotes;

  final bool? directlyBooked;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackFromConsultee;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackFromConsultant;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? rating;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.AppointmentUncheckedCreateNestedOneWithoutConsultationInput?
  appointment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'consultationPlanId': consultationPlanId,
    'requestStatus': requestStatus,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'directlyBooked': directlyBooked,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'appointment': appointment,
  };
}

class ConsultationCreateOrConnectWithoutRequestedByInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationCreateOrConnectWithoutRequestedByInput({
    required this.where,
    required this.create,
  });

  final _i2.ConsultationWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.ConsultationCreateWithoutRequestedByInput,
    _i2.ConsultationUncheckedCreateWithoutRequestedByInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class ConsultationCreateManyRequestedByInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationCreateManyRequestedByInput({
    this.id,
    required this.consultationPlanId,
    this.requestStatus,
    this.requestedAt,
    this.requestNotes,
    this.directlyBooked,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final String consultationPlanId;

  final _i3.RequestStatus? requestStatus;

  final DateTime? requestedAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? requestNotes;

  final bool? directlyBooked;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackFromConsultee;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackFromConsultant;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? rating;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'consultationPlanId': consultationPlanId,
    'requestStatus': requestStatus,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'directlyBooked': directlyBooked,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultationCreateManyRequestedByInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationCreateManyRequestedByInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<
    _i2.ConsultationCreateManyRequestedByInput,
    Iterable<_i2.ConsultationCreateManyRequestedByInput>
  >
  data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
    'data': data,
    'skipDuplicates': skipDuplicates,
  };
}

class ConsultationUncheckedCreateNestedManyWithoutRequestedByInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationUncheckedCreateNestedManyWithoutRequestedByInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.ConsultationCreateWithoutRequestedByInput,
    _i1.PrismaUnion<
      Iterable<_i2.ConsultationCreateWithoutRequestedByInput>,
      _i1.PrismaUnion<
        _i2.ConsultationUncheckedCreateWithoutRequestedByInput,
        Iterable<_i2.ConsultationUncheckedCreateWithoutRequestedByInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.ConsultationCreateOrConnectWithoutRequestedByInput,
    Iterable<_i2.ConsultationCreateOrConnectWithoutRequestedByInput>
  >?
  connectOrCreate;

  final _i2.ConsultationCreateManyRequestedByInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.ConsultationWhereUniqueInput,
    Iterable<_i2.ConsultationWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class SubscriptionUncheckedCreateWithoutRequestedByInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionUncheckedCreateWithoutRequestedByInput({
    this.id,
    this.startDate,
    required this.endDate,
    this.requestStatus,
    this.requestedAt,
    this.requestNotes,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    required this.subscriptionPlanId,
    this.createdAt,
    this.updatedAt,
    this.appointments,
  });

  final String? id;

  final DateTime? startDate;

  final DateTime endDate;

  final _i3.RequestStatus? requestStatus;

  final DateTime? requestedAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? requestNotes;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackFromConsultee;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackFromConsultant;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? rating;

  final String subscriptionPlanId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.AppointmentUncheckedCreateNestedManyWithoutSubscriptionInput?
  appointments;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'requestStatus': requestStatus,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'subscriptionPlanId': subscriptionPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'appointments': appointments,
  };
}

class SubscriptionCreateOrConnectWithoutRequestedByInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionCreateOrConnectWithoutRequestedByInput({
    required this.where,
    required this.create,
  });

  final _i2.SubscriptionWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.SubscriptionCreateWithoutRequestedByInput,
    _i2.SubscriptionUncheckedCreateWithoutRequestedByInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class SubscriptionCreateManyRequestedByInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionCreateManyRequestedByInput({
    this.id,
    this.startDate,
    required this.endDate,
    this.requestStatus,
    this.requestedAt,
    this.requestNotes,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    required this.subscriptionPlanId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final DateTime? startDate;

  final DateTime endDate;

  final _i3.RequestStatus? requestStatus;

  final DateTime? requestedAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? requestNotes;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackFromConsultee;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackFromConsultant;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? rating;

  final String subscriptionPlanId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'requestStatus': requestStatus,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'subscriptionPlanId': subscriptionPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SubscriptionCreateManyRequestedByInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionCreateManyRequestedByInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<
    _i2.SubscriptionCreateManyRequestedByInput,
    Iterable<_i2.SubscriptionCreateManyRequestedByInput>
  >
  data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
    'data': data,
    'skipDuplicates': skipDuplicates,
  };
}

class SubscriptionUncheckedCreateNestedManyWithoutRequestedByInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionUncheckedCreateNestedManyWithoutRequestedByInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.SubscriptionCreateWithoutRequestedByInput,
    _i1.PrismaUnion<
      Iterable<_i2.SubscriptionCreateWithoutRequestedByInput>,
      _i1.PrismaUnion<
        _i2.SubscriptionUncheckedCreateWithoutRequestedByInput,
        Iterable<_i2.SubscriptionUncheckedCreateWithoutRequestedByInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.SubscriptionCreateOrConnectWithoutRequestedByInput,
    Iterable<_i2.SubscriptionCreateOrConnectWithoutRequestedByInput>
  >?
  connectOrCreate;

  final _i2.SubscriptionCreateManyRequestedByInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.SubscriptionWhereUniqueInput,
    Iterable<_i2.SubscriptionWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class ConsultantReviewUncheckedCreateWithoutConsulteeProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewUncheckedCreateWithoutConsulteeProfileInput({
    this.id,
    this.rating,
    this.reviewDescription,
    required this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final int? rating;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? reviewDescription;

  final String consultantProfileId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'rating': rating,
    'reviewDescription': reviewDescription,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultantReviewCreateOrConnectWithoutConsulteeProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewCreateOrConnectWithoutConsulteeProfileInput({
    required this.where,
    required this.create,
  });

  final _i2.ConsultantReviewWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewCreateWithoutConsulteeProfileInput,
    _i2.ConsultantReviewUncheckedCreateWithoutConsulteeProfileInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class ConsultantReviewCreateManyConsulteeProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewCreateManyConsulteeProfileInput({
    this.id,
    this.rating,
    this.reviewDescription,
    required this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final int? rating;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? reviewDescription;

  final String consultantProfileId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'rating': rating,
    'reviewDescription': reviewDescription,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultantReviewCreateManyConsulteeProfileInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewCreateManyConsulteeProfileInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<
    _i2.ConsultantReviewCreateManyConsulteeProfileInput,
    Iterable<_i2.ConsultantReviewCreateManyConsulteeProfileInput>
  >
  data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
    'data': data,
    'skipDuplicates': skipDuplicates,
  };
}

class ConsultantReviewUncheckedCreateNestedManyWithoutConsulteeProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewUncheckedCreateNestedManyWithoutConsulteeProfileInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.ConsultantReviewCreateWithoutConsulteeProfileInput,
    _i1.PrismaUnion<
      Iterable<_i2.ConsultantReviewCreateWithoutConsulteeProfileInput>,
      _i1.PrismaUnion<
        _i2.ConsultantReviewUncheckedCreateWithoutConsulteeProfileInput,
        Iterable<
          _i2.ConsultantReviewUncheckedCreateWithoutConsulteeProfileInput
        >
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewCreateOrConnectWithoutConsulteeProfileInput,
    Iterable<_i2.ConsultantReviewCreateOrConnectWithoutConsulteeProfileInput>
  >?
  connectOrCreate;

  final _i2.ConsultantReviewCreateManyConsulteeProfileInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewWhereUniqueInput,
    Iterable<_i2.ConsultantReviewWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class ConsulteeProfileUncheckedCreateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileUncheckedCreateWithoutUserInput({
    this.id,
    this.education,
    this.occupation,
    this.aboutMe,
    this.preferredCommunicationMethod,
    this.preferredLanguage,
    this.specialRequirements,
    this.interests,
    this.goals,
    this.createdAt,
    this.updatedAt,
    this.consultationRequests,
    this.subscriptionRequests,
    this.consultantReviews,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? education;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? occupation;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? aboutMe;

  final _i1.PrismaUnion<_i3.ConsultationMode, _i1.PrismaNull>?
  preferredCommunicationMethod;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? preferredLanguage;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? specialRequirements;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? interests;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? goals;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ConsultationUncheckedCreateNestedManyWithoutRequestedByInput?
  consultationRequests;

  final _i2.SubscriptionUncheckedCreateNestedManyWithoutRequestedByInput?
  subscriptionRequests;

  final _i2.ConsultantReviewUncheckedCreateNestedManyWithoutConsulteeProfileInput?
  consultantReviews;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'education': education,
    'occupation': occupation,
    'aboutMe': aboutMe,
    'preferredCommunicationMethod': preferredCommunicationMethod,
    'preferredLanguage': preferredLanguage,
    'specialRequirements': specialRequirements,
    'interests': interests,
    'goals': goals,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultationRequests': consultationRequests,
    'subscriptionRequests': subscriptionRequests,
    'consultantReviews': consultantReviews,
  };
}

class ConsulteeProfileCreateNestedOneWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileCreateNestedOneWithoutUserInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.ConsulteeProfileCreateWithoutUserInput,
    _i2.ConsulteeProfileUncheckedCreateWithoutUserInput
  >?
  create;

  final _i2.ConsulteeProfileCreateOrConnectWithoutUserInput? connectOrCreate;

  final _i2.ConsulteeProfileWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class UserCreateWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateWithoutConsultantProfileInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.cookiePreferences,
    this.notificationPreferences,
    this.payment,
    this.consulteeProfile,
    this.staffProfile,
    this.slotsOfAppointment,
    this.waitlist,
    this.feedbacks,
    this.supportTickets,
    this.supportResponses,
    this.accounts,
    this.sessions,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? email;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? emailVerified;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? image;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? address;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? password;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? passwordResetToken;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? passwordResetExpires;

  final bool? onlineStatus;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? currentTimezone;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? onboardingCompleted;

  final _i1.PrismaUnion<_i3.UserRole, _i1.PrismaNull>? role;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consultantProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consulteeProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? staffProfileId;

  final _i2.CookiePreferenceCreateNestedOneWithoutUserInput? cookiePreferences;

  final _i2.NotificationPreferenceCreateNestedOneWithoutUserInput?
  notificationPreferences;

  final _i2.PaymentCreateNestedManyWithoutUserInput? payment;

  final _i2.ConsulteeProfileCreateNestedOneWithoutUserInput? consulteeProfile;

  final _i2.StaffProfileCreateNestedOneWithoutUserInput? staffProfile;

  final _i2.SlotOfAppointmentCreateNestedManyWithoutUserInput?
  slotsOfAppointment;

  final _i2.WaitlistCreateNestedManyWithoutUserInput? waitlist;

  final _i2.FeedbackCreateNestedManyWithoutUserInput? feedbacks;

  final _i2.SupportTicketCreateNestedManyWithoutUserInput? supportTickets;

  final _i2.SupportResponseCreateNestedManyWithoutUserInput? supportResponses;

  final _i2.AccountCreateNestedManyWithoutUserInput? accounts;

  final _i2.SessionCreateNestedManyWithoutUserInput? sessions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'cookiePreferences': cookiePreferences,
    'notificationPreferences': notificationPreferences,
    'Payment': payment,
    'consulteeProfile': consulteeProfile,
    'staffProfile': staffProfile,
    'slotsOfAppointment': slotsOfAppointment,
    'Waitlist': waitlist,
    'feedbacks': feedbacks,
    'supportTickets': supportTickets,
    'supportResponses': supportResponses,
    'accounts': accounts,
    'sessions': sessions,
  };
}

class UserUncheckedCreateWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUncheckedCreateWithoutConsultantProfileInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.cookiePreferences,
    this.notificationPreferences,
    this.payment,
    this.consulteeProfile,
    this.staffProfile,
    this.slotsOfAppointment,
    this.waitlist,
    this.feedbacks,
    this.supportTickets,
    this.supportResponses,
    this.accounts,
    this.sessions,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? email;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? emailVerified;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? image;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? address;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? password;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? passwordResetToken;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? passwordResetExpires;

  final bool? onlineStatus;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? currentTimezone;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? onboardingCompleted;

  final _i1.PrismaUnion<_i3.UserRole, _i1.PrismaNull>? role;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consultantProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consulteeProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? staffProfileId;

  final _i2.CookiePreferenceUncheckedCreateNestedOneWithoutUserInput?
  cookiePreferences;

  final _i2.NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput?
  notificationPreferences;

  final _i2.PaymentUncheckedCreateNestedManyWithoutUserInput? payment;

  final _i2.ConsulteeProfileUncheckedCreateNestedOneWithoutUserInput?
  consulteeProfile;

  final _i2.StaffProfileUncheckedCreateNestedOneWithoutUserInput? staffProfile;

  final _i2.SlotOfAppointmentUncheckedCreateNestedManyWithoutUserInput?
  slotsOfAppointment;

  final _i2.WaitlistUncheckedCreateNestedManyWithoutUserInput? waitlist;

  final _i2.FeedbackUncheckedCreateNestedManyWithoutUserInput? feedbacks;

  final _i2.SupportTicketUncheckedCreateNestedManyWithoutUserInput?
  supportTickets;

  final _i2.SupportResponseUncheckedCreateNestedManyWithoutUserInput?
  supportResponses;

  final _i2.AccountUncheckedCreateNestedManyWithoutUserInput? accounts;

  final _i2.SessionUncheckedCreateNestedManyWithoutUserInput? sessions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'cookiePreferences': cookiePreferences,
    'notificationPreferences': notificationPreferences,
    'Payment': payment,
    'consulteeProfile': consulteeProfile,
    'staffProfile': staffProfile,
    'slotsOfAppointment': slotsOfAppointment,
    'Waitlist': waitlist,
    'feedbacks': feedbacks,
    'supportTickets': supportTickets,
    'supportResponses': supportResponses,
    'accounts': accounts,
    'sessions': sessions,
  };
}

class UserCreateOrConnectWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateOrConnectWithoutConsultantProfileInput({
    required this.where,
    required this.create,
  });

  final _i2.UserWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.UserCreateWithoutConsultantProfileInput,
    _i2.UserUncheckedCreateWithoutConsultantProfileInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class UserCreateNestedOneWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateNestedOneWithoutConsultantProfileInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.UserCreateWithoutConsultantProfileInput,
    _i2.UserUncheckedCreateWithoutConsultantProfileInput
  >?
  create;

  final _i2.UserCreateOrConnectWithoutConsultantProfileInput? connectOrCreate;

  final _i2.UserWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class ConsultantProfileCreateWithoutClassPlansInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileCreateWithoutClassPlansInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    required this.scheduleType,
    this.createdAt,
    this.updatedAt,
    required this.domain,
    this.subDomains,
    this.tags,
    this.reviews,
    this.slotsOfAvailabilityWeekly,
    this.slotsOfAvailabilityCustom,
    this.consultationPlans,
    this.subscriptionPlans,
    this.webinarPlans,
    required this.user,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? qualifications;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? specialization;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? experience;

  final double? rating;

  final _i3.ScheduleType scheduleType;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.DomainCreateNestedOneWithoutConsultantProfilesInput domain;

  final _i2.SubDomainCreateNestedManyWithoutConsultantProfilesInput? subDomains;

  final _i2.TagCreateNestedManyWithoutConsultantProfilesInput? tags;

  final _i2.ConsultantReviewCreateNestedManyWithoutConsultantProfileInput?
  reviews;

  final _i2.SlotOfAvailabilityWeeklyCreateNestedManyWithoutConsultantProfileInput?
  slotsOfAvailabilityWeekly;

  final _i2.SlotOfAvailabilityCustomCreateNestedManyWithoutConsultantProfileInput?
  slotsOfAvailabilityCustom;

  final _i2.ConsultationPlanCreateNestedManyWithoutConsultantProfileInput?
  consultationPlans;

  final _i2.SubscriptionPlanCreateNestedManyWithoutConsultantProfileInput?
  subscriptionPlans;

  final _i2.WebinarPlanCreateNestedManyWithoutConsultantProfileInput?
  webinarPlans;

  final _i2.UserCreateNestedOneWithoutConsultantProfileInput user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'scheduleType': scheduleType,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'domain': domain,
    'subDomains': subDomains,
    'tags': tags,
    'reviews': reviews,
    'slotsOfAvailabilityWeekly': slotsOfAvailabilityWeekly,
    'slotsOfAvailabilityCustom': slotsOfAvailabilityCustom,
    'consultationPlans': consultationPlans,
    'subscriptionPlans': subscriptionPlans,
    'webinarPlans': webinarPlans,
    'user': user,
  };
}

class ConsultantProfileUncheckedCreateWithoutClassPlansInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUncheckedCreateWithoutClassPlansInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    required this.domainId,
    required this.scheduleType,
    required this.userId,
    this.createdAt,
    this.updatedAt,
    this.subDomains,
    this.tags,
    this.reviews,
    this.slotsOfAvailabilityWeekly,
    this.slotsOfAvailabilityCustom,
    this.consultationPlans,
    this.subscriptionPlans,
    this.webinarPlans,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? qualifications;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? specialization;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? experience;

  final double? rating;

  final String domainId;

  final _i3.ScheduleType scheduleType;

  final String userId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.SubDomainUncheckedCreateNestedManyWithoutConsultantProfilesInput?
  subDomains;

  final _i2.TagUncheckedCreateNestedManyWithoutConsultantProfilesInput? tags;

  final _i2.ConsultantReviewUncheckedCreateNestedManyWithoutConsultantProfileInput?
  reviews;

  final _i2.SlotOfAvailabilityWeeklyUncheckedCreateNestedManyWithoutConsultantProfileInput?
  slotsOfAvailabilityWeekly;

  final _i2.SlotOfAvailabilityCustomUncheckedCreateNestedManyWithoutConsultantProfileInput?
  slotsOfAvailabilityCustom;

  final _i2.ConsultationPlanUncheckedCreateNestedManyWithoutConsultantProfileInput?
  consultationPlans;

  final _i2.SubscriptionPlanUncheckedCreateNestedManyWithoutConsultantProfileInput?
  subscriptionPlans;

  final _i2.WebinarPlanUncheckedCreateNestedManyWithoutConsultantProfileInput?
  webinarPlans;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'domainId': domainId,
    'scheduleType': scheduleType,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'subDomains': subDomains,
    'tags': tags,
    'reviews': reviews,
    'slotsOfAvailabilityWeekly': slotsOfAvailabilityWeekly,
    'slotsOfAvailabilityCustom': slotsOfAvailabilityCustom,
    'consultationPlans': consultationPlans,
    'subscriptionPlans': subscriptionPlans,
    'webinarPlans': webinarPlans,
  };
}

class ConsultantProfileCreateOrConnectWithoutClassPlansInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileCreateOrConnectWithoutClassPlansInput({
    required this.where,
    required this.create,
  });

  final _i2.ConsultantProfileWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateWithoutClassPlansInput,
    _i2.ConsultantProfileUncheckedCreateWithoutClassPlansInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class ConsultantProfileCreateNestedOneWithoutClassPlansInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileCreateNestedOneWithoutClassPlansInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateWithoutClassPlansInput,
    _i2.ConsultantProfileUncheckedCreateWithoutClassPlansInput
  >?
  create;

  final _i2.ConsultantProfileCreateOrConnectWithoutClassPlansInput?
  connectOrCreate;

  final _i2.ConsultantProfileWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class ClassPlanCreateWithoutTopicsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanCreateWithoutTopicsInput({
    this.id,
    required this.title,
    required this.description,
    required this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInMonths,
    this.callsPerWeek,
    this.videoMeetings,
    this.emailSupport,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.createdAt,
    this.updatedAt,
    this.classContents,
    this.consultantProfile,
    this.classes,
  });

  final String? id;

  final String title;

  final String description;

  final int price;

  final String? priceCurrency;

  final bool? certificateProvided;

  final int? durationInMonths;

  final int? callsPerWeek;

  final int? videoMeetings;

  final _i3.PlanEmailSupport? emailSupport;

  final int? maxParticipants;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? language;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? level;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? prerequisites;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? materialProvided;

  final _i1.PrismaUnion<
    _i2.ClassPlanCreatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ClassContentCreateNestedManyWithoutClassPlanInput? classContents;

  final _i2.ConsultantProfileCreateNestedOneWithoutClassPlansInput?
  consultantProfile;

  final _i2.ClassCreateNestedManyWithoutClassPlanInput? classes;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInMonths': durationInMonths,
    'callsPerWeek': callsPerWeek,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'classContents': classContents,
    'consultantProfile': consultantProfile,
    'classes': classes,
  };
}

class ClassPlanCreateNestedManyWithoutTopicsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanCreateNestedManyWithoutTopicsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.ClassPlanCreateWithoutTopicsInput,
    _i1.PrismaUnion<
      Iterable<_i2.ClassPlanCreateWithoutTopicsInput>,
      _i1.PrismaUnion<
        _i2.ClassPlanUncheckedCreateWithoutTopicsInput,
        Iterable<_i2.ClassPlanUncheckedCreateWithoutTopicsInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.ClassPlanCreateOrConnectWithoutTopicsInput,
    Iterable<_i2.ClassPlanCreateOrConnectWithoutTopicsInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.ClassPlanWhereUniqueInput,
    Iterable<_i2.ClassPlanWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class TopicCreateWithoutWebinarPlansInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TopicCreateWithoutWebinarPlansInput({
    this.id,
    required this.name,
    this.createdAt,
    this.updatedAt,
    this.classPlans,
  });

  final String? id;

  final String name;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ClassPlanCreateNestedManyWithoutTopicsInput? classPlans;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'classPlans': classPlans,
  };
}

class TopicCreateNestedManyWithoutWebinarPlansInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TopicCreateNestedManyWithoutWebinarPlansInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.TopicCreateWithoutWebinarPlansInput,
    _i1.PrismaUnion<
      Iterable<_i2.TopicCreateWithoutWebinarPlansInput>,
      _i1.PrismaUnion<
        _i2.TopicUncheckedCreateWithoutWebinarPlansInput,
        Iterable<_i2.TopicUncheckedCreateWithoutWebinarPlansInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.TopicCreateOrConnectWithoutWebinarPlansInput,
    Iterable<_i2.TopicCreateOrConnectWithoutWebinarPlansInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.TopicWhereUniqueInput,
    Iterable<_i2.TopicWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class WebinarPlanCreateWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanCreateWithoutConsultantProfileInput({
    this.id,
    required this.title,
    this.description,
    required this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInHours,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.createdAt,
    this.updatedAt,
    this.topics,
    this.webinars,
  });

  final String? id;

  final String title;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final int price;

  final String? priceCurrency;

  final bool? certificateProvided;

  final double? durationInHours;

  final int? maxParticipants;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? language;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? level;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? prerequisites;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? materialProvided;

  final _i1.PrismaUnion<
    _i2.WebinarPlanCreatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.TopicCreateNestedManyWithoutWebinarPlansInput? topics;

  final _i2.WebinarCreateNestedManyWithoutWebinarPlanInput? webinars;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInHours': durationInHours,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'topics': topics,
    'webinars': webinars,
  };
}

class WebinarPlanCreateNestedManyWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanCreateNestedManyWithoutConsultantProfileInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.WebinarPlanCreateWithoutConsultantProfileInput,
    _i1.PrismaUnion<
      Iterable<_i2.WebinarPlanCreateWithoutConsultantProfileInput>,
      _i1.PrismaUnion<
        _i2.WebinarPlanUncheckedCreateWithoutConsultantProfileInput,
        Iterable<_i2.WebinarPlanUncheckedCreateWithoutConsultantProfileInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.WebinarPlanCreateOrConnectWithoutConsultantProfileInput,
    Iterable<_i2.WebinarPlanCreateOrConnectWithoutConsultantProfileInput>
  >?
  connectOrCreate;

  final _i2.WebinarPlanCreateManyConsultantProfileInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.WebinarPlanWhereUniqueInput,
    Iterable<_i2.WebinarPlanWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class ConsultantProfileCreateWithoutSubscriptionPlansInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileCreateWithoutSubscriptionPlansInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    required this.scheduleType,
    this.createdAt,
    this.updatedAt,
    required this.domain,
    this.subDomains,
    this.tags,
    this.reviews,
    this.slotsOfAvailabilityWeekly,
    this.slotsOfAvailabilityCustom,
    this.consultationPlans,
    this.webinarPlans,
    this.classPlans,
    required this.user,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? qualifications;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? specialization;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? experience;

  final double? rating;

  final _i3.ScheduleType scheduleType;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.DomainCreateNestedOneWithoutConsultantProfilesInput domain;

  final _i2.SubDomainCreateNestedManyWithoutConsultantProfilesInput? subDomains;

  final _i2.TagCreateNestedManyWithoutConsultantProfilesInput? tags;

  final _i2.ConsultantReviewCreateNestedManyWithoutConsultantProfileInput?
  reviews;

  final _i2.SlotOfAvailabilityWeeklyCreateNestedManyWithoutConsultantProfileInput?
  slotsOfAvailabilityWeekly;

  final _i2.SlotOfAvailabilityCustomCreateNestedManyWithoutConsultantProfileInput?
  slotsOfAvailabilityCustom;

  final _i2.ConsultationPlanCreateNestedManyWithoutConsultantProfileInput?
  consultationPlans;

  final _i2.WebinarPlanCreateNestedManyWithoutConsultantProfileInput?
  webinarPlans;

  final _i2.ClassPlanCreateNestedManyWithoutConsultantProfileInput? classPlans;

  final _i2.UserCreateNestedOneWithoutConsultantProfileInput user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'scheduleType': scheduleType,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'domain': domain,
    'subDomains': subDomains,
    'tags': tags,
    'reviews': reviews,
    'slotsOfAvailabilityWeekly': slotsOfAvailabilityWeekly,
    'slotsOfAvailabilityCustom': slotsOfAvailabilityCustom,
    'consultationPlans': consultationPlans,
    'webinarPlans': webinarPlans,
    'classPlans': classPlans,
    'user': user,
  };
}

class ConsultantProfileUncheckedCreateWithoutSubscriptionPlansInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUncheckedCreateWithoutSubscriptionPlansInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    required this.domainId,
    required this.scheduleType,
    required this.userId,
    this.createdAt,
    this.updatedAt,
    this.subDomains,
    this.tags,
    this.reviews,
    this.slotsOfAvailabilityWeekly,
    this.slotsOfAvailabilityCustom,
    this.consultationPlans,
    this.webinarPlans,
    this.classPlans,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? qualifications;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? specialization;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? experience;

  final double? rating;

  final String domainId;

  final _i3.ScheduleType scheduleType;

  final String userId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.SubDomainUncheckedCreateNestedManyWithoutConsultantProfilesInput?
  subDomains;

  final _i2.TagUncheckedCreateNestedManyWithoutConsultantProfilesInput? tags;

  final _i2.ConsultantReviewUncheckedCreateNestedManyWithoutConsultantProfileInput?
  reviews;

  final _i2.SlotOfAvailabilityWeeklyUncheckedCreateNestedManyWithoutConsultantProfileInput?
  slotsOfAvailabilityWeekly;

  final _i2.SlotOfAvailabilityCustomUncheckedCreateNestedManyWithoutConsultantProfileInput?
  slotsOfAvailabilityCustom;

  final _i2.ConsultationPlanUncheckedCreateNestedManyWithoutConsultantProfileInput?
  consultationPlans;

  final _i2.WebinarPlanUncheckedCreateNestedManyWithoutConsultantProfileInput?
  webinarPlans;

  final _i2.ClassPlanUncheckedCreateNestedManyWithoutConsultantProfileInput?
  classPlans;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'domainId': domainId,
    'scheduleType': scheduleType,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'subDomains': subDomains,
    'tags': tags,
    'reviews': reviews,
    'slotsOfAvailabilityWeekly': slotsOfAvailabilityWeekly,
    'slotsOfAvailabilityCustom': slotsOfAvailabilityCustom,
    'consultationPlans': consultationPlans,
    'webinarPlans': webinarPlans,
    'classPlans': classPlans,
  };
}

class ConsultantProfileCreateOrConnectWithoutSubscriptionPlansInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileCreateOrConnectWithoutSubscriptionPlansInput({
    required this.where,
    required this.create,
  });

  final _i2.ConsultantProfileWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateWithoutSubscriptionPlansInput,
    _i2.ConsultantProfileUncheckedCreateWithoutSubscriptionPlansInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class ConsultantProfileCreateNestedOneWithoutSubscriptionPlansInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileCreateNestedOneWithoutSubscriptionPlansInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateWithoutSubscriptionPlansInput,
    _i2.ConsultantProfileUncheckedCreateWithoutSubscriptionPlansInput
  >?
  create;

  final _i2.ConsultantProfileCreateOrConnectWithoutSubscriptionPlansInput?
  connectOrCreate;

  final _i2.ConsultantProfileWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class SubscriptionPlanCreateWithoutSubscriptionsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanCreateWithoutSubscriptionsInput({
    this.id,
    required this.title,
    this.description,
    this.durationInMonths,
    required this.price,
    this.callsPerWeek,
    this.sessionDurationInHours,
    this.videoMeetings,
    this.emailSupport,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.createdAt,
    this.updatedAt,
    required this.consultantProfile,
  });

  final String? id;

  final String title;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final int? durationInMonths;

  final int price;

  final int? callsPerWeek;

  final double? sessionDurationInHours;

  final int? videoMeetings;

  final _i3.PlanEmailSupport? emailSupport;

  final String? language;

  final String? level;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? prerequisites;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? materialProvided;

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanCreatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ConsultantProfileCreateNestedOneWithoutSubscriptionPlansInput
  consultantProfile;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInMonths': durationInMonths,
    'price': price,
    'callsPerWeek': callsPerWeek,
    'sessionDurationInHours': sessionDurationInHours,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultantProfile': consultantProfile,
  };
}

class SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput({
    this.id,
    required this.title,
    this.description,
    this.durationInMonths,
    required this.price,
    this.callsPerWeek,
    this.sessionDurationInHours,
    this.videoMeetings,
    this.emailSupport,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    required this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final String title;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final int? durationInMonths;

  final int price;

  final int? callsPerWeek;

  final double? sessionDurationInHours;

  final int? videoMeetings;

  final _i3.PlanEmailSupport? emailSupport;

  final String? language;

  final String? level;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? prerequisites;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? materialProvided;

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanCreatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final String consultantProfileId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInMonths': durationInMonths,
    'price': price,
    'callsPerWeek': callsPerWeek,
    'sessionDurationInHours': sessionDurationInHours,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SubscriptionPlanCreateOrConnectWithoutSubscriptionsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanCreateOrConnectWithoutSubscriptionsInput({
    required this.where,
    required this.create,
  });

  final _i2.SubscriptionPlanWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanCreateWithoutSubscriptionsInput,
    _i2.SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class SubscriptionPlanCreateNestedOneWithoutSubscriptionsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanCreateNestedOneWithoutSubscriptionsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanCreateWithoutSubscriptionsInput,
    _i2.SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput
  >?
  create;

  final _i2.SubscriptionPlanCreateOrConnectWithoutSubscriptionsInput?
  connectOrCreate;

  final _i2.SubscriptionPlanWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class AppointmentCreateNestedManyWithoutSubscriptionInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentCreateNestedManyWithoutSubscriptionInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.AppointmentCreateWithoutSubscriptionInput,
    _i1.PrismaUnion<
      Iterable<_i2.AppointmentCreateWithoutSubscriptionInput>,
      _i1.PrismaUnion<
        _i2.AppointmentUncheckedCreateWithoutSubscriptionInput,
        Iterable<_i2.AppointmentUncheckedCreateWithoutSubscriptionInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.AppointmentCreateOrConnectWithoutSubscriptionInput,
    Iterable<_i2.AppointmentCreateOrConnectWithoutSubscriptionInput>
  >?
  connectOrCreate;

  final _i2.AppointmentCreateManySubscriptionInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.AppointmentWhereUniqueInput,
    Iterable<_i2.AppointmentWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class SubscriptionCreateWithoutRequestedByInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionCreateWithoutRequestedByInput({
    this.id,
    this.startDate,
    required this.endDate,
    this.requestStatus,
    this.requestedAt,
    this.requestNotes,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.createdAt,
    this.updatedAt,
    required this.subscriptionPlan,
    this.appointments,
  });

  final String? id;

  final DateTime? startDate;

  final DateTime endDate;

  final _i3.RequestStatus? requestStatus;

  final DateTime? requestedAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? requestNotes;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackFromConsultee;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackFromConsultant;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? rating;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.SubscriptionPlanCreateNestedOneWithoutSubscriptionsInput
  subscriptionPlan;

  final _i2.AppointmentCreateNestedManyWithoutSubscriptionInput? appointments;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'requestStatus': requestStatus,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'subscriptionPlan': subscriptionPlan,
    'appointments': appointments,
  };
}

class SubscriptionCreateNestedManyWithoutRequestedByInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionCreateNestedManyWithoutRequestedByInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.SubscriptionCreateWithoutRequestedByInput,
    _i1.PrismaUnion<
      Iterable<_i2.SubscriptionCreateWithoutRequestedByInput>,
      _i1.PrismaUnion<
        _i2.SubscriptionUncheckedCreateWithoutRequestedByInput,
        Iterable<_i2.SubscriptionUncheckedCreateWithoutRequestedByInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.SubscriptionCreateOrConnectWithoutRequestedByInput,
    Iterable<_i2.SubscriptionCreateOrConnectWithoutRequestedByInput>
  >?
  connectOrCreate;

  final _i2.SubscriptionCreateManyRequestedByInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.SubscriptionWhereUniqueInput,
    Iterable<_i2.SubscriptionWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class UserCreateWithoutConsulteeProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateWithoutConsulteeProfileInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.cookiePreferences,
    this.notificationPreferences,
    this.payment,
    this.consultantProfile,
    this.staffProfile,
    this.slotsOfAppointment,
    this.waitlist,
    this.feedbacks,
    this.supportTickets,
    this.supportResponses,
    this.accounts,
    this.sessions,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? email;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? emailVerified;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? image;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? address;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? password;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? passwordResetToken;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? passwordResetExpires;

  final bool? onlineStatus;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? currentTimezone;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? onboardingCompleted;

  final _i1.PrismaUnion<_i3.UserRole, _i1.PrismaNull>? role;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consultantProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consulteeProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? staffProfileId;

  final _i2.CookiePreferenceCreateNestedOneWithoutUserInput? cookiePreferences;

  final _i2.NotificationPreferenceCreateNestedOneWithoutUserInput?
  notificationPreferences;

  final _i2.PaymentCreateNestedManyWithoutUserInput? payment;

  final _i2.ConsultantProfileCreateNestedOneWithoutUserInput? consultantProfile;

  final _i2.StaffProfileCreateNestedOneWithoutUserInput? staffProfile;

  final _i2.SlotOfAppointmentCreateNestedManyWithoutUserInput?
  slotsOfAppointment;

  final _i2.WaitlistCreateNestedManyWithoutUserInput? waitlist;

  final _i2.FeedbackCreateNestedManyWithoutUserInput? feedbacks;

  final _i2.SupportTicketCreateNestedManyWithoutUserInput? supportTickets;

  final _i2.SupportResponseCreateNestedManyWithoutUserInput? supportResponses;

  final _i2.AccountCreateNestedManyWithoutUserInput? accounts;

  final _i2.SessionCreateNestedManyWithoutUserInput? sessions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'cookiePreferences': cookiePreferences,
    'notificationPreferences': notificationPreferences,
    'Payment': payment,
    'consultantProfile': consultantProfile,
    'staffProfile': staffProfile,
    'slotsOfAppointment': slotsOfAppointment,
    'Waitlist': waitlist,
    'feedbacks': feedbacks,
    'supportTickets': supportTickets,
    'supportResponses': supportResponses,
    'accounts': accounts,
    'sessions': sessions,
  };
}

class UserUncheckedCreateWithoutConsulteeProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUncheckedCreateWithoutConsulteeProfileInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.cookiePreferences,
    this.notificationPreferences,
    this.payment,
    this.consultantProfile,
    this.staffProfile,
    this.slotsOfAppointment,
    this.waitlist,
    this.feedbacks,
    this.supportTickets,
    this.supportResponses,
    this.accounts,
    this.sessions,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? email;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? emailVerified;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? image;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? address;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? password;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? passwordResetToken;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? passwordResetExpires;

  final bool? onlineStatus;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? currentTimezone;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? onboardingCompleted;

  final _i1.PrismaUnion<_i3.UserRole, _i1.PrismaNull>? role;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consultantProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consulteeProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? staffProfileId;

  final _i2.CookiePreferenceUncheckedCreateNestedOneWithoutUserInput?
  cookiePreferences;

  final _i2.NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput?
  notificationPreferences;

  final _i2.PaymentUncheckedCreateNestedManyWithoutUserInput? payment;

  final _i2.ConsultantProfileUncheckedCreateNestedOneWithoutUserInput?
  consultantProfile;

  final _i2.StaffProfileUncheckedCreateNestedOneWithoutUserInput? staffProfile;

  final _i2.SlotOfAppointmentUncheckedCreateNestedManyWithoutUserInput?
  slotsOfAppointment;

  final _i2.WaitlistUncheckedCreateNestedManyWithoutUserInput? waitlist;

  final _i2.FeedbackUncheckedCreateNestedManyWithoutUserInput? feedbacks;

  final _i2.SupportTicketUncheckedCreateNestedManyWithoutUserInput?
  supportTickets;

  final _i2.SupportResponseUncheckedCreateNestedManyWithoutUserInput?
  supportResponses;

  final _i2.AccountUncheckedCreateNestedManyWithoutUserInput? accounts;

  final _i2.SessionUncheckedCreateNestedManyWithoutUserInput? sessions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'cookiePreferences': cookiePreferences,
    'notificationPreferences': notificationPreferences,
    'Payment': payment,
    'consultantProfile': consultantProfile,
    'staffProfile': staffProfile,
    'slotsOfAppointment': slotsOfAppointment,
    'Waitlist': waitlist,
    'feedbacks': feedbacks,
    'supportTickets': supportTickets,
    'supportResponses': supportResponses,
    'accounts': accounts,
    'sessions': sessions,
  };
}

class UserCreateOrConnectWithoutConsulteeProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateOrConnectWithoutConsulteeProfileInput({
    required this.where,
    required this.create,
  });

  final _i2.UserWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.UserCreateWithoutConsulteeProfileInput,
    _i2.UserUncheckedCreateWithoutConsulteeProfileInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class UserCreateNestedOneWithoutConsulteeProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateNestedOneWithoutConsulteeProfileInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.UserCreateWithoutConsulteeProfileInput,
    _i2.UserUncheckedCreateWithoutConsulteeProfileInput
  >?
  create;

  final _i2.UserCreateOrConnectWithoutConsulteeProfileInput? connectOrCreate;

  final _i2.UserWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class ConsulteeProfileCreateWithoutConsultationRequestsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileCreateWithoutConsultationRequestsInput({
    this.id,
    this.education,
    this.occupation,
    this.aboutMe,
    this.preferredCommunicationMethod,
    this.preferredLanguage,
    this.specialRequirements,
    this.interests,
    this.goals,
    this.createdAt,
    this.updatedAt,
    this.subscriptionRequests,
    this.consultantReviews,
    required this.user,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? education;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? occupation;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? aboutMe;

  final _i1.PrismaUnion<_i3.ConsultationMode, _i1.PrismaNull>?
  preferredCommunicationMethod;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? preferredLanguage;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? specialRequirements;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? interests;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? goals;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.SubscriptionCreateNestedManyWithoutRequestedByInput?
  subscriptionRequests;

  final _i2.ConsultantReviewCreateNestedManyWithoutConsulteeProfileInput?
  consultantReviews;

  final _i2.UserCreateNestedOneWithoutConsulteeProfileInput user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'education': education,
    'occupation': occupation,
    'aboutMe': aboutMe,
    'preferredCommunicationMethod': preferredCommunicationMethod,
    'preferredLanguage': preferredLanguage,
    'specialRequirements': specialRequirements,
    'interests': interests,
    'goals': goals,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'subscriptionRequests': subscriptionRequests,
    'consultantReviews': consultantReviews,
    'user': user,
  };
}

class ConsulteeProfileUncheckedCreateWithoutConsultationRequestsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileUncheckedCreateWithoutConsultationRequestsInput({
    this.id,
    this.education,
    this.occupation,
    this.aboutMe,
    this.preferredCommunicationMethod,
    this.preferredLanguage,
    this.specialRequirements,
    this.interests,
    this.goals,
    required this.userId,
    this.createdAt,
    this.updatedAt,
    this.subscriptionRequests,
    this.consultantReviews,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? education;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? occupation;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? aboutMe;

  final _i1.PrismaUnion<_i3.ConsultationMode, _i1.PrismaNull>?
  preferredCommunicationMethod;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? preferredLanguage;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? specialRequirements;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? interests;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? goals;

  final String userId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.SubscriptionUncheckedCreateNestedManyWithoutRequestedByInput?
  subscriptionRequests;

  final _i2.ConsultantReviewUncheckedCreateNestedManyWithoutConsulteeProfileInput?
  consultantReviews;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'education': education,
    'occupation': occupation,
    'aboutMe': aboutMe,
    'preferredCommunicationMethod': preferredCommunicationMethod,
    'preferredLanguage': preferredLanguage,
    'specialRequirements': specialRequirements,
    'interests': interests,
    'goals': goals,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'subscriptionRequests': subscriptionRequests,
    'consultantReviews': consultantReviews,
  };
}

class ConsulteeProfileCreateOrConnectWithoutConsultationRequestsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileCreateOrConnectWithoutConsultationRequestsInput({
    required this.where,
    required this.create,
  });

  final _i2.ConsulteeProfileWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.ConsulteeProfileCreateWithoutConsultationRequestsInput,
    _i2.ConsulteeProfileUncheckedCreateWithoutConsultationRequestsInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class ConsulteeProfileCreateNestedOneWithoutConsultationRequestsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileCreateNestedOneWithoutConsultationRequestsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.ConsulteeProfileCreateWithoutConsultationRequestsInput,
    _i2.ConsulteeProfileUncheckedCreateWithoutConsultationRequestsInput
  >?
  create;

  final _i2.ConsulteeProfileCreateOrConnectWithoutConsultationRequestsInput?
  connectOrCreate;

  final _i2.ConsulteeProfileWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class AppointmentCreateNestedOneWithoutConsultationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentCreateNestedOneWithoutConsultationInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.AppointmentCreateWithoutConsultationInput,
    _i2.AppointmentUncheckedCreateWithoutConsultationInput
  >?
  create;

  final _i2.AppointmentCreateOrConnectWithoutConsultationInput? connectOrCreate;

  final _i2.AppointmentWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class ConsultationCreateWithoutConsultationPlanInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationCreateWithoutConsultationPlanInput({
    this.id,
    this.requestStatus,
    this.requestedAt,
    this.requestNotes,
    this.directlyBooked,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.createdAt,
    this.updatedAt,
    required this.requestedBy,
    this.appointment,
  });

  final String? id;

  final _i3.RequestStatus? requestStatus;

  final DateTime? requestedAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? requestNotes;

  final bool? directlyBooked;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackFromConsultee;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackFromConsultant;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? rating;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ConsulteeProfileCreateNestedOneWithoutConsultationRequestsInput
  requestedBy;

  final _i2.AppointmentCreateNestedOneWithoutConsultationInput? appointment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'requestStatus': requestStatus,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'directlyBooked': directlyBooked,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'requestedBy': requestedBy,
    'appointment': appointment,
  };
}

class ConsultationCreateNestedManyWithoutConsultationPlanInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationCreateNestedManyWithoutConsultationPlanInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.ConsultationCreateWithoutConsultationPlanInput,
    _i1.PrismaUnion<
      Iterable<_i2.ConsultationCreateWithoutConsultationPlanInput>,
      _i1.PrismaUnion<
        _i2.ConsultationUncheckedCreateWithoutConsultationPlanInput,
        Iterable<_i2.ConsultationUncheckedCreateWithoutConsultationPlanInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.ConsultationCreateOrConnectWithoutConsultationPlanInput,
    Iterable<_i2.ConsultationCreateOrConnectWithoutConsultationPlanInput>
  >?
  connectOrCreate;

  final _i2.ConsultationCreateManyConsultationPlanInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.ConsultationWhereUniqueInput,
    Iterable<_i2.ConsultationWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class ConsultationPlanCreateWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanCreateWithoutConsultantProfileInput({
    this.id,
    required this.title,
    this.description,
    this.durationInHours,
    required this.price,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.createdAt,
    this.updatedAt,
    this.consultations,
  });

  final String? id;

  final String title;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final double? durationInHours;

  final int price;

  final String? language;

  final String? level;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? prerequisites;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? materialProvided;

  final _i1.PrismaUnion<
    _i2.ConsultationPlanCreatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ConsultationCreateNestedManyWithoutConsultationPlanInput?
  consultations;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInHours': durationInHours,
    'price': price,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultations': consultations,
  };
}

class ConsultationPlanCreateNestedManyWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanCreateNestedManyWithoutConsultantProfileInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.ConsultationPlanCreateWithoutConsultantProfileInput,
    _i1.PrismaUnion<
      Iterable<_i2.ConsultationPlanCreateWithoutConsultantProfileInput>,
      _i1.PrismaUnion<
        _i2.ConsultationPlanUncheckedCreateWithoutConsultantProfileInput,
        Iterable<
          _i2.ConsultationPlanUncheckedCreateWithoutConsultantProfileInput
        >
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.ConsultationPlanCreateOrConnectWithoutConsultantProfileInput,
    Iterable<_i2.ConsultationPlanCreateOrConnectWithoutConsultantProfileInput>
  >?
  connectOrCreate;

  final _i2.ConsultationPlanCreateManyConsultantProfileInputEnvelope?
  createMany;

  final _i1.PrismaUnion<
    _i2.ConsultationPlanWhereUniqueInput,
    Iterable<_i2.ConsultationPlanWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class ConsultantProfileCreateWithoutReviewsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileCreateWithoutReviewsInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    required this.scheduleType,
    this.createdAt,
    this.updatedAt,
    required this.domain,
    this.subDomains,
    this.tags,
    this.slotsOfAvailabilityWeekly,
    this.slotsOfAvailabilityCustom,
    this.consultationPlans,
    this.subscriptionPlans,
    this.webinarPlans,
    this.classPlans,
    required this.user,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? qualifications;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? specialization;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? experience;

  final double? rating;

  final _i3.ScheduleType scheduleType;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.DomainCreateNestedOneWithoutConsultantProfilesInput domain;

  final _i2.SubDomainCreateNestedManyWithoutConsultantProfilesInput? subDomains;

  final _i2.TagCreateNestedManyWithoutConsultantProfilesInput? tags;

  final _i2.SlotOfAvailabilityWeeklyCreateNestedManyWithoutConsultantProfileInput?
  slotsOfAvailabilityWeekly;

  final _i2.SlotOfAvailabilityCustomCreateNestedManyWithoutConsultantProfileInput?
  slotsOfAvailabilityCustom;

  final _i2.ConsultationPlanCreateNestedManyWithoutConsultantProfileInput?
  consultationPlans;

  final _i2.SubscriptionPlanCreateNestedManyWithoutConsultantProfileInput?
  subscriptionPlans;

  final _i2.WebinarPlanCreateNestedManyWithoutConsultantProfileInput?
  webinarPlans;

  final _i2.ClassPlanCreateNestedManyWithoutConsultantProfileInput? classPlans;

  final _i2.UserCreateNestedOneWithoutConsultantProfileInput user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'scheduleType': scheduleType,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'domain': domain,
    'subDomains': subDomains,
    'tags': tags,
    'slotsOfAvailabilityWeekly': slotsOfAvailabilityWeekly,
    'slotsOfAvailabilityCustom': slotsOfAvailabilityCustom,
    'consultationPlans': consultationPlans,
    'subscriptionPlans': subscriptionPlans,
    'webinarPlans': webinarPlans,
    'classPlans': classPlans,
    'user': user,
  };
}

class ConsultantProfileUncheckedCreateWithoutReviewsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUncheckedCreateWithoutReviewsInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    required this.domainId,
    required this.scheduleType,
    required this.userId,
    this.createdAt,
    this.updatedAt,
    this.subDomains,
    this.tags,
    this.slotsOfAvailabilityWeekly,
    this.slotsOfAvailabilityCustom,
    this.consultationPlans,
    this.subscriptionPlans,
    this.webinarPlans,
    this.classPlans,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? qualifications;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? specialization;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? experience;

  final double? rating;

  final String domainId;

  final _i3.ScheduleType scheduleType;

  final String userId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.SubDomainUncheckedCreateNestedManyWithoutConsultantProfilesInput?
  subDomains;

  final _i2.TagUncheckedCreateNestedManyWithoutConsultantProfilesInput? tags;

  final _i2.SlotOfAvailabilityWeeklyUncheckedCreateNestedManyWithoutConsultantProfileInput?
  slotsOfAvailabilityWeekly;

  final _i2.SlotOfAvailabilityCustomUncheckedCreateNestedManyWithoutConsultantProfileInput?
  slotsOfAvailabilityCustom;

  final _i2.ConsultationPlanUncheckedCreateNestedManyWithoutConsultantProfileInput?
  consultationPlans;

  final _i2.SubscriptionPlanUncheckedCreateNestedManyWithoutConsultantProfileInput?
  subscriptionPlans;

  final _i2.WebinarPlanUncheckedCreateNestedManyWithoutConsultantProfileInput?
  webinarPlans;

  final _i2.ClassPlanUncheckedCreateNestedManyWithoutConsultantProfileInput?
  classPlans;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'domainId': domainId,
    'scheduleType': scheduleType,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'subDomains': subDomains,
    'tags': tags,
    'slotsOfAvailabilityWeekly': slotsOfAvailabilityWeekly,
    'slotsOfAvailabilityCustom': slotsOfAvailabilityCustom,
    'consultationPlans': consultationPlans,
    'subscriptionPlans': subscriptionPlans,
    'webinarPlans': webinarPlans,
    'classPlans': classPlans,
  };
}

class ConsultantProfileCreateOrConnectWithoutReviewsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileCreateOrConnectWithoutReviewsInput({
    required this.where,
    required this.create,
  });

  final _i2.ConsultantProfileWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateWithoutReviewsInput,
    _i2.ConsultantProfileUncheckedCreateWithoutReviewsInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class ConsultantProfileCreateNestedOneWithoutReviewsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileCreateNestedOneWithoutReviewsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateWithoutReviewsInput,
    _i2.ConsultantProfileUncheckedCreateWithoutReviewsInput
  >?
  create;

  final _i2.ConsultantProfileCreateOrConnectWithoutReviewsInput?
  connectOrCreate;

  final _i2.ConsultantProfileWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class ConsultantReviewCreateWithoutConsulteeProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewCreateWithoutConsulteeProfileInput({
    this.id,
    this.rating,
    this.reviewDescription,
    this.createdAt,
    this.updatedAt,
    required this.consultantProfile,
  });

  final String? id;

  final int? rating;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? reviewDescription;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ConsultantProfileCreateNestedOneWithoutReviewsInput
  consultantProfile;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'rating': rating,
    'reviewDescription': reviewDescription,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultantProfile': consultantProfile,
  };
}

class ConsultantReviewCreateNestedManyWithoutConsulteeProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewCreateNestedManyWithoutConsulteeProfileInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.ConsultantReviewCreateWithoutConsulteeProfileInput,
    _i1.PrismaUnion<
      Iterable<_i2.ConsultantReviewCreateWithoutConsulteeProfileInput>,
      _i1.PrismaUnion<
        _i2.ConsultantReviewUncheckedCreateWithoutConsulteeProfileInput,
        Iterable<
          _i2.ConsultantReviewUncheckedCreateWithoutConsulteeProfileInput
        >
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewCreateOrConnectWithoutConsulteeProfileInput,
    Iterable<_i2.ConsultantReviewCreateOrConnectWithoutConsulteeProfileInput>
  >?
  connectOrCreate;

  final _i2.ConsultantReviewCreateManyConsulteeProfileInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewWhereUniqueInput,
    Iterable<_i2.ConsultantReviewWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class ConsulteeProfileCreateWithoutSubscriptionRequestsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileCreateWithoutSubscriptionRequestsInput({
    this.id,
    this.education,
    this.occupation,
    this.aboutMe,
    this.preferredCommunicationMethod,
    this.preferredLanguage,
    this.specialRequirements,
    this.interests,
    this.goals,
    this.createdAt,
    this.updatedAt,
    this.consultationRequests,
    this.consultantReviews,
    required this.user,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? education;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? occupation;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? aboutMe;

  final _i1.PrismaUnion<_i3.ConsultationMode, _i1.PrismaNull>?
  preferredCommunicationMethod;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? preferredLanguage;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? specialRequirements;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? interests;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? goals;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ConsultationCreateNestedManyWithoutRequestedByInput?
  consultationRequests;

  final _i2.ConsultantReviewCreateNestedManyWithoutConsulteeProfileInput?
  consultantReviews;

  final _i2.UserCreateNestedOneWithoutConsulteeProfileInput user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'education': education,
    'occupation': occupation,
    'aboutMe': aboutMe,
    'preferredCommunicationMethod': preferredCommunicationMethod,
    'preferredLanguage': preferredLanguage,
    'specialRequirements': specialRequirements,
    'interests': interests,
    'goals': goals,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultationRequests': consultationRequests,
    'consultantReviews': consultantReviews,
    'user': user,
  };
}

class ConsulteeProfileUncheckedCreateWithoutSubscriptionRequestsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileUncheckedCreateWithoutSubscriptionRequestsInput({
    this.id,
    this.education,
    this.occupation,
    this.aboutMe,
    this.preferredCommunicationMethod,
    this.preferredLanguage,
    this.specialRequirements,
    this.interests,
    this.goals,
    required this.userId,
    this.createdAt,
    this.updatedAt,
    this.consultationRequests,
    this.consultantReviews,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? education;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? occupation;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? aboutMe;

  final _i1.PrismaUnion<_i3.ConsultationMode, _i1.PrismaNull>?
  preferredCommunicationMethod;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? preferredLanguage;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? specialRequirements;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? interests;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? goals;

  final String userId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ConsultationUncheckedCreateNestedManyWithoutRequestedByInput?
  consultationRequests;

  final _i2.ConsultantReviewUncheckedCreateNestedManyWithoutConsulteeProfileInput?
  consultantReviews;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'education': education,
    'occupation': occupation,
    'aboutMe': aboutMe,
    'preferredCommunicationMethod': preferredCommunicationMethod,
    'preferredLanguage': preferredLanguage,
    'specialRequirements': specialRequirements,
    'interests': interests,
    'goals': goals,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultationRequests': consultationRequests,
    'consultantReviews': consultantReviews,
  };
}

class ConsulteeProfileCreateOrConnectWithoutSubscriptionRequestsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileCreateOrConnectWithoutSubscriptionRequestsInput({
    required this.where,
    required this.create,
  });

  final _i2.ConsulteeProfileWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.ConsulteeProfileCreateWithoutSubscriptionRequestsInput,
    _i2.ConsulteeProfileUncheckedCreateWithoutSubscriptionRequestsInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class ConsulteeProfileCreateNestedOneWithoutSubscriptionRequestsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileCreateNestedOneWithoutSubscriptionRequestsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.ConsulteeProfileCreateWithoutSubscriptionRequestsInput,
    _i2.ConsulteeProfileUncheckedCreateWithoutSubscriptionRequestsInput
  >?
  create;

  final _i2.ConsulteeProfileCreateOrConnectWithoutSubscriptionRequestsInput?
  connectOrCreate;

  final _i2.ConsulteeProfileWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class SubscriptionCreateWithoutSubscriptionPlanInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionCreateWithoutSubscriptionPlanInput({
    this.id,
    this.startDate,
    required this.endDate,
    this.requestStatus,
    this.requestedAt,
    this.requestNotes,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.createdAt,
    this.updatedAt,
    required this.requestedBy,
    this.appointments,
  });

  final String? id;

  final DateTime? startDate;

  final DateTime endDate;

  final _i3.RequestStatus? requestStatus;

  final DateTime? requestedAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? requestNotes;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackFromConsultee;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackFromConsultant;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? rating;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ConsulteeProfileCreateNestedOneWithoutSubscriptionRequestsInput
  requestedBy;

  final _i2.AppointmentCreateNestedManyWithoutSubscriptionInput? appointments;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'requestStatus': requestStatus,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'requestedBy': requestedBy,
    'appointments': appointments,
  };
}

class SubscriptionCreateNestedManyWithoutSubscriptionPlanInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionCreateNestedManyWithoutSubscriptionPlanInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.SubscriptionCreateWithoutSubscriptionPlanInput,
    _i1.PrismaUnion<
      Iterable<_i2.SubscriptionCreateWithoutSubscriptionPlanInput>,
      _i1.PrismaUnion<
        _i2.SubscriptionUncheckedCreateWithoutSubscriptionPlanInput,
        Iterable<_i2.SubscriptionUncheckedCreateWithoutSubscriptionPlanInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.SubscriptionCreateOrConnectWithoutSubscriptionPlanInput,
    Iterable<_i2.SubscriptionCreateOrConnectWithoutSubscriptionPlanInput>
  >?
  connectOrCreate;

  final _i2.SubscriptionCreateManySubscriptionPlanInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.SubscriptionWhereUniqueInput,
    Iterable<_i2.SubscriptionWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class SubscriptionPlanCreateWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanCreateWithoutConsultantProfileInput({
    this.id,
    required this.title,
    this.description,
    this.durationInMonths,
    required this.price,
    this.callsPerWeek,
    this.sessionDurationInHours,
    this.videoMeetings,
    this.emailSupport,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.createdAt,
    this.updatedAt,
    this.subscriptions,
  });

  final String? id;

  final String title;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final int? durationInMonths;

  final int price;

  final int? callsPerWeek;

  final double? sessionDurationInHours;

  final int? videoMeetings;

  final _i3.PlanEmailSupport? emailSupport;

  final String? language;

  final String? level;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? prerequisites;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? materialProvided;

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanCreatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.SubscriptionCreateNestedManyWithoutSubscriptionPlanInput?
  subscriptions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInMonths': durationInMonths,
    'price': price,
    'callsPerWeek': callsPerWeek,
    'sessionDurationInHours': sessionDurationInHours,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'subscriptions': subscriptions,
  };
}

class SubscriptionPlanCreateNestedManyWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanCreateNestedManyWithoutConsultantProfileInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanCreateWithoutConsultantProfileInput,
    _i1.PrismaUnion<
      Iterable<_i2.SubscriptionPlanCreateWithoutConsultantProfileInput>,
      _i1.PrismaUnion<
        _i2.SubscriptionPlanUncheckedCreateWithoutConsultantProfileInput,
        Iterable<
          _i2.SubscriptionPlanUncheckedCreateWithoutConsultantProfileInput
        >
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanCreateOrConnectWithoutConsultantProfileInput,
    Iterable<_i2.SubscriptionPlanCreateOrConnectWithoutConsultantProfileInput>
  >?
  connectOrCreate;

  final _i2.SubscriptionPlanCreateManyConsultantProfileInputEnvelope?
  createMany;

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanWhereUniqueInput,
    Iterable<_i2.SubscriptionPlanWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class ConsultantProfileCreateWithoutConsultationPlansInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileCreateWithoutConsultationPlansInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    required this.scheduleType,
    this.createdAt,
    this.updatedAt,
    required this.domain,
    this.subDomains,
    this.tags,
    this.reviews,
    this.slotsOfAvailabilityWeekly,
    this.slotsOfAvailabilityCustom,
    this.subscriptionPlans,
    this.webinarPlans,
    this.classPlans,
    required this.user,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? qualifications;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? specialization;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? experience;

  final double? rating;

  final _i3.ScheduleType scheduleType;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.DomainCreateNestedOneWithoutConsultantProfilesInput domain;

  final _i2.SubDomainCreateNestedManyWithoutConsultantProfilesInput? subDomains;

  final _i2.TagCreateNestedManyWithoutConsultantProfilesInput? tags;

  final _i2.ConsultantReviewCreateNestedManyWithoutConsultantProfileInput?
  reviews;

  final _i2.SlotOfAvailabilityWeeklyCreateNestedManyWithoutConsultantProfileInput?
  slotsOfAvailabilityWeekly;

  final _i2.SlotOfAvailabilityCustomCreateNestedManyWithoutConsultantProfileInput?
  slotsOfAvailabilityCustom;

  final _i2.SubscriptionPlanCreateNestedManyWithoutConsultantProfileInput?
  subscriptionPlans;

  final _i2.WebinarPlanCreateNestedManyWithoutConsultantProfileInput?
  webinarPlans;

  final _i2.ClassPlanCreateNestedManyWithoutConsultantProfileInput? classPlans;

  final _i2.UserCreateNestedOneWithoutConsultantProfileInput user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'scheduleType': scheduleType,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'domain': domain,
    'subDomains': subDomains,
    'tags': tags,
    'reviews': reviews,
    'slotsOfAvailabilityWeekly': slotsOfAvailabilityWeekly,
    'slotsOfAvailabilityCustom': slotsOfAvailabilityCustom,
    'subscriptionPlans': subscriptionPlans,
    'webinarPlans': webinarPlans,
    'classPlans': classPlans,
    'user': user,
  };
}

class ConsultantProfileUncheckedCreateWithoutConsultationPlansInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUncheckedCreateWithoutConsultationPlansInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    required this.domainId,
    required this.scheduleType,
    required this.userId,
    this.createdAt,
    this.updatedAt,
    this.subDomains,
    this.tags,
    this.reviews,
    this.slotsOfAvailabilityWeekly,
    this.slotsOfAvailabilityCustom,
    this.subscriptionPlans,
    this.webinarPlans,
    this.classPlans,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? qualifications;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? specialization;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? experience;

  final double? rating;

  final String domainId;

  final _i3.ScheduleType scheduleType;

  final String userId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.SubDomainUncheckedCreateNestedManyWithoutConsultantProfilesInput?
  subDomains;

  final _i2.TagUncheckedCreateNestedManyWithoutConsultantProfilesInput? tags;

  final _i2.ConsultantReviewUncheckedCreateNestedManyWithoutConsultantProfileInput?
  reviews;

  final _i2.SlotOfAvailabilityWeeklyUncheckedCreateNestedManyWithoutConsultantProfileInput?
  slotsOfAvailabilityWeekly;

  final _i2.SlotOfAvailabilityCustomUncheckedCreateNestedManyWithoutConsultantProfileInput?
  slotsOfAvailabilityCustom;

  final _i2.SubscriptionPlanUncheckedCreateNestedManyWithoutConsultantProfileInput?
  subscriptionPlans;

  final _i2.WebinarPlanUncheckedCreateNestedManyWithoutConsultantProfileInput?
  webinarPlans;

  final _i2.ClassPlanUncheckedCreateNestedManyWithoutConsultantProfileInput?
  classPlans;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'domainId': domainId,
    'scheduleType': scheduleType,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'subDomains': subDomains,
    'tags': tags,
    'reviews': reviews,
    'slotsOfAvailabilityWeekly': slotsOfAvailabilityWeekly,
    'slotsOfAvailabilityCustom': slotsOfAvailabilityCustom,
    'subscriptionPlans': subscriptionPlans,
    'webinarPlans': webinarPlans,
    'classPlans': classPlans,
  };
}

class ConsultantProfileCreateOrConnectWithoutConsultationPlansInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileCreateOrConnectWithoutConsultationPlansInput({
    required this.where,
    required this.create,
  });

  final _i2.ConsultantProfileWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateWithoutConsultationPlansInput,
    _i2.ConsultantProfileUncheckedCreateWithoutConsultationPlansInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class ConsultantProfileCreateNestedOneWithoutConsultationPlansInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileCreateNestedOneWithoutConsultationPlansInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateWithoutConsultationPlansInput,
    _i2.ConsultantProfileUncheckedCreateWithoutConsultationPlansInput
  >?
  create;

  final _i2.ConsultantProfileCreateOrConnectWithoutConsultationPlansInput?
  connectOrCreate;

  final _i2.ConsultantProfileWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class ConsultationPlanCreateWithoutConsultationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanCreateWithoutConsultationsInput({
    this.id,
    required this.title,
    this.description,
    this.durationInHours,
    required this.price,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.createdAt,
    this.updatedAt,
    required this.consultantProfile,
  });

  final String? id;

  final String title;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final double? durationInHours;

  final int price;

  final String? language;

  final String? level;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? prerequisites;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? materialProvided;

  final _i1.PrismaUnion<
    _i2.ConsultationPlanCreatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ConsultantProfileCreateNestedOneWithoutConsultationPlansInput
  consultantProfile;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInHours': durationInHours,
    'price': price,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultantProfile': consultantProfile,
  };
}

class ConsultationPlanUncheckedCreateWithoutConsultationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanUncheckedCreateWithoutConsultationsInput({
    this.id,
    required this.title,
    this.description,
    this.durationInHours,
    required this.price,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    required this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final String title;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final double? durationInHours;

  final int price;

  final String? language;

  final String? level;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? prerequisites;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? materialProvided;

  final _i1.PrismaUnion<
    _i2.ConsultationPlanCreatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final String consultantProfileId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInHours': durationInHours,
    'price': price,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultationPlanCreateOrConnectWithoutConsultationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanCreateOrConnectWithoutConsultationsInput({
    required this.where,
    required this.create,
  });

  final _i2.ConsultationPlanWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.ConsultationPlanCreateWithoutConsultationsInput,
    _i2.ConsultationPlanUncheckedCreateWithoutConsultationsInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class ConsultationPlanCreateNestedOneWithoutConsultationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanCreateNestedOneWithoutConsultationsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.ConsultationPlanCreateWithoutConsultationsInput,
    _i2.ConsultationPlanUncheckedCreateWithoutConsultationsInput
  >?
  create;

  final _i2.ConsultationPlanCreateOrConnectWithoutConsultationsInput?
  connectOrCreate;

  final _i2.ConsultationPlanWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class ConsultationCreateWithoutRequestedByInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationCreateWithoutRequestedByInput({
    this.id,
    this.requestStatus,
    this.requestedAt,
    this.requestNotes,
    this.directlyBooked,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.createdAt,
    this.updatedAt,
    required this.consultationPlan,
    this.appointment,
  });

  final String? id;

  final _i3.RequestStatus? requestStatus;

  final DateTime? requestedAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? requestNotes;

  final bool? directlyBooked;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackFromConsultee;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackFromConsultant;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? rating;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ConsultationPlanCreateNestedOneWithoutConsultationsInput
  consultationPlan;

  final _i2.AppointmentCreateNestedOneWithoutConsultationInput? appointment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'requestStatus': requestStatus,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'directlyBooked': directlyBooked,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultationPlan': consultationPlan,
    'appointment': appointment,
  };
}

class ConsultationCreateNestedManyWithoutRequestedByInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationCreateNestedManyWithoutRequestedByInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.ConsultationCreateWithoutRequestedByInput,
    _i1.PrismaUnion<
      Iterable<_i2.ConsultationCreateWithoutRequestedByInput>,
      _i1.PrismaUnion<
        _i2.ConsultationUncheckedCreateWithoutRequestedByInput,
        Iterable<_i2.ConsultationUncheckedCreateWithoutRequestedByInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.ConsultationCreateOrConnectWithoutRequestedByInput,
    Iterable<_i2.ConsultationCreateOrConnectWithoutRequestedByInput>
  >?
  connectOrCreate;

  final _i2.ConsultationCreateManyRequestedByInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.ConsultationWhereUniqueInput,
    Iterable<_i2.ConsultationWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class ConsulteeProfileCreateWithoutConsultantReviewsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileCreateWithoutConsultantReviewsInput({
    this.id,
    this.education,
    this.occupation,
    this.aboutMe,
    this.preferredCommunicationMethod,
    this.preferredLanguage,
    this.specialRequirements,
    this.interests,
    this.goals,
    this.createdAt,
    this.updatedAt,
    this.consultationRequests,
    this.subscriptionRequests,
    required this.user,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? education;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? occupation;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? aboutMe;

  final _i1.PrismaUnion<_i3.ConsultationMode, _i1.PrismaNull>?
  preferredCommunicationMethod;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? preferredLanguage;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? specialRequirements;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? interests;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? goals;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ConsultationCreateNestedManyWithoutRequestedByInput?
  consultationRequests;

  final _i2.SubscriptionCreateNestedManyWithoutRequestedByInput?
  subscriptionRequests;

  final _i2.UserCreateNestedOneWithoutConsulteeProfileInput user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'education': education,
    'occupation': occupation,
    'aboutMe': aboutMe,
    'preferredCommunicationMethod': preferredCommunicationMethod,
    'preferredLanguage': preferredLanguage,
    'specialRequirements': specialRequirements,
    'interests': interests,
    'goals': goals,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultationRequests': consultationRequests,
    'subscriptionRequests': subscriptionRequests,
    'user': user,
  };
}

class ConsulteeProfileUncheckedCreateWithoutConsultantReviewsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileUncheckedCreateWithoutConsultantReviewsInput({
    this.id,
    this.education,
    this.occupation,
    this.aboutMe,
    this.preferredCommunicationMethod,
    this.preferredLanguage,
    this.specialRequirements,
    this.interests,
    this.goals,
    required this.userId,
    this.createdAt,
    this.updatedAt,
    this.consultationRequests,
    this.subscriptionRequests,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? education;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? occupation;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? aboutMe;

  final _i1.PrismaUnion<_i3.ConsultationMode, _i1.PrismaNull>?
  preferredCommunicationMethod;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? preferredLanguage;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? specialRequirements;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? interests;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? goals;

  final String userId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ConsultationUncheckedCreateNestedManyWithoutRequestedByInput?
  consultationRequests;

  final _i2.SubscriptionUncheckedCreateNestedManyWithoutRequestedByInput?
  subscriptionRequests;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'education': education,
    'occupation': occupation,
    'aboutMe': aboutMe,
    'preferredCommunicationMethod': preferredCommunicationMethod,
    'preferredLanguage': preferredLanguage,
    'specialRequirements': specialRequirements,
    'interests': interests,
    'goals': goals,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultationRequests': consultationRequests,
    'subscriptionRequests': subscriptionRequests,
  };
}

class ConsulteeProfileCreateOrConnectWithoutConsultantReviewsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileCreateOrConnectWithoutConsultantReviewsInput({
    required this.where,
    required this.create,
  });

  final _i2.ConsulteeProfileWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.ConsulteeProfileCreateWithoutConsultantReviewsInput,
    _i2.ConsulteeProfileUncheckedCreateWithoutConsultantReviewsInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class ConsulteeProfileCreateNestedOneWithoutConsultantReviewsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileCreateNestedOneWithoutConsultantReviewsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.ConsulteeProfileCreateWithoutConsultantReviewsInput,
    _i2.ConsulteeProfileUncheckedCreateWithoutConsultantReviewsInput
  >?
  create;

  final _i2.ConsulteeProfileCreateOrConnectWithoutConsultantReviewsInput?
  connectOrCreate;

  final _i2.ConsulteeProfileWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class ConsultantReviewCreateWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewCreateWithoutConsultantProfileInput({
    this.id,
    this.rating,
    this.reviewDescription,
    this.createdAt,
    this.updatedAt,
    required this.consulteeProfile,
  });

  final String? id;

  final int? rating;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? reviewDescription;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ConsulteeProfileCreateNestedOneWithoutConsultantReviewsInput
  consulteeProfile;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'rating': rating,
    'reviewDescription': reviewDescription,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consulteeProfile': consulteeProfile,
  };
}

class ConsultantReviewCreateNestedManyWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewCreateNestedManyWithoutConsultantProfileInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.ConsultantReviewCreateWithoutConsultantProfileInput,
    _i1.PrismaUnion<
      Iterable<_i2.ConsultantReviewCreateWithoutConsultantProfileInput>,
      _i1.PrismaUnion<
        _i2.ConsultantReviewUncheckedCreateWithoutConsultantProfileInput,
        Iterable<
          _i2.ConsultantReviewUncheckedCreateWithoutConsultantProfileInput
        >
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewCreateOrConnectWithoutConsultantProfileInput,
    Iterable<_i2.ConsultantReviewCreateOrConnectWithoutConsultantProfileInput>
  >?
  connectOrCreate;

  final _i2.ConsultantReviewCreateManyConsultantProfileInputEnvelope?
  createMany;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewWhereUniqueInput,
    Iterable<_i2.ConsultantReviewWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class ConsultantProfileCreateWithoutTagsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileCreateWithoutTagsInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    required this.scheduleType,
    this.createdAt,
    this.updatedAt,
    required this.domain,
    this.subDomains,
    this.reviews,
    this.slotsOfAvailabilityWeekly,
    this.slotsOfAvailabilityCustom,
    this.consultationPlans,
    this.subscriptionPlans,
    this.webinarPlans,
    this.classPlans,
    required this.user,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? qualifications;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? specialization;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? experience;

  final double? rating;

  final _i3.ScheduleType scheduleType;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.DomainCreateNestedOneWithoutConsultantProfilesInput domain;

  final _i2.SubDomainCreateNestedManyWithoutConsultantProfilesInput? subDomains;

  final _i2.ConsultantReviewCreateNestedManyWithoutConsultantProfileInput?
  reviews;

  final _i2.SlotOfAvailabilityWeeklyCreateNestedManyWithoutConsultantProfileInput?
  slotsOfAvailabilityWeekly;

  final _i2.SlotOfAvailabilityCustomCreateNestedManyWithoutConsultantProfileInput?
  slotsOfAvailabilityCustom;

  final _i2.ConsultationPlanCreateNestedManyWithoutConsultantProfileInput?
  consultationPlans;

  final _i2.SubscriptionPlanCreateNestedManyWithoutConsultantProfileInput?
  subscriptionPlans;

  final _i2.WebinarPlanCreateNestedManyWithoutConsultantProfileInput?
  webinarPlans;

  final _i2.ClassPlanCreateNestedManyWithoutConsultantProfileInput? classPlans;

  final _i2.UserCreateNestedOneWithoutConsultantProfileInput user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'scheduleType': scheduleType,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'domain': domain,
    'subDomains': subDomains,
    'reviews': reviews,
    'slotsOfAvailabilityWeekly': slotsOfAvailabilityWeekly,
    'slotsOfAvailabilityCustom': slotsOfAvailabilityCustom,
    'consultationPlans': consultationPlans,
    'subscriptionPlans': subscriptionPlans,
    'webinarPlans': webinarPlans,
    'classPlans': classPlans,
    'user': user,
  };
}

class ConsultantProfileUncheckedCreateWithoutTagsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUncheckedCreateWithoutTagsInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    required this.domainId,
    required this.scheduleType,
    required this.userId,
    this.createdAt,
    this.updatedAt,
    this.subDomains,
    this.reviews,
    this.slotsOfAvailabilityWeekly,
    this.slotsOfAvailabilityCustom,
    this.consultationPlans,
    this.subscriptionPlans,
    this.webinarPlans,
    this.classPlans,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? qualifications;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? specialization;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? experience;

  final double? rating;

  final String domainId;

  final _i3.ScheduleType scheduleType;

  final String userId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.SubDomainUncheckedCreateNestedManyWithoutConsultantProfilesInput?
  subDomains;

  final _i2.ConsultantReviewUncheckedCreateNestedManyWithoutConsultantProfileInput?
  reviews;

  final _i2.SlotOfAvailabilityWeeklyUncheckedCreateNestedManyWithoutConsultantProfileInput?
  slotsOfAvailabilityWeekly;

  final _i2.SlotOfAvailabilityCustomUncheckedCreateNestedManyWithoutConsultantProfileInput?
  slotsOfAvailabilityCustom;

  final _i2.ConsultationPlanUncheckedCreateNestedManyWithoutConsultantProfileInput?
  consultationPlans;

  final _i2.SubscriptionPlanUncheckedCreateNestedManyWithoutConsultantProfileInput?
  subscriptionPlans;

  final _i2.WebinarPlanUncheckedCreateNestedManyWithoutConsultantProfileInput?
  webinarPlans;

  final _i2.ClassPlanUncheckedCreateNestedManyWithoutConsultantProfileInput?
  classPlans;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'domainId': domainId,
    'scheduleType': scheduleType,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'subDomains': subDomains,
    'reviews': reviews,
    'slotsOfAvailabilityWeekly': slotsOfAvailabilityWeekly,
    'slotsOfAvailabilityCustom': slotsOfAvailabilityCustom,
    'consultationPlans': consultationPlans,
    'subscriptionPlans': subscriptionPlans,
    'webinarPlans': webinarPlans,
    'classPlans': classPlans,
  };
}

class ConsultantProfileCreateOrConnectWithoutTagsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileCreateOrConnectWithoutTagsInput({
    required this.where,
    required this.create,
  });

  final _i2.ConsultantProfileWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateWithoutTagsInput,
    _i2.ConsultantProfileUncheckedCreateWithoutTagsInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class ConsultantProfileCreateNestedManyWithoutTagsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileCreateNestedManyWithoutTagsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateWithoutTagsInput,
    _i1.PrismaUnion<
      Iterable<_i2.ConsultantProfileCreateWithoutTagsInput>,
      _i1.PrismaUnion<
        _i2.ConsultantProfileUncheckedCreateWithoutTagsInput,
        Iterable<_i2.ConsultantProfileUncheckedCreateWithoutTagsInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateOrConnectWithoutTagsInput,
    Iterable<_i2.ConsultantProfileCreateOrConnectWithoutTagsInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileWhereUniqueInput,
    Iterable<_i2.ConsultantProfileWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class TagCreateWithoutDomainInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagCreateWithoutDomainInput({
    this.id,
    required this.name,
    this.createdAt,
    this.updatedAt,
    this.consultantProfiles,
  });

  final String? id;

  final String name;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ConsultantProfileCreateNestedManyWithoutTagsInput?
  consultantProfiles;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultantProfiles': consultantProfiles,
  };
}

class ConsultantProfileUncheckedCreateNestedManyWithoutTagsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUncheckedCreateNestedManyWithoutTagsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateWithoutTagsInput,
    _i1.PrismaUnion<
      Iterable<_i2.ConsultantProfileCreateWithoutTagsInput>,
      _i1.PrismaUnion<
        _i2.ConsultantProfileUncheckedCreateWithoutTagsInput,
        Iterable<_i2.ConsultantProfileUncheckedCreateWithoutTagsInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateOrConnectWithoutTagsInput,
    Iterable<_i2.ConsultantProfileCreateOrConnectWithoutTagsInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileWhereUniqueInput,
    Iterable<_i2.ConsultantProfileWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class TagUncheckedCreateWithoutDomainInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagUncheckedCreateWithoutDomainInput({
    this.id,
    required this.name,
    this.createdAt,
    this.updatedAt,
    this.consultantProfiles,
  });

  final String? id;

  final String name;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ConsultantProfileUncheckedCreateNestedManyWithoutTagsInput?
  consultantProfiles;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultantProfiles': consultantProfiles,
  };
}

class TagCreateOrConnectWithoutDomainInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagCreateOrConnectWithoutDomainInput({
    required this.where,
    required this.create,
  });

  final _i2.TagWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.TagCreateWithoutDomainInput,
    _i2.TagUncheckedCreateWithoutDomainInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class TagCreateManyDomainInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagCreateManyDomainInput({
    this.id,
    required this.name,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final String name;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class TagCreateManyDomainInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagCreateManyDomainInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<
    _i2.TagCreateManyDomainInput,
    Iterable<_i2.TagCreateManyDomainInput>
  >
  data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
    'data': data,
    'skipDuplicates': skipDuplicates,
  };
}

class TagCreateNestedManyWithoutDomainInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagCreateNestedManyWithoutDomainInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.TagCreateWithoutDomainInput,
    _i1.PrismaUnion<
      Iterable<_i2.TagCreateWithoutDomainInput>,
      _i1.PrismaUnion<
        _i2.TagUncheckedCreateWithoutDomainInput,
        Iterable<_i2.TagUncheckedCreateWithoutDomainInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.TagCreateOrConnectWithoutDomainInput,
    Iterable<_i2.TagCreateOrConnectWithoutDomainInput>
  >?
  connectOrCreate;

  final _i2.TagCreateManyDomainInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.TagWhereUniqueInput,
    Iterable<_i2.TagWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class DomainCreateWithoutSubDomainsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomainCreateWithoutSubDomainsInput({
    this.id,
    required this.name,
    this.createdAt,
    this.updatedAt,
    this.tags,
    this.consultantProfiles,
  });

  final String? id;

  final String name;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.TagCreateNestedManyWithoutDomainInput? tags;

  final _i2.ConsultantProfileCreateNestedManyWithoutDomainInput?
  consultantProfiles;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'tags': tags,
    'consultantProfiles': consultantProfiles,
  };
}

class TagUncheckedCreateNestedManyWithoutDomainInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagUncheckedCreateNestedManyWithoutDomainInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.TagCreateWithoutDomainInput,
    _i1.PrismaUnion<
      Iterable<_i2.TagCreateWithoutDomainInput>,
      _i1.PrismaUnion<
        _i2.TagUncheckedCreateWithoutDomainInput,
        Iterable<_i2.TagUncheckedCreateWithoutDomainInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.TagCreateOrConnectWithoutDomainInput,
    Iterable<_i2.TagCreateOrConnectWithoutDomainInput>
  >?
  connectOrCreate;

  final _i2.TagCreateManyDomainInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.TagWhereUniqueInput,
    Iterable<_i2.TagWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class ConsultantProfileUncheckedCreateWithoutDomainInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUncheckedCreateWithoutDomainInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    required this.scheduleType,
    required this.userId,
    this.createdAt,
    this.updatedAt,
    this.subDomains,
    this.tags,
    this.reviews,
    this.slotsOfAvailabilityWeekly,
    this.slotsOfAvailabilityCustom,
    this.consultationPlans,
    this.subscriptionPlans,
    this.webinarPlans,
    this.classPlans,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? qualifications;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? specialization;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? experience;

  final double? rating;

  final _i3.ScheduleType scheduleType;

  final String userId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.SubDomainUncheckedCreateNestedManyWithoutConsultantProfilesInput?
  subDomains;

  final _i2.TagUncheckedCreateNestedManyWithoutConsultantProfilesInput? tags;

  final _i2.ConsultantReviewUncheckedCreateNestedManyWithoutConsultantProfileInput?
  reviews;

  final _i2.SlotOfAvailabilityWeeklyUncheckedCreateNestedManyWithoutConsultantProfileInput?
  slotsOfAvailabilityWeekly;

  final _i2.SlotOfAvailabilityCustomUncheckedCreateNestedManyWithoutConsultantProfileInput?
  slotsOfAvailabilityCustom;

  final _i2.ConsultationPlanUncheckedCreateNestedManyWithoutConsultantProfileInput?
  consultationPlans;

  final _i2.SubscriptionPlanUncheckedCreateNestedManyWithoutConsultantProfileInput?
  subscriptionPlans;

  final _i2.WebinarPlanUncheckedCreateNestedManyWithoutConsultantProfileInput?
  webinarPlans;

  final _i2.ClassPlanUncheckedCreateNestedManyWithoutConsultantProfileInput?
  classPlans;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'scheduleType': scheduleType,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'subDomains': subDomains,
    'tags': tags,
    'reviews': reviews,
    'slotsOfAvailabilityWeekly': slotsOfAvailabilityWeekly,
    'slotsOfAvailabilityCustom': slotsOfAvailabilityCustom,
    'consultationPlans': consultationPlans,
    'subscriptionPlans': subscriptionPlans,
    'webinarPlans': webinarPlans,
    'classPlans': classPlans,
  };
}

class ConsultantProfileCreateOrConnectWithoutDomainInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileCreateOrConnectWithoutDomainInput({
    required this.where,
    required this.create,
  });

  final _i2.ConsultantProfileWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateWithoutDomainInput,
    _i2.ConsultantProfileUncheckedCreateWithoutDomainInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class ConsultantProfileCreateManyDomainInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileCreateManyDomainInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    required this.scheduleType,
    required this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? qualifications;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? specialization;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? experience;

  final double? rating;

  final _i3.ScheduleType scheduleType;

  final String userId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'scheduleType': scheduleType,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultantProfileCreateManyDomainInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileCreateManyDomainInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateManyDomainInput,
    Iterable<_i2.ConsultantProfileCreateManyDomainInput>
  >
  data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
    'data': data,
    'skipDuplicates': skipDuplicates,
  };
}

class ConsultantProfileUncheckedCreateNestedManyWithoutDomainInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUncheckedCreateNestedManyWithoutDomainInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateWithoutDomainInput,
    _i1.PrismaUnion<
      Iterable<_i2.ConsultantProfileCreateWithoutDomainInput>,
      _i1.PrismaUnion<
        _i2.ConsultantProfileUncheckedCreateWithoutDomainInput,
        Iterable<_i2.ConsultantProfileUncheckedCreateWithoutDomainInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateOrConnectWithoutDomainInput,
    Iterable<_i2.ConsultantProfileCreateOrConnectWithoutDomainInput>
  >?
  connectOrCreate;

  final _i2.ConsultantProfileCreateManyDomainInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileWhereUniqueInput,
    Iterable<_i2.ConsultantProfileWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class DomainUncheckedCreateWithoutSubDomainsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomainUncheckedCreateWithoutSubDomainsInput({
    this.id,
    required this.name,
    this.createdAt,
    this.updatedAt,
    this.tags,
    this.consultantProfiles,
  });

  final String? id;

  final String name;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.TagUncheckedCreateNestedManyWithoutDomainInput? tags;

  final _i2.ConsultantProfileUncheckedCreateNestedManyWithoutDomainInput?
  consultantProfiles;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'tags': tags,
    'consultantProfiles': consultantProfiles,
  };
}

class DomainWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomainWhereUniqueInput({this.id, this.name});

  final String? id;

  final String? name;

  @override
  Map<String, dynamic> toJson() => {'id': id, 'name': name};
}

class DomainCreateOrConnectWithoutSubDomainsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomainCreateOrConnectWithoutSubDomainsInput({
    required this.where,
    required this.create,
  });

  final _i2.DomainWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.DomainCreateWithoutSubDomainsInput,
    _i2.DomainUncheckedCreateWithoutSubDomainsInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class DomainCreateNestedOneWithoutSubDomainsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomainCreateNestedOneWithoutSubDomainsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.DomainCreateWithoutSubDomainsInput,
    _i2.DomainUncheckedCreateWithoutSubDomainsInput
  >?
  create;

  final _i2.DomainCreateOrConnectWithoutSubDomainsInput? connectOrCreate;

  final _i2.DomainWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class SubDomainCreateWithoutConsultantProfilesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainCreateWithoutConsultantProfilesInput({
    this.id,
    required this.name,
    this.createdAt,
    this.updatedAt,
    required this.domain,
  });

  final String? id;

  final String name;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.DomainCreateNestedOneWithoutSubDomainsInput domain;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'domain': domain,
  };
}

class SubDomainCreateNestedManyWithoutConsultantProfilesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainCreateNestedManyWithoutConsultantProfilesInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.SubDomainCreateWithoutConsultantProfilesInput,
    _i1.PrismaUnion<
      Iterable<_i2.SubDomainCreateWithoutConsultantProfilesInput>,
      _i1.PrismaUnion<
        _i2.SubDomainUncheckedCreateWithoutConsultantProfilesInput,
        Iterable<_i2.SubDomainUncheckedCreateWithoutConsultantProfilesInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.SubDomainCreateOrConnectWithoutConsultantProfilesInput,
    Iterable<_i2.SubDomainCreateOrConnectWithoutConsultantProfilesInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.SubDomainWhereUniqueInput,
    Iterable<_i2.SubDomainWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class ConsultantProfileCreateWithoutDomainInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileCreateWithoutDomainInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    required this.scheduleType,
    this.createdAt,
    this.updatedAt,
    this.subDomains,
    this.tags,
    this.reviews,
    this.slotsOfAvailabilityWeekly,
    this.slotsOfAvailabilityCustom,
    this.consultationPlans,
    this.subscriptionPlans,
    this.webinarPlans,
    this.classPlans,
    required this.user,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? qualifications;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? specialization;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? experience;

  final double? rating;

  final _i3.ScheduleType scheduleType;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.SubDomainCreateNestedManyWithoutConsultantProfilesInput? subDomains;

  final _i2.TagCreateNestedManyWithoutConsultantProfilesInput? tags;

  final _i2.ConsultantReviewCreateNestedManyWithoutConsultantProfileInput?
  reviews;

  final _i2.SlotOfAvailabilityWeeklyCreateNestedManyWithoutConsultantProfileInput?
  slotsOfAvailabilityWeekly;

  final _i2.SlotOfAvailabilityCustomCreateNestedManyWithoutConsultantProfileInput?
  slotsOfAvailabilityCustom;

  final _i2.ConsultationPlanCreateNestedManyWithoutConsultantProfileInput?
  consultationPlans;

  final _i2.SubscriptionPlanCreateNestedManyWithoutConsultantProfileInput?
  subscriptionPlans;

  final _i2.WebinarPlanCreateNestedManyWithoutConsultantProfileInput?
  webinarPlans;

  final _i2.ClassPlanCreateNestedManyWithoutConsultantProfileInput? classPlans;

  final _i2.UserCreateNestedOneWithoutConsultantProfileInput user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'scheduleType': scheduleType,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'subDomains': subDomains,
    'tags': tags,
    'reviews': reviews,
    'slotsOfAvailabilityWeekly': slotsOfAvailabilityWeekly,
    'slotsOfAvailabilityCustom': slotsOfAvailabilityCustom,
    'consultationPlans': consultationPlans,
    'subscriptionPlans': subscriptionPlans,
    'webinarPlans': webinarPlans,
    'classPlans': classPlans,
    'user': user,
  };
}

class ConsultantProfileCreateNestedManyWithoutDomainInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileCreateNestedManyWithoutDomainInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateWithoutDomainInput,
    _i1.PrismaUnion<
      Iterable<_i2.ConsultantProfileCreateWithoutDomainInput>,
      _i1.PrismaUnion<
        _i2.ConsultantProfileUncheckedCreateWithoutDomainInput,
        Iterable<_i2.ConsultantProfileUncheckedCreateWithoutDomainInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateOrConnectWithoutDomainInput,
    Iterable<_i2.ConsultantProfileCreateOrConnectWithoutDomainInput>
  >?
  connectOrCreate;

  final _i2.ConsultantProfileCreateManyDomainInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileWhereUniqueInput,
    Iterable<_i2.ConsultantProfileWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class DomainCreateWithoutTagsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomainCreateWithoutTagsInput({
    this.id,
    required this.name,
    this.createdAt,
    this.updatedAt,
    this.subDomains,
    this.consultantProfiles,
  });

  final String? id;

  final String name;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.SubDomainCreateNestedManyWithoutDomainInput? subDomains;

  final _i2.ConsultantProfileCreateNestedManyWithoutDomainInput?
  consultantProfiles;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'subDomains': subDomains,
    'consultantProfiles': consultantProfiles,
  };
}

class ConsultantProfileUncheckedCreateWithoutSubDomainsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUncheckedCreateWithoutSubDomainsInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    required this.domainId,
    required this.scheduleType,
    required this.userId,
    this.createdAt,
    this.updatedAt,
    this.tags,
    this.reviews,
    this.slotsOfAvailabilityWeekly,
    this.slotsOfAvailabilityCustom,
    this.consultationPlans,
    this.subscriptionPlans,
    this.webinarPlans,
    this.classPlans,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? qualifications;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? specialization;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? experience;

  final double? rating;

  final String domainId;

  final _i3.ScheduleType scheduleType;

  final String userId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.TagUncheckedCreateNestedManyWithoutConsultantProfilesInput? tags;

  final _i2.ConsultantReviewUncheckedCreateNestedManyWithoutConsultantProfileInput?
  reviews;

  final _i2.SlotOfAvailabilityWeeklyUncheckedCreateNestedManyWithoutConsultantProfileInput?
  slotsOfAvailabilityWeekly;

  final _i2.SlotOfAvailabilityCustomUncheckedCreateNestedManyWithoutConsultantProfileInput?
  slotsOfAvailabilityCustom;

  final _i2.ConsultationPlanUncheckedCreateNestedManyWithoutConsultantProfileInput?
  consultationPlans;

  final _i2.SubscriptionPlanUncheckedCreateNestedManyWithoutConsultantProfileInput?
  subscriptionPlans;

  final _i2.WebinarPlanUncheckedCreateNestedManyWithoutConsultantProfileInput?
  webinarPlans;

  final _i2.ClassPlanUncheckedCreateNestedManyWithoutConsultantProfileInput?
  classPlans;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'domainId': domainId,
    'scheduleType': scheduleType,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'tags': tags,
    'reviews': reviews,
    'slotsOfAvailabilityWeekly': slotsOfAvailabilityWeekly,
    'slotsOfAvailabilityCustom': slotsOfAvailabilityCustom,
    'consultationPlans': consultationPlans,
    'subscriptionPlans': subscriptionPlans,
    'webinarPlans': webinarPlans,
    'classPlans': classPlans,
  };
}

class ConsultantProfileCreateOrConnectWithoutSubDomainsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileCreateOrConnectWithoutSubDomainsInput({
    required this.where,
    required this.create,
  });

  final _i2.ConsultantProfileWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateWithoutSubDomainsInput,
    _i2.ConsultantProfileUncheckedCreateWithoutSubDomainsInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class ConsultantProfileUncheckedCreateNestedManyWithoutSubDomainsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUncheckedCreateNestedManyWithoutSubDomainsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateWithoutSubDomainsInput,
    _i1.PrismaUnion<
      Iterable<_i2.ConsultantProfileCreateWithoutSubDomainsInput>,
      _i1.PrismaUnion<
        _i2.ConsultantProfileUncheckedCreateWithoutSubDomainsInput,
        Iterable<_i2.ConsultantProfileUncheckedCreateWithoutSubDomainsInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateOrConnectWithoutSubDomainsInput,
    Iterable<_i2.ConsultantProfileCreateOrConnectWithoutSubDomainsInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileWhereUniqueInput,
    Iterable<_i2.ConsultantProfileWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class SubDomainUncheckedCreateWithoutDomainInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainUncheckedCreateWithoutDomainInput({
    this.id,
    required this.name,
    this.createdAt,
    this.updatedAt,
    this.consultantProfiles,
  });

  final String? id;

  final String name;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ConsultantProfileUncheckedCreateNestedManyWithoutSubDomainsInput?
  consultantProfiles;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultantProfiles': consultantProfiles,
  };
}

class SubDomainCreateOrConnectWithoutDomainInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainCreateOrConnectWithoutDomainInput({
    required this.where,
    required this.create,
  });

  final _i2.SubDomainWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.SubDomainCreateWithoutDomainInput,
    _i2.SubDomainUncheckedCreateWithoutDomainInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class SubDomainCreateManyDomainInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainCreateManyDomainInput({
    this.id,
    required this.name,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final String name;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SubDomainCreateManyDomainInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainCreateManyDomainInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<
    _i2.SubDomainCreateManyDomainInput,
    Iterable<_i2.SubDomainCreateManyDomainInput>
  >
  data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
    'data': data,
    'skipDuplicates': skipDuplicates,
  };
}

class SubDomainUncheckedCreateNestedManyWithoutDomainInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainUncheckedCreateNestedManyWithoutDomainInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.SubDomainCreateWithoutDomainInput,
    _i1.PrismaUnion<
      Iterable<_i2.SubDomainCreateWithoutDomainInput>,
      _i1.PrismaUnion<
        _i2.SubDomainUncheckedCreateWithoutDomainInput,
        Iterable<_i2.SubDomainUncheckedCreateWithoutDomainInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.SubDomainCreateOrConnectWithoutDomainInput,
    Iterable<_i2.SubDomainCreateOrConnectWithoutDomainInput>
  >?
  connectOrCreate;

  final _i2.SubDomainCreateManyDomainInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.SubDomainWhereUniqueInput,
    Iterable<_i2.SubDomainWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class DomainUncheckedCreateWithoutTagsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomainUncheckedCreateWithoutTagsInput({
    this.id,
    required this.name,
    this.createdAt,
    this.updatedAt,
    this.subDomains,
    this.consultantProfiles,
  });

  final String? id;

  final String name;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.SubDomainUncheckedCreateNestedManyWithoutDomainInput? subDomains;

  final _i2.ConsultantProfileUncheckedCreateNestedManyWithoutDomainInput?
  consultantProfiles;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'subDomains': subDomains,
    'consultantProfiles': consultantProfiles,
  };
}

class DomainCreateOrConnectWithoutTagsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomainCreateOrConnectWithoutTagsInput({
    required this.where,
    required this.create,
  });

  final _i2.DomainWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.DomainCreateWithoutTagsInput,
    _i2.DomainUncheckedCreateWithoutTagsInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class DomainCreateNestedOneWithoutTagsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomainCreateNestedOneWithoutTagsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.DomainCreateWithoutTagsInput,
    _i2.DomainUncheckedCreateWithoutTagsInput
  >?
  create;

  final _i2.DomainCreateOrConnectWithoutTagsInput? connectOrCreate;

  final _i2.DomainWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class TagCreateWithoutConsultantProfilesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagCreateWithoutConsultantProfilesInput({
    this.id,
    required this.name,
    this.createdAt,
    this.updatedAt,
    required this.domain,
  });

  final String? id;

  final String name;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.DomainCreateNestedOneWithoutTagsInput domain;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'domain': domain,
  };
}

class TagCreateNestedManyWithoutConsultantProfilesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagCreateNestedManyWithoutConsultantProfilesInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.TagCreateWithoutConsultantProfilesInput,
    _i1.PrismaUnion<
      Iterable<_i2.TagCreateWithoutConsultantProfilesInput>,
      _i1.PrismaUnion<
        _i2.TagUncheckedCreateWithoutConsultantProfilesInput,
        Iterable<_i2.TagUncheckedCreateWithoutConsultantProfilesInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.TagCreateOrConnectWithoutConsultantProfilesInput,
    Iterable<_i2.TagCreateOrConnectWithoutConsultantProfilesInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.TagWhereUniqueInput,
    Iterable<_i2.TagWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class ConsultantProfileCreateWithoutSubDomainsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileCreateWithoutSubDomainsInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    required this.scheduleType,
    this.createdAt,
    this.updatedAt,
    required this.domain,
    this.tags,
    this.reviews,
    this.slotsOfAvailabilityWeekly,
    this.slotsOfAvailabilityCustom,
    this.consultationPlans,
    this.subscriptionPlans,
    this.webinarPlans,
    this.classPlans,
    required this.user,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? qualifications;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? specialization;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? experience;

  final double? rating;

  final _i3.ScheduleType scheduleType;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.DomainCreateNestedOneWithoutConsultantProfilesInput domain;

  final _i2.TagCreateNestedManyWithoutConsultantProfilesInput? tags;

  final _i2.ConsultantReviewCreateNestedManyWithoutConsultantProfileInput?
  reviews;

  final _i2.SlotOfAvailabilityWeeklyCreateNestedManyWithoutConsultantProfileInput?
  slotsOfAvailabilityWeekly;

  final _i2.SlotOfAvailabilityCustomCreateNestedManyWithoutConsultantProfileInput?
  slotsOfAvailabilityCustom;

  final _i2.ConsultationPlanCreateNestedManyWithoutConsultantProfileInput?
  consultationPlans;

  final _i2.SubscriptionPlanCreateNestedManyWithoutConsultantProfileInput?
  subscriptionPlans;

  final _i2.WebinarPlanCreateNestedManyWithoutConsultantProfileInput?
  webinarPlans;

  final _i2.ClassPlanCreateNestedManyWithoutConsultantProfileInput? classPlans;

  final _i2.UserCreateNestedOneWithoutConsultantProfileInput user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'scheduleType': scheduleType,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'domain': domain,
    'tags': tags,
    'reviews': reviews,
    'slotsOfAvailabilityWeekly': slotsOfAvailabilityWeekly,
    'slotsOfAvailabilityCustom': slotsOfAvailabilityCustom,
    'consultationPlans': consultationPlans,
    'subscriptionPlans': subscriptionPlans,
    'webinarPlans': webinarPlans,
    'classPlans': classPlans,
    'user': user,
  };
}

class ConsultantProfileCreateNestedManyWithoutSubDomainsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileCreateNestedManyWithoutSubDomainsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateWithoutSubDomainsInput,
    _i1.PrismaUnion<
      Iterable<_i2.ConsultantProfileCreateWithoutSubDomainsInput>,
      _i1.PrismaUnion<
        _i2.ConsultantProfileUncheckedCreateWithoutSubDomainsInput,
        Iterable<_i2.ConsultantProfileUncheckedCreateWithoutSubDomainsInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateOrConnectWithoutSubDomainsInput,
    Iterable<_i2.ConsultantProfileCreateOrConnectWithoutSubDomainsInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileWhereUniqueInput,
    Iterable<_i2.ConsultantProfileWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class SubDomainCreateWithoutDomainInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainCreateWithoutDomainInput({
    this.id,
    required this.name,
    this.createdAt,
    this.updatedAt,
    this.consultantProfiles,
  });

  final String? id;

  final String name;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ConsultantProfileCreateNestedManyWithoutSubDomainsInput?
  consultantProfiles;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultantProfiles': consultantProfiles,
  };
}

class SubDomainCreateNestedManyWithoutDomainInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainCreateNestedManyWithoutDomainInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.SubDomainCreateWithoutDomainInput,
    _i1.PrismaUnion<
      Iterable<_i2.SubDomainCreateWithoutDomainInput>,
      _i1.PrismaUnion<
        _i2.SubDomainUncheckedCreateWithoutDomainInput,
        Iterable<_i2.SubDomainUncheckedCreateWithoutDomainInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.SubDomainCreateOrConnectWithoutDomainInput,
    Iterable<_i2.SubDomainCreateOrConnectWithoutDomainInput>
  >?
  connectOrCreate;

  final _i2.SubDomainCreateManyDomainInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.SubDomainWhereUniqueInput,
    Iterable<_i2.SubDomainWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class DomainCreateWithoutConsultantProfilesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomainCreateWithoutConsultantProfilesInput({
    this.id,
    required this.name,
    this.createdAt,
    this.updatedAt,
    this.subDomains,
    this.tags,
  });

  final String? id;

  final String name;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.SubDomainCreateNestedManyWithoutDomainInput? subDomains;

  final _i2.TagCreateNestedManyWithoutDomainInput? tags;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'subDomains': subDomains,
    'tags': tags,
  };
}

class DomainUncheckedCreateWithoutConsultantProfilesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomainUncheckedCreateWithoutConsultantProfilesInput({
    this.id,
    required this.name,
    this.createdAt,
    this.updatedAt,
    this.subDomains,
    this.tags,
  });

  final String? id;

  final String name;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.SubDomainUncheckedCreateNestedManyWithoutDomainInput? subDomains;

  final _i2.TagUncheckedCreateNestedManyWithoutDomainInput? tags;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'subDomains': subDomains,
    'tags': tags,
  };
}

class DomainCreateOrConnectWithoutConsultantProfilesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomainCreateOrConnectWithoutConsultantProfilesInput({
    required this.where,
    required this.create,
  });

  final _i2.DomainWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.DomainCreateWithoutConsultantProfilesInput,
    _i2.DomainUncheckedCreateWithoutConsultantProfilesInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class DomainCreateNestedOneWithoutConsultantProfilesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomainCreateNestedOneWithoutConsultantProfilesInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.DomainCreateWithoutConsultantProfilesInput,
    _i2.DomainUncheckedCreateWithoutConsultantProfilesInput
  >?
  create;

  final _i2.DomainCreateOrConnectWithoutConsultantProfilesInput?
  connectOrCreate;

  final _i2.DomainWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class ConsultantProfileCreateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileCreateWithoutUserInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    required this.scheduleType,
    this.createdAt,
    this.updatedAt,
    required this.domain,
    this.subDomains,
    this.tags,
    this.reviews,
    this.slotsOfAvailabilityWeekly,
    this.slotsOfAvailabilityCustom,
    this.consultationPlans,
    this.subscriptionPlans,
    this.webinarPlans,
    this.classPlans,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? qualifications;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? specialization;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? experience;

  final double? rating;

  final _i3.ScheduleType scheduleType;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.DomainCreateNestedOneWithoutConsultantProfilesInput domain;

  final _i2.SubDomainCreateNestedManyWithoutConsultantProfilesInput? subDomains;

  final _i2.TagCreateNestedManyWithoutConsultantProfilesInput? tags;

  final _i2.ConsultantReviewCreateNestedManyWithoutConsultantProfileInput?
  reviews;

  final _i2.SlotOfAvailabilityWeeklyCreateNestedManyWithoutConsultantProfileInput?
  slotsOfAvailabilityWeekly;

  final _i2.SlotOfAvailabilityCustomCreateNestedManyWithoutConsultantProfileInput?
  slotsOfAvailabilityCustom;

  final _i2.ConsultationPlanCreateNestedManyWithoutConsultantProfileInput?
  consultationPlans;

  final _i2.SubscriptionPlanCreateNestedManyWithoutConsultantProfileInput?
  subscriptionPlans;

  final _i2.WebinarPlanCreateNestedManyWithoutConsultantProfileInput?
  webinarPlans;

  final _i2.ClassPlanCreateNestedManyWithoutConsultantProfileInput? classPlans;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'scheduleType': scheduleType,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'domain': domain,
    'subDomains': subDomains,
    'tags': tags,
    'reviews': reviews,
    'slotsOfAvailabilityWeekly': slotsOfAvailabilityWeekly,
    'slotsOfAvailabilityCustom': slotsOfAvailabilityCustom,
    'consultationPlans': consultationPlans,
    'subscriptionPlans': subscriptionPlans,
    'webinarPlans': webinarPlans,
    'classPlans': classPlans,
  };
}

class ConsultantProfileCreateNestedOneWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileCreateNestedOneWithoutUserInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateWithoutUserInput,
    _i2.ConsultantProfileUncheckedCreateWithoutUserInput
  >?
  create;

  final _i2.ConsultantProfileCreateOrConnectWithoutUserInput? connectOrCreate;

  final _i2.ConsultantProfileWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class UserCreateWithoutSlotsOfAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateWithoutSlotsOfAppointmentInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.cookiePreferences,
    this.notificationPreferences,
    this.payment,
    this.consultantProfile,
    this.consulteeProfile,
    this.staffProfile,
    this.waitlist,
    this.feedbacks,
    this.supportTickets,
    this.supportResponses,
    this.accounts,
    this.sessions,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? email;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? emailVerified;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? image;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? address;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? password;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? passwordResetToken;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? passwordResetExpires;

  final bool? onlineStatus;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? currentTimezone;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? onboardingCompleted;

  final _i1.PrismaUnion<_i3.UserRole, _i1.PrismaNull>? role;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consultantProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consulteeProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? staffProfileId;

  final _i2.CookiePreferenceCreateNestedOneWithoutUserInput? cookiePreferences;

  final _i2.NotificationPreferenceCreateNestedOneWithoutUserInput?
  notificationPreferences;

  final _i2.PaymentCreateNestedManyWithoutUserInput? payment;

  final _i2.ConsultantProfileCreateNestedOneWithoutUserInput? consultantProfile;

  final _i2.ConsulteeProfileCreateNestedOneWithoutUserInput? consulteeProfile;

  final _i2.StaffProfileCreateNestedOneWithoutUserInput? staffProfile;

  final _i2.WaitlistCreateNestedManyWithoutUserInput? waitlist;

  final _i2.FeedbackCreateNestedManyWithoutUserInput? feedbacks;

  final _i2.SupportTicketCreateNestedManyWithoutUserInput? supportTickets;

  final _i2.SupportResponseCreateNestedManyWithoutUserInput? supportResponses;

  final _i2.AccountCreateNestedManyWithoutUserInput? accounts;

  final _i2.SessionCreateNestedManyWithoutUserInput? sessions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'cookiePreferences': cookiePreferences,
    'notificationPreferences': notificationPreferences,
    'Payment': payment,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
    'staffProfile': staffProfile,
    'Waitlist': waitlist,
    'feedbacks': feedbacks,
    'supportTickets': supportTickets,
    'supportResponses': supportResponses,
    'accounts': accounts,
    'sessions': sessions,
  };
}

class UserCreateNestedManyWithoutSlotsOfAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateNestedManyWithoutSlotsOfAppointmentInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.UserCreateWithoutSlotsOfAppointmentInput,
    _i1.PrismaUnion<
      Iterable<_i2.UserCreateWithoutSlotsOfAppointmentInput>,
      _i1.PrismaUnion<
        _i2.UserUncheckedCreateWithoutSlotsOfAppointmentInput,
        Iterable<_i2.UserUncheckedCreateWithoutSlotsOfAppointmentInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.UserCreateOrConnectWithoutSlotsOfAppointmentInput,
    Iterable<_i2.UserCreateOrConnectWithoutSlotsOfAppointmentInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.UserWhereUniqueInput,
    Iterable<_i2.UserWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class SlotOfAppointmentCreateWithoutAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentCreateWithoutAppointmentInput({
    this.id,
    required this.slotStartTimeInUTC,
    required this.slotEndTimeInUTC,
    this.isTentative,
    this.createdAt,
    this.updatedAt,
    this.user,
    this.meetingSession,
  });

  final String? id;

  final DateTime slotStartTimeInUTC;

  final DateTime slotEndTimeInUTC;

  final bool? isTentative;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.UserCreateNestedManyWithoutSlotsOfAppointmentInput? user;

  final _i2.MeetingSessionCreateNestedOneWithoutSlotOfAppointmentInput?
  meetingSession;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'isTentative': isTentative,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'user': user,
    'meetingSession': meetingSession,
  };
}

class SlotOfAppointmentCreateNestedManyWithoutAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentCreateNestedManyWithoutAppointmentInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentCreateWithoutAppointmentInput,
    _i1.PrismaUnion<
      Iterable<_i2.SlotOfAppointmentCreateWithoutAppointmentInput>,
      _i1.PrismaUnion<
        _i2.SlotOfAppointmentUncheckedCreateWithoutAppointmentInput,
        Iterable<_i2.SlotOfAppointmentUncheckedCreateWithoutAppointmentInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentCreateOrConnectWithoutAppointmentInput,
    Iterable<_i2.SlotOfAppointmentCreateOrConnectWithoutAppointmentInput>
  >?
  connectOrCreate;

  final _i2.SlotOfAppointmentCreateManyAppointmentInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentWhereUniqueInput,
    Iterable<_i2.SlotOfAppointmentWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class AppointmentCreateWithoutPaymentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentCreateWithoutPaymentInput({
    this.id,
    required this.appointmentType,
    this.createdAt,
    this.updatedAt,
    this.slotsOfAppointment,
    this.consultation,
    this.subscription,
    this.webinar,
    this.$class,
  });

  final String? id;

  final _i3.AppointmentsType appointmentType;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.SlotOfAppointmentCreateNestedManyWithoutAppointmentInput?
  slotsOfAppointment;

  final _i2.ConsultationCreateNestedOneWithoutAppointmentInput? consultation;

  final _i2.SubscriptionCreateNestedOneWithoutAppointmentsInput? subscription;

  final _i2.WebinarCreateNestedOneWithoutAppointmentInput? webinar;

  final _i2.ClassCreateNestedOneWithoutAppointmentsInput? $class;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'appointmentType': appointmentType,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'slotsOfAppointment': slotsOfAppointment,
    'consultation': consultation,
    'subscription': subscription,
    'webinar': webinar,
    'class': $class,
  };
}

class AppointmentUncheckedCreateWithoutPaymentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentUncheckedCreateWithoutPaymentInput({
    this.id,
    required this.appointmentType,
    this.consultationId,
    this.subscriptionId,
    this.webinarId,
    this.classId,
    this.createdAt,
    this.updatedAt,
    this.slotsOfAppointment,
  });

  final String? id;

  final _i3.AppointmentsType appointmentType;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consultationId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? subscriptionId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? webinarId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? classId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.SlotOfAppointmentUncheckedCreateNestedManyWithoutAppointmentInput?
  slotsOfAppointment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'appointmentType': appointmentType,
    'consultationId': consultationId,
    'subscriptionId': subscriptionId,
    'webinarId': webinarId,
    'classId': classId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'slotsOfAppointment': slotsOfAppointment,
  };
}

class AppointmentCreateOrConnectWithoutPaymentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentCreateOrConnectWithoutPaymentInput({
    required this.where,
    required this.create,
  });

  final _i2.AppointmentWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.AppointmentCreateWithoutPaymentInput,
    _i2.AppointmentUncheckedCreateWithoutPaymentInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class AppointmentCreateNestedOneWithoutPaymentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentCreateNestedOneWithoutPaymentInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.AppointmentCreateWithoutPaymentInput,
    _i2.AppointmentUncheckedCreateWithoutPaymentInput
  >?
  create;

  final _i2.AppointmentCreateOrConnectWithoutPaymentInput? connectOrCreate;

  final _i2.AppointmentWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class PaymentCreateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentCreateWithoutUserInput({
    this.id,
    required this.amount,
    required this.currency,
    this.description,
    this.receiptUrl,
    required this.paymentMethod,
    required this.paymentIntent,
    required this.paymentGateway,
    required this.paymentStatus,
    this.expiresAt,
    this.createdAt,
    this.updatedAt,
    this.appointment,
    this.discountCode,
  });

  final String? id;

  final int amount;

  final String currency;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? receiptUrl;

  final String paymentMethod;

  final String paymentIntent;

  final _i3.PaymentGateway paymentGateway;

  final _i3.PaymentStatus paymentStatus;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? expiresAt;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.AppointmentCreateNestedOneWithoutPaymentInput? appointment;

  final _i2.DiscountCodeCreateNestedOneWithoutPaymentInput? discountCode;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'amount': amount,
    'currency': currency,
    'description': description,
    'receiptUrl': receiptUrl,
    'paymentMethod': paymentMethod,
    'paymentIntent': paymentIntent,
    'paymentGateway': paymentGateway,
    'paymentStatus': paymentStatus,
    'expiresAt': expiresAt,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'appointment': appointment,
    'discountCode': discountCode,
  };
}

class PaymentCreateNestedManyWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentCreateNestedManyWithoutUserInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.PaymentCreateWithoutUserInput,
    _i1.PrismaUnion<
      Iterable<_i2.PaymentCreateWithoutUserInput>,
      _i1.PrismaUnion<
        _i2.PaymentUncheckedCreateWithoutUserInput,
        Iterable<_i2.PaymentUncheckedCreateWithoutUserInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.PaymentCreateOrConnectWithoutUserInput,
    Iterable<_i2.PaymentCreateOrConnectWithoutUserInput>
  >?
  connectOrCreate;

  final _i2.PaymentCreateManyUserInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.PaymentWhereUniqueInput,
    Iterable<_i2.PaymentWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class UserCreateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.cookiePreferences,
    this.notificationPreferences,
    this.payment,
    this.consultantProfile,
    this.consulteeProfile,
    this.staffProfile,
    this.slotsOfAppointment,
    this.waitlist,
    this.feedbacks,
    this.supportTickets,
    this.supportResponses,
    this.accounts,
    this.sessions,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? email;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? emailVerified;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? image;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? address;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? password;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? passwordResetToken;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? passwordResetExpires;

  final bool? onlineStatus;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? currentTimezone;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? onboardingCompleted;

  final _i1.PrismaUnion<_i3.UserRole, _i1.PrismaNull>? role;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consultantProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consulteeProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? staffProfileId;

  final _i2.CookiePreferenceCreateNestedOneWithoutUserInput? cookiePreferences;

  final _i2.NotificationPreferenceCreateNestedOneWithoutUserInput?
  notificationPreferences;

  final _i2.PaymentCreateNestedManyWithoutUserInput? payment;

  final _i2.ConsultantProfileCreateNestedOneWithoutUserInput? consultantProfile;

  final _i2.ConsulteeProfileCreateNestedOneWithoutUserInput? consulteeProfile;

  final _i2.StaffProfileCreateNestedOneWithoutUserInput? staffProfile;

  final _i2.SlotOfAppointmentCreateNestedManyWithoutUserInput?
  slotsOfAppointment;

  final _i2.WaitlistCreateNestedManyWithoutUserInput? waitlist;

  final _i2.FeedbackCreateNestedManyWithoutUserInput? feedbacks;

  final _i2.SupportTicketCreateNestedManyWithoutUserInput? supportTickets;

  final _i2.SupportResponseCreateNestedManyWithoutUserInput? supportResponses;

  final _i2.AccountCreateNestedManyWithoutUserInput? accounts;

  final _i2.SessionCreateNestedManyWithoutUserInput? sessions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'cookiePreferences': cookiePreferences,
    'notificationPreferences': notificationPreferences,
    'Payment': payment,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
    'staffProfile': staffProfile,
    'slotsOfAppointment': slotsOfAppointment,
    'Waitlist': waitlist,
    'feedbacks': feedbacks,
    'supportTickets': supportTickets,
    'supportResponses': supportResponses,
    'accounts': accounts,
    'sessions': sessions,
  };
}

class UserUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUncheckedCreateInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.cookiePreferences,
    this.notificationPreferences,
    this.payment,
    this.consultantProfile,
    this.consulteeProfile,
    this.staffProfile,
    this.slotsOfAppointment,
    this.waitlist,
    this.feedbacks,
    this.supportTickets,
    this.supportResponses,
    this.accounts,
    this.sessions,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? email;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? emailVerified;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? image;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? address;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? password;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? passwordResetToken;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? passwordResetExpires;

  final bool? onlineStatus;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? currentTimezone;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? onboardingCompleted;

  final _i1.PrismaUnion<_i3.UserRole, _i1.PrismaNull>? role;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consultantProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consulteeProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? staffProfileId;

  final _i2.CookiePreferenceUncheckedCreateNestedOneWithoutUserInput?
  cookiePreferences;

  final _i2.NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput?
  notificationPreferences;

  final _i2.PaymentUncheckedCreateNestedManyWithoutUserInput? payment;

  final _i2.ConsultantProfileUncheckedCreateNestedOneWithoutUserInput?
  consultantProfile;

  final _i2.ConsulteeProfileUncheckedCreateNestedOneWithoutUserInput?
  consulteeProfile;

  final _i2.StaffProfileUncheckedCreateNestedOneWithoutUserInput? staffProfile;

  final _i2.SlotOfAppointmentUncheckedCreateNestedManyWithoutUserInput?
  slotsOfAppointment;

  final _i2.WaitlistUncheckedCreateNestedManyWithoutUserInput? waitlist;

  final _i2.FeedbackUncheckedCreateNestedManyWithoutUserInput? feedbacks;

  final _i2.SupportTicketUncheckedCreateNestedManyWithoutUserInput?
  supportTickets;

  final _i2.SupportResponseUncheckedCreateNestedManyWithoutUserInput?
  supportResponses;

  final _i2.AccountUncheckedCreateNestedManyWithoutUserInput? accounts;

  final _i2.SessionUncheckedCreateNestedManyWithoutUserInput? sessions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'cookiePreferences': cookiePreferences,
    'notificationPreferences': notificationPreferences,
    'Payment': payment,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
    'staffProfile': staffProfile,
    'slotsOfAppointment': slotsOfAppointment,
    'Waitlist': waitlist,
    'feedbacks': feedbacks,
    'supportTickets': supportTickets,
    'supportResponses': supportResponses,
    'accounts': accounts,
    'sessions': sessions,
  };
}

class AffectedRowsOutput {
  const AffectedRowsOutput({this.count});

  factory AffectedRowsOutput.fromJson(Map json) =>
      AffectedRowsOutput(count: json['count']);

  final int? count;

  Map<String, dynamic> toJson() => {'count': count};
}

class UserCreateManyInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateManyInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? email;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? emailVerified;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? image;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? address;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? password;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? passwordResetToken;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? passwordResetExpires;

  final bool? onlineStatus;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? currentTimezone;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? onboardingCompleted;

  final _i1.PrismaUnion<_i3.UserRole, _i1.PrismaNull>? role;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consultantProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consulteeProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? staffProfileId;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
  };
}

class StringFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StringFieldUpdateOperationsInput({this.set});

  final String? set;

  @override
  Map<String, dynamic> toJson() => {'set': set};
}

class NullableStringFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NullableStringFieldUpdateOperationsInput({this.set});

  final _i1.PrismaUnion<String, _i1.PrismaNull>? set;

  @override
  Map<String, dynamic> toJson() => {'set': set};
}

class NullableDateTimeFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NullableDateTimeFieldUpdateOperationsInput({this.set});

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? set;

  @override
  Map<String, dynamic> toJson() => {'set': set};
}

class BoolFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BoolFieldUpdateOperationsInput({this.set});

  final bool? set;

  @override
  Map<String, dynamic> toJson() => {'set': set};
}

class NullableBoolFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NullableBoolFieldUpdateOperationsInput({this.set});

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? set;

  @override
  Map<String, dynamic> toJson() => {'set': set};
}

class NullableEnumUserRoleFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NullableEnumUserRoleFieldUpdateOperationsInput({this.set});

  final _i1.PrismaUnion<_i3.UserRole, _i1.PrismaNull>? set;

  @override
  Map<String, dynamic> toJson() => {'set': set};
}

class CookiePreferenceUpdateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CookiePreferenceUpdateWithoutUserInput({
    this.id,
    this.essential,
    this.analytics,
    this.marketing,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? essential;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? analytics;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? marketing;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'essential': essential,
    'analytics': analytics,
    'marketing': marketing,
  };
}

class CookiePreferenceUncheckedUpdateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CookiePreferenceUncheckedUpdateWithoutUserInput({
    this.id,
    this.essential,
    this.analytics,
    this.marketing,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? essential;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? analytics;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? marketing;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'essential': essential,
    'analytics': analytics,
    'marketing': marketing,
  };
}

class CookiePreferenceUpsertWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CookiePreferenceUpsertWithoutUserInput({
    required this.update,
    required this.create,
  });

  final _i1.PrismaUnion<
    _i2.CookiePreferenceUpdateWithoutUserInput,
    _i2.CookiePreferenceUncheckedUpdateWithoutUserInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.CookiePreferenceCreateWithoutUserInput,
    _i2.CookiePreferenceUncheckedCreateWithoutUserInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'update': update, 'create': create};
}

class CookiePreferenceUpdateOneWithoutUserNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CookiePreferenceUpdateOneWithoutUserNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.CookiePreferenceCreateWithoutUserInput,
    _i2.CookiePreferenceUncheckedCreateWithoutUserInput
  >?
  create;

  final _i2.CookiePreferenceCreateOrConnectWithoutUserInput? connectOrCreate;

  final _i2.CookiePreferenceUpsertWithoutUserInput? upsert;

  final bool? disconnect;

  final bool? delete;

  final _i2.CookiePreferenceWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.CookiePreferenceUpdateWithoutUserInput,
    _i2.CookiePreferenceUncheckedUpdateWithoutUserInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
  };
}

class NotificationPreferenceUpdateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NotificationPreferenceUpdateWithoutUserInput({
    this.id,
    this.allNotifications,
    this.mentions,
    this.directMessages,
    this.updates,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
  allNotifications;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? mentions;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
  directMessages;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? updates;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'allNotifications': allNotifications,
    'mentions': mentions,
    'directMessages': directMessages,
    'updates': updates,
  };
}

class NotificationPreferenceUncheckedUpdateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NotificationPreferenceUncheckedUpdateWithoutUserInput({
    this.id,
    this.allNotifications,
    this.mentions,
    this.directMessages,
    this.updates,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
  allNotifications;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? mentions;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
  directMessages;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? updates;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'allNotifications': allNotifications,
    'mentions': mentions,
    'directMessages': directMessages,
    'updates': updates,
  };
}

class NotificationPreferenceUpsertWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NotificationPreferenceUpsertWithoutUserInput({
    required this.update,
    required this.create,
  });

  final _i1.PrismaUnion<
    _i2.NotificationPreferenceUpdateWithoutUserInput,
    _i2.NotificationPreferenceUncheckedUpdateWithoutUserInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.NotificationPreferenceCreateWithoutUserInput,
    _i2.NotificationPreferenceUncheckedCreateWithoutUserInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'update': update, 'create': create};
}

class NotificationPreferenceUpdateOneWithoutUserNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NotificationPreferenceUpdateOneWithoutUserNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.NotificationPreferenceCreateWithoutUserInput,
    _i2.NotificationPreferenceUncheckedCreateWithoutUserInput
  >?
  create;

  final _i2.NotificationPreferenceCreateOrConnectWithoutUserInput?
  connectOrCreate;

  final _i2.NotificationPreferenceUpsertWithoutUserInput? upsert;

  final bool? disconnect;

  final bool? delete;

  final _i2.NotificationPreferenceWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.NotificationPreferenceUpdateWithoutUserInput,
    _i2.NotificationPreferenceUncheckedUpdateWithoutUserInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
  };
}

class IntFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IntFieldUpdateOperationsInput({
    this.set,
    this.increment,
    this.decrement,
    this.multiply,
    this.divide,
  });

  final int? set;

  final int? increment;

  final int? decrement;

  final int? multiply;

  final int? divide;

  @override
  Map<String, dynamic> toJson() => {
    'set': set,
    'increment': increment,
    'decrement': decrement,
    'multiply': multiply,
    'divide': divide,
  };
}

class EnumPaymentGatewayFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumPaymentGatewayFieldUpdateOperationsInput({this.set});

  final _i3.PaymentGateway? set;

  @override
  Map<String, dynamic> toJson() => {'set': set};
}

class EnumPaymentStatusFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumPaymentStatusFieldUpdateOperationsInput({this.set});

  final _i3.PaymentStatus? set;

  @override
  Map<String, dynamic> toJson() => {'set': set};
}

class DateTimeFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DateTimeFieldUpdateOperationsInput({this.set});

  final DateTime? set;

  @override
  Map<String, dynamic> toJson() => {'set': set};
}

class EnumAppointmentsTypeFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumAppointmentsTypeFieldUpdateOperationsInput({this.set});

  final _i3.AppointmentsType? set;

  @override
  Map<String, dynamic> toJson() => {'set': set};
}

class NullableFloatFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NullableFloatFieldUpdateOperationsInput({
    this.set,
    this.increment,
    this.decrement,
    this.multiply,
    this.divide,
  });

  final _i1.PrismaUnion<double, _i1.PrismaNull>? set;

  final double? increment;

  final double? decrement;

  final double? multiply;

  final double? divide;

  @override
  Map<String, dynamic> toJson() => {
    'set': set,
    'increment': increment,
    'decrement': decrement,
    'multiply': multiply,
    'divide': divide,
  };
}

class FloatFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FloatFieldUpdateOperationsInput({
    this.set,
    this.increment,
    this.decrement,
    this.multiply,
    this.divide,
  });

  final double? set;

  final double? increment;

  final double? decrement;

  final double? multiply;

  final double? divide;

  @override
  Map<String, dynamic> toJson() => {
    'set': set,
    'increment': increment,
    'decrement': decrement,
    'multiply': multiply,
    'divide': divide,
  };
}

class EnumScheduleTypeFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumScheduleTypeFieldUpdateOperationsInput({this.set});

  final _i3.ScheduleType? set;

  @override
  Map<String, dynamic> toJson() => {'set': set};
}

class NullableEnumConsultationModeFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NullableEnumConsultationModeFieldUpdateOperationsInput({this.set});

  final _i1.PrismaUnion<_i3.ConsultationMode, _i1.PrismaNull>? set;

  @override
  Map<String, dynamic> toJson() => {'set': set};
}

class EnumRequestStatusFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumRequestStatusFieldUpdateOperationsInput({this.set});

  final _i3.RequestStatus? set;

  @override
  Map<String, dynamic> toJson() => {'set': set};
}

class ConsultationPlanUpdatelearningOutcomesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanUpdatelearningOutcomesInput({this.set, this.push});

  final Iterable<String>? set;

  final _i1.PrismaUnion<String, Iterable<String>>? push;

  @override
  Map<String, dynamic> toJson() => {'set': set, 'push': push};
}

class EnumDayOfWeekFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumDayOfWeekFieldUpdateOperationsInput({this.set});

  final _i3.DayOfWeek? set;

  @override
  Map<String, dynamic> toJson() => {'set': set};
}

class SlotOfAvailabilityWeeklyUpdateWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityWeeklyUpdateWithoutConsultantProfileInput({
    this.id,
    this.dayOfWeekforStartTimeInUTC,
    this.slotStartTimeInUTC,
    this.dayOfWeekforEndTimeInUTC,
    this.slotEndTimeInUTC,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    _i3.DayOfWeek,
    _i2.EnumDayOfWeekFieldUpdateOperationsInput
  >?
  dayOfWeekforStartTimeInUTC;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  slotStartTimeInUTC;

  final _i1.PrismaUnion<
    _i3.DayOfWeek,
    _i2.EnumDayOfWeekFieldUpdateOperationsInput
  >?
  dayOfWeekforEndTimeInUTC;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  slotEndTimeInUTC;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'dayOfWeekforStartTimeInUTC': dayOfWeekforStartTimeInUTC,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'dayOfWeekforEndTimeInUTC': dayOfWeekforEndTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SlotOfAvailabilityWeeklyUncheckedUpdateWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityWeeklyUncheckedUpdateWithoutConsultantProfileInput({
    this.id,
    this.dayOfWeekforStartTimeInUTC,
    this.slotStartTimeInUTC,
    this.dayOfWeekforEndTimeInUTC,
    this.slotEndTimeInUTC,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    _i3.DayOfWeek,
    _i2.EnumDayOfWeekFieldUpdateOperationsInput
  >?
  dayOfWeekforStartTimeInUTC;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  slotStartTimeInUTC;

  final _i1.PrismaUnion<
    _i3.DayOfWeek,
    _i2.EnumDayOfWeekFieldUpdateOperationsInput
  >?
  dayOfWeekforEndTimeInUTC;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  slotEndTimeInUTC;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'dayOfWeekforStartTimeInUTC': dayOfWeekforStartTimeInUTC,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'dayOfWeekforEndTimeInUTC': dayOfWeekforEndTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SlotOfAvailabilityWeeklyUpsertWithWhereUniqueWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityWeeklyUpsertWithWhereUniqueWithoutConsultantProfileInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.SlotOfAvailabilityWeeklyWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityWeeklyUpdateWithoutConsultantProfileInput,
    _i2.SlotOfAvailabilityWeeklyUncheckedUpdateWithoutConsultantProfileInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityWeeklyCreateWithoutConsultantProfileInput,
    _i2.SlotOfAvailabilityWeeklyUncheckedCreateWithoutConsultantProfileInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'update': update,
    'create': create,
  };
}

class SlotOfAvailabilityWeeklyUpdateWithWhereUniqueWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityWeeklyUpdateWithWhereUniqueWithoutConsultantProfileInput({
    required this.where,
    required this.data,
  });

  final _i2.SlotOfAvailabilityWeeklyWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityWeeklyUpdateWithoutConsultantProfileInput,
    _i2.SlotOfAvailabilityWeeklyUncheckedUpdateWithoutConsultantProfileInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class SlotOfAvailabilityWeeklyScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityWeeklyScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.dayOfWeekforStartTimeInUTC,
    this.slotStartTimeInUTC,
    this.dayOfWeekforEndTimeInUTC,
    this.slotEndTimeInUTC,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityWeeklyScalarWhereInput,
    Iterable<_i2.SlotOfAvailabilityWeeklyScalarWhereInput>
  >?
  AND;

  final Iterable<_i2.SlotOfAvailabilityWeeklyScalarWhereInput>? OR;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityWeeklyScalarWhereInput,
    Iterable<_i2.SlotOfAvailabilityWeeklyScalarWhereInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.EnumDayOfWeekFilter, _i3.DayOfWeek>?
  dayOfWeekforStartTimeInUTC;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? slotStartTimeInUTC;

  final _i1.PrismaUnion<_i2.EnumDayOfWeekFilter, _i3.DayOfWeek>?
  dayOfWeekforEndTimeInUTC;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? slotEndTimeInUTC;

  final _i1.PrismaUnion<_i2.StringFilter, String>? consultantProfileId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'dayOfWeekforStartTimeInUTC': dayOfWeekforStartTimeInUTC,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'dayOfWeekforEndTimeInUTC': dayOfWeekforEndTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SlotOfAvailabilityWeeklyUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityWeeklyUpdateManyMutationInput({
    this.id,
    this.dayOfWeekforStartTimeInUTC,
    this.slotStartTimeInUTC,
    this.dayOfWeekforEndTimeInUTC,
    this.slotEndTimeInUTC,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    _i3.DayOfWeek,
    _i2.EnumDayOfWeekFieldUpdateOperationsInput
  >?
  dayOfWeekforStartTimeInUTC;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  slotStartTimeInUTC;

  final _i1.PrismaUnion<
    _i3.DayOfWeek,
    _i2.EnumDayOfWeekFieldUpdateOperationsInput
  >?
  dayOfWeekforEndTimeInUTC;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  slotEndTimeInUTC;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'dayOfWeekforStartTimeInUTC': dayOfWeekforStartTimeInUTC,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'dayOfWeekforEndTimeInUTC': dayOfWeekforEndTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SlotOfAvailabilityWeeklyUncheckedUpdateManyWithoutSlotsOfAvailabilityWeeklyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityWeeklyUncheckedUpdateManyWithoutSlotsOfAvailabilityWeeklyInput({
    this.id,
    this.dayOfWeekforStartTimeInUTC,
    this.slotStartTimeInUTC,
    this.dayOfWeekforEndTimeInUTC,
    this.slotEndTimeInUTC,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    _i3.DayOfWeek,
    _i2.EnumDayOfWeekFieldUpdateOperationsInput
  >?
  dayOfWeekforStartTimeInUTC;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  slotStartTimeInUTC;

  final _i1.PrismaUnion<
    _i3.DayOfWeek,
    _i2.EnumDayOfWeekFieldUpdateOperationsInput
  >?
  dayOfWeekforEndTimeInUTC;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  slotEndTimeInUTC;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'dayOfWeekforStartTimeInUTC': dayOfWeekforStartTimeInUTC,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'dayOfWeekforEndTimeInUTC': dayOfWeekforEndTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SlotOfAvailabilityWeeklyUpdateManyWithWhereWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityWeeklyUpdateManyWithWhereWithoutConsultantProfileInput({
    required this.where,
    required this.data,
  });

  final _i2.SlotOfAvailabilityWeeklyScalarWhereInput where;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityWeeklyUpdateManyMutationInput,
    _i2.SlotOfAvailabilityWeeklyUncheckedUpdateManyWithoutSlotsOfAvailabilityWeeklyInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class SlotOfAvailabilityWeeklyUpdateManyWithoutConsultantProfileNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityWeeklyUpdateManyWithoutConsultantProfileNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityWeeklyCreateWithoutConsultantProfileInput,
    _i1.PrismaUnion<
      Iterable<_i2.SlotOfAvailabilityWeeklyCreateWithoutConsultantProfileInput>,
      _i1.PrismaUnion<
        _i2.SlotOfAvailabilityWeeklyUncheckedCreateWithoutConsultantProfileInput,
        Iterable<
          _i2.SlotOfAvailabilityWeeklyUncheckedCreateWithoutConsultantProfileInput
        >
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityWeeklyCreateOrConnectWithoutConsultantProfileInput,
    Iterable<
      _i2.SlotOfAvailabilityWeeklyCreateOrConnectWithoutConsultantProfileInput
    >
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityWeeklyUpsertWithWhereUniqueWithoutConsultantProfileInput,
    Iterable<
      _i2.SlotOfAvailabilityWeeklyUpsertWithWhereUniqueWithoutConsultantProfileInput
    >
  >?
  upsert;

  final _i2.SlotOfAvailabilityWeeklyCreateManyConsultantProfileInputEnvelope?
  createMany;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityWeeklyWhereUniqueInput,
    Iterable<_i2.SlotOfAvailabilityWeeklyWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityWeeklyWhereUniqueInput,
    Iterable<_i2.SlotOfAvailabilityWeeklyWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityWeeklyWhereUniqueInput,
    Iterable<_i2.SlotOfAvailabilityWeeklyWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityWeeklyWhereUniqueInput,
    Iterable<_i2.SlotOfAvailabilityWeeklyWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityWeeklyUpdateWithWhereUniqueWithoutConsultantProfileInput,
    Iterable<
      _i2.SlotOfAvailabilityWeeklyUpdateWithWhereUniqueWithoutConsultantProfileInput
    >
  >?
  update;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityWeeklyUpdateManyWithWhereWithoutConsultantProfileInput,
    Iterable<
      _i2.SlotOfAvailabilityWeeklyUpdateManyWithWhereWithoutConsultantProfileInput
    >
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityWeeklyScalarWhereInput,
    Iterable<_i2.SlotOfAvailabilityWeeklyScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class SlotOfAvailabilityCustomUpdateWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityCustomUpdateWithoutConsultantProfileInput({
    this.id,
    this.slotStartTimeInUTC,
    this.slotEndTimeInUTC,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  slotStartTimeInUTC;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  slotEndTimeInUTC;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SlotOfAvailabilityCustomUncheckedUpdateWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityCustomUncheckedUpdateWithoutConsultantProfileInput({
    this.id,
    this.slotStartTimeInUTC,
    this.slotEndTimeInUTC,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  slotStartTimeInUTC;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  slotEndTimeInUTC;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SlotOfAvailabilityCustomUpsertWithWhereUniqueWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityCustomUpsertWithWhereUniqueWithoutConsultantProfileInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.SlotOfAvailabilityCustomWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityCustomUpdateWithoutConsultantProfileInput,
    _i2.SlotOfAvailabilityCustomUncheckedUpdateWithoutConsultantProfileInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityCustomCreateWithoutConsultantProfileInput,
    _i2.SlotOfAvailabilityCustomUncheckedCreateWithoutConsultantProfileInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'update': update,
    'create': create,
  };
}

class SlotOfAvailabilityCustomUpdateWithWhereUniqueWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityCustomUpdateWithWhereUniqueWithoutConsultantProfileInput({
    required this.where,
    required this.data,
  });

  final _i2.SlotOfAvailabilityCustomWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityCustomUpdateWithoutConsultantProfileInput,
    _i2.SlotOfAvailabilityCustomUncheckedUpdateWithoutConsultantProfileInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class SlotOfAvailabilityCustomScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityCustomScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.slotStartTimeInUTC,
    this.slotEndTimeInUTC,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityCustomScalarWhereInput,
    Iterable<_i2.SlotOfAvailabilityCustomScalarWhereInput>
  >?
  AND;

  final Iterable<_i2.SlotOfAvailabilityCustomScalarWhereInput>? OR;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityCustomScalarWhereInput,
    Iterable<_i2.SlotOfAvailabilityCustomScalarWhereInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? slotStartTimeInUTC;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? slotEndTimeInUTC;

  final _i1.PrismaUnion<_i2.StringFilter, String>? consultantProfileId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SlotOfAvailabilityCustomUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityCustomUpdateManyMutationInput({
    this.id,
    this.slotStartTimeInUTC,
    this.slotEndTimeInUTC,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  slotStartTimeInUTC;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  slotEndTimeInUTC;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SlotOfAvailabilityCustomUncheckedUpdateManyWithoutSlotsOfAvailabilityCustomInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityCustomUncheckedUpdateManyWithoutSlotsOfAvailabilityCustomInput({
    this.id,
    this.slotStartTimeInUTC,
    this.slotEndTimeInUTC,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  slotStartTimeInUTC;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  slotEndTimeInUTC;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SlotOfAvailabilityCustomUpdateManyWithWhereWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityCustomUpdateManyWithWhereWithoutConsultantProfileInput({
    required this.where,
    required this.data,
  });

  final _i2.SlotOfAvailabilityCustomScalarWhereInput where;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityCustomUpdateManyMutationInput,
    _i2.SlotOfAvailabilityCustomUncheckedUpdateManyWithoutSlotsOfAvailabilityCustomInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class SlotOfAvailabilityCustomUpdateManyWithoutConsultantProfileNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityCustomUpdateManyWithoutConsultantProfileNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityCustomCreateWithoutConsultantProfileInput,
    _i1.PrismaUnion<
      Iterable<_i2.SlotOfAvailabilityCustomCreateWithoutConsultantProfileInput>,
      _i1.PrismaUnion<
        _i2.SlotOfAvailabilityCustomUncheckedCreateWithoutConsultantProfileInput,
        Iterable<
          _i2.SlotOfAvailabilityCustomUncheckedCreateWithoutConsultantProfileInput
        >
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityCustomCreateOrConnectWithoutConsultantProfileInput,
    Iterable<
      _i2.SlotOfAvailabilityCustomCreateOrConnectWithoutConsultantProfileInput
    >
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityCustomUpsertWithWhereUniqueWithoutConsultantProfileInput,
    Iterable<
      _i2.SlotOfAvailabilityCustomUpsertWithWhereUniqueWithoutConsultantProfileInput
    >
  >?
  upsert;

  final _i2.SlotOfAvailabilityCustomCreateManyConsultantProfileInputEnvelope?
  createMany;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityCustomWhereUniqueInput,
    Iterable<_i2.SlotOfAvailabilityCustomWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityCustomWhereUniqueInput,
    Iterable<_i2.SlotOfAvailabilityCustomWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityCustomWhereUniqueInput,
    Iterable<_i2.SlotOfAvailabilityCustomWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityCustomWhereUniqueInput,
    Iterable<_i2.SlotOfAvailabilityCustomWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityCustomUpdateWithWhereUniqueWithoutConsultantProfileInput,
    Iterable<
      _i2.SlotOfAvailabilityCustomUpdateWithWhereUniqueWithoutConsultantProfileInput
    >
  >?
  update;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityCustomUpdateManyWithWhereWithoutConsultantProfileInput,
    Iterable<
      _i2.SlotOfAvailabilityCustomUpdateManyWithWhereWithoutConsultantProfileInput
    >
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityCustomScalarWhereInput,
    Iterable<_i2.SlotOfAvailabilityCustomScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class EnumPlanEmailSupportFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumPlanEmailSupportFieldUpdateOperationsInput({this.set});

  final _i3.PlanEmailSupport? set;

  @override
  Map<String, dynamic> toJson() => {'set': set};
}

class SubscriptionPlanUpdatelearningOutcomesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanUpdatelearningOutcomesInput({this.set, this.push});

  final Iterable<String>? set;

  final _i1.PrismaUnion<String, Iterable<String>>? push;

  @override
  Map<String, dynamic> toJson() => {'set': set, 'push': push};
}

class WebinarPlanUpdatelearningOutcomesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanUpdatelearningOutcomesInput({this.set, this.push});

  final Iterable<String>? set;

  final _i1.PrismaUnion<String, Iterable<String>>? push;

  @override
  Map<String, dynamic> toJson() => {'set': set, 'push': push};
}

class ClassPlanUpdatelearningOutcomesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanUpdatelearningOutcomesInput({this.set, this.push});

  final Iterable<String>? set;

  final _i1.PrismaUnion<String, Iterable<String>>? push;

  @override
  Map<String, dynamic> toJson() => {'set': set, 'push': push};
}

class ClassContentUpdateWithoutClassPlanInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassContentUpdateWithoutClassPlanInput({
    this.id,
    this.title,
    this.description,
    this.contentType,
    this.contentUrl,
    this.order,
    this.hoursAllotted,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  description;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  contentType;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  contentUrl;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? order;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
  hoursAllotted;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'contentType': contentType,
    'contentUrl': contentUrl,
    'order': order,
    'hoursAllotted': hoursAllotted,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ClassContentUncheckedUpdateWithoutClassPlanInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassContentUncheckedUpdateWithoutClassPlanInput({
    this.id,
    this.title,
    this.description,
    this.contentType,
    this.contentUrl,
    this.order,
    this.hoursAllotted,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  description;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  contentType;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  contentUrl;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? order;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
  hoursAllotted;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'contentType': contentType,
    'contentUrl': contentUrl,
    'order': order,
    'hoursAllotted': hoursAllotted,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ClassContentUpsertWithWhereUniqueWithoutClassPlanInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassContentUpsertWithWhereUniqueWithoutClassPlanInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.ClassContentWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.ClassContentUpdateWithoutClassPlanInput,
    _i2.ClassContentUncheckedUpdateWithoutClassPlanInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.ClassContentCreateWithoutClassPlanInput,
    _i2.ClassContentUncheckedCreateWithoutClassPlanInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'update': update,
    'create': create,
  };
}

class ClassContentUpdateWithWhereUniqueWithoutClassPlanInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassContentUpdateWithWhereUniqueWithoutClassPlanInput({
    required this.where,
    required this.data,
  });

  final _i2.ClassContentWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.ClassContentUpdateWithoutClassPlanInput,
    _i2.ClassContentUncheckedUpdateWithoutClassPlanInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class ClassContentScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassContentScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.title,
    this.description,
    this.contentType,
    this.contentUrl,
    this.order,
    this.hoursAllotted,
    this.classPlanId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
    _i2.ClassContentScalarWhereInput,
    Iterable<_i2.ClassContentScalarWhereInput>
  >?
  AND;

  final Iterable<_i2.ClassContentScalarWhereInput>? OR;

  final _i1.PrismaUnion<
    _i2.ClassContentScalarWhereInput,
    Iterable<_i2.ClassContentScalarWhereInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? title;

  final _i1.PrismaUnion<_i2.StringFilter, String>? description;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  contentType;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  contentUrl;

  final _i1.PrismaUnion<_i2.IntFilter, int>? order;

  final _i1.PrismaUnion<_i2.FloatFilter, double>? hoursAllotted;

  final _i1.PrismaUnion<_i2.StringFilter, String>? classPlanId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'title': title,
    'description': description,
    'contentType': contentType,
    'contentUrl': contentUrl,
    'order': order,
    'hoursAllotted': hoursAllotted,
    'classPlanId': classPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ClassContentUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassContentUpdateManyMutationInput({
    this.id,
    this.title,
    this.description,
    this.contentType,
    this.contentUrl,
    this.order,
    this.hoursAllotted,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  description;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  contentType;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  contentUrl;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? order;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
  hoursAllotted;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'contentType': contentType,
    'contentUrl': contentUrl,
    'order': order,
    'hoursAllotted': hoursAllotted,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ClassContentUncheckedUpdateManyWithoutClassContentsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassContentUncheckedUpdateManyWithoutClassContentsInput({
    this.id,
    this.title,
    this.description,
    this.contentType,
    this.contentUrl,
    this.order,
    this.hoursAllotted,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  description;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  contentType;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  contentUrl;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? order;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
  hoursAllotted;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'contentType': contentType,
    'contentUrl': contentUrl,
    'order': order,
    'hoursAllotted': hoursAllotted,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ClassContentUpdateManyWithWhereWithoutClassPlanInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassContentUpdateManyWithWhereWithoutClassPlanInput({
    required this.where,
    required this.data,
  });

  final _i2.ClassContentScalarWhereInput where;

  final _i1.PrismaUnion<
    _i2.ClassContentUpdateManyMutationInput,
    _i2.ClassContentUncheckedUpdateManyWithoutClassContentsInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class ClassContentUpdateManyWithoutClassPlanNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassContentUpdateManyWithoutClassPlanNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.ClassContentCreateWithoutClassPlanInput,
    _i1.PrismaUnion<
      Iterable<_i2.ClassContentCreateWithoutClassPlanInput>,
      _i1.PrismaUnion<
        _i2.ClassContentUncheckedCreateWithoutClassPlanInput,
        Iterable<_i2.ClassContentUncheckedCreateWithoutClassPlanInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.ClassContentCreateOrConnectWithoutClassPlanInput,
    Iterable<_i2.ClassContentCreateOrConnectWithoutClassPlanInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.ClassContentUpsertWithWhereUniqueWithoutClassPlanInput,
    Iterable<_i2.ClassContentUpsertWithWhereUniqueWithoutClassPlanInput>
  >?
  upsert;

  final _i2.ClassContentCreateManyClassPlanInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.ClassContentWhereUniqueInput,
    Iterable<_i2.ClassContentWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.ClassContentWhereUniqueInput,
    Iterable<_i2.ClassContentWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.ClassContentWhereUniqueInput,
    Iterable<_i2.ClassContentWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.ClassContentWhereUniqueInput,
    Iterable<_i2.ClassContentWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.ClassContentUpdateWithWhereUniqueWithoutClassPlanInput,
    Iterable<_i2.ClassContentUpdateWithWhereUniqueWithoutClassPlanInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.ClassContentUpdateManyWithWhereWithoutClassPlanInput,
    Iterable<_i2.ClassContentUpdateManyWithWhereWithoutClassPlanInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.ClassContentScalarWhereInput,
    Iterable<_i2.ClassContentScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class ConsulteeProfileUpdateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileUpdateWithoutUserInput({
    this.id,
    this.education,
    this.occupation,
    this.aboutMe,
    this.preferredCommunicationMethod,
    this.preferredLanguage,
    this.specialRequirements,
    this.interests,
    this.goals,
    this.createdAt,
    this.updatedAt,
    this.consultationRequests,
    this.subscriptionRequests,
    this.consultantReviews,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  education;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  occupation;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  aboutMe;

  final _i1.PrismaUnion<
    _i3.ConsultationMode,
    _i1.PrismaUnion<
      _i2.NullableEnumConsultationModeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  preferredCommunicationMethod;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  preferredLanguage;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  specialRequirements;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  interests;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  goals;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.ConsultationUpdateManyWithoutRequestedByNestedInput?
  consultationRequests;

  final _i2.SubscriptionUpdateManyWithoutRequestedByNestedInput?
  subscriptionRequests;

  final _i2.ConsultantReviewUpdateManyWithoutConsulteeProfileNestedInput?
  consultantReviews;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'education': education,
    'occupation': occupation,
    'aboutMe': aboutMe,
    'preferredCommunicationMethod': preferredCommunicationMethod,
    'preferredLanguage': preferredLanguage,
    'specialRequirements': specialRequirements,
    'interests': interests,
    'goals': goals,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultationRequests': consultationRequests,
    'subscriptionRequests': subscriptionRequests,
    'consultantReviews': consultantReviews,
  };
}

class SubscriptionUpdateWithoutAppointmentsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionUpdateWithoutAppointmentsInput({
    this.id,
    this.startDate,
    this.endDate,
    this.requestStatus,
    this.requestedAt,
    this.requestNotes,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.createdAt,
    this.updatedAt,
    this.requestedBy,
    this.subscriptionPlan,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  startDate;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  endDate;

  final _i1.PrismaUnion<
    _i3.RequestStatus,
    _i2.EnumRequestStatusFieldUpdateOperationsInput
  >?
  requestStatus;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  requestedAt;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  requestNotes;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackFromConsultee;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackFromConsultant;

  final _i1.PrismaUnion<
    double,
    _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  rating;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.ConsulteeProfileUpdateOneRequiredWithoutSubscriptionRequestsNestedInput?
  requestedBy;

  final _i2.SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInput?
  subscriptionPlan;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'requestStatus': requestStatus,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'requestedBy': requestedBy,
    'subscriptionPlan': subscriptionPlan,
  };
}

class SubscriptionUncheckedUpdateWithoutAppointmentsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionUncheckedUpdateWithoutAppointmentsInput({
    this.id,
    this.startDate,
    this.endDate,
    this.requestStatus,
    this.requestedById,
    this.requestedAt,
    this.requestNotes,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.subscriptionPlanId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  startDate;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  endDate;

  final _i1.PrismaUnion<
    _i3.RequestStatus,
    _i2.EnumRequestStatusFieldUpdateOperationsInput
  >?
  requestStatus;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  requestedById;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  requestedAt;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  requestNotes;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackFromConsultee;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackFromConsultant;

  final _i1.PrismaUnion<
    double,
    _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  rating;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  subscriptionPlanId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'requestStatus': requestStatus,
    'requestedById': requestedById,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'subscriptionPlanId': subscriptionPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SubscriptionUpsertWithoutAppointmentsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionUpsertWithoutAppointmentsInput({
    required this.update,
    required this.create,
  });

  final _i1.PrismaUnion<
    _i2.SubscriptionUpdateWithoutAppointmentsInput,
    _i2.SubscriptionUncheckedUpdateWithoutAppointmentsInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.SubscriptionCreateWithoutAppointmentsInput,
    _i2.SubscriptionUncheckedCreateWithoutAppointmentsInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'update': update, 'create': create};
}

class SubscriptionUpdateOneWithoutAppointmentsNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionUpdateOneWithoutAppointmentsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.SubscriptionCreateWithoutAppointmentsInput,
    _i2.SubscriptionUncheckedCreateWithoutAppointmentsInput
  >?
  create;

  final _i2.SubscriptionCreateOrConnectWithoutAppointmentsInput?
  connectOrCreate;

  final _i2.SubscriptionUpsertWithoutAppointmentsInput? upsert;

  final bool? disconnect;

  final bool? delete;

  final _i2.SubscriptionWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.SubscriptionUpdateWithoutAppointmentsInput,
    _i2.SubscriptionUncheckedUpdateWithoutAppointmentsInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
  };
}

class EnumWebinarStatusFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumWebinarStatusFieldUpdateOperationsInput({this.set});

  final _i3.WebinarStatus? set;

  @override
  Map<String, dynamic> toJson() => {'set': set};
}

class StaffProfileUpdateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StaffProfileUpdateWithoutUserInput({
    this.id,
    this.department,
    this.position,
    this.permissions,
    this.responsibilities,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  department;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  position;

  final _i1.PrismaUnion<_i2.NullableJsonNullValueInput, _i1.PrismaJson>?
  permissions;

  final _i1.PrismaUnion<_i2.NullableJsonNullValueInput, _i1.PrismaJson>?
  responsibilities;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'department': department,
    'position': position,
    'permissions': permissions,
    'responsibilities': responsibilities,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class StaffProfileUncheckedUpdateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StaffProfileUncheckedUpdateWithoutUserInput({
    this.id,
    this.department,
    this.position,
    this.permissions,
    this.responsibilities,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  department;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  position;

  final _i1.PrismaUnion<_i2.NullableJsonNullValueInput, _i1.PrismaJson>?
  permissions;

  final _i1.PrismaUnion<_i2.NullableJsonNullValueInput, _i1.PrismaJson>?
  responsibilities;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'department': department,
    'position': position,
    'permissions': permissions,
    'responsibilities': responsibilities,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class StaffProfileUpsertWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StaffProfileUpsertWithoutUserInput({
    required this.update,
    required this.create,
  });

  final _i1.PrismaUnion<
    _i2.StaffProfileUpdateWithoutUserInput,
    _i2.StaffProfileUncheckedUpdateWithoutUserInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.StaffProfileCreateWithoutUserInput,
    _i2.StaffProfileUncheckedCreateWithoutUserInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'update': update, 'create': create};
}

class StaffProfileUpdateOneWithoutUserNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StaffProfileUpdateOneWithoutUserNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.StaffProfileCreateWithoutUserInput,
    _i2.StaffProfileUncheckedCreateWithoutUserInput
  >?
  create;

  final _i2.StaffProfileCreateOrConnectWithoutUserInput? connectOrCreate;

  final _i2.StaffProfileUpsertWithoutUserInput? upsert;

  final bool? disconnect;

  final bool? delete;

  final _i2.StaffProfileWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.StaffProfileUpdateWithoutUserInput,
    _i2.StaffProfileUncheckedUpdateWithoutUserInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
  };
}

class ConsultationUpdateWithoutAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationUpdateWithoutAppointmentInput({
    this.id,
    this.requestStatus,
    this.requestedAt,
    this.requestNotes,
    this.directlyBooked,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.createdAt,
    this.updatedAt,
    this.consultationPlan,
    this.requestedBy,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    _i3.RequestStatus,
    _i2.EnumRequestStatusFieldUpdateOperationsInput
  >?
  requestStatus;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  requestedAt;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  requestNotes;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
  directlyBooked;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackFromConsultee;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackFromConsultant;

  final _i1.PrismaUnion<
    double,
    _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  rating;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.ConsultationPlanUpdateOneRequiredWithoutConsultationsNestedInput?
  consultationPlan;

  final _i2.ConsulteeProfileUpdateOneRequiredWithoutConsultationRequestsNestedInput?
  requestedBy;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'requestStatus': requestStatus,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'directlyBooked': directlyBooked,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultationPlan': consultationPlan,
    'requestedBy': requestedBy,
  };
}

class ConsultationUncheckedUpdateWithoutAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationUncheckedUpdateWithoutAppointmentInput({
    this.id,
    this.consultationPlanId,
    this.requestStatus,
    this.requestedById,
    this.requestedAt,
    this.requestNotes,
    this.directlyBooked,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  consultationPlanId;

  final _i1.PrismaUnion<
    _i3.RequestStatus,
    _i2.EnumRequestStatusFieldUpdateOperationsInput
  >?
  requestStatus;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  requestedById;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  requestedAt;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  requestNotes;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
  directlyBooked;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackFromConsultee;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackFromConsultant;

  final _i1.PrismaUnion<
    double,
    _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  rating;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'consultationPlanId': consultationPlanId,
    'requestStatus': requestStatus,
    'requestedById': requestedById,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'directlyBooked': directlyBooked,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultationUpsertWithoutAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationUpsertWithoutAppointmentInput({
    required this.update,
    required this.create,
  });

  final _i1.PrismaUnion<
    _i2.ConsultationUpdateWithoutAppointmentInput,
    _i2.ConsultationUncheckedUpdateWithoutAppointmentInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.ConsultationCreateWithoutAppointmentInput,
    _i2.ConsultationUncheckedCreateWithoutAppointmentInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'update': update, 'create': create};
}

class ConsultationUpdateOneWithoutAppointmentNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationUpdateOneWithoutAppointmentNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.ConsultationCreateWithoutAppointmentInput,
    _i2.ConsultationUncheckedCreateWithoutAppointmentInput
  >?
  create;

  final _i2.ConsultationCreateOrConnectWithoutAppointmentInput? connectOrCreate;

  final _i2.ConsultationUpsertWithoutAppointmentInput? upsert;

  final bool? disconnect;

  final bool? delete;

  final _i2.ConsultationWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.ConsultationUpdateWithoutAppointmentInput,
    _i2.ConsultationUncheckedUpdateWithoutAppointmentInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
  };
}

class EnumClassStatusFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumClassStatusFieldUpdateOperationsInput({this.set});

  final _i3.ClassStatus? set;

  @override
  Map<String, dynamic> toJson() => {'set': set};
}

class ClassUpdaterecordingUrlsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassUpdaterecordingUrlsInput({this.set, this.push});

  final Iterable<String>? set;

  final _i1.PrismaUnion<String, Iterable<String>>? push;

  @override
  Map<String, dynamic> toJson() => {'set': set, 'push': push};
}

class ClassPlanUpdateWithoutClassesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanUpdateWithoutClassesInput({
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInMonths,
    this.callsPerWeek,
    this.videoMeetings,
    this.emailSupport,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.createdAt,
    this.updatedAt,
    this.topics,
    this.classContents,
    this.consultantProfile,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  description;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? price;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  priceCurrency;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
  certificateProvided;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
  durationInMonths;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? callsPerWeek;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? videoMeetings;

  final _i1.PrismaUnion<
    _i3.PlanEmailSupport,
    _i2.EnumPlanEmailSupportFieldUpdateOperationsInput
  >?
  emailSupport;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
  maxParticipants;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  language;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  level;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  prerequisites;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  materialProvided;

  final _i1.PrismaUnion<
    _i2.ClassPlanUpdatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.TopicUpdateManyWithoutClassPlansNestedInput? topics;

  final _i2.ClassContentUpdateManyWithoutClassPlanNestedInput? classContents;

  final _i2.ConsultantProfileUpdateOneWithoutClassPlansNestedInput?
  consultantProfile;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInMonths': durationInMonths,
    'callsPerWeek': callsPerWeek,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'topics': topics,
    'classContents': classContents,
    'consultantProfile': consultantProfile,
  };
}

class WaitlistUncheckedUpdateWithoutWebinarInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistUncheckedUpdateWithoutWebinarInput({
    this.id,
    this.joinedAt,
    this.userId,
    this.classId,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  joinedAt;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  classId;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'joinedAt': joinedAt,
    'userId': userId,
    'classId': classId,
  };
}

class WaitlistUpdateWithWhereUniqueWithoutWebinarInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistUpdateWithWhereUniqueWithoutWebinarInput({
    required this.where,
    required this.data,
  });

  final _i2.WaitlistWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.WaitlistUpdateWithoutWebinarInput,
    _i2.WaitlistUncheckedUpdateWithoutWebinarInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class WaitlistScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.joinedAt,
    this.userId,
    this.webinarId,
    this.classId,
  });

  final _i1.PrismaUnion<
    _i2.WaitlistScalarWhereInput,
    Iterable<_i2.WaitlistScalarWhereInput>
  >?
  AND;

  final Iterable<_i2.WaitlistScalarWhereInput>? OR;

  final _i1.PrismaUnion<
    _i2.WaitlistScalarWhereInput,
    Iterable<_i2.WaitlistScalarWhereInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? joinedAt;

  final _i1.PrismaUnion<_i2.StringFilter, String>? userId;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  webinarId;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  classId;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'joinedAt': joinedAt,
    'userId': userId,
    'webinarId': webinarId,
    'classId': classId,
  };
}

class WaitlistUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistUpdateManyMutationInput({this.id, this.joinedAt});

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  joinedAt;

  @override
  Map<String, dynamic> toJson() => {'id': id, 'joinedAt': joinedAt};
}

class WaitlistUncheckedUpdateManyWithoutWaitlistInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistUncheckedUpdateManyWithoutWaitlistInput({
    this.id,
    this.joinedAt,
    this.webinarId,
    this.classId,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  joinedAt;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  webinarId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  classId;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'joinedAt': joinedAt,
    'webinarId': webinarId,
    'classId': classId,
  };
}

class WaitlistUpdateManyWithWhereWithoutWebinarInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistUpdateManyWithWhereWithoutWebinarInput({
    required this.where,
    required this.data,
  });

  final _i2.WaitlistScalarWhereInput where;

  final _i1.PrismaUnion<
    _i2.WaitlistUpdateManyMutationInput,
    _i2.WaitlistUncheckedUpdateManyWithoutWaitlistInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class WaitlistUncheckedUpdateManyWithoutWebinarNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistUncheckedUpdateManyWithoutWebinarNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.WaitlistCreateWithoutWebinarInput,
    _i1.PrismaUnion<
      Iterable<_i2.WaitlistCreateWithoutWebinarInput>,
      _i1.PrismaUnion<
        _i2.WaitlistUncheckedCreateWithoutWebinarInput,
        Iterable<_i2.WaitlistUncheckedCreateWithoutWebinarInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.WaitlistCreateOrConnectWithoutWebinarInput,
    Iterable<_i2.WaitlistCreateOrConnectWithoutWebinarInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.WaitlistUpsertWithWhereUniqueWithoutWebinarInput,
    Iterable<_i2.WaitlistUpsertWithWhereUniqueWithoutWebinarInput>
  >?
  upsert;

  final _i2.WaitlistCreateManyWebinarInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.WaitlistWhereUniqueInput,
    Iterable<_i2.WaitlistWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.WaitlistWhereUniqueInput,
    Iterable<_i2.WaitlistWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.WaitlistWhereUniqueInput,
    Iterable<_i2.WaitlistWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.WaitlistWhereUniqueInput,
    Iterable<_i2.WaitlistWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.WaitlistUpdateWithWhereUniqueWithoutWebinarInput,
    Iterable<_i2.WaitlistUpdateWithWhereUniqueWithoutWebinarInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.WaitlistUpdateManyWithWhereWithoutWebinarInput,
    Iterable<_i2.WaitlistUpdateManyWithWhereWithoutWebinarInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.WaitlistScalarWhereInput,
    Iterable<_i2.WaitlistScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class CookiePreferenceUncheckedUpdateOneWithoutUserNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CookiePreferenceUncheckedUpdateOneWithoutUserNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.CookiePreferenceCreateWithoutUserInput,
    _i2.CookiePreferenceUncheckedCreateWithoutUserInput
  >?
  create;

  final _i2.CookiePreferenceCreateOrConnectWithoutUserInput? connectOrCreate;

  final _i2.CookiePreferenceUpsertWithoutUserInput? upsert;

  final bool? disconnect;

  final bool? delete;

  final _i2.CookiePreferenceWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.CookiePreferenceUpdateWithoutUserInput,
    _i2.CookiePreferenceUncheckedUpdateWithoutUserInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
  };
}

class NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.NotificationPreferenceCreateWithoutUserInput,
    _i2.NotificationPreferenceUncheckedCreateWithoutUserInput
  >?
  create;

  final _i2.NotificationPreferenceCreateOrConnectWithoutUserInput?
  connectOrCreate;

  final _i2.NotificationPreferenceUpsertWithoutUserInput? upsert;

  final bool? disconnect;

  final bool? delete;

  final _i2.NotificationPreferenceWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.NotificationPreferenceUpdateWithoutUserInput,
    _i2.NotificationPreferenceUncheckedUpdateWithoutUserInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
  };
}

class PaymentUncheckedUpdateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentUncheckedUpdateWithoutUserInput({
    this.id,
    this.amount,
    this.currency,
    this.description,
    this.receiptUrl,
    this.paymentMethod,
    this.paymentIntent,
    this.paymentGateway,
    this.paymentStatus,
    this.expiresAt,
    this.appointmentId,
    this.discountCodeId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? amount;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? currency;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  receiptUrl;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  paymentMethod;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  paymentIntent;

  final _i1.PrismaUnion<
    _i3.PaymentGateway,
    _i2.EnumPaymentGatewayFieldUpdateOperationsInput
  >?
  paymentGateway;

  final _i1.PrismaUnion<
    _i3.PaymentStatus,
    _i2.EnumPaymentStatusFieldUpdateOperationsInput
  >?
  paymentStatus;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  expiresAt;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  appointmentId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  discountCodeId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'amount': amount,
    'currency': currency,
    'description': description,
    'receiptUrl': receiptUrl,
    'paymentMethod': paymentMethod,
    'paymentIntent': paymentIntent,
    'paymentGateway': paymentGateway,
    'paymentStatus': paymentStatus,
    'expiresAt': expiresAt,
    'appointmentId': appointmentId,
    'discountCodeId': discountCodeId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class PaymentUpdateWithWhereUniqueWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentUpdateWithWhereUniqueWithoutUserInput({
    required this.where,
    required this.data,
  });

  final _i2.PaymentWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.PaymentUpdateWithoutUserInput,
    _i2.PaymentUncheckedUpdateWithoutUserInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class PaymentScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.amount,
    this.currency,
    this.description,
    this.receiptUrl,
    this.paymentMethod,
    this.paymentIntent,
    this.paymentGateway,
    this.paymentStatus,
    this.expiresAt,
    this.userId,
    this.appointmentId,
    this.discountCodeId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
    _i2.PaymentScalarWhereInput,
    Iterable<_i2.PaymentScalarWhereInput>
  >?
  AND;

  final Iterable<_i2.PaymentScalarWhereInput>? OR;

  final _i1.PrismaUnion<
    _i2.PaymentScalarWhereInput,
    Iterable<_i2.PaymentScalarWhereInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.IntFilter, int>? amount;

  final _i1.PrismaUnion<_i2.StringFilter, String>? currency;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  description;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  receiptUrl;

  final _i1.PrismaUnion<_i2.StringFilter, String>? paymentMethod;

  final _i1.PrismaUnion<_i2.StringFilter, String>? paymentIntent;

  final _i1.PrismaUnion<_i2.EnumPaymentGatewayFilter, _i3.PaymentGateway>?
  paymentGateway;

  final _i1.PrismaUnion<_i2.EnumPaymentStatusFilter, _i3.PaymentStatus>?
  paymentStatus;

  final _i1.PrismaUnion<
    _i2.DateTimeNullableFilter,
    _i1.PrismaUnion<DateTime, _i1.PrismaNull>
  >?
  expiresAt;

  final _i1.PrismaUnion<_i2.StringFilter, String>? userId;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  appointmentId;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  discountCodeId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'amount': amount,
    'currency': currency,
    'description': description,
    'receiptUrl': receiptUrl,
    'paymentMethod': paymentMethod,
    'paymentIntent': paymentIntent,
    'paymentGateway': paymentGateway,
    'paymentStatus': paymentStatus,
    'expiresAt': expiresAt,
    'userId': userId,
    'appointmentId': appointmentId,
    'discountCodeId': discountCodeId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class PaymentUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentUpdateManyMutationInput({
    this.id,
    this.amount,
    this.currency,
    this.description,
    this.receiptUrl,
    this.paymentMethod,
    this.paymentIntent,
    this.paymentGateway,
    this.paymentStatus,
    this.expiresAt,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? amount;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? currency;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  receiptUrl;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  paymentMethod;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  paymentIntent;

  final _i1.PrismaUnion<
    _i3.PaymentGateway,
    _i2.EnumPaymentGatewayFieldUpdateOperationsInput
  >?
  paymentGateway;

  final _i1.PrismaUnion<
    _i3.PaymentStatus,
    _i2.EnumPaymentStatusFieldUpdateOperationsInput
  >?
  paymentStatus;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  expiresAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'amount': amount,
    'currency': currency,
    'description': description,
    'receiptUrl': receiptUrl,
    'paymentMethod': paymentMethod,
    'paymentIntent': paymentIntent,
    'paymentGateway': paymentGateway,
    'paymentStatus': paymentStatus,
    'expiresAt': expiresAt,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class PaymentUncheckedUpdateManyWithoutPaymentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentUncheckedUpdateManyWithoutPaymentInput({
    this.id,
    this.amount,
    this.currency,
    this.description,
    this.receiptUrl,
    this.paymentMethod,
    this.paymentIntent,
    this.paymentGateway,
    this.paymentStatus,
    this.expiresAt,
    this.appointmentId,
    this.discountCodeId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? amount;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? currency;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  receiptUrl;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  paymentMethod;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  paymentIntent;

  final _i1.PrismaUnion<
    _i3.PaymentGateway,
    _i2.EnumPaymentGatewayFieldUpdateOperationsInput
  >?
  paymentGateway;

  final _i1.PrismaUnion<
    _i3.PaymentStatus,
    _i2.EnumPaymentStatusFieldUpdateOperationsInput
  >?
  paymentStatus;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  expiresAt;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  appointmentId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  discountCodeId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'amount': amount,
    'currency': currency,
    'description': description,
    'receiptUrl': receiptUrl,
    'paymentMethod': paymentMethod,
    'paymentIntent': paymentIntent,
    'paymentGateway': paymentGateway,
    'paymentStatus': paymentStatus,
    'expiresAt': expiresAt,
    'appointmentId': appointmentId,
    'discountCodeId': discountCodeId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class PaymentUpdateManyWithWhereWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentUpdateManyWithWhereWithoutUserInput({
    required this.where,
    required this.data,
  });

  final _i2.PaymentScalarWhereInput where;

  final _i1.PrismaUnion<
    _i2.PaymentUpdateManyMutationInput,
    _i2.PaymentUncheckedUpdateManyWithoutPaymentInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class PaymentUncheckedUpdateManyWithoutUserNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentUncheckedUpdateManyWithoutUserNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.PaymentCreateWithoutUserInput,
    _i1.PrismaUnion<
      Iterable<_i2.PaymentCreateWithoutUserInput>,
      _i1.PrismaUnion<
        _i2.PaymentUncheckedCreateWithoutUserInput,
        Iterable<_i2.PaymentUncheckedCreateWithoutUserInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.PaymentCreateOrConnectWithoutUserInput,
    Iterable<_i2.PaymentCreateOrConnectWithoutUserInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.PaymentUpsertWithWhereUniqueWithoutUserInput,
    Iterable<_i2.PaymentUpsertWithWhereUniqueWithoutUserInput>
  >?
  upsert;

  final _i2.PaymentCreateManyUserInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.PaymentWhereUniqueInput,
    Iterable<_i2.PaymentWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.PaymentWhereUniqueInput,
    Iterable<_i2.PaymentWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.PaymentWhereUniqueInput,
    Iterable<_i2.PaymentWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.PaymentWhereUniqueInput,
    Iterable<_i2.PaymentWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.PaymentUpdateWithWhereUniqueWithoutUserInput,
    Iterable<_i2.PaymentUpdateWithWhereUniqueWithoutUserInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.PaymentUpdateManyWithWhereWithoutUserInput,
    Iterable<_i2.PaymentUpdateManyWithWhereWithoutUserInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.PaymentScalarWhereInput,
    Iterable<_i2.PaymentScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class SubDomainUncheckedUpdateWithoutConsultantProfilesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainUncheckedUpdateWithoutConsultantProfilesInput({
    this.id,
    this.name,
    this.domainId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? domainId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'domainId': domainId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SubDomainUpdateWithWhereUniqueWithoutConsultantProfilesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainUpdateWithWhereUniqueWithoutConsultantProfilesInput({
    required this.where,
    required this.data,
  });

  final _i2.SubDomainWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.SubDomainUpdateWithoutConsultantProfilesInput,
    _i2.SubDomainUncheckedUpdateWithoutConsultantProfilesInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class SubDomainScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.name,
    this.domainId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
    _i2.SubDomainScalarWhereInput,
    Iterable<_i2.SubDomainScalarWhereInput>
  >?
  AND;

  final Iterable<_i2.SubDomainScalarWhereInput>? OR;

  final _i1.PrismaUnion<
    _i2.SubDomainScalarWhereInput,
    Iterable<_i2.SubDomainScalarWhereInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? name;

  final _i1.PrismaUnion<_i2.StringFilter, String>? domainId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'name': name,
    'domainId': domainId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SubDomainUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainUpdateManyMutationInput({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SubDomainUncheckedUpdateManyWithoutSubDomainsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainUncheckedUpdateManyWithoutSubDomainsInput({
    this.id,
    this.name,
    this.domainId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? domainId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'domainId': domainId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SubDomainUpdateManyWithWhereWithoutConsultantProfilesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainUpdateManyWithWhereWithoutConsultantProfilesInput({
    required this.where,
    required this.data,
  });

  final _i2.SubDomainScalarWhereInput where;

  final _i1.PrismaUnion<
    _i2.SubDomainUpdateManyMutationInput,
    _i2.SubDomainUncheckedUpdateManyWithoutSubDomainsInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class SubDomainUncheckedUpdateManyWithoutConsultantProfilesNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainUncheckedUpdateManyWithoutConsultantProfilesNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.SubDomainCreateWithoutConsultantProfilesInput,
    _i1.PrismaUnion<
      Iterable<_i2.SubDomainCreateWithoutConsultantProfilesInput>,
      _i1.PrismaUnion<
        _i2.SubDomainUncheckedCreateWithoutConsultantProfilesInput,
        Iterable<_i2.SubDomainUncheckedCreateWithoutConsultantProfilesInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.SubDomainCreateOrConnectWithoutConsultantProfilesInput,
    Iterable<_i2.SubDomainCreateOrConnectWithoutConsultantProfilesInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.SubDomainUpsertWithWhereUniqueWithoutConsultantProfilesInput,
    Iterable<_i2.SubDomainUpsertWithWhereUniqueWithoutConsultantProfilesInput>
  >?
  upsert;

  final _i1.PrismaUnion<
    _i2.SubDomainWhereUniqueInput,
    Iterable<_i2.SubDomainWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.SubDomainWhereUniqueInput,
    Iterable<_i2.SubDomainWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.SubDomainWhereUniqueInput,
    Iterable<_i2.SubDomainWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.SubDomainWhereUniqueInput,
    Iterable<_i2.SubDomainWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.SubDomainUpdateWithWhereUniqueWithoutConsultantProfilesInput,
    Iterable<_i2.SubDomainUpdateWithWhereUniqueWithoutConsultantProfilesInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.SubDomainUpdateManyWithWhereWithoutConsultantProfilesInput,
    Iterable<_i2.SubDomainUpdateManyWithWhereWithoutConsultantProfilesInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.SubDomainScalarWhereInput,
    Iterable<_i2.SubDomainScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class TagUncheckedUpdateWithoutConsultantProfilesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagUncheckedUpdateWithoutConsultantProfilesInput({
    this.id,
    this.name,
    this.domainId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? domainId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'domainId': domainId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class TagUpdateWithWhereUniqueWithoutConsultantProfilesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagUpdateWithWhereUniqueWithoutConsultantProfilesInput({
    required this.where,
    required this.data,
  });

  final _i2.TagWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.TagUpdateWithoutConsultantProfilesInput,
    _i2.TagUncheckedUpdateWithoutConsultantProfilesInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class TagScalarWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.name,
    this.domainId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
    _i2.TagScalarWhereInput,
    Iterable<_i2.TagScalarWhereInput>
  >?
  AND;

  final Iterable<_i2.TagScalarWhereInput>? OR;

  final _i1.PrismaUnion<
    _i2.TagScalarWhereInput,
    Iterable<_i2.TagScalarWhereInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? name;

  final _i1.PrismaUnion<_i2.StringFilter, String>? domainId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'name': name,
    'domainId': domainId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class TagUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagUpdateManyMutationInput({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class TagUncheckedUpdateManyWithoutTagsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagUncheckedUpdateManyWithoutTagsInput({
    this.id,
    this.name,
    this.domainId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? domainId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'domainId': domainId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class TagUpdateManyWithWhereWithoutConsultantProfilesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagUpdateManyWithWhereWithoutConsultantProfilesInput({
    required this.where,
    required this.data,
  });

  final _i2.TagScalarWhereInput where;

  final _i1.PrismaUnion<
    _i2.TagUpdateManyMutationInput,
    _i2.TagUncheckedUpdateManyWithoutTagsInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class TagUncheckedUpdateManyWithoutConsultantProfilesNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagUncheckedUpdateManyWithoutConsultantProfilesNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.TagCreateWithoutConsultantProfilesInput,
    _i1.PrismaUnion<
      Iterable<_i2.TagCreateWithoutConsultantProfilesInput>,
      _i1.PrismaUnion<
        _i2.TagUncheckedCreateWithoutConsultantProfilesInput,
        Iterable<_i2.TagUncheckedCreateWithoutConsultantProfilesInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.TagCreateOrConnectWithoutConsultantProfilesInput,
    Iterable<_i2.TagCreateOrConnectWithoutConsultantProfilesInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.TagUpsertWithWhereUniqueWithoutConsultantProfilesInput,
    Iterable<_i2.TagUpsertWithWhereUniqueWithoutConsultantProfilesInput>
  >?
  upsert;

  final _i1.PrismaUnion<
    _i2.TagWhereUniqueInput,
    Iterable<_i2.TagWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.TagWhereUniqueInput,
    Iterable<_i2.TagWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.TagWhereUniqueInput,
    Iterable<_i2.TagWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.TagWhereUniqueInput,
    Iterable<_i2.TagWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.TagUpdateWithWhereUniqueWithoutConsultantProfilesInput,
    Iterable<_i2.TagUpdateWithWhereUniqueWithoutConsultantProfilesInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.TagUpdateManyWithWhereWithoutConsultantProfilesInput,
    Iterable<_i2.TagUpdateManyWithWhereWithoutConsultantProfilesInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.TagScalarWhereInput,
    Iterable<_i2.TagScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class ConsultantReviewUncheckedUpdateWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewUncheckedUpdateWithoutConsultantProfileInput({
    this.id,
    this.rating,
    this.reviewDescription,
    this.consulteeProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? rating;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  reviewDescription;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  consulteeProfileId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'rating': rating,
    'reviewDescription': reviewDescription,
    'consulteeProfileId': consulteeProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultantReviewUpdateWithWhereUniqueWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewUpdateWithWhereUniqueWithoutConsultantProfileInput({
    required this.where,
    required this.data,
  });

  final _i2.ConsultantReviewWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewUpdateWithoutConsultantProfileInput,
    _i2.ConsultantReviewUncheckedUpdateWithoutConsultantProfileInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class ConsultantReviewScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.rating,
    this.reviewDescription,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
    _i2.ConsultantReviewScalarWhereInput,
    Iterable<_i2.ConsultantReviewScalarWhereInput>
  >?
  AND;

  final Iterable<_i2.ConsultantReviewScalarWhereInput>? OR;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewScalarWhereInput,
    Iterable<_i2.ConsultantReviewScalarWhereInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.IntFilter, int>? rating;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  reviewDescription;

  final _i1.PrismaUnion<_i2.StringFilter, String>? consultantProfileId;

  final _i1.PrismaUnion<_i2.StringFilter, String>? consulteeProfileId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'rating': rating,
    'reviewDescription': reviewDescription,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultantReviewUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewUpdateManyMutationInput({
    this.id,
    this.rating,
    this.reviewDescription,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? rating;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  reviewDescription;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'rating': rating,
    'reviewDescription': reviewDescription,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultantReviewUncheckedUpdateManyWithoutReviewsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewUncheckedUpdateManyWithoutReviewsInput({
    this.id,
    this.rating,
    this.reviewDescription,
    this.consulteeProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? rating;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  reviewDescription;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  consulteeProfileId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'rating': rating,
    'reviewDescription': reviewDescription,
    'consulteeProfileId': consulteeProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultantReviewUpdateManyWithWhereWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewUpdateManyWithWhereWithoutConsultantProfileInput({
    required this.where,
    required this.data,
  });

  final _i2.ConsultantReviewScalarWhereInput where;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewUpdateManyMutationInput,
    _i2.ConsultantReviewUncheckedUpdateManyWithoutReviewsInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class ConsultantReviewUncheckedUpdateManyWithoutConsultantProfileNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewUncheckedUpdateManyWithoutConsultantProfileNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.ConsultantReviewCreateWithoutConsultantProfileInput,
    _i1.PrismaUnion<
      Iterable<_i2.ConsultantReviewCreateWithoutConsultantProfileInput>,
      _i1.PrismaUnion<
        _i2.ConsultantReviewUncheckedCreateWithoutConsultantProfileInput,
        Iterable<
          _i2.ConsultantReviewUncheckedCreateWithoutConsultantProfileInput
        >
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewCreateOrConnectWithoutConsultantProfileInput,
    Iterable<_i2.ConsultantReviewCreateOrConnectWithoutConsultantProfileInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewUpsertWithWhereUniqueWithoutConsultantProfileInput,
    Iterable<
      _i2.ConsultantReviewUpsertWithWhereUniqueWithoutConsultantProfileInput
    >
  >?
  upsert;

  final _i2.ConsultantReviewCreateManyConsultantProfileInputEnvelope?
  createMany;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewWhereUniqueInput,
    Iterable<_i2.ConsultantReviewWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewWhereUniqueInput,
    Iterable<_i2.ConsultantReviewWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewWhereUniqueInput,
    Iterable<_i2.ConsultantReviewWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewWhereUniqueInput,
    Iterable<_i2.ConsultantReviewWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewUpdateWithWhereUniqueWithoutConsultantProfileInput,
    Iterable<
      _i2.ConsultantReviewUpdateWithWhereUniqueWithoutConsultantProfileInput
    >
  >?
  update;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewUpdateManyWithWhereWithoutConsultantProfileInput,
    Iterable<
      _i2.ConsultantReviewUpdateManyWithWhereWithoutConsultantProfileInput
    >
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewScalarWhereInput,
    Iterable<_i2.ConsultantReviewScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class SlotOfAvailabilityWeeklyUncheckedUpdateManyWithoutConsultantProfileNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityWeeklyUncheckedUpdateManyWithoutConsultantProfileNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityWeeklyCreateWithoutConsultantProfileInput,
    _i1.PrismaUnion<
      Iterable<_i2.SlotOfAvailabilityWeeklyCreateWithoutConsultantProfileInput>,
      _i1.PrismaUnion<
        _i2.SlotOfAvailabilityWeeklyUncheckedCreateWithoutConsultantProfileInput,
        Iterable<
          _i2.SlotOfAvailabilityWeeklyUncheckedCreateWithoutConsultantProfileInput
        >
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityWeeklyCreateOrConnectWithoutConsultantProfileInput,
    Iterable<
      _i2.SlotOfAvailabilityWeeklyCreateOrConnectWithoutConsultantProfileInput
    >
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityWeeklyUpsertWithWhereUniqueWithoutConsultantProfileInput,
    Iterable<
      _i2.SlotOfAvailabilityWeeklyUpsertWithWhereUniqueWithoutConsultantProfileInput
    >
  >?
  upsert;

  final _i2.SlotOfAvailabilityWeeklyCreateManyConsultantProfileInputEnvelope?
  createMany;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityWeeklyWhereUniqueInput,
    Iterable<_i2.SlotOfAvailabilityWeeklyWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityWeeklyWhereUniqueInput,
    Iterable<_i2.SlotOfAvailabilityWeeklyWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityWeeklyWhereUniqueInput,
    Iterable<_i2.SlotOfAvailabilityWeeklyWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityWeeklyWhereUniqueInput,
    Iterable<_i2.SlotOfAvailabilityWeeklyWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityWeeklyUpdateWithWhereUniqueWithoutConsultantProfileInput,
    Iterable<
      _i2.SlotOfAvailabilityWeeklyUpdateWithWhereUniqueWithoutConsultantProfileInput
    >
  >?
  update;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityWeeklyUpdateManyWithWhereWithoutConsultantProfileInput,
    Iterable<
      _i2.SlotOfAvailabilityWeeklyUpdateManyWithWhereWithoutConsultantProfileInput
    >
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityWeeklyScalarWhereInput,
    Iterable<_i2.SlotOfAvailabilityWeeklyScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class SlotOfAvailabilityCustomUncheckedUpdateManyWithoutConsultantProfileNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityCustomUncheckedUpdateManyWithoutConsultantProfileNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityCustomCreateWithoutConsultantProfileInput,
    _i1.PrismaUnion<
      Iterable<_i2.SlotOfAvailabilityCustomCreateWithoutConsultantProfileInput>,
      _i1.PrismaUnion<
        _i2.SlotOfAvailabilityCustomUncheckedCreateWithoutConsultantProfileInput,
        Iterable<
          _i2.SlotOfAvailabilityCustomUncheckedCreateWithoutConsultantProfileInput
        >
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityCustomCreateOrConnectWithoutConsultantProfileInput,
    Iterable<
      _i2.SlotOfAvailabilityCustomCreateOrConnectWithoutConsultantProfileInput
    >
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityCustomUpsertWithWhereUniqueWithoutConsultantProfileInput,
    Iterable<
      _i2.SlotOfAvailabilityCustomUpsertWithWhereUniqueWithoutConsultantProfileInput
    >
  >?
  upsert;

  final _i2.SlotOfAvailabilityCustomCreateManyConsultantProfileInputEnvelope?
  createMany;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityCustomWhereUniqueInput,
    Iterable<_i2.SlotOfAvailabilityCustomWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityCustomWhereUniqueInput,
    Iterable<_i2.SlotOfAvailabilityCustomWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityCustomWhereUniqueInput,
    Iterable<_i2.SlotOfAvailabilityCustomWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityCustomWhereUniqueInput,
    Iterable<_i2.SlotOfAvailabilityCustomWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityCustomUpdateWithWhereUniqueWithoutConsultantProfileInput,
    Iterable<
      _i2.SlotOfAvailabilityCustomUpdateWithWhereUniqueWithoutConsultantProfileInput
    >
  >?
  update;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityCustomUpdateManyWithWhereWithoutConsultantProfileInput,
    Iterable<
      _i2.SlotOfAvailabilityCustomUpdateManyWithWhereWithoutConsultantProfileInput
    >
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityCustomScalarWhereInput,
    Iterable<_i2.SlotOfAvailabilityCustomScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class ConsultationUncheckedUpdateWithoutConsultationPlanInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationUncheckedUpdateWithoutConsultationPlanInput({
    this.id,
    this.requestStatus,
    this.requestedById,
    this.requestedAt,
    this.requestNotes,
    this.directlyBooked,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.createdAt,
    this.updatedAt,
    this.appointment,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    _i3.RequestStatus,
    _i2.EnumRequestStatusFieldUpdateOperationsInput
  >?
  requestStatus;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  requestedById;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  requestedAt;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  requestNotes;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
  directlyBooked;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackFromConsultee;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackFromConsultant;

  final _i1.PrismaUnion<
    double,
    _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  rating;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.AppointmentUncheckedUpdateOneWithoutConsultationNestedInput?
  appointment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'requestStatus': requestStatus,
    'requestedById': requestedById,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'directlyBooked': directlyBooked,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'appointment': appointment,
  };
}

class ConsultationUpdateWithWhereUniqueWithoutConsultationPlanInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationUpdateWithWhereUniqueWithoutConsultationPlanInput({
    required this.where,
    required this.data,
  });

  final _i2.ConsultationWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.ConsultationUpdateWithoutConsultationPlanInput,
    _i2.ConsultationUncheckedUpdateWithoutConsultationPlanInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class ConsultationScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.consultationPlanId,
    this.requestStatus,
    this.requestedById,
    this.requestedAt,
    this.requestNotes,
    this.directlyBooked,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
    _i2.ConsultationScalarWhereInput,
    Iterable<_i2.ConsultationScalarWhereInput>
  >?
  AND;

  final Iterable<_i2.ConsultationScalarWhereInput>? OR;

  final _i1.PrismaUnion<
    _i2.ConsultationScalarWhereInput,
    Iterable<_i2.ConsultationScalarWhereInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? consultationPlanId;

  final _i1.PrismaUnion<_i2.EnumRequestStatusFilter, _i3.RequestStatus>?
  requestStatus;

  final _i1.PrismaUnion<_i2.StringFilter, String>? requestedById;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? requestedAt;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  requestNotes;

  final _i1.PrismaUnion<_i2.BoolFilter, bool>? directlyBooked;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  feedbackFromConsultee;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  feedbackFromConsultant;

  final _i1.PrismaUnion<
    _i2.FloatNullableFilter,
    _i1.PrismaUnion<double, _i1.PrismaNull>
  >?
  rating;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'consultationPlanId': consultationPlanId,
    'requestStatus': requestStatus,
    'requestedById': requestedById,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'directlyBooked': directlyBooked,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultationUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationUpdateManyMutationInput({
    this.id,
    this.requestStatus,
    this.requestedAt,
    this.requestNotes,
    this.directlyBooked,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    _i3.RequestStatus,
    _i2.EnumRequestStatusFieldUpdateOperationsInput
  >?
  requestStatus;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  requestedAt;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  requestNotes;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
  directlyBooked;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackFromConsultee;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackFromConsultant;

  final _i1.PrismaUnion<
    double,
    _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  rating;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'requestStatus': requestStatus,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'directlyBooked': directlyBooked,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultationUncheckedUpdateManyWithoutConsultationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationUncheckedUpdateManyWithoutConsultationsInput({
    this.id,
    this.requestStatus,
    this.requestedById,
    this.requestedAt,
    this.requestNotes,
    this.directlyBooked,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    _i3.RequestStatus,
    _i2.EnumRequestStatusFieldUpdateOperationsInput
  >?
  requestStatus;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  requestedById;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  requestedAt;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  requestNotes;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
  directlyBooked;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackFromConsultee;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackFromConsultant;

  final _i1.PrismaUnion<
    double,
    _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  rating;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'requestStatus': requestStatus,
    'requestedById': requestedById,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'directlyBooked': directlyBooked,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultationUpdateManyWithWhereWithoutConsultationPlanInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationUpdateManyWithWhereWithoutConsultationPlanInput({
    required this.where,
    required this.data,
  });

  final _i2.ConsultationScalarWhereInput where;

  final _i1.PrismaUnion<
    _i2.ConsultationUpdateManyMutationInput,
    _i2.ConsultationUncheckedUpdateManyWithoutConsultationsInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class ConsultationUncheckedUpdateManyWithoutConsultationPlanNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationUncheckedUpdateManyWithoutConsultationPlanNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.ConsultationCreateWithoutConsultationPlanInput,
    _i1.PrismaUnion<
      Iterable<_i2.ConsultationCreateWithoutConsultationPlanInput>,
      _i1.PrismaUnion<
        _i2.ConsultationUncheckedCreateWithoutConsultationPlanInput,
        Iterable<_i2.ConsultationUncheckedCreateWithoutConsultationPlanInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.ConsultationCreateOrConnectWithoutConsultationPlanInput,
    Iterable<_i2.ConsultationCreateOrConnectWithoutConsultationPlanInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.ConsultationUpsertWithWhereUniqueWithoutConsultationPlanInput,
    Iterable<_i2.ConsultationUpsertWithWhereUniqueWithoutConsultationPlanInput>
  >?
  upsert;

  final _i2.ConsultationCreateManyConsultationPlanInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.ConsultationWhereUniqueInput,
    Iterable<_i2.ConsultationWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.ConsultationWhereUniqueInput,
    Iterable<_i2.ConsultationWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.ConsultationWhereUniqueInput,
    Iterable<_i2.ConsultationWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.ConsultationWhereUniqueInput,
    Iterable<_i2.ConsultationWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.ConsultationUpdateWithWhereUniqueWithoutConsultationPlanInput,
    Iterable<_i2.ConsultationUpdateWithWhereUniqueWithoutConsultationPlanInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.ConsultationUpdateManyWithWhereWithoutConsultationPlanInput,
    Iterable<_i2.ConsultationUpdateManyWithWhereWithoutConsultationPlanInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.ConsultationScalarWhereInput,
    Iterable<_i2.ConsultationScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class ConsultationPlanUncheckedUpdateWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanUncheckedUpdateWithoutConsultantProfileInput({
    this.id,
    this.title,
    this.description,
    this.durationInHours,
    this.price,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.createdAt,
    this.updatedAt,
    this.consultations,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
  durationInHours;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? price;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? language;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? level;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  prerequisites;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  materialProvided;

  final _i1.PrismaUnion<
    _i2.ConsultationPlanUpdatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.ConsultationUncheckedUpdateManyWithoutConsultationPlanNestedInput?
  consultations;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInHours': durationInHours,
    'price': price,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultations': consultations,
  };
}

class ConsultationPlanUpdateWithWhereUniqueWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanUpdateWithWhereUniqueWithoutConsultantProfileInput({
    required this.where,
    required this.data,
  });

  final _i2.ConsultationPlanWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.ConsultationPlanUpdateWithoutConsultantProfileInput,
    _i2.ConsultationPlanUncheckedUpdateWithoutConsultantProfileInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class ConsultationPlanScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.title,
    this.description,
    this.durationInHours,
    this.price,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
    _i2.ConsultationPlanScalarWhereInput,
    Iterable<_i2.ConsultationPlanScalarWhereInput>
  >?
  AND;

  final Iterable<_i2.ConsultationPlanScalarWhereInput>? OR;

  final _i1.PrismaUnion<
    _i2.ConsultationPlanScalarWhereInput,
    Iterable<_i2.ConsultationPlanScalarWhereInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? title;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  description;

  final _i1.PrismaUnion<_i2.FloatFilter, double>? durationInHours;

  final _i1.PrismaUnion<_i2.IntFilter, int>? price;

  final _i1.PrismaUnion<_i2.StringFilter, String>? language;

  final _i1.PrismaUnion<_i2.StringFilter, String>? level;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  prerequisites;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  materialProvided;

  final _i2.StringNullableListFilter? learningOutcomes;

  final _i1.PrismaUnion<_i2.StringFilter, String>? consultantProfileId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'title': title,
    'description': description,
    'durationInHours': durationInHours,
    'price': price,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultationPlanUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanUpdateManyMutationInput({
    this.id,
    this.title,
    this.description,
    this.durationInHours,
    this.price,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
  durationInHours;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? price;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? language;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? level;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  prerequisites;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  materialProvided;

  final _i1.PrismaUnion<
    _i2.ConsultationPlanUpdatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInHours': durationInHours,
    'price': price,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultationPlanUncheckedUpdateManyWithoutConsultationPlansInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanUncheckedUpdateManyWithoutConsultationPlansInput({
    this.id,
    this.title,
    this.description,
    this.durationInHours,
    this.price,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
  durationInHours;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? price;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? language;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? level;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  prerequisites;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  materialProvided;

  final _i1.PrismaUnion<
    _i2.ConsultationPlanUpdatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInHours': durationInHours,
    'price': price,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultationPlanUpdateManyWithWhereWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanUpdateManyWithWhereWithoutConsultantProfileInput({
    required this.where,
    required this.data,
  });

  final _i2.ConsultationPlanScalarWhereInput where;

  final _i1.PrismaUnion<
    _i2.ConsultationPlanUpdateManyMutationInput,
    _i2.ConsultationPlanUncheckedUpdateManyWithoutConsultationPlansInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class ConsultationPlanUncheckedUpdateManyWithoutConsultantProfileNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanUncheckedUpdateManyWithoutConsultantProfileNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.ConsultationPlanCreateWithoutConsultantProfileInput,
    _i1.PrismaUnion<
      Iterable<_i2.ConsultationPlanCreateWithoutConsultantProfileInput>,
      _i1.PrismaUnion<
        _i2.ConsultationPlanUncheckedCreateWithoutConsultantProfileInput,
        Iterable<
          _i2.ConsultationPlanUncheckedCreateWithoutConsultantProfileInput
        >
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.ConsultationPlanCreateOrConnectWithoutConsultantProfileInput,
    Iterable<_i2.ConsultationPlanCreateOrConnectWithoutConsultantProfileInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.ConsultationPlanUpsertWithWhereUniqueWithoutConsultantProfileInput,
    Iterable<
      _i2.ConsultationPlanUpsertWithWhereUniqueWithoutConsultantProfileInput
    >
  >?
  upsert;

  final _i2.ConsultationPlanCreateManyConsultantProfileInputEnvelope?
  createMany;

  final _i1.PrismaUnion<
    _i2.ConsultationPlanWhereUniqueInput,
    Iterable<_i2.ConsultationPlanWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.ConsultationPlanWhereUniqueInput,
    Iterable<_i2.ConsultationPlanWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.ConsultationPlanWhereUniqueInput,
    Iterable<_i2.ConsultationPlanWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.ConsultationPlanWhereUniqueInput,
    Iterable<_i2.ConsultationPlanWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.ConsultationPlanUpdateWithWhereUniqueWithoutConsultantProfileInput,
    Iterable<
      _i2.ConsultationPlanUpdateWithWhereUniqueWithoutConsultantProfileInput
    >
  >?
  update;

  final _i1.PrismaUnion<
    _i2.ConsultationPlanUpdateManyWithWhereWithoutConsultantProfileInput,
    Iterable<
      _i2.ConsultationPlanUpdateManyWithWhereWithoutConsultantProfileInput
    >
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.ConsultationPlanScalarWhereInput,
    Iterable<_i2.ConsultationPlanScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class AppointmentUpdateWithoutSubscriptionInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentUpdateWithoutSubscriptionInput({
    this.id,
    this.appointmentType,
    this.createdAt,
    this.updatedAt,
    this.slotsOfAppointment,
    this.consultation,
    this.webinar,
    this.$class,
    this.payment,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    _i3.AppointmentsType,
    _i2.EnumAppointmentsTypeFieldUpdateOperationsInput
  >?
  appointmentType;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.SlotOfAppointmentUpdateManyWithoutAppointmentNestedInput?
  slotsOfAppointment;

  final _i2.ConsultationUpdateOneWithoutAppointmentNestedInput? consultation;

  final _i2.WebinarUpdateOneWithoutAppointmentNestedInput? webinar;

  final _i2.ClassUpdateOneWithoutAppointmentsNestedInput? $class;

  final _i2.PaymentUpdateManyWithoutAppointmentNestedInput? payment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'appointmentType': appointmentType,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'slotsOfAppointment': slotsOfAppointment,
    'consultation': consultation,
    'webinar': webinar,
    'class': $class,
    'payment': payment,
  };
}

class PaymentUncheckedUpdateWithoutAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentUncheckedUpdateWithoutAppointmentInput({
    this.id,
    this.amount,
    this.currency,
    this.description,
    this.receiptUrl,
    this.paymentMethod,
    this.paymentIntent,
    this.paymentGateway,
    this.paymentStatus,
    this.expiresAt,
    this.userId,
    this.discountCodeId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? amount;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? currency;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  receiptUrl;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  paymentMethod;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  paymentIntent;

  final _i1.PrismaUnion<
    _i3.PaymentGateway,
    _i2.EnumPaymentGatewayFieldUpdateOperationsInput
  >?
  paymentGateway;

  final _i1.PrismaUnion<
    _i3.PaymentStatus,
    _i2.EnumPaymentStatusFieldUpdateOperationsInput
  >?
  paymentStatus;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  expiresAt;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  discountCodeId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'amount': amount,
    'currency': currency,
    'description': description,
    'receiptUrl': receiptUrl,
    'paymentMethod': paymentMethod,
    'paymentIntent': paymentIntent,
    'paymentGateway': paymentGateway,
    'paymentStatus': paymentStatus,
    'expiresAt': expiresAt,
    'userId': userId,
    'discountCodeId': discountCodeId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class PaymentUpdateWithWhereUniqueWithoutAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentUpdateWithWhereUniqueWithoutAppointmentInput({
    required this.where,
    required this.data,
  });

  final _i2.PaymentWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.PaymentUpdateWithoutAppointmentInput,
    _i2.PaymentUncheckedUpdateWithoutAppointmentInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class PaymentUpdateManyWithWhereWithoutAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentUpdateManyWithWhereWithoutAppointmentInput({
    required this.where,
    required this.data,
  });

  final _i2.PaymentScalarWhereInput where;

  final _i1.PrismaUnion<
    _i2.PaymentUpdateManyMutationInput,
    _i2.PaymentUncheckedUpdateManyWithoutPaymentInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class PaymentUncheckedUpdateManyWithoutAppointmentNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentUncheckedUpdateManyWithoutAppointmentNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.PaymentCreateWithoutAppointmentInput,
    _i1.PrismaUnion<
      Iterable<_i2.PaymentCreateWithoutAppointmentInput>,
      _i1.PrismaUnion<
        _i2.PaymentUncheckedCreateWithoutAppointmentInput,
        Iterable<_i2.PaymentUncheckedCreateWithoutAppointmentInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.PaymentCreateOrConnectWithoutAppointmentInput,
    Iterable<_i2.PaymentCreateOrConnectWithoutAppointmentInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.PaymentUpsertWithWhereUniqueWithoutAppointmentInput,
    Iterable<_i2.PaymentUpsertWithWhereUniqueWithoutAppointmentInput>
  >?
  upsert;

  final _i2.PaymentCreateManyAppointmentInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.PaymentWhereUniqueInput,
    Iterable<_i2.PaymentWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.PaymentWhereUniqueInput,
    Iterable<_i2.PaymentWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.PaymentWhereUniqueInput,
    Iterable<_i2.PaymentWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.PaymentWhereUniqueInput,
    Iterable<_i2.PaymentWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.PaymentUpdateWithWhereUniqueWithoutAppointmentInput,
    Iterable<_i2.PaymentUpdateWithWhereUniqueWithoutAppointmentInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.PaymentUpdateManyWithWhereWithoutAppointmentInput,
    Iterable<_i2.PaymentUpdateManyWithWhereWithoutAppointmentInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.PaymentScalarWhereInput,
    Iterable<_i2.PaymentScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class AppointmentUncheckedUpdateWithoutSubscriptionInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentUncheckedUpdateWithoutSubscriptionInput({
    this.id,
    this.appointmentType,
    this.consultationId,
    this.webinarId,
    this.classId,
    this.createdAt,
    this.updatedAt,
    this.slotsOfAppointment,
    this.payment,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    _i3.AppointmentsType,
    _i2.EnumAppointmentsTypeFieldUpdateOperationsInput
  >?
  appointmentType;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consultationId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  webinarId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  classId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.SlotOfAppointmentUncheckedUpdateManyWithoutAppointmentNestedInput?
  slotsOfAppointment;

  final _i2.PaymentUncheckedUpdateManyWithoutAppointmentNestedInput? payment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'appointmentType': appointmentType,
    'consultationId': consultationId,
    'webinarId': webinarId,
    'classId': classId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'slotsOfAppointment': slotsOfAppointment,
    'payment': payment,
  };
}

class AppointmentUpsertWithWhereUniqueWithoutSubscriptionInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentUpsertWithWhereUniqueWithoutSubscriptionInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.AppointmentWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.AppointmentUpdateWithoutSubscriptionInput,
    _i2.AppointmentUncheckedUpdateWithoutSubscriptionInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.AppointmentCreateWithoutSubscriptionInput,
    _i2.AppointmentUncheckedCreateWithoutSubscriptionInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'update': update,
    'create': create,
  };
}

class AppointmentUpdateWithWhereUniqueWithoutSubscriptionInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentUpdateWithWhereUniqueWithoutSubscriptionInput({
    required this.where,
    required this.data,
  });

  final _i2.AppointmentWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.AppointmentUpdateWithoutSubscriptionInput,
    _i2.AppointmentUncheckedUpdateWithoutSubscriptionInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class AppointmentScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.appointmentType,
    this.consultationId,
    this.subscriptionId,
    this.webinarId,
    this.classId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
    _i2.AppointmentScalarWhereInput,
    Iterable<_i2.AppointmentScalarWhereInput>
  >?
  AND;

  final Iterable<_i2.AppointmentScalarWhereInput>? OR;

  final _i1.PrismaUnion<
    _i2.AppointmentScalarWhereInput,
    Iterable<_i2.AppointmentScalarWhereInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.EnumAppointmentsTypeFilter, _i3.AppointmentsType>?
  appointmentType;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  consultationId;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  subscriptionId;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  webinarId;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  classId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'appointmentType': appointmentType,
    'consultationId': consultationId,
    'subscriptionId': subscriptionId,
    'webinarId': webinarId,
    'classId': classId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class AppointmentUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentUpdateManyMutationInput({
    this.id,
    this.appointmentType,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    _i3.AppointmentsType,
    _i2.EnumAppointmentsTypeFieldUpdateOperationsInput
  >?
  appointmentType;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'appointmentType': appointmentType,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class AppointmentUncheckedUpdateManyWithoutAppointmentsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentUncheckedUpdateManyWithoutAppointmentsInput({
    this.id,
    this.appointmentType,
    this.consultationId,
    this.webinarId,
    this.classId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    _i3.AppointmentsType,
    _i2.EnumAppointmentsTypeFieldUpdateOperationsInput
  >?
  appointmentType;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consultationId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  webinarId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  classId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'appointmentType': appointmentType,
    'consultationId': consultationId,
    'webinarId': webinarId,
    'classId': classId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class AppointmentUpdateManyWithWhereWithoutSubscriptionInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentUpdateManyWithWhereWithoutSubscriptionInput({
    required this.where,
    required this.data,
  });

  final _i2.AppointmentScalarWhereInput where;

  final _i1.PrismaUnion<
    _i2.AppointmentUpdateManyMutationInput,
    _i2.AppointmentUncheckedUpdateManyWithoutAppointmentsInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class AppointmentUncheckedUpdateManyWithoutSubscriptionNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentUncheckedUpdateManyWithoutSubscriptionNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.AppointmentCreateWithoutSubscriptionInput,
    _i1.PrismaUnion<
      Iterable<_i2.AppointmentCreateWithoutSubscriptionInput>,
      _i1.PrismaUnion<
        _i2.AppointmentUncheckedCreateWithoutSubscriptionInput,
        Iterable<_i2.AppointmentUncheckedCreateWithoutSubscriptionInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.AppointmentCreateOrConnectWithoutSubscriptionInput,
    Iterable<_i2.AppointmentCreateOrConnectWithoutSubscriptionInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.AppointmentUpsertWithWhereUniqueWithoutSubscriptionInput,
    Iterable<_i2.AppointmentUpsertWithWhereUniqueWithoutSubscriptionInput>
  >?
  upsert;

  final _i2.AppointmentCreateManySubscriptionInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.AppointmentWhereUniqueInput,
    Iterable<_i2.AppointmentWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.AppointmentWhereUniqueInput,
    Iterable<_i2.AppointmentWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.AppointmentWhereUniqueInput,
    Iterable<_i2.AppointmentWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.AppointmentWhereUniqueInput,
    Iterable<_i2.AppointmentWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.AppointmentUpdateWithWhereUniqueWithoutSubscriptionInput,
    Iterable<_i2.AppointmentUpdateWithWhereUniqueWithoutSubscriptionInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.AppointmentUpdateManyWithWhereWithoutSubscriptionInput,
    Iterable<_i2.AppointmentUpdateManyWithWhereWithoutSubscriptionInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.AppointmentScalarWhereInput,
    Iterable<_i2.AppointmentScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class SubscriptionUncheckedUpdateWithoutSubscriptionPlanInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionUncheckedUpdateWithoutSubscriptionPlanInput({
    this.id,
    this.startDate,
    this.endDate,
    this.requestStatus,
    this.requestedById,
    this.requestedAt,
    this.requestNotes,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.createdAt,
    this.updatedAt,
    this.appointments,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  startDate;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  endDate;

  final _i1.PrismaUnion<
    _i3.RequestStatus,
    _i2.EnumRequestStatusFieldUpdateOperationsInput
  >?
  requestStatus;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  requestedById;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  requestedAt;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  requestNotes;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackFromConsultee;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackFromConsultant;

  final _i1.PrismaUnion<
    double,
    _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  rating;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.AppointmentUncheckedUpdateManyWithoutSubscriptionNestedInput?
  appointments;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'requestStatus': requestStatus,
    'requestedById': requestedById,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'appointments': appointments,
  };
}

class SubscriptionUpdateWithWhereUniqueWithoutSubscriptionPlanInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionUpdateWithWhereUniqueWithoutSubscriptionPlanInput({
    required this.where,
    required this.data,
  });

  final _i2.SubscriptionWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.SubscriptionUpdateWithoutSubscriptionPlanInput,
    _i2.SubscriptionUncheckedUpdateWithoutSubscriptionPlanInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class SubscriptionScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.startDate,
    this.endDate,
    this.requestStatus,
    this.requestedById,
    this.requestedAt,
    this.requestNotes,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.subscriptionPlanId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
    _i2.SubscriptionScalarWhereInput,
    Iterable<_i2.SubscriptionScalarWhereInput>
  >?
  AND;

  final Iterable<_i2.SubscriptionScalarWhereInput>? OR;

  final _i1.PrismaUnion<
    _i2.SubscriptionScalarWhereInput,
    Iterable<_i2.SubscriptionScalarWhereInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? startDate;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? endDate;

  final _i1.PrismaUnion<_i2.EnumRequestStatusFilter, _i3.RequestStatus>?
  requestStatus;

  final _i1.PrismaUnion<_i2.StringFilter, String>? requestedById;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? requestedAt;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  requestNotes;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  feedbackFromConsultee;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  feedbackFromConsultant;

  final _i1.PrismaUnion<
    _i2.FloatNullableFilter,
    _i1.PrismaUnion<double, _i1.PrismaNull>
  >?
  rating;

  final _i1.PrismaUnion<_i2.StringFilter, String>? subscriptionPlanId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'requestStatus': requestStatus,
    'requestedById': requestedById,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'subscriptionPlanId': subscriptionPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SubscriptionUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionUpdateManyMutationInput({
    this.id,
    this.startDate,
    this.endDate,
    this.requestStatus,
    this.requestedAt,
    this.requestNotes,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  startDate;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  endDate;

  final _i1.PrismaUnion<
    _i3.RequestStatus,
    _i2.EnumRequestStatusFieldUpdateOperationsInput
  >?
  requestStatus;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  requestedAt;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  requestNotes;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackFromConsultee;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackFromConsultant;

  final _i1.PrismaUnion<
    double,
    _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  rating;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'requestStatus': requestStatus,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SubscriptionUncheckedUpdateManyWithoutSubscriptionsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionUncheckedUpdateManyWithoutSubscriptionsInput({
    this.id,
    this.startDate,
    this.endDate,
    this.requestStatus,
    this.requestedById,
    this.requestedAt,
    this.requestNotes,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  startDate;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  endDate;

  final _i1.PrismaUnion<
    _i3.RequestStatus,
    _i2.EnumRequestStatusFieldUpdateOperationsInput
  >?
  requestStatus;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  requestedById;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  requestedAt;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  requestNotes;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackFromConsultee;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackFromConsultant;

  final _i1.PrismaUnion<
    double,
    _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  rating;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'requestStatus': requestStatus,
    'requestedById': requestedById,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SubscriptionUpdateManyWithWhereWithoutSubscriptionPlanInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionUpdateManyWithWhereWithoutSubscriptionPlanInput({
    required this.where,
    required this.data,
  });

  final _i2.SubscriptionScalarWhereInput where;

  final _i1.PrismaUnion<
    _i2.SubscriptionUpdateManyMutationInput,
    _i2.SubscriptionUncheckedUpdateManyWithoutSubscriptionsInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class SubscriptionUncheckedUpdateManyWithoutSubscriptionPlanNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionUncheckedUpdateManyWithoutSubscriptionPlanNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.SubscriptionCreateWithoutSubscriptionPlanInput,
    _i1.PrismaUnion<
      Iterable<_i2.SubscriptionCreateWithoutSubscriptionPlanInput>,
      _i1.PrismaUnion<
        _i2.SubscriptionUncheckedCreateWithoutSubscriptionPlanInput,
        Iterable<_i2.SubscriptionUncheckedCreateWithoutSubscriptionPlanInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.SubscriptionCreateOrConnectWithoutSubscriptionPlanInput,
    Iterable<_i2.SubscriptionCreateOrConnectWithoutSubscriptionPlanInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.SubscriptionUpsertWithWhereUniqueWithoutSubscriptionPlanInput,
    Iterable<_i2.SubscriptionUpsertWithWhereUniqueWithoutSubscriptionPlanInput>
  >?
  upsert;

  final _i2.SubscriptionCreateManySubscriptionPlanInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.SubscriptionWhereUniqueInput,
    Iterable<_i2.SubscriptionWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.SubscriptionWhereUniqueInput,
    Iterable<_i2.SubscriptionWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.SubscriptionWhereUniqueInput,
    Iterable<_i2.SubscriptionWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.SubscriptionWhereUniqueInput,
    Iterable<_i2.SubscriptionWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.SubscriptionUpdateWithWhereUniqueWithoutSubscriptionPlanInput,
    Iterable<_i2.SubscriptionUpdateWithWhereUniqueWithoutSubscriptionPlanInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.SubscriptionUpdateManyWithWhereWithoutSubscriptionPlanInput,
    Iterable<_i2.SubscriptionUpdateManyWithWhereWithoutSubscriptionPlanInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.SubscriptionScalarWhereInput,
    Iterable<_i2.SubscriptionScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class SubscriptionPlanUncheckedUpdateWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanUncheckedUpdateWithoutConsultantProfileInput({
    this.id,
    this.title,
    this.description,
    this.durationInMonths,
    this.price,
    this.callsPerWeek,
    this.sessionDurationInHours,
    this.videoMeetings,
    this.emailSupport,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.createdAt,
    this.updatedAt,
    this.subscriptions,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
  durationInMonths;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? price;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? callsPerWeek;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
  sessionDurationInHours;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? videoMeetings;

  final _i1.PrismaUnion<
    _i3.PlanEmailSupport,
    _i2.EnumPlanEmailSupportFieldUpdateOperationsInput
  >?
  emailSupport;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? language;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? level;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  prerequisites;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  materialProvided;

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanUpdatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.SubscriptionUncheckedUpdateManyWithoutSubscriptionPlanNestedInput?
  subscriptions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInMonths': durationInMonths,
    'price': price,
    'callsPerWeek': callsPerWeek,
    'sessionDurationInHours': sessionDurationInHours,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'subscriptions': subscriptions,
  };
}

class SubscriptionPlanUpdateWithWhereUniqueWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanUpdateWithWhereUniqueWithoutConsultantProfileInput({
    required this.where,
    required this.data,
  });

  final _i2.SubscriptionPlanWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanUpdateWithoutConsultantProfileInput,
    _i2.SubscriptionPlanUncheckedUpdateWithoutConsultantProfileInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class SubscriptionPlanScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.title,
    this.description,
    this.durationInMonths,
    this.price,
    this.callsPerWeek,
    this.sessionDurationInHours,
    this.videoMeetings,
    this.emailSupport,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanScalarWhereInput,
    Iterable<_i2.SubscriptionPlanScalarWhereInput>
  >?
  AND;

  final Iterable<_i2.SubscriptionPlanScalarWhereInput>? OR;

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanScalarWhereInput,
    Iterable<_i2.SubscriptionPlanScalarWhereInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? title;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  description;

  final _i1.PrismaUnion<_i2.IntFilter, int>? durationInMonths;

  final _i1.PrismaUnion<_i2.IntFilter, int>? price;

  final _i1.PrismaUnion<_i2.IntFilter, int>? callsPerWeek;

  final _i1.PrismaUnion<_i2.FloatFilter, double>? sessionDurationInHours;

  final _i1.PrismaUnion<_i2.IntFilter, int>? videoMeetings;

  final _i1.PrismaUnion<_i2.EnumPlanEmailSupportFilter, _i3.PlanEmailSupport>?
  emailSupport;

  final _i1.PrismaUnion<_i2.StringFilter, String>? language;

  final _i1.PrismaUnion<_i2.StringFilter, String>? level;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  prerequisites;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  materialProvided;

  final _i2.StringNullableListFilter? learningOutcomes;

  final _i1.PrismaUnion<_i2.StringFilter, String>? consultantProfileId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'title': title,
    'description': description,
    'durationInMonths': durationInMonths,
    'price': price,
    'callsPerWeek': callsPerWeek,
    'sessionDurationInHours': sessionDurationInHours,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SubscriptionPlanUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanUpdateManyMutationInput({
    this.id,
    this.title,
    this.description,
    this.durationInMonths,
    this.price,
    this.callsPerWeek,
    this.sessionDurationInHours,
    this.videoMeetings,
    this.emailSupport,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
  durationInMonths;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? price;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? callsPerWeek;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
  sessionDurationInHours;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? videoMeetings;

  final _i1.PrismaUnion<
    _i3.PlanEmailSupport,
    _i2.EnumPlanEmailSupportFieldUpdateOperationsInput
  >?
  emailSupport;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? language;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? level;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  prerequisites;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  materialProvided;

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanUpdatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInMonths': durationInMonths,
    'price': price,
    'callsPerWeek': callsPerWeek,
    'sessionDurationInHours': sessionDurationInHours,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SubscriptionPlanUncheckedUpdateManyWithoutSubscriptionPlansInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanUncheckedUpdateManyWithoutSubscriptionPlansInput({
    this.id,
    this.title,
    this.description,
    this.durationInMonths,
    this.price,
    this.callsPerWeek,
    this.sessionDurationInHours,
    this.videoMeetings,
    this.emailSupport,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
  durationInMonths;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? price;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? callsPerWeek;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
  sessionDurationInHours;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? videoMeetings;

  final _i1.PrismaUnion<
    _i3.PlanEmailSupport,
    _i2.EnumPlanEmailSupportFieldUpdateOperationsInput
  >?
  emailSupport;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? language;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? level;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  prerequisites;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  materialProvided;

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanUpdatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInMonths': durationInMonths,
    'price': price,
    'callsPerWeek': callsPerWeek,
    'sessionDurationInHours': sessionDurationInHours,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SubscriptionPlanUpdateManyWithWhereWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanUpdateManyWithWhereWithoutConsultantProfileInput({
    required this.where,
    required this.data,
  });

  final _i2.SubscriptionPlanScalarWhereInput where;

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanUpdateManyMutationInput,
    _i2.SubscriptionPlanUncheckedUpdateManyWithoutSubscriptionPlansInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class SubscriptionPlanUncheckedUpdateManyWithoutConsultantProfileNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanUncheckedUpdateManyWithoutConsultantProfileNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanCreateWithoutConsultantProfileInput,
    _i1.PrismaUnion<
      Iterable<_i2.SubscriptionPlanCreateWithoutConsultantProfileInput>,
      _i1.PrismaUnion<
        _i2.SubscriptionPlanUncheckedCreateWithoutConsultantProfileInput,
        Iterable<
          _i2.SubscriptionPlanUncheckedCreateWithoutConsultantProfileInput
        >
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanCreateOrConnectWithoutConsultantProfileInput,
    Iterable<_i2.SubscriptionPlanCreateOrConnectWithoutConsultantProfileInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanUpsertWithWhereUniqueWithoutConsultantProfileInput,
    Iterable<
      _i2.SubscriptionPlanUpsertWithWhereUniqueWithoutConsultantProfileInput
    >
  >?
  upsert;

  final _i2.SubscriptionPlanCreateManyConsultantProfileInputEnvelope?
  createMany;

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanWhereUniqueInput,
    Iterable<_i2.SubscriptionPlanWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanWhereUniqueInput,
    Iterable<_i2.SubscriptionPlanWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanWhereUniqueInput,
    Iterable<_i2.SubscriptionPlanWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanWhereUniqueInput,
    Iterable<_i2.SubscriptionPlanWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanUpdateWithWhereUniqueWithoutConsultantProfileInput,
    Iterable<
      _i2.SubscriptionPlanUpdateWithWhereUniqueWithoutConsultantProfileInput
    >
  >?
  update;

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanUpdateManyWithWhereWithoutConsultantProfileInput,
    Iterable<
      _i2.SubscriptionPlanUpdateManyWithWhereWithoutConsultantProfileInput
    >
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanScalarWhereInput,
    Iterable<_i2.SubscriptionPlanScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class ClassContentUncheckedUpdateManyWithoutClassPlanNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassContentUncheckedUpdateManyWithoutClassPlanNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.ClassContentCreateWithoutClassPlanInput,
    _i1.PrismaUnion<
      Iterable<_i2.ClassContentCreateWithoutClassPlanInput>,
      _i1.PrismaUnion<
        _i2.ClassContentUncheckedCreateWithoutClassPlanInput,
        Iterable<_i2.ClassContentUncheckedCreateWithoutClassPlanInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.ClassContentCreateOrConnectWithoutClassPlanInput,
    Iterable<_i2.ClassContentCreateOrConnectWithoutClassPlanInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.ClassContentUpsertWithWhereUniqueWithoutClassPlanInput,
    Iterable<_i2.ClassContentUpsertWithWhereUniqueWithoutClassPlanInput>
  >?
  upsert;

  final _i2.ClassContentCreateManyClassPlanInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.ClassContentWhereUniqueInput,
    Iterable<_i2.ClassContentWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.ClassContentWhereUniqueInput,
    Iterable<_i2.ClassContentWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.ClassContentWhereUniqueInput,
    Iterable<_i2.ClassContentWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.ClassContentWhereUniqueInput,
    Iterable<_i2.ClassContentWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.ClassContentUpdateWithWhereUniqueWithoutClassPlanInput,
    Iterable<_i2.ClassContentUpdateWithWhereUniqueWithoutClassPlanInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.ClassContentUpdateManyWithWhereWithoutClassPlanInput,
    Iterable<_i2.ClassContentUpdateManyWithWhereWithoutClassPlanInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.ClassContentScalarWhereInput,
    Iterable<_i2.ClassContentScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class AppointmentUpdateWithoutClassInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentUpdateWithoutClassInput({
    this.id,
    this.appointmentType,
    this.createdAt,
    this.updatedAt,
    this.slotsOfAppointment,
    this.consultation,
    this.subscription,
    this.webinar,
    this.payment,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    _i3.AppointmentsType,
    _i2.EnumAppointmentsTypeFieldUpdateOperationsInput
  >?
  appointmentType;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.SlotOfAppointmentUpdateManyWithoutAppointmentNestedInput?
  slotsOfAppointment;

  final _i2.ConsultationUpdateOneWithoutAppointmentNestedInput? consultation;

  final _i2.SubscriptionUpdateOneWithoutAppointmentsNestedInput? subscription;

  final _i2.WebinarUpdateOneWithoutAppointmentNestedInput? webinar;

  final _i2.PaymentUpdateManyWithoutAppointmentNestedInput? payment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'appointmentType': appointmentType,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'slotsOfAppointment': slotsOfAppointment,
    'consultation': consultation,
    'subscription': subscription,
    'webinar': webinar,
    'payment': payment,
  };
}

class AppointmentUncheckedUpdateWithoutClassInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentUncheckedUpdateWithoutClassInput({
    this.id,
    this.appointmentType,
    this.consultationId,
    this.subscriptionId,
    this.webinarId,
    this.createdAt,
    this.updatedAt,
    this.slotsOfAppointment,
    this.payment,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    _i3.AppointmentsType,
    _i2.EnumAppointmentsTypeFieldUpdateOperationsInput
  >?
  appointmentType;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consultationId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  subscriptionId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  webinarId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.SlotOfAppointmentUncheckedUpdateManyWithoutAppointmentNestedInput?
  slotsOfAppointment;

  final _i2.PaymentUncheckedUpdateManyWithoutAppointmentNestedInput? payment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'appointmentType': appointmentType,
    'consultationId': consultationId,
    'subscriptionId': subscriptionId,
    'webinarId': webinarId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'slotsOfAppointment': slotsOfAppointment,
    'payment': payment,
  };
}

class AppointmentUpsertWithWhereUniqueWithoutClassInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentUpsertWithWhereUniqueWithoutClassInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.AppointmentWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.AppointmentUpdateWithoutClassInput,
    _i2.AppointmentUncheckedUpdateWithoutClassInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.AppointmentCreateWithoutClassInput,
    _i2.AppointmentUncheckedCreateWithoutClassInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'update': update,
    'create': create,
  };
}

class AppointmentUpdateWithWhereUniqueWithoutClassInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentUpdateWithWhereUniqueWithoutClassInput({
    required this.where,
    required this.data,
  });

  final _i2.AppointmentWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.AppointmentUpdateWithoutClassInput,
    _i2.AppointmentUncheckedUpdateWithoutClassInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class AppointmentUpdateManyWithWhereWithoutClassInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentUpdateManyWithWhereWithoutClassInput({
    required this.where,
    required this.data,
  });

  final _i2.AppointmentScalarWhereInput where;

  final _i1.PrismaUnion<
    _i2.AppointmentUpdateManyMutationInput,
    _i2.AppointmentUncheckedUpdateManyWithoutAppointmentsInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class AppointmentUpdateManyWithoutClassNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentUpdateManyWithoutClassNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.AppointmentCreateWithoutClassInput,
    _i1.PrismaUnion<
      Iterable<_i2.AppointmentCreateWithoutClassInput>,
      _i1.PrismaUnion<
        _i2.AppointmentUncheckedCreateWithoutClassInput,
        Iterable<_i2.AppointmentUncheckedCreateWithoutClassInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.AppointmentCreateOrConnectWithoutClassInput,
    Iterable<_i2.AppointmentCreateOrConnectWithoutClassInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.AppointmentUpsertWithWhereUniqueWithoutClassInput,
    Iterable<_i2.AppointmentUpsertWithWhereUniqueWithoutClassInput>
  >?
  upsert;

  final _i2.AppointmentCreateManyClassInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.AppointmentWhereUniqueInput,
    Iterable<_i2.AppointmentWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.AppointmentWhereUniqueInput,
    Iterable<_i2.AppointmentWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.AppointmentWhereUniqueInput,
    Iterable<_i2.AppointmentWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.AppointmentWhereUniqueInput,
    Iterable<_i2.AppointmentWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.AppointmentUpdateWithWhereUniqueWithoutClassInput,
    Iterable<_i2.AppointmentUpdateWithWhereUniqueWithoutClassInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.AppointmentUpdateManyWithWhereWithoutClassInput,
    Iterable<_i2.AppointmentUpdateManyWithWhereWithoutClassInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.AppointmentScalarWhereInput,
    Iterable<_i2.AppointmentScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class ClassUpdateWithoutClassPlanInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassUpdateWithoutClassPlanInput({
    this.id,
    this.startDate,
    this.endDate,
    this.status,
    this.recordingUrls,
    this.feedbackSummary,
    this.createdAt,
    this.updatedAt,
    this.waitlist,
    this.appointments,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  startDate;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  endDate;

  final _i1.PrismaUnion<
    _i3.ClassStatus,
    _i2.EnumClassStatusFieldUpdateOperationsInput
  >?
  status;

  final _i1.PrismaUnion<_i2.ClassUpdaterecordingUrlsInput, Iterable<String>>?
  recordingUrls;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackSummary;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.WaitlistUpdateManyWithoutClassNestedInput? waitlist;

  final _i2.AppointmentUpdateManyWithoutClassNestedInput? appointments;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'status': status,
    'recordingUrls': recordingUrls,
    'feedbackSummary': feedbackSummary,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'waitlist': waitlist,
    'appointments': appointments,
  };
}

class WaitlistUncheckedUpdateWithoutClassInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistUncheckedUpdateWithoutClassInput({
    this.id,
    this.joinedAt,
    this.userId,
    this.webinarId,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  joinedAt;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  webinarId;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'joinedAt': joinedAt,
    'userId': userId,
    'webinarId': webinarId,
  };
}

class WaitlistUpdateWithWhereUniqueWithoutClassInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistUpdateWithWhereUniqueWithoutClassInput({
    required this.where,
    required this.data,
  });

  final _i2.WaitlistWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.WaitlistUpdateWithoutClassInput,
    _i2.WaitlistUncheckedUpdateWithoutClassInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class WaitlistUpdateManyWithWhereWithoutClassInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistUpdateManyWithWhereWithoutClassInput({
    required this.where,
    required this.data,
  });

  final _i2.WaitlistScalarWhereInput where;

  final _i1.PrismaUnion<
    _i2.WaitlistUpdateManyMutationInput,
    _i2.WaitlistUncheckedUpdateManyWithoutWaitlistInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class WaitlistUncheckedUpdateManyWithoutClassNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistUncheckedUpdateManyWithoutClassNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.WaitlistCreateWithoutClassInput,
    _i1.PrismaUnion<
      Iterable<_i2.WaitlistCreateWithoutClassInput>,
      _i1.PrismaUnion<
        _i2.WaitlistUncheckedCreateWithoutClassInput,
        Iterable<_i2.WaitlistUncheckedCreateWithoutClassInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.WaitlistCreateOrConnectWithoutClassInput,
    Iterable<_i2.WaitlistCreateOrConnectWithoutClassInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.WaitlistUpsertWithWhereUniqueWithoutClassInput,
    Iterable<_i2.WaitlistUpsertWithWhereUniqueWithoutClassInput>
  >?
  upsert;

  final _i2.WaitlistCreateManyClassInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.WaitlistWhereUniqueInput,
    Iterable<_i2.WaitlistWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.WaitlistWhereUniqueInput,
    Iterable<_i2.WaitlistWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.WaitlistWhereUniqueInput,
    Iterable<_i2.WaitlistWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.WaitlistWhereUniqueInput,
    Iterable<_i2.WaitlistWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.WaitlistUpdateWithWhereUniqueWithoutClassInput,
    Iterable<_i2.WaitlistUpdateWithWhereUniqueWithoutClassInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.WaitlistUpdateManyWithWhereWithoutClassInput,
    Iterable<_i2.WaitlistUpdateManyWithWhereWithoutClassInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.WaitlistScalarWhereInput,
    Iterable<_i2.WaitlistScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class AppointmentUncheckedUpdateManyWithoutClassNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentUncheckedUpdateManyWithoutClassNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.AppointmentCreateWithoutClassInput,
    _i1.PrismaUnion<
      Iterable<_i2.AppointmentCreateWithoutClassInput>,
      _i1.PrismaUnion<
        _i2.AppointmentUncheckedCreateWithoutClassInput,
        Iterable<_i2.AppointmentUncheckedCreateWithoutClassInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.AppointmentCreateOrConnectWithoutClassInput,
    Iterable<_i2.AppointmentCreateOrConnectWithoutClassInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.AppointmentUpsertWithWhereUniqueWithoutClassInput,
    Iterable<_i2.AppointmentUpsertWithWhereUniqueWithoutClassInput>
  >?
  upsert;

  final _i2.AppointmentCreateManyClassInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.AppointmentWhereUniqueInput,
    Iterable<_i2.AppointmentWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.AppointmentWhereUniqueInput,
    Iterable<_i2.AppointmentWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.AppointmentWhereUniqueInput,
    Iterable<_i2.AppointmentWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.AppointmentWhereUniqueInput,
    Iterable<_i2.AppointmentWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.AppointmentUpdateWithWhereUniqueWithoutClassInput,
    Iterable<_i2.AppointmentUpdateWithWhereUniqueWithoutClassInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.AppointmentUpdateManyWithWhereWithoutClassInput,
    Iterable<_i2.AppointmentUpdateManyWithWhereWithoutClassInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.AppointmentScalarWhereInput,
    Iterable<_i2.AppointmentScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class ClassUncheckedUpdateWithoutClassPlanInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassUncheckedUpdateWithoutClassPlanInput({
    this.id,
    this.startDate,
    this.endDate,
    this.status,
    this.recordingUrls,
    this.feedbackSummary,
    this.createdAt,
    this.updatedAt,
    this.waitlist,
    this.appointments,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  startDate;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  endDate;

  final _i1.PrismaUnion<
    _i3.ClassStatus,
    _i2.EnumClassStatusFieldUpdateOperationsInput
  >?
  status;

  final _i1.PrismaUnion<_i2.ClassUpdaterecordingUrlsInput, Iterable<String>>?
  recordingUrls;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackSummary;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.WaitlistUncheckedUpdateManyWithoutClassNestedInput? waitlist;

  final _i2.AppointmentUncheckedUpdateManyWithoutClassNestedInput? appointments;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'status': status,
    'recordingUrls': recordingUrls,
    'feedbackSummary': feedbackSummary,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'waitlist': waitlist,
    'appointments': appointments,
  };
}

class ClassUpsertWithWhereUniqueWithoutClassPlanInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassUpsertWithWhereUniqueWithoutClassPlanInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.ClassWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.ClassUpdateWithoutClassPlanInput,
    _i2.ClassUncheckedUpdateWithoutClassPlanInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.ClassCreateWithoutClassPlanInput,
    _i2.ClassUncheckedCreateWithoutClassPlanInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'update': update,
    'create': create,
  };
}

class ClassUpdateWithWhereUniqueWithoutClassPlanInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassUpdateWithWhereUniqueWithoutClassPlanInput({
    required this.where,
    required this.data,
  });

  final _i2.ClassWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.ClassUpdateWithoutClassPlanInput,
    _i2.ClassUncheckedUpdateWithoutClassPlanInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class ClassScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.startDate,
    this.endDate,
    this.status,
    this.recordingUrls,
    this.feedbackSummary,
    this.classPlanId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
    _i2.ClassScalarWhereInput,
    Iterable<_i2.ClassScalarWhereInput>
  >?
  AND;

  final Iterable<_i2.ClassScalarWhereInput>? OR;

  final _i1.PrismaUnion<
    _i2.ClassScalarWhereInput,
    Iterable<_i2.ClassScalarWhereInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<
    _i2.DateTimeNullableFilter,
    _i1.PrismaUnion<DateTime, _i1.PrismaNull>
  >?
  startDate;

  final _i1.PrismaUnion<
    _i2.DateTimeNullableFilter,
    _i1.PrismaUnion<DateTime, _i1.PrismaNull>
  >?
  endDate;

  final _i1.PrismaUnion<_i2.EnumClassStatusFilter, _i3.ClassStatus>? status;

  final _i2.StringNullableListFilter? recordingUrls;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  feedbackSummary;

  final _i1.PrismaUnion<_i2.StringFilter, String>? classPlanId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'status': status,
    'recordingUrls': recordingUrls,
    'feedbackSummary': feedbackSummary,
    'classPlanId': classPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ClassUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassUpdateManyMutationInput({
    this.id,
    this.startDate,
    this.endDate,
    this.status,
    this.recordingUrls,
    this.feedbackSummary,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  startDate;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  endDate;

  final _i1.PrismaUnion<
    _i3.ClassStatus,
    _i2.EnumClassStatusFieldUpdateOperationsInput
  >?
  status;

  final _i1.PrismaUnion<_i2.ClassUpdaterecordingUrlsInput, Iterable<String>>?
  recordingUrls;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackSummary;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'status': status,
    'recordingUrls': recordingUrls,
    'feedbackSummary': feedbackSummary,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ClassUncheckedUpdateManyWithoutClassesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassUncheckedUpdateManyWithoutClassesInput({
    this.id,
    this.startDate,
    this.endDate,
    this.status,
    this.recordingUrls,
    this.feedbackSummary,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  startDate;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  endDate;

  final _i1.PrismaUnion<
    _i3.ClassStatus,
    _i2.EnumClassStatusFieldUpdateOperationsInput
  >?
  status;

  final _i1.PrismaUnion<_i2.ClassUpdaterecordingUrlsInput, Iterable<String>>?
  recordingUrls;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackSummary;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'status': status,
    'recordingUrls': recordingUrls,
    'feedbackSummary': feedbackSummary,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ClassUpdateManyWithWhereWithoutClassPlanInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassUpdateManyWithWhereWithoutClassPlanInput({
    required this.where,
    required this.data,
  });

  final _i2.ClassScalarWhereInput where;

  final _i1.PrismaUnion<
    _i2.ClassUpdateManyMutationInput,
    _i2.ClassUncheckedUpdateManyWithoutClassesInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class ClassUncheckedUpdateManyWithoutClassPlanNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassUncheckedUpdateManyWithoutClassPlanNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.ClassCreateWithoutClassPlanInput,
    _i1.PrismaUnion<
      Iterable<_i2.ClassCreateWithoutClassPlanInput>,
      _i1.PrismaUnion<
        _i2.ClassUncheckedCreateWithoutClassPlanInput,
        Iterable<_i2.ClassUncheckedCreateWithoutClassPlanInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.ClassCreateOrConnectWithoutClassPlanInput,
    Iterable<_i2.ClassCreateOrConnectWithoutClassPlanInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.ClassUpsertWithWhereUniqueWithoutClassPlanInput,
    Iterable<_i2.ClassUpsertWithWhereUniqueWithoutClassPlanInput>
  >?
  upsert;

  final _i2.ClassCreateManyClassPlanInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.ClassWhereUniqueInput,
    Iterable<_i2.ClassWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.ClassWhereUniqueInput,
    Iterable<_i2.ClassWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.ClassWhereUniqueInput,
    Iterable<_i2.ClassWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.ClassWhereUniqueInput,
    Iterable<_i2.ClassWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.ClassUpdateWithWhereUniqueWithoutClassPlanInput,
    Iterable<_i2.ClassUpdateWithWhereUniqueWithoutClassPlanInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.ClassUpdateManyWithWhereWithoutClassPlanInput,
    Iterable<_i2.ClassUpdateManyWithWhereWithoutClassPlanInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.ClassScalarWhereInput,
    Iterable<_i2.ClassScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class ClassPlanUncheckedUpdateWithoutTopicsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanUncheckedUpdateWithoutTopicsInput({
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInMonths,
    this.callsPerWeek,
    this.videoMeetings,
    this.emailSupport,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.classContents,
    this.classes,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  description;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? price;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  priceCurrency;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
  certificateProvided;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
  durationInMonths;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? callsPerWeek;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? videoMeetings;

  final _i1.PrismaUnion<
    _i3.PlanEmailSupport,
    _i2.EnumPlanEmailSupportFieldUpdateOperationsInput
  >?
  emailSupport;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
  maxParticipants;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  language;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  level;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  prerequisites;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  materialProvided;

  final _i1.PrismaUnion<
    _i2.ClassPlanUpdatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consultantProfileId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.ClassContentUncheckedUpdateManyWithoutClassPlanNestedInput?
  classContents;

  final _i2.ClassUncheckedUpdateManyWithoutClassPlanNestedInput? classes;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInMonths': durationInMonths,
    'callsPerWeek': callsPerWeek,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'classContents': classContents,
    'classes': classes,
  };
}

class ClassPlanUpdateWithWhereUniqueWithoutTopicsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanUpdateWithWhereUniqueWithoutTopicsInput({
    required this.where,
    required this.data,
  });

  final _i2.ClassPlanWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.ClassPlanUpdateWithoutTopicsInput,
    _i2.ClassPlanUncheckedUpdateWithoutTopicsInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class ClassPlanScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInMonths,
    this.callsPerWeek,
    this.videoMeetings,
    this.emailSupport,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
    _i2.ClassPlanScalarWhereInput,
    Iterable<_i2.ClassPlanScalarWhereInput>
  >?
  AND;

  final Iterable<_i2.ClassPlanScalarWhereInput>? OR;

  final _i1.PrismaUnion<
    _i2.ClassPlanScalarWhereInput,
    Iterable<_i2.ClassPlanScalarWhereInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? title;

  final _i1.PrismaUnion<_i2.StringFilter, String>? description;

  final _i1.PrismaUnion<_i2.IntFilter, int>? price;

  final _i1.PrismaUnion<_i2.StringFilter, String>? priceCurrency;

  final _i1.PrismaUnion<_i2.BoolFilter, bool>? certificateProvided;

  final _i1.PrismaUnion<_i2.IntFilter, int>? durationInMonths;

  final _i1.PrismaUnion<_i2.IntFilter, int>? callsPerWeek;

  final _i1.PrismaUnion<_i2.IntFilter, int>? videoMeetings;

  final _i1.PrismaUnion<_i2.EnumPlanEmailSupportFilter, _i3.PlanEmailSupport>?
  emailSupport;

  final _i1.PrismaUnion<_i2.IntFilter, int>? maxParticipants;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  language;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  level;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  prerequisites;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  materialProvided;

  final _i2.StringNullableListFilter? learningOutcomes;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  consultantProfileId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInMonths': durationInMonths,
    'callsPerWeek': callsPerWeek,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ClassPlanUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanUpdateManyMutationInput({
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInMonths,
    this.callsPerWeek,
    this.videoMeetings,
    this.emailSupport,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  description;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? price;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  priceCurrency;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
  certificateProvided;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
  durationInMonths;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? callsPerWeek;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? videoMeetings;

  final _i1.PrismaUnion<
    _i3.PlanEmailSupport,
    _i2.EnumPlanEmailSupportFieldUpdateOperationsInput
  >?
  emailSupport;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
  maxParticipants;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  language;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  level;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  prerequisites;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  materialProvided;

  final _i1.PrismaUnion<
    _i2.ClassPlanUpdatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInMonths': durationInMonths,
    'callsPerWeek': callsPerWeek,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ClassPlanUncheckedUpdateManyWithoutClassPlansInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanUncheckedUpdateManyWithoutClassPlansInput({
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInMonths,
    this.callsPerWeek,
    this.videoMeetings,
    this.emailSupport,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  description;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? price;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  priceCurrency;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
  certificateProvided;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
  durationInMonths;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? callsPerWeek;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? videoMeetings;

  final _i1.PrismaUnion<
    _i3.PlanEmailSupport,
    _i2.EnumPlanEmailSupportFieldUpdateOperationsInput
  >?
  emailSupport;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
  maxParticipants;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  language;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  level;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  prerequisites;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  materialProvided;

  final _i1.PrismaUnion<
    _i2.ClassPlanUpdatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInMonths': durationInMonths,
    'callsPerWeek': callsPerWeek,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ClassPlanUpdateManyWithWhereWithoutTopicsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanUpdateManyWithWhereWithoutTopicsInput({
    required this.where,
    required this.data,
  });

  final _i2.ClassPlanScalarWhereInput where;

  final _i1.PrismaUnion<
    _i2.ClassPlanUpdateManyMutationInput,
    _i2.ClassPlanUncheckedUpdateManyWithoutClassPlansInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class ClassPlanUncheckedUpdateManyWithoutTopicsNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanUncheckedUpdateManyWithoutTopicsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.ClassPlanCreateWithoutTopicsInput,
    _i1.PrismaUnion<
      Iterable<_i2.ClassPlanCreateWithoutTopicsInput>,
      _i1.PrismaUnion<
        _i2.ClassPlanUncheckedCreateWithoutTopicsInput,
        Iterable<_i2.ClassPlanUncheckedCreateWithoutTopicsInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.ClassPlanCreateOrConnectWithoutTopicsInput,
    Iterable<_i2.ClassPlanCreateOrConnectWithoutTopicsInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.ClassPlanUpsertWithWhereUniqueWithoutTopicsInput,
    Iterable<_i2.ClassPlanUpsertWithWhereUniqueWithoutTopicsInput>
  >?
  upsert;

  final _i1.PrismaUnion<
    _i2.ClassPlanWhereUniqueInput,
    Iterable<_i2.ClassPlanWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.ClassPlanWhereUniqueInput,
    Iterable<_i2.ClassPlanWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.ClassPlanWhereUniqueInput,
    Iterable<_i2.ClassPlanWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.ClassPlanWhereUniqueInput,
    Iterable<_i2.ClassPlanWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.ClassPlanUpdateWithWhereUniqueWithoutTopicsInput,
    Iterable<_i2.ClassPlanUpdateWithWhereUniqueWithoutTopicsInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.ClassPlanUpdateManyWithWhereWithoutTopicsInput,
    Iterable<_i2.ClassPlanUpdateManyWithWhereWithoutTopicsInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.ClassPlanScalarWhereInput,
    Iterable<_i2.ClassPlanScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class TopicUncheckedUpdateWithoutWebinarPlansInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TopicUncheckedUpdateWithoutWebinarPlansInput({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
    this.classPlans,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.ClassPlanUncheckedUpdateManyWithoutTopicsNestedInput? classPlans;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'classPlans': classPlans,
  };
}

class TopicUpdateWithWhereUniqueWithoutWebinarPlansInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TopicUpdateWithWhereUniqueWithoutWebinarPlansInput({
    required this.where,
    required this.data,
  });

  final _i2.TopicWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.TopicUpdateWithoutWebinarPlansInput,
    _i2.TopicUncheckedUpdateWithoutWebinarPlansInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class TopicScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TopicScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
    _i2.TopicScalarWhereInput,
    Iterable<_i2.TopicScalarWhereInput>
  >?
  AND;

  final Iterable<_i2.TopicScalarWhereInput>? OR;

  final _i1.PrismaUnion<
    _i2.TopicScalarWhereInput,
    Iterable<_i2.TopicScalarWhereInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? name;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class TopicUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TopicUpdateManyMutationInput({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class TopicUncheckedUpdateManyWithoutTopicsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TopicUncheckedUpdateManyWithoutTopicsInput({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class TopicUpdateManyWithWhereWithoutWebinarPlansInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TopicUpdateManyWithWhereWithoutWebinarPlansInput({
    required this.where,
    required this.data,
  });

  final _i2.TopicScalarWhereInput where;

  final _i1.PrismaUnion<
    _i2.TopicUpdateManyMutationInput,
    _i2.TopicUncheckedUpdateManyWithoutTopicsInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class TopicUncheckedUpdateManyWithoutWebinarPlansNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TopicUncheckedUpdateManyWithoutWebinarPlansNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.TopicCreateWithoutWebinarPlansInput,
    _i1.PrismaUnion<
      Iterable<_i2.TopicCreateWithoutWebinarPlansInput>,
      _i1.PrismaUnion<
        _i2.TopicUncheckedCreateWithoutWebinarPlansInput,
        Iterable<_i2.TopicUncheckedCreateWithoutWebinarPlansInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.TopicCreateOrConnectWithoutWebinarPlansInput,
    Iterable<_i2.TopicCreateOrConnectWithoutWebinarPlansInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.TopicUpsertWithWhereUniqueWithoutWebinarPlansInput,
    Iterable<_i2.TopicUpsertWithWhereUniqueWithoutWebinarPlansInput>
  >?
  upsert;

  final _i1.PrismaUnion<
    _i2.TopicWhereUniqueInput,
    Iterable<_i2.TopicWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.TopicWhereUniqueInput,
    Iterable<_i2.TopicWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.TopicWhereUniqueInput,
    Iterable<_i2.TopicWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.TopicWhereUniqueInput,
    Iterable<_i2.TopicWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.TopicUpdateWithWhereUniqueWithoutWebinarPlansInput,
    Iterable<_i2.TopicUpdateWithWhereUniqueWithoutWebinarPlansInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.TopicUpdateManyWithWhereWithoutWebinarPlansInput,
    Iterable<_i2.TopicUpdateManyWithWhereWithoutWebinarPlansInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.TopicScalarWhereInput,
    Iterable<_i2.TopicScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class WebinarPlanUncheckedUpdateWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanUncheckedUpdateWithoutConsultantProfileInput({
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInHours,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.createdAt,
    this.updatedAt,
    this.topics,
    this.webinars,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? price;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  priceCurrency;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
  certificateProvided;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
  durationInHours;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
  maxParticipants;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  language;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  level;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  prerequisites;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  materialProvided;

  final _i1.PrismaUnion<
    _i2.WebinarPlanUpdatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.TopicUncheckedUpdateManyWithoutWebinarPlansNestedInput? topics;

  final _i2.WebinarUncheckedUpdateManyWithoutWebinarPlanNestedInput? webinars;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInHours': durationInHours,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'topics': topics,
    'webinars': webinars,
  };
}

class WebinarPlanUpdateWithWhereUniqueWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanUpdateWithWhereUniqueWithoutConsultantProfileInput({
    required this.where,
    required this.data,
  });

  final _i2.WebinarPlanWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.WebinarPlanUpdateWithoutConsultantProfileInput,
    _i2.WebinarPlanUncheckedUpdateWithoutConsultantProfileInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class WebinarPlanScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInHours,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
    _i2.WebinarPlanScalarWhereInput,
    Iterable<_i2.WebinarPlanScalarWhereInput>
  >?
  AND;

  final Iterable<_i2.WebinarPlanScalarWhereInput>? OR;

  final _i1.PrismaUnion<
    _i2.WebinarPlanScalarWhereInput,
    Iterable<_i2.WebinarPlanScalarWhereInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? title;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  description;

  final _i1.PrismaUnion<_i2.IntFilter, int>? price;

  final _i1.PrismaUnion<_i2.StringFilter, String>? priceCurrency;

  final _i1.PrismaUnion<_i2.BoolFilter, bool>? certificateProvided;

  final _i1.PrismaUnion<_i2.FloatFilter, double>? durationInHours;

  final _i1.PrismaUnion<_i2.IntFilter, int>? maxParticipants;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  language;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  level;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  prerequisites;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  materialProvided;

  final _i2.StringNullableListFilter? learningOutcomes;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  consultantProfileId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInHours': durationInHours,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class WebinarPlanUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanUpdateManyMutationInput({
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInHours,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? price;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  priceCurrency;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
  certificateProvided;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
  durationInHours;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
  maxParticipants;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  language;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  level;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  prerequisites;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  materialProvided;

  final _i1.PrismaUnion<
    _i2.WebinarPlanUpdatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInHours': durationInHours,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class WebinarPlanUncheckedUpdateManyWithoutWebinarPlansInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanUncheckedUpdateManyWithoutWebinarPlansInput({
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInHours,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? price;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  priceCurrency;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
  certificateProvided;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
  durationInHours;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
  maxParticipants;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  language;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  level;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  prerequisites;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  materialProvided;

  final _i1.PrismaUnion<
    _i2.WebinarPlanUpdatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInHours': durationInHours,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class WebinarPlanUpdateManyWithWhereWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanUpdateManyWithWhereWithoutConsultantProfileInput({
    required this.where,
    required this.data,
  });

  final _i2.WebinarPlanScalarWhereInput where;

  final _i1.PrismaUnion<
    _i2.WebinarPlanUpdateManyMutationInput,
    _i2.WebinarPlanUncheckedUpdateManyWithoutWebinarPlansInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class WebinarPlanUncheckedUpdateManyWithoutConsultantProfileNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanUncheckedUpdateManyWithoutConsultantProfileNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.WebinarPlanCreateWithoutConsultantProfileInput,
    _i1.PrismaUnion<
      Iterable<_i2.WebinarPlanCreateWithoutConsultantProfileInput>,
      _i1.PrismaUnion<
        _i2.WebinarPlanUncheckedCreateWithoutConsultantProfileInput,
        Iterable<_i2.WebinarPlanUncheckedCreateWithoutConsultantProfileInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.WebinarPlanCreateOrConnectWithoutConsultantProfileInput,
    Iterable<_i2.WebinarPlanCreateOrConnectWithoutConsultantProfileInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.WebinarPlanUpsertWithWhereUniqueWithoutConsultantProfileInput,
    Iterable<_i2.WebinarPlanUpsertWithWhereUniqueWithoutConsultantProfileInput>
  >?
  upsert;

  final _i2.WebinarPlanCreateManyConsultantProfileInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.WebinarPlanWhereUniqueInput,
    Iterable<_i2.WebinarPlanWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.WebinarPlanWhereUniqueInput,
    Iterable<_i2.WebinarPlanWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.WebinarPlanWhereUniqueInput,
    Iterable<_i2.WebinarPlanWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.WebinarPlanWhereUniqueInput,
    Iterable<_i2.WebinarPlanWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.WebinarPlanUpdateWithWhereUniqueWithoutConsultantProfileInput,
    Iterable<_i2.WebinarPlanUpdateWithWhereUniqueWithoutConsultantProfileInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.WebinarPlanUpdateManyWithWhereWithoutConsultantProfileInput,
    Iterable<_i2.WebinarPlanUpdateManyWithWhereWithoutConsultantProfileInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.WebinarPlanScalarWhereInput,
    Iterable<_i2.WebinarPlanScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class ClassPlanUncheckedUpdateWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanUncheckedUpdateWithoutConsultantProfileInput({
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInMonths,
    this.callsPerWeek,
    this.videoMeetings,
    this.emailSupport,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.createdAt,
    this.updatedAt,
    this.topics,
    this.classContents,
    this.classes,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  description;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? price;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  priceCurrency;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
  certificateProvided;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
  durationInMonths;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? callsPerWeek;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? videoMeetings;

  final _i1.PrismaUnion<
    _i3.PlanEmailSupport,
    _i2.EnumPlanEmailSupportFieldUpdateOperationsInput
  >?
  emailSupport;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
  maxParticipants;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  language;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  level;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  prerequisites;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  materialProvided;

  final _i1.PrismaUnion<
    _i2.ClassPlanUpdatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.TopicUncheckedUpdateManyWithoutClassPlansNestedInput? topics;

  final _i2.ClassContentUncheckedUpdateManyWithoutClassPlanNestedInput?
  classContents;

  final _i2.ClassUncheckedUpdateManyWithoutClassPlanNestedInput? classes;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInMonths': durationInMonths,
    'callsPerWeek': callsPerWeek,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'topics': topics,
    'classContents': classContents,
    'classes': classes,
  };
}

class ClassPlanUpdateWithWhereUniqueWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanUpdateWithWhereUniqueWithoutConsultantProfileInput({
    required this.where,
    required this.data,
  });

  final _i2.ClassPlanWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.ClassPlanUpdateWithoutConsultantProfileInput,
    _i2.ClassPlanUncheckedUpdateWithoutConsultantProfileInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class ClassPlanUpdateManyWithWhereWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanUpdateManyWithWhereWithoutConsultantProfileInput({
    required this.where,
    required this.data,
  });

  final _i2.ClassPlanScalarWhereInput where;

  final _i1.PrismaUnion<
    _i2.ClassPlanUpdateManyMutationInput,
    _i2.ClassPlanUncheckedUpdateManyWithoutClassPlansInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class ClassPlanUncheckedUpdateManyWithoutConsultantProfileNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanUncheckedUpdateManyWithoutConsultantProfileNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.ClassPlanCreateWithoutConsultantProfileInput,
    _i1.PrismaUnion<
      Iterable<_i2.ClassPlanCreateWithoutConsultantProfileInput>,
      _i1.PrismaUnion<
        _i2.ClassPlanUncheckedCreateWithoutConsultantProfileInput,
        Iterable<_i2.ClassPlanUncheckedCreateWithoutConsultantProfileInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.ClassPlanCreateOrConnectWithoutConsultantProfileInput,
    Iterable<_i2.ClassPlanCreateOrConnectWithoutConsultantProfileInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.ClassPlanUpsertWithWhereUniqueWithoutConsultantProfileInput,
    Iterable<_i2.ClassPlanUpsertWithWhereUniqueWithoutConsultantProfileInput>
  >?
  upsert;

  final _i2.ClassPlanCreateManyConsultantProfileInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.ClassPlanWhereUniqueInput,
    Iterable<_i2.ClassPlanWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.ClassPlanWhereUniqueInput,
    Iterable<_i2.ClassPlanWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.ClassPlanWhereUniqueInput,
    Iterable<_i2.ClassPlanWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.ClassPlanWhereUniqueInput,
    Iterable<_i2.ClassPlanWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.ClassPlanUpdateWithWhereUniqueWithoutConsultantProfileInput,
    Iterable<_i2.ClassPlanUpdateWithWhereUniqueWithoutConsultantProfileInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.ClassPlanUpdateManyWithWhereWithoutConsultantProfileInput,
    Iterable<_i2.ClassPlanUpdateManyWithWhereWithoutConsultantProfileInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.ClassPlanScalarWhereInput,
    Iterable<_i2.ClassPlanScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class ConsultantProfileUncheckedUpdateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUncheckedUpdateWithoutUserInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    this.domainId,
    this.scheduleType,
    this.createdAt,
    this.updatedAt,
    this.subDomains,
    this.tags,
    this.reviews,
    this.slotsOfAvailabilityWeekly,
    this.slotsOfAvailabilityCustom,
    this.consultationPlans,
    this.subscriptionPlans,
    this.webinarPlans,
    this.classPlans,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  qualifications;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  specialization;

  final _i1.PrismaUnion<
    double,
    _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  experience;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? rating;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? domainId;

  final _i1.PrismaUnion<
    _i3.ScheduleType,
    _i2.EnumScheduleTypeFieldUpdateOperationsInput
  >?
  scheduleType;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.SubDomainUncheckedUpdateManyWithoutConsultantProfilesNestedInput?
  subDomains;

  final _i2.TagUncheckedUpdateManyWithoutConsultantProfilesNestedInput? tags;

  final _i2.ConsultantReviewUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  reviews;

  final _i2.SlotOfAvailabilityWeeklyUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  slotsOfAvailabilityWeekly;

  final _i2.SlotOfAvailabilityCustomUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  slotsOfAvailabilityCustom;

  final _i2.ConsultationPlanUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  consultationPlans;

  final _i2.SubscriptionPlanUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  subscriptionPlans;

  final _i2.WebinarPlanUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  webinarPlans;

  final _i2.ClassPlanUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  classPlans;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'domainId': domainId,
    'scheduleType': scheduleType,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'subDomains': subDomains,
    'tags': tags,
    'reviews': reviews,
    'slotsOfAvailabilityWeekly': slotsOfAvailabilityWeekly,
    'slotsOfAvailabilityCustom': slotsOfAvailabilityCustom,
    'consultationPlans': consultationPlans,
    'subscriptionPlans': subscriptionPlans,
    'webinarPlans': webinarPlans,
    'classPlans': classPlans,
  };
}

class ConsultantProfileUncheckedUpdateOneWithoutUserNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUncheckedUpdateOneWithoutUserNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateWithoutUserInput,
    _i2.ConsultantProfileUncheckedCreateWithoutUserInput
  >?
  create;

  final _i2.ConsultantProfileCreateOrConnectWithoutUserInput? connectOrCreate;

  final _i2.ConsultantProfileUpsertWithoutUserInput? upsert;

  final bool? disconnect;

  final bool? delete;

  final _i2.ConsultantProfileWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileUpdateWithoutUserInput,
    _i2.ConsultantProfileUncheckedUpdateWithoutUserInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
  };
}

class ConsulteeProfileUncheckedUpdateOneWithoutUserNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileUncheckedUpdateOneWithoutUserNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.ConsulteeProfileCreateWithoutUserInput,
    _i2.ConsulteeProfileUncheckedCreateWithoutUserInput
  >?
  create;

  final _i2.ConsulteeProfileCreateOrConnectWithoutUserInput? connectOrCreate;

  final _i2.ConsulteeProfileUpsertWithoutUserInput? upsert;

  final bool? disconnect;

  final bool? delete;

  final _i2.ConsulteeProfileWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.ConsulteeProfileUpdateWithoutUserInput,
    _i2.ConsulteeProfileUncheckedUpdateWithoutUserInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
  };
}

class StaffProfileUncheckedUpdateOneWithoutUserNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StaffProfileUncheckedUpdateOneWithoutUserNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.StaffProfileCreateWithoutUserInput,
    _i2.StaffProfileUncheckedCreateWithoutUserInput
  >?
  create;

  final _i2.StaffProfileCreateOrConnectWithoutUserInput? connectOrCreate;

  final _i2.StaffProfileUpsertWithoutUserInput? upsert;

  final bool? disconnect;

  final bool? delete;

  final _i2.StaffProfileWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.StaffProfileUpdateWithoutUserInput,
    _i2.StaffProfileUncheckedUpdateWithoutUserInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
  };
}

class WaitlistUncheckedUpdateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistUncheckedUpdateWithoutUserInput({
    this.id,
    this.joinedAt,
    this.webinarId,
    this.classId,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  joinedAt;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  webinarId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  classId;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'joinedAt': joinedAt,
    'webinarId': webinarId,
    'classId': classId,
  };
}

class WaitlistUpdateWithWhereUniqueWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistUpdateWithWhereUniqueWithoutUserInput({
    required this.where,
    required this.data,
  });

  final _i2.WaitlistWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.WaitlistUpdateWithoutUserInput,
    _i2.WaitlistUncheckedUpdateWithoutUserInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class WaitlistUpdateManyWithWhereWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistUpdateManyWithWhereWithoutUserInput({
    required this.where,
    required this.data,
  });

  final _i2.WaitlistScalarWhereInput where;

  final _i1.PrismaUnion<
    _i2.WaitlistUpdateManyMutationInput,
    _i2.WaitlistUncheckedUpdateManyWithoutWaitlistInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class WaitlistUncheckedUpdateManyWithoutUserNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistUncheckedUpdateManyWithoutUserNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.WaitlistCreateWithoutUserInput,
    _i1.PrismaUnion<
      Iterable<_i2.WaitlistCreateWithoutUserInput>,
      _i1.PrismaUnion<
        _i2.WaitlistUncheckedCreateWithoutUserInput,
        Iterable<_i2.WaitlistUncheckedCreateWithoutUserInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.WaitlistCreateOrConnectWithoutUserInput,
    Iterable<_i2.WaitlistCreateOrConnectWithoutUserInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.WaitlistUpsertWithWhereUniqueWithoutUserInput,
    Iterable<_i2.WaitlistUpsertWithWhereUniqueWithoutUserInput>
  >?
  upsert;

  final _i2.WaitlistCreateManyUserInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.WaitlistWhereUniqueInput,
    Iterable<_i2.WaitlistWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.WaitlistWhereUniqueInput,
    Iterable<_i2.WaitlistWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.WaitlistWhereUniqueInput,
    Iterable<_i2.WaitlistWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.WaitlistWhereUniqueInput,
    Iterable<_i2.WaitlistWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.WaitlistUpdateWithWhereUniqueWithoutUserInput,
    Iterable<_i2.WaitlistUpdateWithWhereUniqueWithoutUserInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.WaitlistUpdateManyWithWhereWithoutUserInput,
    Iterable<_i2.WaitlistUpdateManyWithWhereWithoutUserInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.WaitlistScalarWhereInput,
    Iterable<_i2.WaitlistScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class NullableIntFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NullableIntFieldUpdateOperationsInput({
    this.set,
    this.increment,
    this.decrement,
    this.multiply,
    this.divide,
  });

  final _i1.PrismaUnion<int, _i1.PrismaNull>? set;

  final int? increment;

  final int? decrement;

  final int? multiply;

  final int? divide;

  @override
  Map<String, dynamic> toJson() => {
    'set': set,
    'increment': increment,
    'decrement': decrement,
    'multiply': multiply,
    'divide': divide,
  };
}

class EnumFeedbackStatusFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumFeedbackStatusFieldUpdateOperationsInput({this.set});

  final _i3.FeedbackStatus? set;

  @override
  Map<String, dynamic> toJson() => {'set': set};
}

class FeedbackUpdateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FeedbackUpdateWithoutUserInput({
    this.id,
    this.title,
    this.description,
    this.rating,
    this.category,
    this.status,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  description;

  final _i1.PrismaUnion<
    int,
    _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  rating;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  category;

  final _i1.PrismaUnion<
    _i3.FeedbackStatus,
    _i2.EnumFeedbackStatusFieldUpdateOperationsInput
  >?
  status;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'rating': rating,
    'category': category,
    'status': status,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class FeedbackUncheckedUpdateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FeedbackUncheckedUpdateWithoutUserInput({
    this.id,
    this.title,
    this.description,
    this.rating,
    this.category,
    this.status,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  description;

  final _i1.PrismaUnion<
    int,
    _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  rating;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  category;

  final _i1.PrismaUnion<
    _i3.FeedbackStatus,
    _i2.EnumFeedbackStatusFieldUpdateOperationsInput
  >?
  status;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'rating': rating,
    'category': category,
    'status': status,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class FeedbackUpsertWithWhereUniqueWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FeedbackUpsertWithWhereUniqueWithoutUserInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.FeedbackWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.FeedbackUpdateWithoutUserInput,
    _i2.FeedbackUncheckedUpdateWithoutUserInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.FeedbackCreateWithoutUserInput,
    _i2.FeedbackUncheckedCreateWithoutUserInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'update': update,
    'create': create,
  };
}

class FeedbackUpdateWithWhereUniqueWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FeedbackUpdateWithWhereUniqueWithoutUserInput({
    required this.where,
    required this.data,
  });

  final _i2.FeedbackWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.FeedbackUpdateWithoutUserInput,
    _i2.FeedbackUncheckedUpdateWithoutUserInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class FeedbackScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FeedbackScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.title,
    this.description,
    this.rating,
    this.category,
    this.status,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
    _i2.FeedbackScalarWhereInput,
    Iterable<_i2.FeedbackScalarWhereInput>
  >?
  AND;

  final Iterable<_i2.FeedbackScalarWhereInput>? OR;

  final _i1.PrismaUnion<
    _i2.FeedbackScalarWhereInput,
    Iterable<_i2.FeedbackScalarWhereInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? title;

  final _i1.PrismaUnion<_i2.StringFilter, String>? description;

  final _i1.PrismaUnion<
    _i2.IntNullableFilter,
    _i1.PrismaUnion<int, _i1.PrismaNull>
  >?
  rating;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  category;

  final _i1.PrismaUnion<_i2.EnumFeedbackStatusFilter, _i3.FeedbackStatus>?
  status;

  final _i1.PrismaUnion<_i2.StringFilter, String>? userId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'title': title,
    'description': description,
    'rating': rating,
    'category': category,
    'status': status,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class FeedbackUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FeedbackUpdateManyMutationInput({
    this.id,
    this.title,
    this.description,
    this.rating,
    this.category,
    this.status,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  description;

  final _i1.PrismaUnion<
    int,
    _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  rating;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  category;

  final _i1.PrismaUnion<
    _i3.FeedbackStatus,
    _i2.EnumFeedbackStatusFieldUpdateOperationsInput
  >?
  status;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'rating': rating,
    'category': category,
    'status': status,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class FeedbackUncheckedUpdateManyWithoutFeedbacksInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FeedbackUncheckedUpdateManyWithoutFeedbacksInput({
    this.id,
    this.title,
    this.description,
    this.rating,
    this.category,
    this.status,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  description;

  final _i1.PrismaUnion<
    int,
    _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  rating;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  category;

  final _i1.PrismaUnion<
    _i3.FeedbackStatus,
    _i2.EnumFeedbackStatusFieldUpdateOperationsInput
  >?
  status;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'rating': rating,
    'category': category,
    'status': status,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class FeedbackUpdateManyWithWhereWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FeedbackUpdateManyWithWhereWithoutUserInput({
    required this.where,
    required this.data,
  });

  final _i2.FeedbackScalarWhereInput where;

  final _i1.PrismaUnion<
    _i2.FeedbackUpdateManyMutationInput,
    _i2.FeedbackUncheckedUpdateManyWithoutFeedbacksInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class FeedbackUncheckedUpdateManyWithoutUserNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FeedbackUncheckedUpdateManyWithoutUserNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.FeedbackCreateWithoutUserInput,
    _i1.PrismaUnion<
      Iterable<_i2.FeedbackCreateWithoutUserInput>,
      _i1.PrismaUnion<
        _i2.FeedbackUncheckedCreateWithoutUserInput,
        Iterable<_i2.FeedbackUncheckedCreateWithoutUserInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.FeedbackCreateOrConnectWithoutUserInput,
    Iterable<_i2.FeedbackCreateOrConnectWithoutUserInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.FeedbackUpsertWithWhereUniqueWithoutUserInput,
    Iterable<_i2.FeedbackUpsertWithWhereUniqueWithoutUserInput>
  >?
  upsert;

  final _i2.FeedbackCreateManyUserInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.FeedbackWhereUniqueInput,
    Iterable<_i2.FeedbackWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.FeedbackWhereUniqueInput,
    Iterable<_i2.FeedbackWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.FeedbackWhereUniqueInput,
    Iterable<_i2.FeedbackWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.FeedbackWhereUniqueInput,
    Iterable<_i2.FeedbackWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.FeedbackUpdateWithWhereUniqueWithoutUserInput,
    Iterable<_i2.FeedbackUpdateWithWhereUniqueWithoutUserInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.FeedbackUpdateManyWithWhereWithoutUserInput,
    Iterable<_i2.FeedbackUpdateManyWithWhereWithoutUserInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.FeedbackScalarWhereInput,
    Iterable<_i2.FeedbackScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class EnumSupportPriorityFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumSupportPriorityFieldUpdateOperationsInput({this.set});

  final _i3.SupportPriority? set;

  @override
  Map<String, dynamic> toJson() => {'set': set};
}

class EnumSupportTicketStatusFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumSupportTicketStatusFieldUpdateOperationsInput({this.set});

  final _i3.SupportTicketStatus? set;

  @override
  Map<String, dynamic> toJson() => {'set': set};
}

class FeedbackUpdateManyWithoutUserNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FeedbackUpdateManyWithoutUserNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.FeedbackCreateWithoutUserInput,
    _i1.PrismaUnion<
      Iterable<_i2.FeedbackCreateWithoutUserInput>,
      _i1.PrismaUnion<
        _i2.FeedbackUncheckedCreateWithoutUserInput,
        Iterable<_i2.FeedbackUncheckedCreateWithoutUserInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.FeedbackCreateOrConnectWithoutUserInput,
    Iterable<_i2.FeedbackCreateOrConnectWithoutUserInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.FeedbackUpsertWithWhereUniqueWithoutUserInput,
    Iterable<_i2.FeedbackUpsertWithWhereUniqueWithoutUserInput>
  >?
  upsert;

  final _i2.FeedbackCreateManyUserInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.FeedbackWhereUniqueInput,
    Iterable<_i2.FeedbackWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.FeedbackWhereUniqueInput,
    Iterable<_i2.FeedbackWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.FeedbackWhereUniqueInput,
    Iterable<_i2.FeedbackWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.FeedbackWhereUniqueInput,
    Iterable<_i2.FeedbackWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.FeedbackUpdateWithWhereUniqueWithoutUserInput,
    Iterable<_i2.FeedbackUpdateWithWhereUniqueWithoutUserInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.FeedbackUpdateManyWithWhereWithoutUserInput,
    Iterable<_i2.FeedbackUpdateManyWithWhereWithoutUserInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.FeedbackScalarWhereInput,
    Iterable<_i2.FeedbackScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class SupportResponseUncheckedUpdateWithoutSupportTicketInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseUncheckedUpdateWithoutSupportTicketInput({
    this.id,
    this.message,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? message;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'message': message,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SupportResponseUpdateWithWhereUniqueWithoutSupportTicketInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseUpdateWithWhereUniqueWithoutSupportTicketInput({
    required this.where,
    required this.data,
  });

  final _i2.SupportResponseWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.SupportResponseUpdateWithoutSupportTicketInput,
    _i2.SupportResponseUncheckedUpdateWithoutSupportTicketInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class SupportResponseScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.message,
    this.supportTicketId,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
    _i2.SupportResponseScalarWhereInput,
    Iterable<_i2.SupportResponseScalarWhereInput>
  >?
  AND;

  final Iterable<_i2.SupportResponseScalarWhereInput>? OR;

  final _i1.PrismaUnion<
    _i2.SupportResponseScalarWhereInput,
    Iterable<_i2.SupportResponseScalarWhereInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? message;

  final _i1.PrismaUnion<_i2.StringFilter, String>? supportTicketId;

  final _i1.PrismaUnion<_i2.StringFilter, String>? userId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'message': message,
    'supportTicketId': supportTicketId,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SupportResponseUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseUpdateManyMutationInput({
    this.id,
    this.message,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? message;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'message': message,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SupportResponseUncheckedUpdateManyWithoutResponsesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseUncheckedUpdateManyWithoutResponsesInput({
    this.id,
    this.message,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? message;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'message': message,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SupportResponseUpdateManyWithWhereWithoutSupportTicketInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseUpdateManyWithWhereWithoutSupportTicketInput({
    required this.where,
    required this.data,
  });

  final _i2.SupportResponseScalarWhereInput where;

  final _i1.PrismaUnion<
    _i2.SupportResponseUpdateManyMutationInput,
    _i2.SupportResponseUncheckedUpdateManyWithoutResponsesInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class SupportResponseUncheckedUpdateManyWithoutSupportTicketNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseUncheckedUpdateManyWithoutSupportTicketNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.SupportResponseCreateWithoutSupportTicketInput,
    _i1.PrismaUnion<
      Iterable<_i2.SupportResponseCreateWithoutSupportTicketInput>,
      _i1.PrismaUnion<
        _i2.SupportResponseUncheckedCreateWithoutSupportTicketInput,
        Iterable<_i2.SupportResponseUncheckedCreateWithoutSupportTicketInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.SupportResponseCreateOrConnectWithoutSupportTicketInput,
    Iterable<_i2.SupportResponseCreateOrConnectWithoutSupportTicketInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.SupportResponseUpsertWithWhereUniqueWithoutSupportTicketInput,
    Iterable<_i2.SupportResponseUpsertWithWhereUniqueWithoutSupportTicketInput>
  >?
  upsert;

  final _i2.SupportResponseCreateManySupportTicketInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.SupportResponseWhereUniqueInput,
    Iterable<_i2.SupportResponseWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.SupportResponseWhereUniqueInput,
    Iterable<_i2.SupportResponseWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.SupportResponseWhereUniqueInput,
    Iterable<_i2.SupportResponseWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.SupportResponseWhereUniqueInput,
    Iterable<_i2.SupportResponseWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.SupportResponseUpdateWithWhereUniqueWithoutSupportTicketInput,
    Iterable<_i2.SupportResponseUpdateWithWhereUniqueWithoutSupportTicketInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.SupportResponseUpdateManyWithWhereWithoutSupportTicketInput,
    Iterable<_i2.SupportResponseUpdateManyWithWhereWithoutSupportTicketInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.SupportResponseScalarWhereInput,
    Iterable<_i2.SupportResponseScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class SupportTicketUncheckedUpdateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportTicketUncheckedUpdateWithoutUserInput({
    this.id,
    this.title,
    this.description,
    this.priority,
    this.status,
    this.category,
    this.createdAt,
    this.updatedAt,
    this.responses,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  description;

  final _i1.PrismaUnion<
    _i3.SupportPriority,
    _i2.EnumSupportPriorityFieldUpdateOperationsInput
  >?
  priority;

  final _i1.PrismaUnion<
    _i3.SupportTicketStatus,
    _i2.EnumSupportTicketStatusFieldUpdateOperationsInput
  >?
  status;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  category;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.SupportResponseUncheckedUpdateManyWithoutSupportTicketNestedInput?
  responses;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'priority': priority,
    'status': status,
    'category': category,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'responses': responses,
  };
}

class SupportTicketUpdateWithWhereUniqueWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportTicketUpdateWithWhereUniqueWithoutUserInput({
    required this.where,
    required this.data,
  });

  final _i2.SupportTicketWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.SupportTicketUpdateWithoutUserInput,
    _i2.SupportTicketUncheckedUpdateWithoutUserInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class SupportTicketScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportTicketScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.title,
    this.description,
    this.priority,
    this.status,
    this.category,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
    _i2.SupportTicketScalarWhereInput,
    Iterable<_i2.SupportTicketScalarWhereInput>
  >?
  AND;

  final Iterable<_i2.SupportTicketScalarWhereInput>? OR;

  final _i1.PrismaUnion<
    _i2.SupportTicketScalarWhereInput,
    Iterable<_i2.SupportTicketScalarWhereInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? title;

  final _i1.PrismaUnion<_i2.StringFilter, String>? description;

  final _i1.PrismaUnion<_i2.EnumSupportPriorityFilter, _i3.SupportPriority>?
  priority;

  final _i1.PrismaUnion<
    _i2.EnumSupportTicketStatusFilter,
    _i3.SupportTicketStatus
  >?
  status;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  category;

  final _i1.PrismaUnion<_i2.StringFilter, String>? userId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'title': title,
    'description': description,
    'priority': priority,
    'status': status,
    'category': category,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SupportTicketUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportTicketUpdateManyMutationInput({
    this.id,
    this.title,
    this.description,
    this.priority,
    this.status,
    this.category,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  description;

  final _i1.PrismaUnion<
    _i3.SupportPriority,
    _i2.EnumSupportPriorityFieldUpdateOperationsInput
  >?
  priority;

  final _i1.PrismaUnion<
    _i3.SupportTicketStatus,
    _i2.EnumSupportTicketStatusFieldUpdateOperationsInput
  >?
  status;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  category;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'priority': priority,
    'status': status,
    'category': category,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SupportTicketUncheckedUpdateManyWithoutSupportTicketsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportTicketUncheckedUpdateManyWithoutSupportTicketsInput({
    this.id,
    this.title,
    this.description,
    this.priority,
    this.status,
    this.category,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  description;

  final _i1.PrismaUnion<
    _i3.SupportPriority,
    _i2.EnumSupportPriorityFieldUpdateOperationsInput
  >?
  priority;

  final _i1.PrismaUnion<
    _i3.SupportTicketStatus,
    _i2.EnumSupportTicketStatusFieldUpdateOperationsInput
  >?
  status;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  category;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'priority': priority,
    'status': status,
    'category': category,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SupportTicketUpdateManyWithWhereWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportTicketUpdateManyWithWhereWithoutUserInput({
    required this.where,
    required this.data,
  });

  final _i2.SupportTicketScalarWhereInput where;

  final _i1.PrismaUnion<
    _i2.SupportTicketUpdateManyMutationInput,
    _i2.SupportTicketUncheckedUpdateManyWithoutSupportTicketsInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class SupportTicketUpdateManyWithoutUserNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportTicketUpdateManyWithoutUserNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.SupportTicketCreateWithoutUserInput,
    _i1.PrismaUnion<
      Iterable<_i2.SupportTicketCreateWithoutUserInput>,
      _i1.PrismaUnion<
        _i2.SupportTicketUncheckedCreateWithoutUserInput,
        Iterable<_i2.SupportTicketUncheckedCreateWithoutUserInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.SupportTicketCreateOrConnectWithoutUserInput,
    Iterable<_i2.SupportTicketCreateOrConnectWithoutUserInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.SupportTicketUpsertWithWhereUniqueWithoutUserInput,
    Iterable<_i2.SupportTicketUpsertWithWhereUniqueWithoutUserInput>
  >?
  upsert;

  final _i2.SupportTicketCreateManyUserInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.SupportTicketWhereUniqueInput,
    Iterable<_i2.SupportTicketWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.SupportTicketWhereUniqueInput,
    Iterable<_i2.SupportTicketWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.SupportTicketWhereUniqueInput,
    Iterable<_i2.SupportTicketWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.SupportTicketWhereUniqueInput,
    Iterable<_i2.SupportTicketWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.SupportTicketUpdateWithWhereUniqueWithoutUserInput,
    Iterable<_i2.SupportTicketUpdateWithWhereUniqueWithoutUserInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.SupportTicketUpdateManyWithWhereWithoutUserInput,
    Iterable<_i2.SupportTicketUpdateManyWithWhereWithoutUserInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.SupportTicketScalarWhereInput,
    Iterable<_i2.SupportTicketScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class AccountUpdateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AccountUpdateWithoutUserInput({
    this.id,
    this.type,
    this.provider,
    this.providerAccountId,
    this.refreshToken,
    this.accessToken,
    this.expiresAt,
    this.tokenType,
    this.scope,
    this.idToken,
    this.sessionState,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? type;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? provider;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  providerAccountId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  refreshToken;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  accessToken;

  final _i1.PrismaUnion<
    int,
    _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  expiresAt;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  tokenType;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  scope;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  idToken;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  sessionState;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'type': type,
    'provider': provider,
    'providerAccountId': providerAccountId,
    'refresh_token': refreshToken,
    'access_token': accessToken,
    'expires_at': expiresAt,
    'token_type': tokenType,
    'scope': scope,
    'id_token': idToken,
    'session_state': sessionState,
  };
}

class AccountUncheckedUpdateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AccountUncheckedUpdateWithoutUserInput({
    this.id,
    this.type,
    this.provider,
    this.providerAccountId,
    this.refreshToken,
    this.accessToken,
    this.expiresAt,
    this.tokenType,
    this.scope,
    this.idToken,
    this.sessionState,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? type;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? provider;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  providerAccountId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  refreshToken;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  accessToken;

  final _i1.PrismaUnion<
    int,
    _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  expiresAt;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  tokenType;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  scope;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  idToken;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  sessionState;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'type': type,
    'provider': provider,
    'providerAccountId': providerAccountId,
    'refresh_token': refreshToken,
    'access_token': accessToken,
    'expires_at': expiresAt,
    'token_type': tokenType,
    'scope': scope,
    'id_token': idToken,
    'session_state': sessionState,
  };
}

class AccountUpsertWithWhereUniqueWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AccountUpsertWithWhereUniqueWithoutUserInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.AccountWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.AccountUpdateWithoutUserInput,
    _i2.AccountUncheckedUpdateWithoutUserInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.AccountCreateWithoutUserInput,
    _i2.AccountUncheckedCreateWithoutUserInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'update': update,
    'create': create,
  };
}

class AccountUpdateWithWhereUniqueWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AccountUpdateWithWhereUniqueWithoutUserInput({
    required this.where,
    required this.data,
  });

  final _i2.AccountWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.AccountUpdateWithoutUserInput,
    _i2.AccountUncheckedUpdateWithoutUserInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class AccountScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AccountScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.userId,
    this.type,
    this.provider,
    this.providerAccountId,
    this.refreshToken,
    this.accessToken,
    this.expiresAt,
    this.tokenType,
    this.scope,
    this.idToken,
    this.sessionState,
  });

  final _i1.PrismaUnion<
    _i2.AccountScalarWhereInput,
    Iterable<_i2.AccountScalarWhereInput>
  >?
  AND;

  final Iterable<_i2.AccountScalarWhereInput>? OR;

  final _i1.PrismaUnion<
    _i2.AccountScalarWhereInput,
    Iterable<_i2.AccountScalarWhereInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? userId;

  final _i1.PrismaUnion<_i2.StringFilter, String>? type;

  final _i1.PrismaUnion<_i2.StringFilter, String>? provider;

  final _i1.PrismaUnion<_i2.StringFilter, String>? providerAccountId;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  refreshToken;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  accessToken;

  final _i1.PrismaUnion<
    _i2.IntNullableFilter,
    _i1.PrismaUnion<int, _i1.PrismaNull>
  >?
  expiresAt;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  tokenType;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  scope;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  idToken;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  sessionState;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'userId': userId,
    'type': type,
    'provider': provider,
    'providerAccountId': providerAccountId,
    'refresh_token': refreshToken,
    'access_token': accessToken,
    'expires_at': expiresAt,
    'token_type': tokenType,
    'scope': scope,
    'id_token': idToken,
    'session_state': sessionState,
  };
}

class AccountUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AccountUpdateManyMutationInput({
    this.id,
    this.type,
    this.provider,
    this.providerAccountId,
    this.refreshToken,
    this.accessToken,
    this.expiresAt,
    this.tokenType,
    this.scope,
    this.idToken,
    this.sessionState,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? type;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? provider;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  providerAccountId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  refreshToken;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  accessToken;

  final _i1.PrismaUnion<
    int,
    _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  expiresAt;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  tokenType;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  scope;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  idToken;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  sessionState;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'type': type,
    'provider': provider,
    'providerAccountId': providerAccountId,
    'refresh_token': refreshToken,
    'access_token': accessToken,
    'expires_at': expiresAt,
    'token_type': tokenType,
    'scope': scope,
    'id_token': idToken,
    'session_state': sessionState,
  };
}

class AccountUncheckedUpdateManyWithoutAccountsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AccountUncheckedUpdateManyWithoutAccountsInput({
    this.id,
    this.type,
    this.provider,
    this.providerAccountId,
    this.refreshToken,
    this.accessToken,
    this.expiresAt,
    this.tokenType,
    this.scope,
    this.idToken,
    this.sessionState,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? type;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? provider;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  providerAccountId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  refreshToken;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  accessToken;

  final _i1.PrismaUnion<
    int,
    _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  expiresAt;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  tokenType;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  scope;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  idToken;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  sessionState;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'type': type,
    'provider': provider,
    'providerAccountId': providerAccountId,
    'refresh_token': refreshToken,
    'access_token': accessToken,
    'expires_at': expiresAt,
    'token_type': tokenType,
    'scope': scope,
    'id_token': idToken,
    'session_state': sessionState,
  };
}

class AccountUpdateManyWithWhereWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AccountUpdateManyWithWhereWithoutUserInput({
    required this.where,
    required this.data,
  });

  final _i2.AccountScalarWhereInput where;

  final _i1.PrismaUnion<
    _i2.AccountUpdateManyMutationInput,
    _i2.AccountUncheckedUpdateManyWithoutAccountsInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class AccountUpdateManyWithoutUserNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AccountUpdateManyWithoutUserNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.AccountCreateWithoutUserInput,
    _i1.PrismaUnion<
      Iterable<_i2.AccountCreateWithoutUserInput>,
      _i1.PrismaUnion<
        _i2.AccountUncheckedCreateWithoutUserInput,
        Iterable<_i2.AccountUncheckedCreateWithoutUserInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.AccountCreateOrConnectWithoutUserInput,
    Iterable<_i2.AccountCreateOrConnectWithoutUserInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.AccountUpsertWithWhereUniqueWithoutUserInput,
    Iterable<_i2.AccountUpsertWithWhereUniqueWithoutUserInput>
  >?
  upsert;

  final _i2.AccountCreateManyUserInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.AccountWhereUniqueInput,
    Iterable<_i2.AccountWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.AccountWhereUniqueInput,
    Iterable<_i2.AccountWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.AccountWhereUniqueInput,
    Iterable<_i2.AccountWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.AccountWhereUniqueInput,
    Iterable<_i2.AccountWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.AccountUpdateWithWhereUniqueWithoutUserInput,
    Iterable<_i2.AccountUpdateWithWhereUniqueWithoutUserInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.AccountUpdateManyWithWhereWithoutUserInput,
    Iterable<_i2.AccountUpdateManyWithWhereWithoutUserInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.AccountScalarWhereInput,
    Iterable<_i2.AccountScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class SessionUpdateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SessionUpdateWithoutUserInput({
    this.id,
    this.sessionToken,
    this.expires,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  sessionToken;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  expires;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'sessionToken': sessionToken,
    'expires': expires,
  };
}

class SessionUncheckedUpdateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SessionUncheckedUpdateWithoutUserInput({
    this.id,
    this.sessionToken,
    this.expires,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  sessionToken;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  expires;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'sessionToken': sessionToken,
    'expires': expires,
  };
}

class SessionUpsertWithWhereUniqueWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SessionUpsertWithWhereUniqueWithoutUserInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.SessionWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.SessionUpdateWithoutUserInput,
    _i2.SessionUncheckedUpdateWithoutUserInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.SessionCreateWithoutUserInput,
    _i2.SessionUncheckedCreateWithoutUserInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'update': update,
    'create': create,
  };
}

class SessionUpdateWithWhereUniqueWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SessionUpdateWithWhereUniqueWithoutUserInput({
    required this.where,
    required this.data,
  });

  final _i2.SessionWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.SessionUpdateWithoutUserInput,
    _i2.SessionUncheckedUpdateWithoutUserInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class SessionScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SessionScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.sessionToken,
    this.userId,
    this.expires,
  });

  final _i1.PrismaUnion<
    _i2.SessionScalarWhereInput,
    Iterable<_i2.SessionScalarWhereInput>
  >?
  AND;

  final Iterable<_i2.SessionScalarWhereInput>? OR;

  final _i1.PrismaUnion<
    _i2.SessionScalarWhereInput,
    Iterable<_i2.SessionScalarWhereInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? sessionToken;

  final _i1.PrismaUnion<_i2.StringFilter, String>? userId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? expires;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'sessionToken': sessionToken,
    'userId': userId,
    'expires': expires,
  };
}

class SessionUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SessionUpdateManyMutationInput({
    this.id,
    this.sessionToken,
    this.expires,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  sessionToken;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  expires;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'sessionToken': sessionToken,
    'expires': expires,
  };
}

class SessionUncheckedUpdateManyWithoutSessionsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SessionUncheckedUpdateManyWithoutSessionsInput({
    this.id,
    this.sessionToken,
    this.expires,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  sessionToken;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  expires;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'sessionToken': sessionToken,
    'expires': expires,
  };
}

class SessionUpdateManyWithWhereWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SessionUpdateManyWithWhereWithoutUserInput({
    required this.where,
    required this.data,
  });

  final _i2.SessionScalarWhereInput where;

  final _i1.PrismaUnion<
    _i2.SessionUpdateManyMutationInput,
    _i2.SessionUncheckedUpdateManyWithoutSessionsInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class SessionUpdateManyWithoutUserNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SessionUpdateManyWithoutUserNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.SessionCreateWithoutUserInput,
    _i1.PrismaUnion<
      Iterable<_i2.SessionCreateWithoutUserInput>,
      _i1.PrismaUnion<
        _i2.SessionUncheckedCreateWithoutUserInput,
        Iterable<_i2.SessionUncheckedCreateWithoutUserInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.SessionCreateOrConnectWithoutUserInput,
    Iterable<_i2.SessionCreateOrConnectWithoutUserInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.SessionUpsertWithWhereUniqueWithoutUserInput,
    Iterable<_i2.SessionUpsertWithWhereUniqueWithoutUserInput>
  >?
  upsert;

  final _i2.SessionCreateManyUserInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.SessionWhereUniqueInput,
    Iterable<_i2.SessionWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.SessionWhereUniqueInput,
    Iterable<_i2.SessionWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.SessionWhereUniqueInput,
    Iterable<_i2.SessionWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.SessionWhereUniqueInput,
    Iterable<_i2.SessionWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.SessionUpdateWithWhereUniqueWithoutUserInput,
    Iterable<_i2.SessionUpdateWithWhereUniqueWithoutUserInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.SessionUpdateManyWithWhereWithoutUserInput,
    Iterable<_i2.SessionUpdateManyWithWhereWithoutUserInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.SessionScalarWhereInput,
    Iterable<_i2.SessionScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class UserUpdateWithoutSupportResponsesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpdateWithoutSupportResponsesInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.cookiePreferences,
    this.notificationPreferences,
    this.payment,
    this.consultantProfile,
    this.consulteeProfile,
    this.staffProfile,
    this.slotsOfAppointment,
    this.waitlist,
    this.feedbacks,
    this.supportTickets,
    this.accounts,
    this.sessions,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  name;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  email;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  emailVerified;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  image;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  phone;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  address;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  password;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetToken;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetExpires;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? onlineStatus;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  currentTimezone;

  final _i1.PrismaUnion<
    bool,
    _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  onboardingCompleted;

  final _i1.PrismaUnion<
    _i3.UserRole,
    _i1.PrismaUnion<
      _i2.NullableEnumUserRoleFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  role;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consultantProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consulteeProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  staffProfileId;

  final _i2.CookiePreferenceUpdateOneWithoutUserNestedInput? cookiePreferences;

  final _i2.NotificationPreferenceUpdateOneWithoutUserNestedInput?
  notificationPreferences;

  final _i2.PaymentUpdateManyWithoutUserNestedInput? payment;

  final _i2.ConsultantProfileUpdateOneWithoutUserNestedInput? consultantProfile;

  final _i2.ConsulteeProfileUpdateOneWithoutUserNestedInput? consulteeProfile;

  final _i2.StaffProfileUpdateOneWithoutUserNestedInput? staffProfile;

  final _i2.SlotOfAppointmentUpdateManyWithoutUserNestedInput?
  slotsOfAppointment;

  final _i2.WaitlistUpdateManyWithoutUserNestedInput? waitlist;

  final _i2.FeedbackUpdateManyWithoutUserNestedInput? feedbacks;

  final _i2.SupportTicketUpdateManyWithoutUserNestedInput? supportTickets;

  final _i2.AccountUpdateManyWithoutUserNestedInput? accounts;

  final _i2.SessionUpdateManyWithoutUserNestedInput? sessions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'cookiePreferences': cookiePreferences,
    'notificationPreferences': notificationPreferences,
    'Payment': payment,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
    'staffProfile': staffProfile,
    'slotsOfAppointment': slotsOfAppointment,
    'Waitlist': waitlist,
    'feedbacks': feedbacks,
    'supportTickets': supportTickets,
    'accounts': accounts,
    'sessions': sessions,
  };
}

class EnumPlatformFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumPlatformFieldUpdateOperationsInput({this.set});

  final _i3.Platform? set;

  @override
  Map<String, dynamic> toJson() => {'set': set};
}

class MeetingSessionUpdatehostKeysInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const MeetingSessionUpdatehostKeysInput({this.set, this.push});

  final Iterable<String>? set;

  final _i1.PrismaUnion<String, Iterable<String>>? push;

  @override
  Map<String, dynamic> toJson() => {'set': set, 'push': push};
}

class RecordingUpdateWithoutMeetingSessionInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const RecordingUpdateWithoutMeetingSessionInput({
    this.id,
    this.title,
    this.recordingUrl,
    this.durationInMinutes,
    this.recordedAt,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  recordingUrl;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
  durationInMinutes;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  recordedAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'recordingUrl': recordingUrl,
    'durationInMinutes': durationInMinutes,
    'recordedAt': recordedAt,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class RecordingUncheckedUpdateWithoutMeetingSessionInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const RecordingUncheckedUpdateWithoutMeetingSessionInput({
    this.id,
    this.title,
    this.recordingUrl,
    this.durationInMinutes,
    this.recordedAt,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  recordingUrl;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
  durationInMinutes;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  recordedAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'recordingUrl': recordingUrl,
    'durationInMinutes': durationInMinutes,
    'recordedAt': recordedAt,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class RecordingUpsertWithWhereUniqueWithoutMeetingSessionInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const RecordingUpsertWithWhereUniqueWithoutMeetingSessionInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.RecordingWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.RecordingUpdateWithoutMeetingSessionInput,
    _i2.RecordingUncheckedUpdateWithoutMeetingSessionInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.RecordingCreateWithoutMeetingSessionInput,
    _i2.RecordingUncheckedCreateWithoutMeetingSessionInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'update': update,
    'create': create,
  };
}

class RecordingUpdateWithWhereUniqueWithoutMeetingSessionInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const RecordingUpdateWithWhereUniqueWithoutMeetingSessionInput({
    required this.where,
    required this.data,
  });

  final _i2.RecordingWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.RecordingUpdateWithoutMeetingSessionInput,
    _i2.RecordingUncheckedUpdateWithoutMeetingSessionInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class RecordingScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const RecordingScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.title,
    this.recordingUrl,
    this.durationInMinutes,
    this.recordedAt,
    this.meetingSessionId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
    _i2.RecordingScalarWhereInput,
    Iterable<_i2.RecordingScalarWhereInput>
  >?
  AND;

  final Iterable<_i2.RecordingScalarWhereInput>? OR;

  final _i1.PrismaUnion<
    _i2.RecordingScalarWhereInput,
    Iterable<_i2.RecordingScalarWhereInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? title;

  final _i1.PrismaUnion<_i2.StringFilter, String>? recordingUrl;

  final _i1.PrismaUnion<_i2.IntFilter, int>? durationInMinutes;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? recordedAt;

  final _i1.PrismaUnion<_i2.StringFilter, String>? meetingSessionId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'title': title,
    'recordingUrl': recordingUrl,
    'durationInMinutes': durationInMinutes,
    'recordedAt': recordedAt,
    'meetingSessionId': meetingSessionId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class RecordingUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const RecordingUpdateManyMutationInput({
    this.id,
    this.title,
    this.recordingUrl,
    this.durationInMinutes,
    this.recordedAt,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  recordingUrl;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
  durationInMinutes;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  recordedAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'recordingUrl': recordingUrl,
    'durationInMinutes': durationInMinutes,
    'recordedAt': recordedAt,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class RecordingUncheckedUpdateManyWithoutRecordingsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const RecordingUncheckedUpdateManyWithoutRecordingsInput({
    this.id,
    this.title,
    this.recordingUrl,
    this.durationInMinutes,
    this.recordedAt,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  recordingUrl;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
  durationInMinutes;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  recordedAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'recordingUrl': recordingUrl,
    'durationInMinutes': durationInMinutes,
    'recordedAt': recordedAt,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class RecordingUpdateManyWithWhereWithoutMeetingSessionInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const RecordingUpdateManyWithWhereWithoutMeetingSessionInput({
    required this.where,
    required this.data,
  });

  final _i2.RecordingScalarWhereInput where;

  final _i1.PrismaUnion<
    _i2.RecordingUpdateManyMutationInput,
    _i2.RecordingUncheckedUpdateManyWithoutRecordingsInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class RecordingUpdateManyWithoutMeetingSessionNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const RecordingUpdateManyWithoutMeetingSessionNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.RecordingCreateWithoutMeetingSessionInput,
    _i1.PrismaUnion<
      Iterable<_i2.RecordingCreateWithoutMeetingSessionInput>,
      _i1.PrismaUnion<
        _i2.RecordingUncheckedCreateWithoutMeetingSessionInput,
        Iterable<_i2.RecordingUncheckedCreateWithoutMeetingSessionInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.RecordingCreateOrConnectWithoutMeetingSessionInput,
    Iterable<_i2.RecordingCreateOrConnectWithoutMeetingSessionInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.RecordingUpsertWithWhereUniqueWithoutMeetingSessionInput,
    Iterable<_i2.RecordingUpsertWithWhereUniqueWithoutMeetingSessionInput>
  >?
  upsert;

  final _i2.RecordingCreateManyMeetingSessionInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.RecordingWhereUniqueInput,
    Iterable<_i2.RecordingWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.RecordingWhereUniqueInput,
    Iterable<_i2.RecordingWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.RecordingWhereUniqueInput,
    Iterable<_i2.RecordingWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.RecordingWhereUniqueInput,
    Iterable<_i2.RecordingWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.RecordingUpdateWithWhereUniqueWithoutMeetingSessionInput,
    Iterable<_i2.RecordingUpdateWithWhereUniqueWithoutMeetingSessionInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.RecordingUpdateManyWithWhereWithoutMeetingSessionInput,
    Iterable<_i2.RecordingUpdateManyWithWhereWithoutMeetingSessionInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.RecordingScalarWhereInput,
    Iterable<_i2.RecordingScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class MeetingSessionUpdateWithoutSlotOfAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const MeetingSessionUpdateWithoutSlotOfAppointmentInput({
    this.id,
    this.streamCallId,
    this.platform,
    this.passcode,
    this.hostKeys,
    this.createdAt,
    this.updatedAt,
    this.recordings,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  streamCallId;

  final _i1.PrismaUnion<
    _i3.Platform,
    _i2.EnumPlatformFieldUpdateOperationsInput
  >?
  platform;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passcode;

  final _i1.PrismaUnion<
    _i2.MeetingSessionUpdatehostKeysInput,
    Iterable<String>
  >?
  hostKeys;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.RecordingUpdateManyWithoutMeetingSessionNestedInput? recordings;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'streamCallId': streamCallId,
    'platform': platform,
    'passcode': passcode,
    'hostKeys': hostKeys,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'recordings': recordings,
  };
}

class RecordingUncheckedUpdateManyWithoutMeetingSessionNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const RecordingUncheckedUpdateManyWithoutMeetingSessionNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.RecordingCreateWithoutMeetingSessionInput,
    _i1.PrismaUnion<
      Iterable<_i2.RecordingCreateWithoutMeetingSessionInput>,
      _i1.PrismaUnion<
        _i2.RecordingUncheckedCreateWithoutMeetingSessionInput,
        Iterable<_i2.RecordingUncheckedCreateWithoutMeetingSessionInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.RecordingCreateOrConnectWithoutMeetingSessionInput,
    Iterable<_i2.RecordingCreateOrConnectWithoutMeetingSessionInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.RecordingUpsertWithWhereUniqueWithoutMeetingSessionInput,
    Iterable<_i2.RecordingUpsertWithWhereUniqueWithoutMeetingSessionInput>
  >?
  upsert;

  final _i2.RecordingCreateManyMeetingSessionInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.RecordingWhereUniqueInput,
    Iterable<_i2.RecordingWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.RecordingWhereUniqueInput,
    Iterable<_i2.RecordingWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.RecordingWhereUniqueInput,
    Iterable<_i2.RecordingWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.RecordingWhereUniqueInput,
    Iterable<_i2.RecordingWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.RecordingUpdateWithWhereUniqueWithoutMeetingSessionInput,
    Iterable<_i2.RecordingUpdateWithWhereUniqueWithoutMeetingSessionInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.RecordingUpdateManyWithWhereWithoutMeetingSessionInput,
    Iterable<_i2.RecordingUpdateManyWithWhereWithoutMeetingSessionInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.RecordingScalarWhereInput,
    Iterable<_i2.RecordingScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class MeetingSessionUncheckedUpdateWithoutSlotOfAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const MeetingSessionUncheckedUpdateWithoutSlotOfAppointmentInput({
    this.id,
    this.streamCallId,
    this.platform,
    this.passcode,
    this.hostKeys,
    this.createdAt,
    this.updatedAt,
    this.recordings,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  streamCallId;

  final _i1.PrismaUnion<
    _i3.Platform,
    _i2.EnumPlatformFieldUpdateOperationsInput
  >?
  platform;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passcode;

  final _i1.PrismaUnion<
    _i2.MeetingSessionUpdatehostKeysInput,
    Iterable<String>
  >?
  hostKeys;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.RecordingUncheckedUpdateManyWithoutMeetingSessionNestedInput?
  recordings;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'streamCallId': streamCallId,
    'platform': platform,
    'passcode': passcode,
    'hostKeys': hostKeys,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'recordings': recordings,
  };
}

class MeetingSessionUpsertWithoutSlotOfAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const MeetingSessionUpsertWithoutSlotOfAppointmentInput({
    required this.update,
    required this.create,
  });

  final _i1.PrismaUnion<
    _i2.MeetingSessionUpdateWithoutSlotOfAppointmentInput,
    _i2.MeetingSessionUncheckedUpdateWithoutSlotOfAppointmentInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.MeetingSessionCreateWithoutSlotOfAppointmentInput,
    _i2.MeetingSessionUncheckedCreateWithoutSlotOfAppointmentInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'update': update, 'create': create};
}

class MeetingSessionUncheckedUpdateOneWithoutSlotOfAppointmentNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const MeetingSessionUncheckedUpdateOneWithoutSlotOfAppointmentNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.MeetingSessionCreateWithoutSlotOfAppointmentInput,
    _i2.MeetingSessionUncheckedCreateWithoutSlotOfAppointmentInput
  >?
  create;

  final _i2.MeetingSessionCreateOrConnectWithoutSlotOfAppointmentInput?
  connectOrCreate;

  final _i2.MeetingSessionUpsertWithoutSlotOfAppointmentInput? upsert;

  final bool? disconnect;

  final bool? delete;

  final _i2.MeetingSessionWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.MeetingSessionUpdateWithoutSlotOfAppointmentInput,
    _i2.MeetingSessionUncheckedUpdateWithoutSlotOfAppointmentInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
  };
}

class SlotOfAppointmentUncheckedUpdateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentUncheckedUpdateWithoutUserInput({
    this.id,
    this.slotStartTimeInUTC,
    this.slotEndTimeInUTC,
    this.isTentative,
    this.appointmentId,
    this.createdAt,
    this.updatedAt,
    this.meetingSession,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  slotStartTimeInUTC;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  slotEndTimeInUTC;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? isTentative;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  appointmentId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.MeetingSessionUncheckedUpdateOneWithoutSlotOfAppointmentNestedInput?
  meetingSession;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'isTentative': isTentative,
    'appointmentId': appointmentId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'meetingSession': meetingSession,
  };
}

class SlotOfAppointmentUpdateWithWhereUniqueWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentUpdateWithWhereUniqueWithoutUserInput({
    required this.where,
    required this.data,
  });

  final _i2.SlotOfAppointmentWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentUpdateWithoutUserInput,
    _i2.SlotOfAppointmentUncheckedUpdateWithoutUserInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class SlotOfAppointmentScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.slotStartTimeInUTC,
    this.slotEndTimeInUTC,
    this.isTentative,
    this.appointmentId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentScalarWhereInput,
    Iterable<_i2.SlotOfAppointmentScalarWhereInput>
  >?
  AND;

  final Iterable<_i2.SlotOfAppointmentScalarWhereInput>? OR;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentScalarWhereInput,
    Iterable<_i2.SlotOfAppointmentScalarWhereInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? slotStartTimeInUTC;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? slotEndTimeInUTC;

  final _i1.PrismaUnion<_i2.BoolFilter, bool>? isTentative;

  final _i1.PrismaUnion<_i2.StringFilter, String>? appointmentId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'isTentative': isTentative,
    'appointmentId': appointmentId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SlotOfAppointmentUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentUpdateManyMutationInput({
    this.id,
    this.slotStartTimeInUTC,
    this.slotEndTimeInUTC,
    this.isTentative,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  slotStartTimeInUTC;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  slotEndTimeInUTC;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? isTentative;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'isTentative': isTentative,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SlotOfAppointmentUncheckedUpdateManyWithoutSlotsOfAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentUncheckedUpdateManyWithoutSlotsOfAppointmentInput({
    this.id,
    this.slotStartTimeInUTC,
    this.slotEndTimeInUTC,
    this.isTentative,
    this.appointmentId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  slotStartTimeInUTC;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  slotEndTimeInUTC;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? isTentative;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  appointmentId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'isTentative': isTentative,
    'appointmentId': appointmentId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SlotOfAppointmentUpdateManyWithWhereWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentUpdateManyWithWhereWithoutUserInput({
    required this.where,
    required this.data,
  });

  final _i2.SlotOfAppointmentScalarWhereInput where;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentUpdateManyMutationInput,
    _i2.SlotOfAppointmentUncheckedUpdateManyWithoutSlotsOfAppointmentInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class SlotOfAppointmentUncheckedUpdateManyWithoutUserNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentUncheckedUpdateManyWithoutUserNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentCreateWithoutUserInput,
    _i1.PrismaUnion<
      Iterable<_i2.SlotOfAppointmentCreateWithoutUserInput>,
      _i1.PrismaUnion<
        _i2.SlotOfAppointmentUncheckedCreateWithoutUserInput,
        Iterable<_i2.SlotOfAppointmentUncheckedCreateWithoutUserInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentCreateOrConnectWithoutUserInput,
    Iterable<_i2.SlotOfAppointmentCreateOrConnectWithoutUserInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentUpsertWithWhereUniqueWithoutUserInput,
    Iterable<_i2.SlotOfAppointmentUpsertWithWhereUniqueWithoutUserInput>
  >?
  upsert;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentWhereUniqueInput,
    Iterable<_i2.SlotOfAppointmentWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentWhereUniqueInput,
    Iterable<_i2.SlotOfAppointmentWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentWhereUniqueInput,
    Iterable<_i2.SlotOfAppointmentWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentWhereUniqueInput,
    Iterable<_i2.SlotOfAppointmentWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentUpdateWithWhereUniqueWithoutUserInput,
    Iterable<_i2.SlotOfAppointmentUpdateWithWhereUniqueWithoutUserInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentUpdateManyWithWhereWithoutUserInput,
    Iterable<_i2.SlotOfAppointmentUpdateManyWithWhereWithoutUserInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentScalarWhereInput,
    Iterable<_i2.SlotOfAppointmentScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class AccountUncheckedUpdateManyWithoutUserNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AccountUncheckedUpdateManyWithoutUserNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.AccountCreateWithoutUserInput,
    _i1.PrismaUnion<
      Iterable<_i2.AccountCreateWithoutUserInput>,
      _i1.PrismaUnion<
        _i2.AccountUncheckedCreateWithoutUserInput,
        Iterable<_i2.AccountUncheckedCreateWithoutUserInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.AccountCreateOrConnectWithoutUserInput,
    Iterable<_i2.AccountCreateOrConnectWithoutUserInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.AccountUpsertWithWhereUniqueWithoutUserInput,
    Iterable<_i2.AccountUpsertWithWhereUniqueWithoutUserInput>
  >?
  upsert;

  final _i2.AccountCreateManyUserInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.AccountWhereUniqueInput,
    Iterable<_i2.AccountWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.AccountWhereUniqueInput,
    Iterable<_i2.AccountWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.AccountWhereUniqueInput,
    Iterable<_i2.AccountWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.AccountWhereUniqueInput,
    Iterable<_i2.AccountWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.AccountUpdateWithWhereUniqueWithoutUserInput,
    Iterable<_i2.AccountUpdateWithWhereUniqueWithoutUserInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.AccountUpdateManyWithWhereWithoutUserInput,
    Iterable<_i2.AccountUpdateManyWithWhereWithoutUserInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.AccountScalarWhereInput,
    Iterable<_i2.AccountScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class SessionUncheckedUpdateManyWithoutUserNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SessionUncheckedUpdateManyWithoutUserNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.SessionCreateWithoutUserInput,
    _i1.PrismaUnion<
      Iterable<_i2.SessionCreateWithoutUserInput>,
      _i1.PrismaUnion<
        _i2.SessionUncheckedCreateWithoutUserInput,
        Iterable<_i2.SessionUncheckedCreateWithoutUserInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.SessionCreateOrConnectWithoutUserInput,
    Iterable<_i2.SessionCreateOrConnectWithoutUserInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.SessionUpsertWithWhereUniqueWithoutUserInput,
    Iterable<_i2.SessionUpsertWithWhereUniqueWithoutUserInput>
  >?
  upsert;

  final _i2.SessionCreateManyUserInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.SessionWhereUniqueInput,
    Iterable<_i2.SessionWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.SessionWhereUniqueInput,
    Iterable<_i2.SessionWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.SessionWhereUniqueInput,
    Iterable<_i2.SessionWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.SessionWhereUniqueInput,
    Iterable<_i2.SessionWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.SessionUpdateWithWhereUniqueWithoutUserInput,
    Iterable<_i2.SessionUpdateWithWhereUniqueWithoutUserInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.SessionUpdateManyWithWhereWithoutUserInput,
    Iterable<_i2.SessionUpdateManyWithWhereWithoutUserInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.SessionScalarWhereInput,
    Iterable<_i2.SessionScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class UserUncheckedUpdateWithoutSupportResponsesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUncheckedUpdateWithoutSupportResponsesInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.cookiePreferences,
    this.notificationPreferences,
    this.payment,
    this.consultantProfile,
    this.consulteeProfile,
    this.staffProfile,
    this.slotsOfAppointment,
    this.waitlist,
    this.feedbacks,
    this.supportTickets,
    this.accounts,
    this.sessions,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  name;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  email;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  emailVerified;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  image;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  phone;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  address;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  password;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetToken;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetExpires;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? onlineStatus;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  currentTimezone;

  final _i1.PrismaUnion<
    bool,
    _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  onboardingCompleted;

  final _i1.PrismaUnion<
    _i3.UserRole,
    _i1.PrismaUnion<
      _i2.NullableEnumUserRoleFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  role;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consultantProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consulteeProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  staffProfileId;

  final _i2.CookiePreferenceUncheckedUpdateOneWithoutUserNestedInput?
  cookiePreferences;

  final _i2.NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput?
  notificationPreferences;

  final _i2.PaymentUncheckedUpdateManyWithoutUserNestedInput? payment;

  final _i2.ConsultantProfileUncheckedUpdateOneWithoutUserNestedInput?
  consultantProfile;

  final _i2.ConsulteeProfileUncheckedUpdateOneWithoutUserNestedInput?
  consulteeProfile;

  final _i2.StaffProfileUncheckedUpdateOneWithoutUserNestedInput? staffProfile;

  final _i2.SlotOfAppointmentUncheckedUpdateManyWithoutUserNestedInput?
  slotsOfAppointment;

  final _i2.WaitlistUncheckedUpdateManyWithoutUserNestedInput? waitlist;

  final _i2.FeedbackUncheckedUpdateManyWithoutUserNestedInput? feedbacks;

  final _i2.SupportTicketUncheckedUpdateManyWithoutUserNestedInput?
  supportTickets;

  final _i2.AccountUncheckedUpdateManyWithoutUserNestedInput? accounts;

  final _i2.SessionUncheckedUpdateManyWithoutUserNestedInput? sessions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'cookiePreferences': cookiePreferences,
    'notificationPreferences': notificationPreferences,
    'Payment': payment,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
    'staffProfile': staffProfile,
    'slotsOfAppointment': slotsOfAppointment,
    'Waitlist': waitlist,
    'feedbacks': feedbacks,
    'supportTickets': supportTickets,
    'accounts': accounts,
    'sessions': sessions,
  };
}

class UserUpsertWithoutSupportResponsesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpsertWithoutSupportResponsesInput({
    required this.update,
    required this.create,
  });

  final _i1.PrismaUnion<
    _i2.UserUpdateWithoutSupportResponsesInput,
    _i2.UserUncheckedUpdateWithoutSupportResponsesInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.UserCreateWithoutSupportResponsesInput,
    _i2.UserUncheckedCreateWithoutSupportResponsesInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'update': update, 'create': create};
}

class UserUpdateOneRequiredWithoutSupportResponsesNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpdateOneRequiredWithoutSupportResponsesNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.UserCreateWithoutSupportResponsesInput,
    _i2.UserUncheckedCreateWithoutSupportResponsesInput
  >?
  create;

  final _i2.UserCreateOrConnectWithoutSupportResponsesInput? connectOrCreate;

  final _i2.UserUpsertWithoutSupportResponsesInput? upsert;

  final _i2.UserWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.UserUpdateWithoutSupportResponsesInput,
    _i2.UserUncheckedUpdateWithoutSupportResponsesInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'connect': connect,
    'update': update,
  };
}

class SupportResponseUpdateWithoutSupportTicketInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseUpdateWithoutSupportTicketInput({
    this.id,
    this.message,
    this.createdAt,
    this.updatedAt,
    this.user,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? message;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.UserUpdateOneRequiredWithoutSupportResponsesNestedInput? user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'message': message,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'user': user,
  };
}

class SupportResponseUpsertWithWhereUniqueWithoutSupportTicketInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseUpsertWithWhereUniqueWithoutSupportTicketInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.SupportResponseWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.SupportResponseUpdateWithoutSupportTicketInput,
    _i2.SupportResponseUncheckedUpdateWithoutSupportTicketInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.SupportResponseCreateWithoutSupportTicketInput,
    _i2.SupportResponseUncheckedCreateWithoutSupportTicketInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'update': update,
    'create': create,
  };
}

class SupportResponseUpdateManyWithoutSupportTicketNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseUpdateManyWithoutSupportTicketNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.SupportResponseCreateWithoutSupportTicketInput,
    _i1.PrismaUnion<
      Iterable<_i2.SupportResponseCreateWithoutSupportTicketInput>,
      _i1.PrismaUnion<
        _i2.SupportResponseUncheckedCreateWithoutSupportTicketInput,
        Iterable<_i2.SupportResponseUncheckedCreateWithoutSupportTicketInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.SupportResponseCreateOrConnectWithoutSupportTicketInput,
    Iterable<_i2.SupportResponseCreateOrConnectWithoutSupportTicketInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.SupportResponseUpsertWithWhereUniqueWithoutSupportTicketInput,
    Iterable<_i2.SupportResponseUpsertWithWhereUniqueWithoutSupportTicketInput>
  >?
  upsert;

  final _i2.SupportResponseCreateManySupportTicketInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.SupportResponseWhereUniqueInput,
    Iterable<_i2.SupportResponseWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.SupportResponseWhereUniqueInput,
    Iterable<_i2.SupportResponseWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.SupportResponseWhereUniqueInput,
    Iterable<_i2.SupportResponseWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.SupportResponseWhereUniqueInput,
    Iterable<_i2.SupportResponseWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.SupportResponseUpdateWithWhereUniqueWithoutSupportTicketInput,
    Iterable<_i2.SupportResponseUpdateWithWhereUniqueWithoutSupportTicketInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.SupportResponseUpdateManyWithWhereWithoutSupportTicketInput,
    Iterable<_i2.SupportResponseUpdateManyWithWhereWithoutSupportTicketInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.SupportResponseScalarWhereInput,
    Iterable<_i2.SupportResponseScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class SupportTicketUpdateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportTicketUpdateWithoutUserInput({
    this.id,
    this.title,
    this.description,
    this.priority,
    this.status,
    this.category,
    this.createdAt,
    this.updatedAt,
    this.responses,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  description;

  final _i1.PrismaUnion<
    _i3.SupportPriority,
    _i2.EnumSupportPriorityFieldUpdateOperationsInput
  >?
  priority;

  final _i1.PrismaUnion<
    _i3.SupportTicketStatus,
    _i2.EnumSupportTicketStatusFieldUpdateOperationsInput
  >?
  status;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  category;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.SupportResponseUpdateManyWithoutSupportTicketNestedInput? responses;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'priority': priority,
    'status': status,
    'category': category,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'responses': responses,
  };
}

class SupportTicketUpsertWithWhereUniqueWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportTicketUpsertWithWhereUniqueWithoutUserInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.SupportTicketWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.SupportTicketUpdateWithoutUserInput,
    _i2.SupportTicketUncheckedUpdateWithoutUserInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.SupportTicketCreateWithoutUserInput,
    _i2.SupportTicketUncheckedCreateWithoutUserInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'update': update,
    'create': create,
  };
}

class SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportTicketUncheckedUpdateManyWithoutUserNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.SupportTicketCreateWithoutUserInput,
    _i1.PrismaUnion<
      Iterable<_i2.SupportTicketCreateWithoutUserInput>,
      _i1.PrismaUnion<
        _i2.SupportTicketUncheckedCreateWithoutUserInput,
        Iterable<_i2.SupportTicketUncheckedCreateWithoutUserInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.SupportTicketCreateOrConnectWithoutUserInput,
    Iterable<_i2.SupportTicketCreateOrConnectWithoutUserInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.SupportTicketUpsertWithWhereUniqueWithoutUserInput,
    Iterable<_i2.SupportTicketUpsertWithWhereUniqueWithoutUserInput>
  >?
  upsert;

  final _i2.SupportTicketCreateManyUserInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.SupportTicketWhereUniqueInput,
    Iterable<_i2.SupportTicketWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.SupportTicketWhereUniqueInput,
    Iterable<_i2.SupportTicketWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.SupportTicketWhereUniqueInput,
    Iterable<_i2.SupportTicketWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.SupportTicketWhereUniqueInput,
    Iterable<_i2.SupportTicketWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.SupportTicketUpdateWithWhereUniqueWithoutUserInput,
    Iterable<_i2.SupportTicketUpdateWithWhereUniqueWithoutUserInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.SupportTicketUpdateManyWithWhereWithoutUserInput,
    Iterable<_i2.SupportTicketUpdateManyWithWhereWithoutUserInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.SupportTicketScalarWhereInput,
    Iterable<_i2.SupportTicketScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class SupportResponseUncheckedUpdateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseUncheckedUpdateWithoutUserInput({
    this.id,
    this.message,
    this.supportTicketId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? message;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  supportTicketId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'message': message,
    'supportTicketId': supportTicketId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SupportResponseUpdateWithWhereUniqueWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseUpdateWithWhereUniqueWithoutUserInput({
    required this.where,
    required this.data,
  });

  final _i2.SupportResponseWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.SupportResponseUpdateWithoutUserInput,
    _i2.SupportResponseUncheckedUpdateWithoutUserInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class SupportResponseUncheckedUpdateManyWithoutSupportResponsesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseUncheckedUpdateManyWithoutSupportResponsesInput({
    this.id,
    this.message,
    this.supportTicketId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? message;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  supportTicketId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'message': message,
    'supportTicketId': supportTicketId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SupportResponseUpdateManyWithWhereWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseUpdateManyWithWhereWithoutUserInput({
    required this.where,
    required this.data,
  });

  final _i2.SupportResponseScalarWhereInput where;

  final _i1.PrismaUnion<
    _i2.SupportResponseUpdateManyMutationInput,
    _i2.SupportResponseUncheckedUpdateManyWithoutSupportResponsesInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class SupportResponseUpdateManyWithoutUserNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseUpdateManyWithoutUserNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.SupportResponseCreateWithoutUserInput,
    _i1.PrismaUnion<
      Iterable<_i2.SupportResponseCreateWithoutUserInput>,
      _i1.PrismaUnion<
        _i2.SupportResponseUncheckedCreateWithoutUserInput,
        Iterable<_i2.SupportResponseUncheckedCreateWithoutUserInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.SupportResponseCreateOrConnectWithoutUserInput,
    Iterable<_i2.SupportResponseCreateOrConnectWithoutUserInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.SupportResponseUpsertWithWhereUniqueWithoutUserInput,
    Iterable<_i2.SupportResponseUpsertWithWhereUniqueWithoutUserInput>
  >?
  upsert;

  final _i2.SupportResponseCreateManyUserInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.SupportResponseWhereUniqueInput,
    Iterable<_i2.SupportResponseWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.SupportResponseWhereUniqueInput,
    Iterable<_i2.SupportResponseWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.SupportResponseWhereUniqueInput,
    Iterable<_i2.SupportResponseWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.SupportResponseWhereUniqueInput,
    Iterable<_i2.SupportResponseWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.SupportResponseUpdateWithWhereUniqueWithoutUserInput,
    Iterable<_i2.SupportResponseUpdateWithWhereUniqueWithoutUserInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.SupportResponseUpdateManyWithWhereWithoutUserInput,
    Iterable<_i2.SupportResponseUpdateManyWithWhereWithoutUserInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.SupportResponseScalarWhereInput,
    Iterable<_i2.SupportResponseScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class UserUpdateWithoutSupportTicketsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpdateWithoutSupportTicketsInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.cookiePreferences,
    this.notificationPreferences,
    this.payment,
    this.consultantProfile,
    this.consulteeProfile,
    this.staffProfile,
    this.slotsOfAppointment,
    this.waitlist,
    this.feedbacks,
    this.supportResponses,
    this.accounts,
    this.sessions,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  name;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  email;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  emailVerified;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  image;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  phone;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  address;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  password;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetToken;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetExpires;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? onlineStatus;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  currentTimezone;

  final _i1.PrismaUnion<
    bool,
    _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  onboardingCompleted;

  final _i1.PrismaUnion<
    _i3.UserRole,
    _i1.PrismaUnion<
      _i2.NullableEnumUserRoleFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  role;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consultantProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consulteeProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  staffProfileId;

  final _i2.CookiePreferenceUpdateOneWithoutUserNestedInput? cookiePreferences;

  final _i2.NotificationPreferenceUpdateOneWithoutUserNestedInput?
  notificationPreferences;

  final _i2.PaymentUpdateManyWithoutUserNestedInput? payment;

  final _i2.ConsultantProfileUpdateOneWithoutUserNestedInput? consultantProfile;

  final _i2.ConsulteeProfileUpdateOneWithoutUserNestedInput? consulteeProfile;

  final _i2.StaffProfileUpdateOneWithoutUserNestedInput? staffProfile;

  final _i2.SlotOfAppointmentUpdateManyWithoutUserNestedInput?
  slotsOfAppointment;

  final _i2.WaitlistUpdateManyWithoutUserNestedInput? waitlist;

  final _i2.FeedbackUpdateManyWithoutUserNestedInput? feedbacks;

  final _i2.SupportResponseUpdateManyWithoutUserNestedInput? supportResponses;

  final _i2.AccountUpdateManyWithoutUserNestedInput? accounts;

  final _i2.SessionUpdateManyWithoutUserNestedInput? sessions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'cookiePreferences': cookiePreferences,
    'notificationPreferences': notificationPreferences,
    'Payment': payment,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
    'staffProfile': staffProfile,
    'slotsOfAppointment': slotsOfAppointment,
    'Waitlist': waitlist,
    'feedbacks': feedbacks,
    'supportResponses': supportResponses,
    'accounts': accounts,
    'sessions': sessions,
  };
}

class UserUncheckedUpdateWithoutSupportTicketsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUncheckedUpdateWithoutSupportTicketsInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.cookiePreferences,
    this.notificationPreferences,
    this.payment,
    this.consultantProfile,
    this.consulteeProfile,
    this.staffProfile,
    this.slotsOfAppointment,
    this.waitlist,
    this.feedbacks,
    this.supportResponses,
    this.accounts,
    this.sessions,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  name;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  email;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  emailVerified;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  image;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  phone;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  address;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  password;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetToken;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetExpires;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? onlineStatus;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  currentTimezone;

  final _i1.PrismaUnion<
    bool,
    _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  onboardingCompleted;

  final _i1.PrismaUnion<
    _i3.UserRole,
    _i1.PrismaUnion<
      _i2.NullableEnumUserRoleFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  role;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consultantProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consulteeProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  staffProfileId;

  final _i2.CookiePreferenceUncheckedUpdateOneWithoutUserNestedInput?
  cookiePreferences;

  final _i2.NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput?
  notificationPreferences;

  final _i2.PaymentUncheckedUpdateManyWithoutUserNestedInput? payment;

  final _i2.ConsultantProfileUncheckedUpdateOneWithoutUserNestedInput?
  consultantProfile;

  final _i2.ConsulteeProfileUncheckedUpdateOneWithoutUserNestedInput?
  consulteeProfile;

  final _i2.StaffProfileUncheckedUpdateOneWithoutUserNestedInput? staffProfile;

  final _i2.SlotOfAppointmentUncheckedUpdateManyWithoutUserNestedInput?
  slotsOfAppointment;

  final _i2.WaitlistUncheckedUpdateManyWithoutUserNestedInput? waitlist;

  final _i2.FeedbackUncheckedUpdateManyWithoutUserNestedInput? feedbacks;

  final _i2.SupportResponseUncheckedUpdateManyWithoutUserNestedInput?
  supportResponses;

  final _i2.AccountUncheckedUpdateManyWithoutUserNestedInput? accounts;

  final _i2.SessionUncheckedUpdateManyWithoutUserNestedInput? sessions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'cookiePreferences': cookiePreferences,
    'notificationPreferences': notificationPreferences,
    'Payment': payment,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
    'staffProfile': staffProfile,
    'slotsOfAppointment': slotsOfAppointment,
    'Waitlist': waitlist,
    'feedbacks': feedbacks,
    'supportResponses': supportResponses,
    'accounts': accounts,
    'sessions': sessions,
  };
}

class UserUpsertWithoutSupportTicketsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpsertWithoutSupportTicketsInput({
    required this.update,
    required this.create,
  });

  final _i1.PrismaUnion<
    _i2.UserUpdateWithoutSupportTicketsInput,
    _i2.UserUncheckedUpdateWithoutSupportTicketsInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.UserCreateWithoutSupportTicketsInput,
    _i2.UserUncheckedCreateWithoutSupportTicketsInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'update': update, 'create': create};
}

class UserUpdateOneRequiredWithoutSupportTicketsNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpdateOneRequiredWithoutSupportTicketsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.UserCreateWithoutSupportTicketsInput,
    _i2.UserUncheckedCreateWithoutSupportTicketsInput
  >?
  create;

  final _i2.UserCreateOrConnectWithoutSupportTicketsInput? connectOrCreate;

  final _i2.UserUpsertWithoutSupportTicketsInput? upsert;

  final _i2.UserWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.UserUpdateWithoutSupportTicketsInput,
    _i2.UserUncheckedUpdateWithoutSupportTicketsInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'connect': connect,
    'update': update,
  };
}

class SupportTicketUpdateWithoutResponsesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportTicketUpdateWithoutResponsesInput({
    this.id,
    this.title,
    this.description,
    this.priority,
    this.status,
    this.category,
    this.createdAt,
    this.updatedAt,
    this.user,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  description;

  final _i1.PrismaUnion<
    _i3.SupportPriority,
    _i2.EnumSupportPriorityFieldUpdateOperationsInput
  >?
  priority;

  final _i1.PrismaUnion<
    _i3.SupportTicketStatus,
    _i2.EnumSupportTicketStatusFieldUpdateOperationsInput
  >?
  status;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  category;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.UserUpdateOneRequiredWithoutSupportTicketsNestedInput? user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'priority': priority,
    'status': status,
    'category': category,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'user': user,
  };
}

class SupportTicketUncheckedUpdateWithoutResponsesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportTicketUncheckedUpdateWithoutResponsesInput({
    this.id,
    this.title,
    this.description,
    this.priority,
    this.status,
    this.category,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  description;

  final _i1.PrismaUnion<
    _i3.SupportPriority,
    _i2.EnumSupportPriorityFieldUpdateOperationsInput
  >?
  priority;

  final _i1.PrismaUnion<
    _i3.SupportTicketStatus,
    _i2.EnumSupportTicketStatusFieldUpdateOperationsInput
  >?
  status;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  category;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'priority': priority,
    'status': status,
    'category': category,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SupportTicketUpsertWithoutResponsesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportTicketUpsertWithoutResponsesInput({
    required this.update,
    required this.create,
  });

  final _i1.PrismaUnion<
    _i2.SupportTicketUpdateWithoutResponsesInput,
    _i2.SupportTicketUncheckedUpdateWithoutResponsesInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.SupportTicketCreateWithoutResponsesInput,
    _i2.SupportTicketUncheckedCreateWithoutResponsesInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'update': update, 'create': create};
}

class SupportTicketUpdateOneRequiredWithoutResponsesNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportTicketUpdateOneRequiredWithoutResponsesNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.SupportTicketCreateWithoutResponsesInput,
    _i2.SupportTicketUncheckedCreateWithoutResponsesInput
  >?
  create;

  final _i2.SupportTicketCreateOrConnectWithoutResponsesInput? connectOrCreate;

  final _i2.SupportTicketUpsertWithoutResponsesInput? upsert;

  final _i2.SupportTicketWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.SupportTicketUpdateWithoutResponsesInput,
    _i2.SupportTicketUncheckedUpdateWithoutResponsesInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'connect': connect,
    'update': update,
  };
}

class SupportResponseUpdateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseUpdateWithoutUserInput({
    this.id,
    this.message,
    this.createdAt,
    this.updatedAt,
    this.supportTicket,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? message;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.SupportTicketUpdateOneRequiredWithoutResponsesNestedInput?
  supportTicket;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'message': message,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'supportTicket': supportTicket,
  };
}

class SupportResponseUpsertWithWhereUniqueWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseUpsertWithWhereUniqueWithoutUserInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.SupportResponseWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.SupportResponseUpdateWithoutUserInput,
    _i2.SupportResponseUncheckedUpdateWithoutUserInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.SupportResponseCreateWithoutUserInput,
    _i2.SupportResponseUncheckedCreateWithoutUserInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'update': update,
    'create': create,
  };
}

class SupportResponseUncheckedUpdateManyWithoutUserNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseUncheckedUpdateManyWithoutUserNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.SupportResponseCreateWithoutUserInput,
    _i1.PrismaUnion<
      Iterable<_i2.SupportResponseCreateWithoutUserInput>,
      _i1.PrismaUnion<
        _i2.SupportResponseUncheckedCreateWithoutUserInput,
        Iterable<_i2.SupportResponseUncheckedCreateWithoutUserInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.SupportResponseCreateOrConnectWithoutUserInput,
    Iterable<_i2.SupportResponseCreateOrConnectWithoutUserInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.SupportResponseUpsertWithWhereUniqueWithoutUserInput,
    Iterable<_i2.SupportResponseUpsertWithWhereUniqueWithoutUserInput>
  >?
  upsert;

  final _i2.SupportResponseCreateManyUserInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.SupportResponseWhereUniqueInput,
    Iterable<_i2.SupportResponseWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.SupportResponseWhereUniqueInput,
    Iterable<_i2.SupportResponseWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.SupportResponseWhereUniqueInput,
    Iterable<_i2.SupportResponseWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.SupportResponseWhereUniqueInput,
    Iterable<_i2.SupportResponseWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.SupportResponseUpdateWithWhereUniqueWithoutUserInput,
    Iterable<_i2.SupportResponseUpdateWithWhereUniqueWithoutUserInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.SupportResponseUpdateManyWithWhereWithoutUserInput,
    Iterable<_i2.SupportResponseUpdateManyWithWhereWithoutUserInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.SupportResponseScalarWhereInput,
    Iterable<_i2.SupportResponseScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class UserUncheckedUpdateWithoutSlotsOfAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUncheckedUpdateWithoutSlotsOfAppointmentInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.cookiePreferences,
    this.notificationPreferences,
    this.payment,
    this.consultantProfile,
    this.consulteeProfile,
    this.staffProfile,
    this.waitlist,
    this.feedbacks,
    this.supportTickets,
    this.supportResponses,
    this.accounts,
    this.sessions,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  name;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  email;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  emailVerified;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  image;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  phone;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  address;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  password;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetToken;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetExpires;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? onlineStatus;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  currentTimezone;

  final _i1.PrismaUnion<
    bool,
    _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  onboardingCompleted;

  final _i1.PrismaUnion<
    _i3.UserRole,
    _i1.PrismaUnion<
      _i2.NullableEnumUserRoleFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  role;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consultantProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consulteeProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  staffProfileId;

  final _i2.CookiePreferenceUncheckedUpdateOneWithoutUserNestedInput?
  cookiePreferences;

  final _i2.NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput?
  notificationPreferences;

  final _i2.PaymentUncheckedUpdateManyWithoutUserNestedInput? payment;

  final _i2.ConsultantProfileUncheckedUpdateOneWithoutUserNestedInput?
  consultantProfile;

  final _i2.ConsulteeProfileUncheckedUpdateOneWithoutUserNestedInput?
  consulteeProfile;

  final _i2.StaffProfileUncheckedUpdateOneWithoutUserNestedInput? staffProfile;

  final _i2.WaitlistUncheckedUpdateManyWithoutUserNestedInput? waitlist;

  final _i2.FeedbackUncheckedUpdateManyWithoutUserNestedInput? feedbacks;

  final _i2.SupportTicketUncheckedUpdateManyWithoutUserNestedInput?
  supportTickets;

  final _i2.SupportResponseUncheckedUpdateManyWithoutUserNestedInput?
  supportResponses;

  final _i2.AccountUncheckedUpdateManyWithoutUserNestedInput? accounts;

  final _i2.SessionUncheckedUpdateManyWithoutUserNestedInput? sessions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'cookiePreferences': cookiePreferences,
    'notificationPreferences': notificationPreferences,
    'Payment': payment,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
    'staffProfile': staffProfile,
    'Waitlist': waitlist,
    'feedbacks': feedbacks,
    'supportTickets': supportTickets,
    'supportResponses': supportResponses,
    'accounts': accounts,
    'sessions': sessions,
  };
}

class UserUpdateWithWhereUniqueWithoutSlotsOfAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpdateWithWhereUniqueWithoutSlotsOfAppointmentInput({
    required this.where,
    required this.data,
  });

  final _i2.UserWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.UserUpdateWithoutSlotsOfAppointmentInput,
    _i2.UserUncheckedUpdateWithoutSlotsOfAppointmentInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class UserScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
  });

  final _i1.PrismaUnion<
    _i2.UserScalarWhereInput,
    Iterable<_i2.UserScalarWhereInput>
  >?
  AND;

  final Iterable<_i2.UserScalarWhereInput>? OR;

  final _i1.PrismaUnion<
    _i2.UserScalarWhereInput,
    Iterable<_i2.UserScalarWhereInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  name;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  email;

  final _i1.PrismaUnion<
    _i2.DateTimeNullableFilter,
    _i1.PrismaUnion<DateTime, _i1.PrismaNull>
  >?
  emailVerified;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  image;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  phone;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  address;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  password;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  passwordResetToken;

  final _i1.PrismaUnion<
    _i2.DateTimeNullableFilter,
    _i1.PrismaUnion<DateTime, _i1.PrismaNull>
  >?
  passwordResetExpires;

  final _i1.PrismaUnion<_i2.BoolFilter, bool>? onlineStatus;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  currentTimezone;

  final _i1.PrismaUnion<
    _i2.BoolNullableFilter,
    _i1.PrismaUnion<bool, _i1.PrismaNull>
  >?
  onboardingCompleted;

  final _i1.PrismaUnion<
    _i2.EnumUserRoleNullableFilter,
    _i1.PrismaUnion<_i3.UserRole, _i1.PrismaNull>
  >?
  role;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  consultantProfileId;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  consulteeProfileId;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  staffProfileId;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
  };
}

class UserUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpdateManyMutationInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  name;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  email;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  emailVerified;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  image;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  phone;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  address;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  password;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetToken;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetExpires;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? onlineStatus;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  currentTimezone;

  final _i1.PrismaUnion<
    bool,
    _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  onboardingCompleted;

  final _i1.PrismaUnion<
    _i3.UserRole,
    _i1.PrismaUnion<
      _i2.NullableEnumUserRoleFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  role;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consultantProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consulteeProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  staffProfileId;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
  };
}

class UserUncheckedUpdateManyWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUncheckedUpdateManyWithoutUserInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  name;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  email;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  emailVerified;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  image;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  phone;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  address;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  password;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetToken;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetExpires;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? onlineStatus;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  currentTimezone;

  final _i1.PrismaUnion<
    bool,
    _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  onboardingCompleted;

  final _i1.PrismaUnion<
    _i3.UserRole,
    _i1.PrismaUnion<
      _i2.NullableEnumUserRoleFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  role;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consultantProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consulteeProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  staffProfileId;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
  };
}

class UserUpdateManyWithWhereWithoutSlotsOfAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpdateManyWithWhereWithoutSlotsOfAppointmentInput({
    required this.where,
    required this.data,
  });

  final _i2.UserScalarWhereInput where;

  final _i1.PrismaUnion<
    _i2.UserUpdateManyMutationInput,
    _i2.UserUncheckedUpdateManyWithoutUserInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class UserUncheckedUpdateManyWithoutSlotsOfAppointmentNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUncheckedUpdateManyWithoutSlotsOfAppointmentNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.UserCreateWithoutSlotsOfAppointmentInput,
    _i1.PrismaUnion<
      Iterable<_i2.UserCreateWithoutSlotsOfAppointmentInput>,
      _i1.PrismaUnion<
        _i2.UserUncheckedCreateWithoutSlotsOfAppointmentInput,
        Iterable<_i2.UserUncheckedCreateWithoutSlotsOfAppointmentInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.UserCreateOrConnectWithoutSlotsOfAppointmentInput,
    Iterable<_i2.UserCreateOrConnectWithoutSlotsOfAppointmentInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.UserUpsertWithWhereUniqueWithoutSlotsOfAppointmentInput,
    Iterable<_i2.UserUpsertWithWhereUniqueWithoutSlotsOfAppointmentInput>
  >?
  upsert;

  final _i1.PrismaUnion<
    _i2.UserWhereUniqueInput,
    Iterable<_i2.UserWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.UserWhereUniqueInput,
    Iterable<_i2.UserWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.UserWhereUniqueInput,
    Iterable<_i2.UserWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.UserWhereUniqueInput,
    Iterable<_i2.UserWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.UserUpdateWithWhereUniqueWithoutSlotsOfAppointmentInput,
    Iterable<_i2.UserUpdateWithWhereUniqueWithoutSlotsOfAppointmentInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.UserUpdateManyWithWhereWithoutSlotsOfAppointmentInput,
    Iterable<_i2.UserUpdateManyWithWhereWithoutSlotsOfAppointmentInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.UserScalarWhereInput,
    Iterable<_i2.UserScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class SlotOfAppointmentUncheckedUpdateWithoutAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentUncheckedUpdateWithoutAppointmentInput({
    this.id,
    this.slotStartTimeInUTC,
    this.slotEndTimeInUTC,
    this.isTentative,
    this.createdAt,
    this.updatedAt,
    this.user,
    this.meetingSession,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  slotStartTimeInUTC;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  slotEndTimeInUTC;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? isTentative;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.UserUncheckedUpdateManyWithoutSlotsOfAppointmentNestedInput? user;

  final _i2.MeetingSessionUncheckedUpdateOneWithoutSlotOfAppointmentNestedInput?
  meetingSession;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'isTentative': isTentative,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'user': user,
    'meetingSession': meetingSession,
  };
}

class SlotOfAppointmentUpdateWithWhereUniqueWithoutAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentUpdateWithWhereUniqueWithoutAppointmentInput({
    required this.where,
    required this.data,
  });

  final _i2.SlotOfAppointmentWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentUpdateWithoutAppointmentInput,
    _i2.SlotOfAppointmentUncheckedUpdateWithoutAppointmentInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class SlotOfAppointmentUpdateManyWithWhereWithoutAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentUpdateManyWithWhereWithoutAppointmentInput({
    required this.where,
    required this.data,
  });

  final _i2.SlotOfAppointmentScalarWhereInput where;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentUpdateManyMutationInput,
    _i2.SlotOfAppointmentUncheckedUpdateManyWithoutSlotsOfAppointmentInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class SlotOfAppointmentUncheckedUpdateManyWithoutAppointmentNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentUncheckedUpdateManyWithoutAppointmentNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentCreateWithoutAppointmentInput,
    _i1.PrismaUnion<
      Iterable<_i2.SlotOfAppointmentCreateWithoutAppointmentInput>,
      _i1.PrismaUnion<
        _i2.SlotOfAppointmentUncheckedCreateWithoutAppointmentInput,
        Iterable<_i2.SlotOfAppointmentUncheckedCreateWithoutAppointmentInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentCreateOrConnectWithoutAppointmentInput,
    Iterable<_i2.SlotOfAppointmentCreateOrConnectWithoutAppointmentInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentUpsertWithWhereUniqueWithoutAppointmentInput,
    Iterable<_i2.SlotOfAppointmentUpsertWithWhereUniqueWithoutAppointmentInput>
  >?
  upsert;

  final _i2.SlotOfAppointmentCreateManyAppointmentInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentWhereUniqueInput,
    Iterable<_i2.SlotOfAppointmentWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentWhereUniqueInput,
    Iterable<_i2.SlotOfAppointmentWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentWhereUniqueInput,
    Iterable<_i2.SlotOfAppointmentWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentWhereUniqueInput,
    Iterable<_i2.SlotOfAppointmentWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentUpdateWithWhereUniqueWithoutAppointmentInput,
    Iterable<_i2.SlotOfAppointmentUpdateWithWhereUniqueWithoutAppointmentInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentUpdateManyWithWhereWithoutAppointmentInput,
    Iterable<_i2.SlotOfAppointmentUpdateManyWithWhereWithoutAppointmentInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentScalarWhereInput,
    Iterable<_i2.SlotOfAppointmentScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class AppointmentUncheckedUpdateWithoutWebinarInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentUncheckedUpdateWithoutWebinarInput({
    this.id,
    this.appointmentType,
    this.consultationId,
    this.subscriptionId,
    this.classId,
    this.createdAt,
    this.updatedAt,
    this.slotsOfAppointment,
    this.payment,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    _i3.AppointmentsType,
    _i2.EnumAppointmentsTypeFieldUpdateOperationsInput
  >?
  appointmentType;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consultationId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  subscriptionId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  classId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.SlotOfAppointmentUncheckedUpdateManyWithoutAppointmentNestedInput?
  slotsOfAppointment;

  final _i2.PaymentUncheckedUpdateManyWithoutAppointmentNestedInput? payment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'appointmentType': appointmentType,
    'consultationId': consultationId,
    'subscriptionId': subscriptionId,
    'classId': classId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'slotsOfAppointment': slotsOfAppointment,
    'payment': payment,
  };
}

class AppointmentUncheckedUpdateOneWithoutWebinarNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentUncheckedUpdateOneWithoutWebinarNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.AppointmentCreateWithoutWebinarInput,
    _i2.AppointmentUncheckedCreateWithoutWebinarInput
  >?
  create;

  final _i2.AppointmentCreateOrConnectWithoutWebinarInput? connectOrCreate;

  final _i2.AppointmentUpsertWithoutWebinarInput? upsert;

  final bool? disconnect;

  final bool? delete;

  final _i2.AppointmentWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.AppointmentUpdateWithoutWebinarInput,
    _i2.AppointmentUncheckedUpdateWithoutWebinarInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
  };
}

class WebinarUncheckedUpdateWithoutWebinarPlanInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarUncheckedUpdateWithoutWebinarPlanInput({
    this.id,
    this.status,
    this.feedbackSummary,
    this.createdAt,
    this.updatedAt,
    this.waitlist,
    this.appointment,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    _i3.WebinarStatus,
    _i2.EnumWebinarStatusFieldUpdateOperationsInput
  >?
  status;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackSummary;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.WaitlistUncheckedUpdateManyWithoutWebinarNestedInput? waitlist;

  final _i2.AppointmentUncheckedUpdateOneWithoutWebinarNestedInput? appointment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'status': status,
    'feedbackSummary': feedbackSummary,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'waitlist': waitlist,
    'appointment': appointment,
  };
}

class WebinarUpdateWithWhereUniqueWithoutWebinarPlanInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarUpdateWithWhereUniqueWithoutWebinarPlanInput({
    required this.where,
    required this.data,
  });

  final _i2.WebinarWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.WebinarUpdateWithoutWebinarPlanInput,
    _i2.WebinarUncheckedUpdateWithoutWebinarPlanInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class WebinarScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.status,
    this.feedbackSummary,
    this.webinarPlanId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
    _i2.WebinarScalarWhereInput,
    Iterable<_i2.WebinarScalarWhereInput>
  >?
  AND;

  final Iterable<_i2.WebinarScalarWhereInput>? OR;

  final _i1.PrismaUnion<
    _i2.WebinarScalarWhereInput,
    Iterable<_i2.WebinarScalarWhereInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.EnumWebinarStatusFilter, _i3.WebinarStatus>? status;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  feedbackSummary;

  final _i1.PrismaUnion<_i2.StringFilter, String>? webinarPlanId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'status': status,
    'feedbackSummary': feedbackSummary,
    'webinarPlanId': webinarPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class WebinarUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarUpdateManyMutationInput({
    this.id,
    this.status,
    this.feedbackSummary,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    _i3.WebinarStatus,
    _i2.EnumWebinarStatusFieldUpdateOperationsInput
  >?
  status;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackSummary;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'status': status,
    'feedbackSummary': feedbackSummary,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class WebinarUncheckedUpdateManyWithoutWebinarsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarUncheckedUpdateManyWithoutWebinarsInput({
    this.id,
    this.status,
    this.feedbackSummary,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    _i3.WebinarStatus,
    _i2.EnumWebinarStatusFieldUpdateOperationsInput
  >?
  status;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackSummary;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'status': status,
    'feedbackSummary': feedbackSummary,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class WebinarUpdateManyWithWhereWithoutWebinarPlanInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarUpdateManyWithWhereWithoutWebinarPlanInput({
    required this.where,
    required this.data,
  });

  final _i2.WebinarScalarWhereInput where;

  final _i1.PrismaUnion<
    _i2.WebinarUpdateManyMutationInput,
    _i2.WebinarUncheckedUpdateManyWithoutWebinarsInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class WebinarUncheckedUpdateManyWithoutWebinarPlanNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarUncheckedUpdateManyWithoutWebinarPlanNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.WebinarCreateWithoutWebinarPlanInput,
    _i1.PrismaUnion<
      Iterable<_i2.WebinarCreateWithoutWebinarPlanInput>,
      _i1.PrismaUnion<
        _i2.WebinarUncheckedCreateWithoutWebinarPlanInput,
        Iterable<_i2.WebinarUncheckedCreateWithoutWebinarPlanInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.WebinarCreateOrConnectWithoutWebinarPlanInput,
    Iterable<_i2.WebinarCreateOrConnectWithoutWebinarPlanInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.WebinarUpsertWithWhereUniqueWithoutWebinarPlanInput,
    Iterable<_i2.WebinarUpsertWithWhereUniqueWithoutWebinarPlanInput>
  >?
  upsert;

  final _i2.WebinarCreateManyWebinarPlanInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.WebinarWhereUniqueInput,
    Iterable<_i2.WebinarWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.WebinarWhereUniqueInput,
    Iterable<_i2.WebinarWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.WebinarWhereUniqueInput,
    Iterable<_i2.WebinarWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.WebinarWhereUniqueInput,
    Iterable<_i2.WebinarWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.WebinarUpdateWithWhereUniqueWithoutWebinarPlanInput,
    Iterable<_i2.WebinarUpdateWithWhereUniqueWithoutWebinarPlanInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.WebinarUpdateManyWithWhereWithoutWebinarPlanInput,
    Iterable<_i2.WebinarUpdateManyWithWhereWithoutWebinarPlanInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.WebinarScalarWhereInput,
    Iterable<_i2.WebinarScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class WebinarPlanUncheckedUpdateWithoutTopicsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanUncheckedUpdateWithoutTopicsInput({
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInHours,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.webinars,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? price;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  priceCurrency;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
  certificateProvided;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
  durationInHours;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
  maxParticipants;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  language;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  level;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  prerequisites;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  materialProvided;

  final _i1.PrismaUnion<
    _i2.WebinarPlanUpdatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consultantProfileId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.WebinarUncheckedUpdateManyWithoutWebinarPlanNestedInput? webinars;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInHours': durationInHours,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'webinars': webinars,
  };
}

class WebinarPlanUpdateWithWhereUniqueWithoutTopicsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanUpdateWithWhereUniqueWithoutTopicsInput({
    required this.where,
    required this.data,
  });

  final _i2.WebinarPlanWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.WebinarPlanUpdateWithoutTopicsInput,
    _i2.WebinarPlanUncheckedUpdateWithoutTopicsInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class WebinarPlanUpdateManyWithWhereWithoutTopicsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanUpdateManyWithWhereWithoutTopicsInput({
    required this.where,
    required this.data,
  });

  final _i2.WebinarPlanScalarWhereInput where;

  final _i1.PrismaUnion<
    _i2.WebinarPlanUpdateManyMutationInput,
    _i2.WebinarPlanUncheckedUpdateManyWithoutWebinarPlansInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class WebinarPlanUncheckedUpdateManyWithoutTopicsNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanUncheckedUpdateManyWithoutTopicsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.WebinarPlanCreateWithoutTopicsInput,
    _i1.PrismaUnion<
      Iterable<_i2.WebinarPlanCreateWithoutTopicsInput>,
      _i1.PrismaUnion<
        _i2.WebinarPlanUncheckedCreateWithoutTopicsInput,
        Iterable<_i2.WebinarPlanUncheckedCreateWithoutTopicsInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.WebinarPlanCreateOrConnectWithoutTopicsInput,
    Iterable<_i2.WebinarPlanCreateOrConnectWithoutTopicsInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.WebinarPlanUpsertWithWhereUniqueWithoutTopicsInput,
    Iterable<_i2.WebinarPlanUpsertWithWhereUniqueWithoutTopicsInput>
  >?
  upsert;

  final _i1.PrismaUnion<
    _i2.WebinarPlanWhereUniqueInput,
    Iterable<_i2.WebinarPlanWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.WebinarPlanWhereUniqueInput,
    Iterable<_i2.WebinarPlanWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.WebinarPlanWhereUniqueInput,
    Iterable<_i2.WebinarPlanWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.WebinarPlanWhereUniqueInput,
    Iterable<_i2.WebinarPlanWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.WebinarPlanUpdateWithWhereUniqueWithoutTopicsInput,
    Iterable<_i2.WebinarPlanUpdateWithWhereUniqueWithoutTopicsInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.WebinarPlanUpdateManyWithWhereWithoutTopicsInput,
    Iterable<_i2.WebinarPlanUpdateManyWithWhereWithoutTopicsInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.WebinarPlanScalarWhereInput,
    Iterable<_i2.WebinarPlanScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class TopicUncheckedUpdateWithoutClassPlansInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TopicUncheckedUpdateWithoutClassPlansInput({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
    this.webinarPlans,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.WebinarPlanUncheckedUpdateManyWithoutTopicsNestedInput?
  webinarPlans;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'webinarPlans': webinarPlans,
  };
}

class TopicUpdateWithWhereUniqueWithoutClassPlansInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TopicUpdateWithWhereUniqueWithoutClassPlansInput({
    required this.where,
    required this.data,
  });

  final _i2.TopicWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.TopicUpdateWithoutClassPlansInput,
    _i2.TopicUncheckedUpdateWithoutClassPlansInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class TopicUpdateManyWithWhereWithoutClassPlansInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TopicUpdateManyWithWhereWithoutClassPlansInput({
    required this.where,
    required this.data,
  });

  final _i2.TopicScalarWhereInput where;

  final _i1.PrismaUnion<
    _i2.TopicUpdateManyMutationInput,
    _i2.TopicUncheckedUpdateManyWithoutTopicsInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class TopicUncheckedUpdateManyWithoutClassPlansNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TopicUncheckedUpdateManyWithoutClassPlansNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.TopicCreateWithoutClassPlansInput,
    _i1.PrismaUnion<
      Iterable<_i2.TopicCreateWithoutClassPlansInput>,
      _i1.PrismaUnion<
        _i2.TopicUncheckedCreateWithoutClassPlansInput,
        Iterable<_i2.TopicUncheckedCreateWithoutClassPlansInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.TopicCreateOrConnectWithoutClassPlansInput,
    Iterable<_i2.TopicCreateOrConnectWithoutClassPlansInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.TopicUpsertWithWhereUniqueWithoutClassPlansInput,
    Iterable<_i2.TopicUpsertWithWhereUniqueWithoutClassPlansInput>
  >?
  upsert;

  final _i1.PrismaUnion<
    _i2.TopicWhereUniqueInput,
    Iterable<_i2.TopicWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.TopicWhereUniqueInput,
    Iterable<_i2.TopicWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.TopicWhereUniqueInput,
    Iterable<_i2.TopicWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.TopicWhereUniqueInput,
    Iterable<_i2.TopicWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.TopicUpdateWithWhereUniqueWithoutClassPlansInput,
    Iterable<_i2.TopicUpdateWithWhereUniqueWithoutClassPlansInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.TopicUpdateManyWithWhereWithoutClassPlansInput,
    Iterable<_i2.TopicUpdateManyWithWhereWithoutClassPlansInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.TopicScalarWhereInput,
    Iterable<_i2.TopicScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class ClassPlanUncheckedUpdateWithoutClassesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanUncheckedUpdateWithoutClassesInput({
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInMonths,
    this.callsPerWeek,
    this.videoMeetings,
    this.emailSupport,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.topics,
    this.classContents,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  description;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? price;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  priceCurrency;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
  certificateProvided;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
  durationInMonths;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? callsPerWeek;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? videoMeetings;

  final _i1.PrismaUnion<
    _i3.PlanEmailSupport,
    _i2.EnumPlanEmailSupportFieldUpdateOperationsInput
  >?
  emailSupport;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
  maxParticipants;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  language;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  level;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  prerequisites;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  materialProvided;

  final _i1.PrismaUnion<
    _i2.ClassPlanUpdatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consultantProfileId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.TopicUncheckedUpdateManyWithoutClassPlansNestedInput? topics;

  final _i2.ClassContentUncheckedUpdateManyWithoutClassPlanNestedInput?
  classContents;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInMonths': durationInMonths,
    'callsPerWeek': callsPerWeek,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'topics': topics,
    'classContents': classContents,
  };
}

class ClassPlanUpsertWithoutClassesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanUpsertWithoutClassesInput({
    required this.update,
    required this.create,
  });

  final _i1.PrismaUnion<
    _i2.ClassPlanUpdateWithoutClassesInput,
    _i2.ClassPlanUncheckedUpdateWithoutClassesInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.ClassPlanCreateWithoutClassesInput,
    _i2.ClassPlanUncheckedCreateWithoutClassesInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'update': update, 'create': create};
}

class ClassPlanUpdateOneRequiredWithoutClassesNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanUpdateOneRequiredWithoutClassesNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.ClassPlanCreateWithoutClassesInput,
    _i2.ClassPlanUncheckedCreateWithoutClassesInput
  >?
  create;

  final _i2.ClassPlanCreateOrConnectWithoutClassesInput? connectOrCreate;

  final _i2.ClassPlanUpsertWithoutClassesInput? upsert;

  final _i2.ClassPlanWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.ClassPlanUpdateWithoutClassesInput,
    _i2.ClassPlanUncheckedUpdateWithoutClassesInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'connect': connect,
    'update': update,
  };
}

class ClassUpdateWithoutWaitlistInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassUpdateWithoutWaitlistInput({
    this.id,
    this.startDate,
    this.endDate,
    this.status,
    this.recordingUrls,
    this.feedbackSummary,
    this.createdAt,
    this.updatedAt,
    this.classPlan,
    this.appointments,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  startDate;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  endDate;

  final _i1.PrismaUnion<
    _i3.ClassStatus,
    _i2.EnumClassStatusFieldUpdateOperationsInput
  >?
  status;

  final _i1.PrismaUnion<_i2.ClassUpdaterecordingUrlsInput, Iterable<String>>?
  recordingUrls;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackSummary;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.ClassPlanUpdateOneRequiredWithoutClassesNestedInput? classPlan;

  final _i2.AppointmentUpdateManyWithoutClassNestedInput? appointments;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'status': status,
    'recordingUrls': recordingUrls,
    'feedbackSummary': feedbackSummary,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'classPlan': classPlan,
    'appointments': appointments,
  };
}

class ClassUncheckedUpdateWithoutWaitlistInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassUncheckedUpdateWithoutWaitlistInput({
    this.id,
    this.startDate,
    this.endDate,
    this.status,
    this.recordingUrls,
    this.feedbackSummary,
    this.classPlanId,
    this.createdAt,
    this.updatedAt,
    this.appointments,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  startDate;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  endDate;

  final _i1.PrismaUnion<
    _i3.ClassStatus,
    _i2.EnumClassStatusFieldUpdateOperationsInput
  >?
  status;

  final _i1.PrismaUnion<_i2.ClassUpdaterecordingUrlsInput, Iterable<String>>?
  recordingUrls;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackSummary;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  classPlanId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.AppointmentUncheckedUpdateManyWithoutClassNestedInput? appointments;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'status': status,
    'recordingUrls': recordingUrls,
    'feedbackSummary': feedbackSummary,
    'classPlanId': classPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'appointments': appointments,
  };
}

class ClassUpsertWithoutWaitlistInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassUpsertWithoutWaitlistInput({
    required this.update,
    required this.create,
  });

  final _i1.PrismaUnion<
    _i2.ClassUpdateWithoutWaitlistInput,
    _i2.ClassUncheckedUpdateWithoutWaitlistInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.ClassCreateWithoutWaitlistInput,
    _i2.ClassUncheckedCreateWithoutWaitlistInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'update': update, 'create': create};
}

class ClassUpdateOneWithoutWaitlistNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassUpdateOneWithoutWaitlistNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.ClassCreateWithoutWaitlistInput,
    _i2.ClassUncheckedCreateWithoutWaitlistInput
  >?
  create;

  final _i2.ClassCreateOrConnectWithoutWaitlistInput? connectOrCreate;

  final _i2.ClassUpsertWithoutWaitlistInput? upsert;

  final bool? disconnect;

  final bool? delete;

  final _i2.ClassWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.ClassUpdateWithoutWaitlistInput,
    _i2.ClassUncheckedUpdateWithoutWaitlistInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
  };
}

class WaitlistUpdateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistUpdateWithoutUserInput({
    this.id,
    this.joinedAt,
    this.webinar,
    this.$class,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  joinedAt;

  final _i2.WebinarUpdateOneWithoutWaitlistNestedInput? webinar;

  final _i2.ClassUpdateOneWithoutWaitlistNestedInput? $class;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'joinedAt': joinedAt,
    'webinar': webinar,
    'class': $class,
  };
}

class WaitlistUpsertWithWhereUniqueWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistUpsertWithWhereUniqueWithoutUserInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.WaitlistWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.WaitlistUpdateWithoutUserInput,
    _i2.WaitlistUncheckedUpdateWithoutUserInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.WaitlistCreateWithoutUserInput,
    _i2.WaitlistUncheckedCreateWithoutUserInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'update': update,
    'create': create,
  };
}

class WaitlistUpdateManyWithoutUserNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistUpdateManyWithoutUserNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.WaitlistCreateWithoutUserInput,
    _i1.PrismaUnion<
      Iterable<_i2.WaitlistCreateWithoutUserInput>,
      _i1.PrismaUnion<
        _i2.WaitlistUncheckedCreateWithoutUserInput,
        Iterable<_i2.WaitlistUncheckedCreateWithoutUserInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.WaitlistCreateOrConnectWithoutUserInput,
    Iterable<_i2.WaitlistCreateOrConnectWithoutUserInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.WaitlistUpsertWithWhereUniqueWithoutUserInput,
    Iterable<_i2.WaitlistUpsertWithWhereUniqueWithoutUserInput>
  >?
  upsert;

  final _i2.WaitlistCreateManyUserInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.WaitlistWhereUniqueInput,
    Iterable<_i2.WaitlistWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.WaitlistWhereUniqueInput,
    Iterable<_i2.WaitlistWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.WaitlistWhereUniqueInput,
    Iterable<_i2.WaitlistWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.WaitlistWhereUniqueInput,
    Iterable<_i2.WaitlistWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.WaitlistUpdateWithWhereUniqueWithoutUserInput,
    Iterable<_i2.WaitlistUpdateWithWhereUniqueWithoutUserInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.WaitlistUpdateManyWithWhereWithoutUserInput,
    Iterable<_i2.WaitlistUpdateManyWithWhereWithoutUserInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.WaitlistScalarWhereInput,
    Iterable<_i2.WaitlistScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class UserUpdateWithoutPaymentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpdateWithoutPaymentInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.cookiePreferences,
    this.notificationPreferences,
    this.consultantProfile,
    this.consulteeProfile,
    this.staffProfile,
    this.slotsOfAppointment,
    this.waitlist,
    this.feedbacks,
    this.supportTickets,
    this.supportResponses,
    this.accounts,
    this.sessions,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  name;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  email;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  emailVerified;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  image;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  phone;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  address;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  password;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetToken;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetExpires;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? onlineStatus;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  currentTimezone;

  final _i1.PrismaUnion<
    bool,
    _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  onboardingCompleted;

  final _i1.PrismaUnion<
    _i3.UserRole,
    _i1.PrismaUnion<
      _i2.NullableEnumUserRoleFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  role;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consultantProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consulteeProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  staffProfileId;

  final _i2.CookiePreferenceUpdateOneWithoutUserNestedInput? cookiePreferences;

  final _i2.NotificationPreferenceUpdateOneWithoutUserNestedInput?
  notificationPreferences;

  final _i2.ConsultantProfileUpdateOneWithoutUserNestedInput? consultantProfile;

  final _i2.ConsulteeProfileUpdateOneWithoutUserNestedInput? consulteeProfile;

  final _i2.StaffProfileUpdateOneWithoutUserNestedInput? staffProfile;

  final _i2.SlotOfAppointmentUpdateManyWithoutUserNestedInput?
  slotsOfAppointment;

  final _i2.WaitlistUpdateManyWithoutUserNestedInput? waitlist;

  final _i2.FeedbackUpdateManyWithoutUserNestedInput? feedbacks;

  final _i2.SupportTicketUpdateManyWithoutUserNestedInput? supportTickets;

  final _i2.SupportResponseUpdateManyWithoutUserNestedInput? supportResponses;

  final _i2.AccountUpdateManyWithoutUserNestedInput? accounts;

  final _i2.SessionUpdateManyWithoutUserNestedInput? sessions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'cookiePreferences': cookiePreferences,
    'notificationPreferences': notificationPreferences,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
    'staffProfile': staffProfile,
    'slotsOfAppointment': slotsOfAppointment,
    'Waitlist': waitlist,
    'feedbacks': feedbacks,
    'supportTickets': supportTickets,
    'supportResponses': supportResponses,
    'accounts': accounts,
    'sessions': sessions,
  };
}

class UserUncheckedUpdateWithoutPaymentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUncheckedUpdateWithoutPaymentInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.cookiePreferences,
    this.notificationPreferences,
    this.consultantProfile,
    this.consulteeProfile,
    this.staffProfile,
    this.slotsOfAppointment,
    this.waitlist,
    this.feedbacks,
    this.supportTickets,
    this.supportResponses,
    this.accounts,
    this.sessions,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  name;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  email;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  emailVerified;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  image;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  phone;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  address;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  password;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetToken;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetExpires;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? onlineStatus;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  currentTimezone;

  final _i1.PrismaUnion<
    bool,
    _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  onboardingCompleted;

  final _i1.PrismaUnion<
    _i3.UserRole,
    _i1.PrismaUnion<
      _i2.NullableEnumUserRoleFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  role;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consultantProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consulteeProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  staffProfileId;

  final _i2.CookiePreferenceUncheckedUpdateOneWithoutUserNestedInput?
  cookiePreferences;

  final _i2.NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput?
  notificationPreferences;

  final _i2.ConsultantProfileUncheckedUpdateOneWithoutUserNestedInput?
  consultantProfile;

  final _i2.ConsulteeProfileUncheckedUpdateOneWithoutUserNestedInput?
  consulteeProfile;

  final _i2.StaffProfileUncheckedUpdateOneWithoutUserNestedInput? staffProfile;

  final _i2.SlotOfAppointmentUncheckedUpdateManyWithoutUserNestedInput?
  slotsOfAppointment;

  final _i2.WaitlistUncheckedUpdateManyWithoutUserNestedInput? waitlist;

  final _i2.FeedbackUncheckedUpdateManyWithoutUserNestedInput? feedbacks;

  final _i2.SupportTicketUncheckedUpdateManyWithoutUserNestedInput?
  supportTickets;

  final _i2.SupportResponseUncheckedUpdateManyWithoutUserNestedInput?
  supportResponses;

  final _i2.AccountUncheckedUpdateManyWithoutUserNestedInput? accounts;

  final _i2.SessionUncheckedUpdateManyWithoutUserNestedInput? sessions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'cookiePreferences': cookiePreferences,
    'notificationPreferences': notificationPreferences,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
    'staffProfile': staffProfile,
    'slotsOfAppointment': slotsOfAppointment,
    'Waitlist': waitlist,
    'feedbacks': feedbacks,
    'supportTickets': supportTickets,
    'supportResponses': supportResponses,
    'accounts': accounts,
    'sessions': sessions,
  };
}

class UserUpsertWithoutPaymentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpsertWithoutPaymentInput({
    required this.update,
    required this.create,
  });

  final _i1.PrismaUnion<
    _i2.UserUpdateWithoutPaymentInput,
    _i2.UserUncheckedUpdateWithoutPaymentInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.UserCreateWithoutPaymentInput,
    _i2.UserUncheckedCreateWithoutPaymentInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'update': update, 'create': create};
}

class UserUpdateOneRequiredWithoutPaymentNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpdateOneRequiredWithoutPaymentNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.UserCreateWithoutPaymentInput,
    _i2.UserUncheckedCreateWithoutPaymentInput
  >?
  create;

  final _i2.UserCreateOrConnectWithoutPaymentInput? connectOrCreate;

  final _i2.UserUpsertWithoutPaymentInput? upsert;

  final _i2.UserWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.UserUpdateWithoutPaymentInput,
    _i2.UserUncheckedUpdateWithoutPaymentInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'connect': connect,
    'update': update,
  };
}

class EnumDiscountTypeFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumDiscountTypeFieldUpdateOperationsInput({this.set});

  final _i3.DiscountType? set;

  @override
  Map<String, dynamic> toJson() => {'set': set};
}

class DiscountCodeUpdateWithoutPaymentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountCodeUpdateWithoutPaymentInput({
    this.id,
    this.code,
    this.description,
    this.discountType,
    this.discountValue,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? code;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  description;

  final _i1.PrismaUnion<
    _i3.DiscountType,
    _i2.EnumDiscountTypeFieldUpdateOperationsInput
  >?
  discountType;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
  discountValue;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'code': code,
    'description': description,
    'discountType': discountType,
    'discountValue': discountValue,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class DiscountCodeUncheckedUpdateWithoutPaymentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountCodeUncheckedUpdateWithoutPaymentInput({
    this.id,
    this.code,
    this.description,
    this.discountType,
    this.discountValue,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? code;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  description;

  final _i1.PrismaUnion<
    _i3.DiscountType,
    _i2.EnumDiscountTypeFieldUpdateOperationsInput
  >?
  discountType;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
  discountValue;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'code': code,
    'description': description,
    'discountType': discountType,
    'discountValue': discountValue,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class DiscountCodeUpsertWithoutPaymentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountCodeUpsertWithoutPaymentInput({
    required this.update,
    required this.create,
  });

  final _i1.PrismaUnion<
    _i2.DiscountCodeUpdateWithoutPaymentInput,
    _i2.DiscountCodeUncheckedUpdateWithoutPaymentInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.DiscountCodeCreateWithoutPaymentInput,
    _i2.DiscountCodeUncheckedCreateWithoutPaymentInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'update': update, 'create': create};
}

class DiscountCodeUpdateOneWithoutPaymentNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountCodeUpdateOneWithoutPaymentNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.DiscountCodeCreateWithoutPaymentInput,
    _i2.DiscountCodeUncheckedCreateWithoutPaymentInput
  >?
  create;

  final _i2.DiscountCodeCreateOrConnectWithoutPaymentInput? connectOrCreate;

  final _i2.DiscountCodeUpsertWithoutPaymentInput? upsert;

  final bool? disconnect;

  final bool? delete;

  final _i2.DiscountCodeWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.DiscountCodeUpdateWithoutPaymentInput,
    _i2.DiscountCodeUncheckedUpdateWithoutPaymentInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
  };
}

class PaymentUpdateWithoutAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentUpdateWithoutAppointmentInput({
    this.id,
    this.amount,
    this.currency,
    this.description,
    this.receiptUrl,
    this.paymentMethod,
    this.paymentIntent,
    this.paymentGateway,
    this.paymentStatus,
    this.expiresAt,
    this.createdAt,
    this.updatedAt,
    this.user,
    this.discountCode,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? amount;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? currency;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  receiptUrl;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  paymentMethod;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  paymentIntent;

  final _i1.PrismaUnion<
    _i3.PaymentGateway,
    _i2.EnumPaymentGatewayFieldUpdateOperationsInput
  >?
  paymentGateway;

  final _i1.PrismaUnion<
    _i3.PaymentStatus,
    _i2.EnumPaymentStatusFieldUpdateOperationsInput
  >?
  paymentStatus;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  expiresAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.UserUpdateOneRequiredWithoutPaymentNestedInput? user;

  final _i2.DiscountCodeUpdateOneWithoutPaymentNestedInput? discountCode;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'amount': amount,
    'currency': currency,
    'description': description,
    'receiptUrl': receiptUrl,
    'paymentMethod': paymentMethod,
    'paymentIntent': paymentIntent,
    'paymentGateway': paymentGateway,
    'paymentStatus': paymentStatus,
    'expiresAt': expiresAt,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'user': user,
    'discountCode': discountCode,
  };
}

class PaymentUpsertWithWhereUniqueWithoutAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentUpsertWithWhereUniqueWithoutAppointmentInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.PaymentWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.PaymentUpdateWithoutAppointmentInput,
    _i2.PaymentUncheckedUpdateWithoutAppointmentInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.PaymentCreateWithoutAppointmentInput,
    _i2.PaymentUncheckedCreateWithoutAppointmentInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'update': update,
    'create': create,
  };
}

class PaymentUpdateManyWithoutAppointmentNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentUpdateManyWithoutAppointmentNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.PaymentCreateWithoutAppointmentInput,
    _i1.PrismaUnion<
      Iterable<_i2.PaymentCreateWithoutAppointmentInput>,
      _i1.PrismaUnion<
        _i2.PaymentUncheckedCreateWithoutAppointmentInput,
        Iterable<_i2.PaymentUncheckedCreateWithoutAppointmentInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.PaymentCreateOrConnectWithoutAppointmentInput,
    Iterable<_i2.PaymentCreateOrConnectWithoutAppointmentInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.PaymentUpsertWithWhereUniqueWithoutAppointmentInput,
    Iterable<_i2.PaymentUpsertWithWhereUniqueWithoutAppointmentInput>
  >?
  upsert;

  final _i2.PaymentCreateManyAppointmentInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.PaymentWhereUniqueInput,
    Iterable<_i2.PaymentWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.PaymentWhereUniqueInput,
    Iterable<_i2.PaymentWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.PaymentWhereUniqueInput,
    Iterable<_i2.PaymentWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.PaymentWhereUniqueInput,
    Iterable<_i2.PaymentWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.PaymentUpdateWithWhereUniqueWithoutAppointmentInput,
    Iterable<_i2.PaymentUpdateWithWhereUniqueWithoutAppointmentInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.PaymentUpdateManyWithWhereWithoutAppointmentInput,
    Iterable<_i2.PaymentUpdateManyWithWhereWithoutAppointmentInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.PaymentScalarWhereInput,
    Iterable<_i2.PaymentScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class AppointmentUpdateWithoutWebinarInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentUpdateWithoutWebinarInput({
    this.id,
    this.appointmentType,
    this.createdAt,
    this.updatedAt,
    this.slotsOfAppointment,
    this.consultation,
    this.subscription,
    this.$class,
    this.payment,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    _i3.AppointmentsType,
    _i2.EnumAppointmentsTypeFieldUpdateOperationsInput
  >?
  appointmentType;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.SlotOfAppointmentUpdateManyWithoutAppointmentNestedInput?
  slotsOfAppointment;

  final _i2.ConsultationUpdateOneWithoutAppointmentNestedInput? consultation;

  final _i2.SubscriptionUpdateOneWithoutAppointmentsNestedInput? subscription;

  final _i2.ClassUpdateOneWithoutAppointmentsNestedInput? $class;

  final _i2.PaymentUpdateManyWithoutAppointmentNestedInput? payment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'appointmentType': appointmentType,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'slotsOfAppointment': slotsOfAppointment,
    'consultation': consultation,
    'subscription': subscription,
    'class': $class,
    'payment': payment,
  };
}

class AppointmentUpsertWithoutWebinarInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentUpsertWithoutWebinarInput({
    required this.update,
    required this.create,
  });

  final _i1.PrismaUnion<
    _i2.AppointmentUpdateWithoutWebinarInput,
    _i2.AppointmentUncheckedUpdateWithoutWebinarInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.AppointmentCreateWithoutWebinarInput,
    _i2.AppointmentUncheckedCreateWithoutWebinarInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'update': update, 'create': create};
}

class AppointmentUpdateOneWithoutWebinarNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentUpdateOneWithoutWebinarNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.AppointmentCreateWithoutWebinarInput,
    _i2.AppointmentUncheckedCreateWithoutWebinarInput
  >?
  create;

  final _i2.AppointmentCreateOrConnectWithoutWebinarInput? connectOrCreate;

  final _i2.AppointmentUpsertWithoutWebinarInput? upsert;

  final bool? disconnect;

  final bool? delete;

  final _i2.AppointmentWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.AppointmentUpdateWithoutWebinarInput,
    _i2.AppointmentUncheckedUpdateWithoutWebinarInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
  };
}

class WebinarUpdateWithoutWebinarPlanInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarUpdateWithoutWebinarPlanInput({
    this.id,
    this.status,
    this.feedbackSummary,
    this.createdAt,
    this.updatedAt,
    this.waitlist,
    this.appointment,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    _i3.WebinarStatus,
    _i2.EnumWebinarStatusFieldUpdateOperationsInput
  >?
  status;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackSummary;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.WaitlistUpdateManyWithoutWebinarNestedInput? waitlist;

  final _i2.AppointmentUpdateOneWithoutWebinarNestedInput? appointment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'status': status,
    'feedbackSummary': feedbackSummary,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'waitlist': waitlist,
    'appointment': appointment,
  };
}

class WebinarUpsertWithWhereUniqueWithoutWebinarPlanInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarUpsertWithWhereUniqueWithoutWebinarPlanInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.WebinarWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.WebinarUpdateWithoutWebinarPlanInput,
    _i2.WebinarUncheckedUpdateWithoutWebinarPlanInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.WebinarCreateWithoutWebinarPlanInput,
    _i2.WebinarUncheckedCreateWithoutWebinarPlanInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'update': update,
    'create': create,
  };
}

class WebinarUpdateManyWithoutWebinarPlanNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarUpdateManyWithoutWebinarPlanNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.WebinarCreateWithoutWebinarPlanInput,
    _i1.PrismaUnion<
      Iterable<_i2.WebinarCreateWithoutWebinarPlanInput>,
      _i1.PrismaUnion<
        _i2.WebinarUncheckedCreateWithoutWebinarPlanInput,
        Iterable<_i2.WebinarUncheckedCreateWithoutWebinarPlanInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.WebinarCreateOrConnectWithoutWebinarPlanInput,
    Iterable<_i2.WebinarCreateOrConnectWithoutWebinarPlanInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.WebinarUpsertWithWhereUniqueWithoutWebinarPlanInput,
    Iterable<_i2.WebinarUpsertWithWhereUniqueWithoutWebinarPlanInput>
  >?
  upsert;

  final _i2.WebinarCreateManyWebinarPlanInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.WebinarWhereUniqueInput,
    Iterable<_i2.WebinarWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.WebinarWhereUniqueInput,
    Iterable<_i2.WebinarWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.WebinarWhereUniqueInput,
    Iterable<_i2.WebinarWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.WebinarWhereUniqueInput,
    Iterable<_i2.WebinarWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.WebinarUpdateWithWhereUniqueWithoutWebinarPlanInput,
    Iterable<_i2.WebinarUpdateWithWhereUniqueWithoutWebinarPlanInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.WebinarUpdateManyWithWhereWithoutWebinarPlanInput,
    Iterable<_i2.WebinarUpdateManyWithWhereWithoutWebinarPlanInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.WebinarScalarWhereInput,
    Iterable<_i2.WebinarScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class WebinarPlanUpdateWithoutTopicsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanUpdateWithoutTopicsInput({
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInHours,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.createdAt,
    this.updatedAt,
    this.consultantProfile,
    this.webinars,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? price;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  priceCurrency;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
  certificateProvided;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
  durationInHours;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
  maxParticipants;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  language;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  level;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  prerequisites;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  materialProvided;

  final _i1.PrismaUnion<
    _i2.WebinarPlanUpdatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.ConsultantProfileUpdateOneWithoutWebinarPlansNestedInput?
  consultantProfile;

  final _i2.WebinarUpdateManyWithoutWebinarPlanNestedInput? webinars;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInHours': durationInHours,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultantProfile': consultantProfile,
    'webinars': webinars,
  };
}

class WebinarPlanUpsertWithWhereUniqueWithoutTopicsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanUpsertWithWhereUniqueWithoutTopicsInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.WebinarPlanWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.WebinarPlanUpdateWithoutTopicsInput,
    _i2.WebinarPlanUncheckedUpdateWithoutTopicsInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.WebinarPlanCreateWithoutTopicsInput,
    _i2.WebinarPlanUncheckedCreateWithoutTopicsInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'update': update,
    'create': create,
  };
}

class WebinarPlanUpdateManyWithoutTopicsNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanUpdateManyWithoutTopicsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.WebinarPlanCreateWithoutTopicsInput,
    _i1.PrismaUnion<
      Iterable<_i2.WebinarPlanCreateWithoutTopicsInput>,
      _i1.PrismaUnion<
        _i2.WebinarPlanUncheckedCreateWithoutTopicsInput,
        Iterable<_i2.WebinarPlanUncheckedCreateWithoutTopicsInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.WebinarPlanCreateOrConnectWithoutTopicsInput,
    Iterable<_i2.WebinarPlanCreateOrConnectWithoutTopicsInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.WebinarPlanUpsertWithWhereUniqueWithoutTopicsInput,
    Iterable<_i2.WebinarPlanUpsertWithWhereUniqueWithoutTopicsInput>
  >?
  upsert;

  final _i1.PrismaUnion<
    _i2.WebinarPlanWhereUniqueInput,
    Iterable<_i2.WebinarPlanWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.WebinarPlanWhereUniqueInput,
    Iterable<_i2.WebinarPlanWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.WebinarPlanWhereUniqueInput,
    Iterable<_i2.WebinarPlanWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.WebinarPlanWhereUniqueInput,
    Iterable<_i2.WebinarPlanWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.WebinarPlanUpdateWithWhereUniqueWithoutTopicsInput,
    Iterable<_i2.WebinarPlanUpdateWithWhereUniqueWithoutTopicsInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.WebinarPlanUpdateManyWithWhereWithoutTopicsInput,
    Iterable<_i2.WebinarPlanUpdateManyWithWhereWithoutTopicsInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.WebinarPlanScalarWhereInput,
    Iterable<_i2.WebinarPlanScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class TopicUpdateWithoutClassPlansInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TopicUpdateWithoutClassPlansInput({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
    this.webinarPlans,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.WebinarPlanUpdateManyWithoutTopicsNestedInput? webinarPlans;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'webinarPlans': webinarPlans,
  };
}

class TopicUpsertWithWhereUniqueWithoutClassPlansInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TopicUpsertWithWhereUniqueWithoutClassPlansInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.TopicWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.TopicUpdateWithoutClassPlansInput,
    _i2.TopicUncheckedUpdateWithoutClassPlansInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.TopicCreateWithoutClassPlansInput,
    _i2.TopicUncheckedCreateWithoutClassPlansInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'update': update,
    'create': create,
  };
}

class TopicUpdateManyWithoutClassPlansNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TopicUpdateManyWithoutClassPlansNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.TopicCreateWithoutClassPlansInput,
    _i1.PrismaUnion<
      Iterable<_i2.TopicCreateWithoutClassPlansInput>,
      _i1.PrismaUnion<
        _i2.TopicUncheckedCreateWithoutClassPlansInput,
        Iterable<_i2.TopicUncheckedCreateWithoutClassPlansInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.TopicCreateOrConnectWithoutClassPlansInput,
    Iterable<_i2.TopicCreateOrConnectWithoutClassPlansInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.TopicUpsertWithWhereUniqueWithoutClassPlansInput,
    Iterable<_i2.TopicUpsertWithWhereUniqueWithoutClassPlansInput>
  >?
  upsert;

  final _i1.PrismaUnion<
    _i2.TopicWhereUniqueInput,
    Iterable<_i2.TopicWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.TopicWhereUniqueInput,
    Iterable<_i2.TopicWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.TopicWhereUniqueInput,
    Iterable<_i2.TopicWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.TopicWhereUniqueInput,
    Iterable<_i2.TopicWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.TopicUpdateWithWhereUniqueWithoutClassPlansInput,
    Iterable<_i2.TopicUpdateWithWhereUniqueWithoutClassPlansInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.TopicUpdateManyWithWhereWithoutClassPlansInput,
    Iterable<_i2.TopicUpdateManyWithWhereWithoutClassPlansInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.TopicScalarWhereInput,
    Iterable<_i2.TopicScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class ClassUpdateManyWithoutClassPlanNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassUpdateManyWithoutClassPlanNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.ClassCreateWithoutClassPlanInput,
    _i1.PrismaUnion<
      Iterable<_i2.ClassCreateWithoutClassPlanInput>,
      _i1.PrismaUnion<
        _i2.ClassUncheckedCreateWithoutClassPlanInput,
        Iterable<_i2.ClassUncheckedCreateWithoutClassPlanInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.ClassCreateOrConnectWithoutClassPlanInput,
    Iterable<_i2.ClassCreateOrConnectWithoutClassPlanInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.ClassUpsertWithWhereUniqueWithoutClassPlanInput,
    Iterable<_i2.ClassUpsertWithWhereUniqueWithoutClassPlanInput>
  >?
  upsert;

  final _i2.ClassCreateManyClassPlanInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.ClassWhereUniqueInput,
    Iterable<_i2.ClassWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.ClassWhereUniqueInput,
    Iterable<_i2.ClassWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.ClassWhereUniqueInput,
    Iterable<_i2.ClassWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.ClassWhereUniqueInput,
    Iterable<_i2.ClassWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.ClassUpdateWithWhereUniqueWithoutClassPlanInput,
    Iterable<_i2.ClassUpdateWithWhereUniqueWithoutClassPlanInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.ClassUpdateManyWithWhereWithoutClassPlanInput,
    Iterable<_i2.ClassUpdateManyWithWhereWithoutClassPlanInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.ClassScalarWhereInput,
    Iterable<_i2.ClassScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class ClassPlanUpdateWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanUpdateWithoutConsultantProfileInput({
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInMonths,
    this.callsPerWeek,
    this.videoMeetings,
    this.emailSupport,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.createdAt,
    this.updatedAt,
    this.topics,
    this.classContents,
    this.classes,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  description;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? price;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  priceCurrency;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
  certificateProvided;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
  durationInMonths;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? callsPerWeek;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? videoMeetings;

  final _i1.PrismaUnion<
    _i3.PlanEmailSupport,
    _i2.EnumPlanEmailSupportFieldUpdateOperationsInput
  >?
  emailSupport;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
  maxParticipants;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  language;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  level;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  prerequisites;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  materialProvided;

  final _i1.PrismaUnion<
    _i2.ClassPlanUpdatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.TopicUpdateManyWithoutClassPlansNestedInput? topics;

  final _i2.ClassContentUpdateManyWithoutClassPlanNestedInput? classContents;

  final _i2.ClassUpdateManyWithoutClassPlanNestedInput? classes;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInMonths': durationInMonths,
    'callsPerWeek': callsPerWeek,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'topics': topics,
    'classContents': classContents,
    'classes': classes,
  };
}

class ClassPlanUpsertWithWhereUniqueWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanUpsertWithWhereUniqueWithoutConsultantProfileInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.ClassPlanWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.ClassPlanUpdateWithoutConsultantProfileInput,
    _i2.ClassPlanUncheckedUpdateWithoutConsultantProfileInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.ClassPlanCreateWithoutConsultantProfileInput,
    _i2.ClassPlanUncheckedCreateWithoutConsultantProfileInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'update': update,
    'create': create,
  };
}

class ClassPlanUpdateManyWithoutConsultantProfileNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanUpdateManyWithoutConsultantProfileNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.ClassPlanCreateWithoutConsultantProfileInput,
    _i1.PrismaUnion<
      Iterable<_i2.ClassPlanCreateWithoutConsultantProfileInput>,
      _i1.PrismaUnion<
        _i2.ClassPlanUncheckedCreateWithoutConsultantProfileInput,
        Iterable<_i2.ClassPlanUncheckedCreateWithoutConsultantProfileInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.ClassPlanCreateOrConnectWithoutConsultantProfileInput,
    Iterable<_i2.ClassPlanCreateOrConnectWithoutConsultantProfileInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.ClassPlanUpsertWithWhereUniqueWithoutConsultantProfileInput,
    Iterable<_i2.ClassPlanUpsertWithWhereUniqueWithoutConsultantProfileInput>
  >?
  upsert;

  final _i2.ClassPlanCreateManyConsultantProfileInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.ClassPlanWhereUniqueInput,
    Iterable<_i2.ClassPlanWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.ClassPlanWhereUniqueInput,
    Iterable<_i2.ClassPlanWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.ClassPlanWhereUniqueInput,
    Iterable<_i2.ClassPlanWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.ClassPlanWhereUniqueInput,
    Iterable<_i2.ClassPlanWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.ClassPlanUpdateWithWhereUniqueWithoutConsultantProfileInput,
    Iterable<_i2.ClassPlanUpdateWithWhereUniqueWithoutConsultantProfileInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.ClassPlanUpdateManyWithWhereWithoutConsultantProfileInput,
    Iterable<_i2.ClassPlanUpdateManyWithWhereWithoutConsultantProfileInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.ClassPlanScalarWhereInput,
    Iterable<_i2.ClassPlanScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class ConsultantProfileUpdateWithoutWebinarPlansInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUpdateWithoutWebinarPlansInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    this.scheduleType,
    this.createdAt,
    this.updatedAt,
    this.domain,
    this.subDomains,
    this.tags,
    this.reviews,
    this.slotsOfAvailabilityWeekly,
    this.slotsOfAvailabilityCustom,
    this.consultationPlans,
    this.subscriptionPlans,
    this.classPlans,
    this.user,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  qualifications;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  specialization;

  final _i1.PrismaUnion<
    double,
    _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  experience;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? rating;

  final _i1.PrismaUnion<
    _i3.ScheduleType,
    _i2.EnumScheduleTypeFieldUpdateOperationsInput
  >?
  scheduleType;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.DomainUpdateOneRequiredWithoutConsultantProfilesNestedInput? domain;

  final _i2.SubDomainUpdateManyWithoutConsultantProfilesNestedInput? subDomains;

  final _i2.TagUpdateManyWithoutConsultantProfilesNestedInput? tags;

  final _i2.ConsultantReviewUpdateManyWithoutConsultantProfileNestedInput?
  reviews;

  final _i2.SlotOfAvailabilityWeeklyUpdateManyWithoutConsultantProfileNestedInput?
  slotsOfAvailabilityWeekly;

  final _i2.SlotOfAvailabilityCustomUpdateManyWithoutConsultantProfileNestedInput?
  slotsOfAvailabilityCustom;

  final _i2.ConsultationPlanUpdateManyWithoutConsultantProfileNestedInput?
  consultationPlans;

  final _i2.SubscriptionPlanUpdateManyWithoutConsultantProfileNestedInput?
  subscriptionPlans;

  final _i2.ClassPlanUpdateManyWithoutConsultantProfileNestedInput? classPlans;

  final _i2.UserUpdateOneRequiredWithoutConsultantProfileNestedInput? user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'scheduleType': scheduleType,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'domain': domain,
    'subDomains': subDomains,
    'tags': tags,
    'reviews': reviews,
    'slotsOfAvailabilityWeekly': slotsOfAvailabilityWeekly,
    'slotsOfAvailabilityCustom': slotsOfAvailabilityCustom,
    'consultationPlans': consultationPlans,
    'subscriptionPlans': subscriptionPlans,
    'classPlans': classPlans,
    'user': user,
  };
}

class ConsultantProfileUncheckedUpdateWithoutWebinarPlansInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUncheckedUpdateWithoutWebinarPlansInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    this.domainId,
    this.scheduleType,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.subDomains,
    this.tags,
    this.reviews,
    this.slotsOfAvailabilityWeekly,
    this.slotsOfAvailabilityCustom,
    this.consultationPlans,
    this.subscriptionPlans,
    this.classPlans,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  qualifications;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  specialization;

  final _i1.PrismaUnion<
    double,
    _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  experience;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? rating;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? domainId;

  final _i1.PrismaUnion<
    _i3.ScheduleType,
    _i2.EnumScheduleTypeFieldUpdateOperationsInput
  >?
  scheduleType;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.SubDomainUncheckedUpdateManyWithoutConsultantProfilesNestedInput?
  subDomains;

  final _i2.TagUncheckedUpdateManyWithoutConsultantProfilesNestedInput? tags;

  final _i2.ConsultantReviewUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  reviews;

  final _i2.SlotOfAvailabilityWeeklyUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  slotsOfAvailabilityWeekly;

  final _i2.SlotOfAvailabilityCustomUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  slotsOfAvailabilityCustom;

  final _i2.ConsultationPlanUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  consultationPlans;

  final _i2.SubscriptionPlanUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  subscriptionPlans;

  final _i2.ClassPlanUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  classPlans;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'domainId': domainId,
    'scheduleType': scheduleType,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'subDomains': subDomains,
    'tags': tags,
    'reviews': reviews,
    'slotsOfAvailabilityWeekly': slotsOfAvailabilityWeekly,
    'slotsOfAvailabilityCustom': slotsOfAvailabilityCustom,
    'consultationPlans': consultationPlans,
    'subscriptionPlans': subscriptionPlans,
    'classPlans': classPlans,
  };
}

class ConsultantProfileUpsertWithoutWebinarPlansInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUpsertWithoutWebinarPlansInput({
    required this.update,
    required this.create,
  });

  final _i1.PrismaUnion<
    _i2.ConsultantProfileUpdateWithoutWebinarPlansInput,
    _i2.ConsultantProfileUncheckedUpdateWithoutWebinarPlansInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateWithoutWebinarPlansInput,
    _i2.ConsultantProfileUncheckedCreateWithoutWebinarPlansInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'update': update, 'create': create};
}

class ConsultantProfileUpdateOneWithoutWebinarPlansNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUpdateOneWithoutWebinarPlansNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateWithoutWebinarPlansInput,
    _i2.ConsultantProfileUncheckedCreateWithoutWebinarPlansInput
  >?
  create;

  final _i2.ConsultantProfileCreateOrConnectWithoutWebinarPlansInput?
  connectOrCreate;

  final _i2.ConsultantProfileUpsertWithoutWebinarPlansInput? upsert;

  final bool? disconnect;

  final bool? delete;

  final _i2.ConsultantProfileWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileUpdateWithoutWebinarPlansInput,
    _i2.ConsultantProfileUncheckedUpdateWithoutWebinarPlansInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
  };
}

class WebinarPlanUpdateWithoutWebinarsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanUpdateWithoutWebinarsInput({
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInHours,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.createdAt,
    this.updatedAt,
    this.topics,
    this.consultantProfile,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? price;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  priceCurrency;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
  certificateProvided;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
  durationInHours;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
  maxParticipants;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  language;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  level;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  prerequisites;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  materialProvided;

  final _i1.PrismaUnion<
    _i2.WebinarPlanUpdatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.TopicUpdateManyWithoutWebinarPlansNestedInput? topics;

  final _i2.ConsultantProfileUpdateOneWithoutWebinarPlansNestedInput?
  consultantProfile;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInHours': durationInHours,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'topics': topics,
    'consultantProfile': consultantProfile,
  };
}

class WebinarPlanUncheckedUpdateWithoutWebinarsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanUncheckedUpdateWithoutWebinarsInput({
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInHours,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.topics,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? price;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  priceCurrency;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
  certificateProvided;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
  durationInHours;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
  maxParticipants;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  language;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  level;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  prerequisites;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  materialProvided;

  final _i1.PrismaUnion<
    _i2.WebinarPlanUpdatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consultantProfileId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.TopicUncheckedUpdateManyWithoutWebinarPlansNestedInput? topics;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInHours': durationInHours,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'topics': topics,
  };
}

class WebinarPlanUpsertWithoutWebinarsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanUpsertWithoutWebinarsInput({
    required this.update,
    required this.create,
  });

  final _i1.PrismaUnion<
    _i2.WebinarPlanUpdateWithoutWebinarsInput,
    _i2.WebinarPlanUncheckedUpdateWithoutWebinarsInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.WebinarPlanCreateWithoutWebinarsInput,
    _i2.WebinarPlanUncheckedCreateWithoutWebinarsInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'update': update, 'create': create};
}

class WebinarPlanUpdateOneRequiredWithoutWebinarsNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanUpdateOneRequiredWithoutWebinarsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.WebinarPlanCreateWithoutWebinarsInput,
    _i2.WebinarPlanUncheckedCreateWithoutWebinarsInput
  >?
  create;

  final _i2.WebinarPlanCreateOrConnectWithoutWebinarsInput? connectOrCreate;

  final _i2.WebinarPlanUpsertWithoutWebinarsInput? upsert;

  final _i2.WebinarPlanWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.WebinarPlanUpdateWithoutWebinarsInput,
    _i2.WebinarPlanUncheckedUpdateWithoutWebinarsInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'connect': connect,
    'update': update,
  };
}

class WebinarUpdateWithoutWaitlistInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarUpdateWithoutWaitlistInput({
    this.id,
    this.status,
    this.feedbackSummary,
    this.createdAt,
    this.updatedAt,
    this.webinarPlan,
    this.appointment,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    _i3.WebinarStatus,
    _i2.EnumWebinarStatusFieldUpdateOperationsInput
  >?
  status;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackSummary;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.WebinarPlanUpdateOneRequiredWithoutWebinarsNestedInput? webinarPlan;

  final _i2.AppointmentUpdateOneWithoutWebinarNestedInput? appointment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'status': status,
    'feedbackSummary': feedbackSummary,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'webinarPlan': webinarPlan,
    'appointment': appointment,
  };
}

class WebinarUncheckedUpdateWithoutWaitlistInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarUncheckedUpdateWithoutWaitlistInput({
    this.id,
    this.status,
    this.feedbackSummary,
    this.webinarPlanId,
    this.createdAt,
    this.updatedAt,
    this.appointment,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    _i3.WebinarStatus,
    _i2.EnumWebinarStatusFieldUpdateOperationsInput
  >?
  status;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackSummary;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  webinarPlanId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.AppointmentUncheckedUpdateOneWithoutWebinarNestedInput? appointment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'status': status,
    'feedbackSummary': feedbackSummary,
    'webinarPlanId': webinarPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'appointment': appointment,
  };
}

class WebinarUpsertWithoutWaitlistInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarUpsertWithoutWaitlistInput({
    required this.update,
    required this.create,
  });

  final _i1.PrismaUnion<
    _i2.WebinarUpdateWithoutWaitlistInput,
    _i2.WebinarUncheckedUpdateWithoutWaitlistInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.WebinarCreateWithoutWaitlistInput,
    _i2.WebinarUncheckedCreateWithoutWaitlistInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'update': update, 'create': create};
}

class WebinarUpdateOneWithoutWaitlistNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarUpdateOneWithoutWaitlistNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.WebinarCreateWithoutWaitlistInput,
    _i2.WebinarUncheckedCreateWithoutWaitlistInput
  >?
  create;

  final _i2.WebinarCreateOrConnectWithoutWaitlistInput? connectOrCreate;

  final _i2.WebinarUpsertWithoutWaitlistInput? upsert;

  final bool? disconnect;

  final bool? delete;

  final _i2.WebinarWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.WebinarUpdateWithoutWaitlistInput,
    _i2.WebinarUncheckedUpdateWithoutWaitlistInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
  };
}

class WaitlistUpdateWithoutClassInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistUpdateWithoutClassInput({
    this.id,
    this.joinedAt,
    this.user,
    this.webinar,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  joinedAt;

  final _i2.UserUpdateOneRequiredWithoutWaitlistNestedInput? user;

  final _i2.WebinarUpdateOneWithoutWaitlistNestedInput? webinar;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'joinedAt': joinedAt,
    'user': user,
    'webinar': webinar,
  };
}

class WaitlistUpsertWithWhereUniqueWithoutClassInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistUpsertWithWhereUniqueWithoutClassInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.WaitlistWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.WaitlistUpdateWithoutClassInput,
    _i2.WaitlistUncheckedUpdateWithoutClassInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.WaitlistCreateWithoutClassInput,
    _i2.WaitlistUncheckedCreateWithoutClassInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'update': update,
    'create': create,
  };
}

class WaitlistUpdateManyWithoutClassNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistUpdateManyWithoutClassNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.WaitlistCreateWithoutClassInput,
    _i1.PrismaUnion<
      Iterable<_i2.WaitlistCreateWithoutClassInput>,
      _i1.PrismaUnion<
        _i2.WaitlistUncheckedCreateWithoutClassInput,
        Iterable<_i2.WaitlistUncheckedCreateWithoutClassInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.WaitlistCreateOrConnectWithoutClassInput,
    Iterable<_i2.WaitlistCreateOrConnectWithoutClassInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.WaitlistUpsertWithWhereUniqueWithoutClassInput,
    Iterable<_i2.WaitlistUpsertWithWhereUniqueWithoutClassInput>
  >?
  upsert;

  final _i2.WaitlistCreateManyClassInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.WaitlistWhereUniqueInput,
    Iterable<_i2.WaitlistWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.WaitlistWhereUniqueInput,
    Iterable<_i2.WaitlistWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.WaitlistWhereUniqueInput,
    Iterable<_i2.WaitlistWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.WaitlistWhereUniqueInput,
    Iterable<_i2.WaitlistWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.WaitlistUpdateWithWhereUniqueWithoutClassInput,
    Iterable<_i2.WaitlistUpdateWithWhereUniqueWithoutClassInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.WaitlistUpdateManyWithWhereWithoutClassInput,
    Iterable<_i2.WaitlistUpdateManyWithWhereWithoutClassInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.WaitlistScalarWhereInput,
    Iterable<_i2.WaitlistScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class ClassUpdateWithoutAppointmentsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassUpdateWithoutAppointmentsInput({
    this.id,
    this.startDate,
    this.endDate,
    this.status,
    this.recordingUrls,
    this.feedbackSummary,
    this.createdAt,
    this.updatedAt,
    this.waitlist,
    this.classPlan,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  startDate;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  endDate;

  final _i1.PrismaUnion<
    _i3.ClassStatus,
    _i2.EnumClassStatusFieldUpdateOperationsInput
  >?
  status;

  final _i1.PrismaUnion<_i2.ClassUpdaterecordingUrlsInput, Iterable<String>>?
  recordingUrls;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackSummary;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.WaitlistUpdateManyWithoutClassNestedInput? waitlist;

  final _i2.ClassPlanUpdateOneRequiredWithoutClassesNestedInput? classPlan;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'status': status,
    'recordingUrls': recordingUrls,
    'feedbackSummary': feedbackSummary,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'waitlist': waitlist,
    'classPlan': classPlan,
  };
}

class ClassUncheckedUpdateWithoutAppointmentsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassUncheckedUpdateWithoutAppointmentsInput({
    this.id,
    this.startDate,
    this.endDate,
    this.status,
    this.recordingUrls,
    this.feedbackSummary,
    this.classPlanId,
    this.createdAt,
    this.updatedAt,
    this.waitlist,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  startDate;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  endDate;

  final _i1.PrismaUnion<
    _i3.ClassStatus,
    _i2.EnumClassStatusFieldUpdateOperationsInput
  >?
  status;

  final _i1.PrismaUnion<_i2.ClassUpdaterecordingUrlsInput, Iterable<String>>?
  recordingUrls;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackSummary;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  classPlanId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.WaitlistUncheckedUpdateManyWithoutClassNestedInput? waitlist;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'status': status,
    'recordingUrls': recordingUrls,
    'feedbackSummary': feedbackSummary,
    'classPlanId': classPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'waitlist': waitlist,
  };
}

class ClassUpsertWithoutAppointmentsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassUpsertWithoutAppointmentsInput({
    required this.update,
    required this.create,
  });

  final _i1.PrismaUnion<
    _i2.ClassUpdateWithoutAppointmentsInput,
    _i2.ClassUncheckedUpdateWithoutAppointmentsInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.ClassCreateWithoutAppointmentsInput,
    _i2.ClassUncheckedCreateWithoutAppointmentsInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'update': update, 'create': create};
}

class ClassUpdateOneWithoutAppointmentsNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassUpdateOneWithoutAppointmentsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.ClassCreateWithoutAppointmentsInput,
    _i2.ClassUncheckedCreateWithoutAppointmentsInput
  >?
  create;

  final _i2.ClassCreateOrConnectWithoutAppointmentsInput? connectOrCreate;

  final _i2.ClassUpsertWithoutAppointmentsInput? upsert;

  final bool? disconnect;

  final bool? delete;

  final _i2.ClassWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.ClassUpdateWithoutAppointmentsInput,
    _i2.ClassUncheckedUpdateWithoutAppointmentsInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
  };
}

class AppointmentUpdateWithoutSlotsOfAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentUpdateWithoutSlotsOfAppointmentInput({
    this.id,
    this.appointmentType,
    this.createdAt,
    this.updatedAt,
    this.consultation,
    this.subscription,
    this.webinar,
    this.$class,
    this.payment,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    _i3.AppointmentsType,
    _i2.EnumAppointmentsTypeFieldUpdateOperationsInput
  >?
  appointmentType;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.ConsultationUpdateOneWithoutAppointmentNestedInput? consultation;

  final _i2.SubscriptionUpdateOneWithoutAppointmentsNestedInput? subscription;

  final _i2.WebinarUpdateOneWithoutAppointmentNestedInput? webinar;

  final _i2.ClassUpdateOneWithoutAppointmentsNestedInput? $class;

  final _i2.PaymentUpdateManyWithoutAppointmentNestedInput? payment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'appointmentType': appointmentType,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultation': consultation,
    'subscription': subscription,
    'webinar': webinar,
    'class': $class,
    'payment': payment,
  };
}

class AppointmentUncheckedUpdateWithoutSlotsOfAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentUncheckedUpdateWithoutSlotsOfAppointmentInput({
    this.id,
    this.appointmentType,
    this.consultationId,
    this.subscriptionId,
    this.webinarId,
    this.classId,
    this.createdAt,
    this.updatedAt,
    this.payment,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    _i3.AppointmentsType,
    _i2.EnumAppointmentsTypeFieldUpdateOperationsInput
  >?
  appointmentType;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consultationId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  subscriptionId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  webinarId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  classId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.PaymentUncheckedUpdateManyWithoutAppointmentNestedInput? payment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'appointmentType': appointmentType,
    'consultationId': consultationId,
    'subscriptionId': subscriptionId,
    'webinarId': webinarId,
    'classId': classId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'payment': payment,
  };
}

class AppointmentUpsertWithoutSlotsOfAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentUpsertWithoutSlotsOfAppointmentInput({
    required this.update,
    required this.create,
  });

  final _i1.PrismaUnion<
    _i2.AppointmentUpdateWithoutSlotsOfAppointmentInput,
    _i2.AppointmentUncheckedUpdateWithoutSlotsOfAppointmentInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.AppointmentCreateWithoutSlotsOfAppointmentInput,
    _i2.AppointmentUncheckedCreateWithoutSlotsOfAppointmentInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'update': update, 'create': create};
}

class AppointmentUpdateOneRequiredWithoutSlotsOfAppointmentNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentUpdateOneRequiredWithoutSlotsOfAppointmentNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.AppointmentCreateWithoutSlotsOfAppointmentInput,
    _i2.AppointmentUncheckedCreateWithoutSlotsOfAppointmentInput
  >?
  create;

  final _i2.AppointmentCreateOrConnectWithoutSlotsOfAppointmentInput?
  connectOrCreate;

  final _i2.AppointmentUpsertWithoutSlotsOfAppointmentInput? upsert;

  final _i2.AppointmentWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.AppointmentUpdateWithoutSlotsOfAppointmentInput,
    _i2.AppointmentUncheckedUpdateWithoutSlotsOfAppointmentInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'connect': connect,
    'update': update,
  };
}

class MeetingSessionUpdateOneWithoutSlotOfAppointmentNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const MeetingSessionUpdateOneWithoutSlotOfAppointmentNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.MeetingSessionCreateWithoutSlotOfAppointmentInput,
    _i2.MeetingSessionUncheckedCreateWithoutSlotOfAppointmentInput
  >?
  create;

  final _i2.MeetingSessionCreateOrConnectWithoutSlotOfAppointmentInput?
  connectOrCreate;

  final _i2.MeetingSessionUpsertWithoutSlotOfAppointmentInput? upsert;

  final bool? disconnect;

  final bool? delete;

  final _i2.MeetingSessionWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.MeetingSessionUpdateWithoutSlotOfAppointmentInput,
    _i2.MeetingSessionUncheckedUpdateWithoutSlotOfAppointmentInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
  };
}

class SlotOfAppointmentUpdateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentUpdateWithoutUserInput({
    this.id,
    this.slotStartTimeInUTC,
    this.slotEndTimeInUTC,
    this.isTentative,
    this.createdAt,
    this.updatedAt,
    this.appointment,
    this.meetingSession,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  slotStartTimeInUTC;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  slotEndTimeInUTC;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? isTentative;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.AppointmentUpdateOneRequiredWithoutSlotsOfAppointmentNestedInput?
  appointment;

  final _i2.MeetingSessionUpdateOneWithoutSlotOfAppointmentNestedInput?
  meetingSession;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'isTentative': isTentative,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'appointment': appointment,
    'meetingSession': meetingSession,
  };
}

class SlotOfAppointmentUpsertWithWhereUniqueWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentUpsertWithWhereUniqueWithoutUserInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.SlotOfAppointmentWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentUpdateWithoutUserInput,
    _i2.SlotOfAppointmentUncheckedUpdateWithoutUserInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentCreateWithoutUserInput,
    _i2.SlotOfAppointmentUncheckedCreateWithoutUserInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'update': update,
    'create': create,
  };
}

class SlotOfAppointmentUpdateManyWithoutUserNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentUpdateManyWithoutUserNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentCreateWithoutUserInput,
    _i1.PrismaUnion<
      Iterable<_i2.SlotOfAppointmentCreateWithoutUserInput>,
      _i1.PrismaUnion<
        _i2.SlotOfAppointmentUncheckedCreateWithoutUserInput,
        Iterable<_i2.SlotOfAppointmentUncheckedCreateWithoutUserInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentCreateOrConnectWithoutUserInput,
    Iterable<_i2.SlotOfAppointmentCreateOrConnectWithoutUserInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentUpsertWithWhereUniqueWithoutUserInput,
    Iterable<_i2.SlotOfAppointmentUpsertWithWhereUniqueWithoutUserInput>
  >?
  upsert;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentWhereUniqueInput,
    Iterable<_i2.SlotOfAppointmentWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentWhereUniqueInput,
    Iterable<_i2.SlotOfAppointmentWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentWhereUniqueInput,
    Iterable<_i2.SlotOfAppointmentWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentWhereUniqueInput,
    Iterable<_i2.SlotOfAppointmentWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentUpdateWithWhereUniqueWithoutUserInput,
    Iterable<_i2.SlotOfAppointmentUpdateWithWhereUniqueWithoutUserInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentUpdateManyWithWhereWithoutUserInput,
    Iterable<_i2.SlotOfAppointmentUpdateManyWithWhereWithoutUserInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentScalarWhereInput,
    Iterable<_i2.SlotOfAppointmentScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class UserUpdateWithoutWaitlistInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpdateWithoutWaitlistInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.cookiePreferences,
    this.notificationPreferences,
    this.payment,
    this.consultantProfile,
    this.consulteeProfile,
    this.staffProfile,
    this.slotsOfAppointment,
    this.feedbacks,
    this.supportTickets,
    this.supportResponses,
    this.accounts,
    this.sessions,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  name;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  email;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  emailVerified;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  image;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  phone;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  address;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  password;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetToken;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetExpires;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? onlineStatus;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  currentTimezone;

  final _i1.PrismaUnion<
    bool,
    _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  onboardingCompleted;

  final _i1.PrismaUnion<
    _i3.UserRole,
    _i1.PrismaUnion<
      _i2.NullableEnumUserRoleFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  role;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consultantProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consulteeProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  staffProfileId;

  final _i2.CookiePreferenceUpdateOneWithoutUserNestedInput? cookiePreferences;

  final _i2.NotificationPreferenceUpdateOneWithoutUserNestedInput?
  notificationPreferences;

  final _i2.PaymentUpdateManyWithoutUserNestedInput? payment;

  final _i2.ConsultantProfileUpdateOneWithoutUserNestedInput? consultantProfile;

  final _i2.ConsulteeProfileUpdateOneWithoutUserNestedInput? consulteeProfile;

  final _i2.StaffProfileUpdateOneWithoutUserNestedInput? staffProfile;

  final _i2.SlotOfAppointmentUpdateManyWithoutUserNestedInput?
  slotsOfAppointment;

  final _i2.FeedbackUpdateManyWithoutUserNestedInput? feedbacks;

  final _i2.SupportTicketUpdateManyWithoutUserNestedInput? supportTickets;

  final _i2.SupportResponseUpdateManyWithoutUserNestedInput? supportResponses;

  final _i2.AccountUpdateManyWithoutUserNestedInput? accounts;

  final _i2.SessionUpdateManyWithoutUserNestedInput? sessions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'cookiePreferences': cookiePreferences,
    'notificationPreferences': notificationPreferences,
    'Payment': payment,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
    'staffProfile': staffProfile,
    'slotsOfAppointment': slotsOfAppointment,
    'feedbacks': feedbacks,
    'supportTickets': supportTickets,
    'supportResponses': supportResponses,
    'accounts': accounts,
    'sessions': sessions,
  };
}

class UserUncheckedUpdateWithoutWaitlistInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUncheckedUpdateWithoutWaitlistInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.cookiePreferences,
    this.notificationPreferences,
    this.payment,
    this.consultantProfile,
    this.consulteeProfile,
    this.staffProfile,
    this.slotsOfAppointment,
    this.feedbacks,
    this.supportTickets,
    this.supportResponses,
    this.accounts,
    this.sessions,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  name;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  email;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  emailVerified;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  image;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  phone;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  address;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  password;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetToken;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetExpires;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? onlineStatus;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  currentTimezone;

  final _i1.PrismaUnion<
    bool,
    _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  onboardingCompleted;

  final _i1.PrismaUnion<
    _i3.UserRole,
    _i1.PrismaUnion<
      _i2.NullableEnumUserRoleFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  role;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consultantProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consulteeProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  staffProfileId;

  final _i2.CookiePreferenceUncheckedUpdateOneWithoutUserNestedInput?
  cookiePreferences;

  final _i2.NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput?
  notificationPreferences;

  final _i2.PaymentUncheckedUpdateManyWithoutUserNestedInput? payment;

  final _i2.ConsultantProfileUncheckedUpdateOneWithoutUserNestedInput?
  consultantProfile;

  final _i2.ConsulteeProfileUncheckedUpdateOneWithoutUserNestedInput?
  consulteeProfile;

  final _i2.StaffProfileUncheckedUpdateOneWithoutUserNestedInput? staffProfile;

  final _i2.SlotOfAppointmentUncheckedUpdateManyWithoutUserNestedInput?
  slotsOfAppointment;

  final _i2.FeedbackUncheckedUpdateManyWithoutUserNestedInput? feedbacks;

  final _i2.SupportTicketUncheckedUpdateManyWithoutUserNestedInput?
  supportTickets;

  final _i2.SupportResponseUncheckedUpdateManyWithoutUserNestedInput?
  supportResponses;

  final _i2.AccountUncheckedUpdateManyWithoutUserNestedInput? accounts;

  final _i2.SessionUncheckedUpdateManyWithoutUserNestedInput? sessions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'cookiePreferences': cookiePreferences,
    'notificationPreferences': notificationPreferences,
    'Payment': payment,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
    'staffProfile': staffProfile,
    'slotsOfAppointment': slotsOfAppointment,
    'feedbacks': feedbacks,
    'supportTickets': supportTickets,
    'supportResponses': supportResponses,
    'accounts': accounts,
    'sessions': sessions,
  };
}

class UserUpsertWithoutWaitlistInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpsertWithoutWaitlistInput({
    required this.update,
    required this.create,
  });

  final _i1.PrismaUnion<
    _i2.UserUpdateWithoutWaitlistInput,
    _i2.UserUncheckedUpdateWithoutWaitlistInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.UserCreateWithoutWaitlistInput,
    _i2.UserUncheckedCreateWithoutWaitlistInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'update': update, 'create': create};
}

class UserUpdateOneRequiredWithoutWaitlistNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpdateOneRequiredWithoutWaitlistNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.UserCreateWithoutWaitlistInput,
    _i2.UserUncheckedCreateWithoutWaitlistInput
  >?
  create;

  final _i2.UserCreateOrConnectWithoutWaitlistInput? connectOrCreate;

  final _i2.UserUpsertWithoutWaitlistInput? upsert;

  final _i2.UserWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.UserUpdateWithoutWaitlistInput,
    _i2.UserUncheckedUpdateWithoutWaitlistInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'connect': connect,
    'update': update,
  };
}

class WaitlistUpdateWithoutWebinarInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistUpdateWithoutWebinarInput({
    this.id,
    this.joinedAt,
    this.user,
    this.$class,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  joinedAt;

  final _i2.UserUpdateOneRequiredWithoutWaitlistNestedInput? user;

  final _i2.ClassUpdateOneWithoutWaitlistNestedInput? $class;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'joinedAt': joinedAt,
    'user': user,
    'class': $class,
  };
}

class WaitlistUpsertWithWhereUniqueWithoutWebinarInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistUpsertWithWhereUniqueWithoutWebinarInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.WaitlistWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.WaitlistUpdateWithoutWebinarInput,
    _i2.WaitlistUncheckedUpdateWithoutWebinarInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.WaitlistCreateWithoutWebinarInput,
    _i2.WaitlistUncheckedCreateWithoutWebinarInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'update': update,
    'create': create,
  };
}

class WaitlistUpdateManyWithoutWebinarNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistUpdateManyWithoutWebinarNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.WaitlistCreateWithoutWebinarInput,
    _i1.PrismaUnion<
      Iterable<_i2.WaitlistCreateWithoutWebinarInput>,
      _i1.PrismaUnion<
        _i2.WaitlistUncheckedCreateWithoutWebinarInput,
        Iterable<_i2.WaitlistUncheckedCreateWithoutWebinarInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.WaitlistCreateOrConnectWithoutWebinarInput,
    Iterable<_i2.WaitlistCreateOrConnectWithoutWebinarInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.WaitlistUpsertWithWhereUniqueWithoutWebinarInput,
    Iterable<_i2.WaitlistUpsertWithWhereUniqueWithoutWebinarInput>
  >?
  upsert;

  final _i2.WaitlistCreateManyWebinarInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.WaitlistWhereUniqueInput,
    Iterable<_i2.WaitlistWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.WaitlistWhereUniqueInput,
    Iterable<_i2.WaitlistWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.WaitlistWhereUniqueInput,
    Iterable<_i2.WaitlistWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.WaitlistWhereUniqueInput,
    Iterable<_i2.WaitlistWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.WaitlistUpdateWithWhereUniqueWithoutWebinarInput,
    Iterable<_i2.WaitlistUpdateWithWhereUniqueWithoutWebinarInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.WaitlistUpdateManyWithWhereWithoutWebinarInput,
    Iterable<_i2.WaitlistUpdateManyWithWhereWithoutWebinarInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.WaitlistScalarWhereInput,
    Iterable<_i2.WaitlistScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class WebinarUpdateWithoutAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarUpdateWithoutAppointmentInput({
    this.id,
    this.status,
    this.feedbackSummary,
    this.createdAt,
    this.updatedAt,
    this.waitlist,
    this.webinarPlan,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    _i3.WebinarStatus,
    _i2.EnumWebinarStatusFieldUpdateOperationsInput
  >?
  status;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackSummary;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.WaitlistUpdateManyWithoutWebinarNestedInput? waitlist;

  final _i2.WebinarPlanUpdateOneRequiredWithoutWebinarsNestedInput? webinarPlan;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'status': status,
    'feedbackSummary': feedbackSummary,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'waitlist': waitlist,
    'webinarPlan': webinarPlan,
  };
}

class WebinarUncheckedUpdateWithoutAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarUncheckedUpdateWithoutAppointmentInput({
    this.id,
    this.status,
    this.feedbackSummary,
    this.webinarPlanId,
    this.createdAt,
    this.updatedAt,
    this.waitlist,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    _i3.WebinarStatus,
    _i2.EnumWebinarStatusFieldUpdateOperationsInput
  >?
  status;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackSummary;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  webinarPlanId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.WaitlistUncheckedUpdateManyWithoutWebinarNestedInput? waitlist;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'status': status,
    'feedbackSummary': feedbackSummary,
    'webinarPlanId': webinarPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'waitlist': waitlist,
  };
}

class WebinarUpsertWithoutAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarUpsertWithoutAppointmentInput({
    required this.update,
    required this.create,
  });

  final _i1.PrismaUnion<
    _i2.WebinarUpdateWithoutAppointmentInput,
    _i2.WebinarUncheckedUpdateWithoutAppointmentInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.WebinarCreateWithoutAppointmentInput,
    _i2.WebinarUncheckedCreateWithoutAppointmentInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'update': update, 'create': create};
}

class WebinarUpdateOneWithoutAppointmentNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarUpdateOneWithoutAppointmentNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.WebinarCreateWithoutAppointmentInput,
    _i2.WebinarUncheckedCreateWithoutAppointmentInput
  >?
  create;

  final _i2.WebinarCreateOrConnectWithoutAppointmentInput? connectOrCreate;

  final _i2.WebinarUpsertWithoutAppointmentInput? upsert;

  final bool? disconnect;

  final bool? delete;

  final _i2.WebinarWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.WebinarUpdateWithoutAppointmentInput,
    _i2.WebinarUncheckedUpdateWithoutAppointmentInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
  };
}

class AppointmentUpdateWithoutConsultationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentUpdateWithoutConsultationInput({
    this.id,
    this.appointmentType,
    this.createdAt,
    this.updatedAt,
    this.slotsOfAppointment,
    this.subscription,
    this.webinar,
    this.$class,
    this.payment,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    _i3.AppointmentsType,
    _i2.EnumAppointmentsTypeFieldUpdateOperationsInput
  >?
  appointmentType;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.SlotOfAppointmentUpdateManyWithoutAppointmentNestedInput?
  slotsOfAppointment;

  final _i2.SubscriptionUpdateOneWithoutAppointmentsNestedInput? subscription;

  final _i2.WebinarUpdateOneWithoutAppointmentNestedInput? webinar;

  final _i2.ClassUpdateOneWithoutAppointmentsNestedInput? $class;

  final _i2.PaymentUpdateManyWithoutAppointmentNestedInput? payment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'appointmentType': appointmentType,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'slotsOfAppointment': slotsOfAppointment,
    'subscription': subscription,
    'webinar': webinar,
    'class': $class,
    'payment': payment,
  };
}

class AppointmentUncheckedUpdateWithoutConsultationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentUncheckedUpdateWithoutConsultationInput({
    this.id,
    this.appointmentType,
    this.subscriptionId,
    this.webinarId,
    this.classId,
    this.createdAt,
    this.updatedAt,
    this.slotsOfAppointment,
    this.payment,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    _i3.AppointmentsType,
    _i2.EnumAppointmentsTypeFieldUpdateOperationsInput
  >?
  appointmentType;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  subscriptionId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  webinarId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  classId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.SlotOfAppointmentUncheckedUpdateManyWithoutAppointmentNestedInput?
  slotsOfAppointment;

  final _i2.PaymentUncheckedUpdateManyWithoutAppointmentNestedInput? payment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'appointmentType': appointmentType,
    'subscriptionId': subscriptionId,
    'webinarId': webinarId,
    'classId': classId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'slotsOfAppointment': slotsOfAppointment,
    'payment': payment,
  };
}

class AppointmentUpsertWithoutConsultationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentUpsertWithoutConsultationInput({
    required this.update,
    required this.create,
  });

  final _i1.PrismaUnion<
    _i2.AppointmentUpdateWithoutConsultationInput,
    _i2.AppointmentUncheckedUpdateWithoutConsultationInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.AppointmentCreateWithoutConsultationInput,
    _i2.AppointmentUncheckedCreateWithoutConsultationInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'update': update, 'create': create};
}

class AppointmentUncheckedUpdateOneWithoutConsultationNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentUncheckedUpdateOneWithoutConsultationNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.AppointmentCreateWithoutConsultationInput,
    _i2.AppointmentUncheckedCreateWithoutConsultationInput
  >?
  create;

  final _i2.AppointmentCreateOrConnectWithoutConsultationInput? connectOrCreate;

  final _i2.AppointmentUpsertWithoutConsultationInput? upsert;

  final bool? disconnect;

  final bool? delete;

  final _i2.AppointmentWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.AppointmentUpdateWithoutConsultationInput,
    _i2.AppointmentUncheckedUpdateWithoutConsultationInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
  };
}

class ConsultationUncheckedUpdateWithoutRequestedByInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationUncheckedUpdateWithoutRequestedByInput({
    this.id,
    this.consultationPlanId,
    this.requestStatus,
    this.requestedAt,
    this.requestNotes,
    this.directlyBooked,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.createdAt,
    this.updatedAt,
    this.appointment,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  consultationPlanId;

  final _i1.PrismaUnion<
    _i3.RequestStatus,
    _i2.EnumRequestStatusFieldUpdateOperationsInput
  >?
  requestStatus;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  requestedAt;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  requestNotes;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
  directlyBooked;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackFromConsultee;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackFromConsultant;

  final _i1.PrismaUnion<
    double,
    _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  rating;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.AppointmentUncheckedUpdateOneWithoutConsultationNestedInput?
  appointment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'consultationPlanId': consultationPlanId,
    'requestStatus': requestStatus,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'directlyBooked': directlyBooked,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'appointment': appointment,
  };
}

class ConsultationUpdateWithWhereUniqueWithoutRequestedByInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationUpdateWithWhereUniqueWithoutRequestedByInput({
    required this.where,
    required this.data,
  });

  final _i2.ConsultationWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.ConsultationUpdateWithoutRequestedByInput,
    _i2.ConsultationUncheckedUpdateWithoutRequestedByInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class ConsultationUncheckedUpdateManyWithoutConsultationRequestsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationUncheckedUpdateManyWithoutConsultationRequestsInput({
    this.id,
    this.consultationPlanId,
    this.requestStatus,
    this.requestedAt,
    this.requestNotes,
    this.directlyBooked,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  consultationPlanId;

  final _i1.PrismaUnion<
    _i3.RequestStatus,
    _i2.EnumRequestStatusFieldUpdateOperationsInput
  >?
  requestStatus;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  requestedAt;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  requestNotes;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
  directlyBooked;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackFromConsultee;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackFromConsultant;

  final _i1.PrismaUnion<
    double,
    _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  rating;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'consultationPlanId': consultationPlanId,
    'requestStatus': requestStatus,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'directlyBooked': directlyBooked,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultationUpdateManyWithWhereWithoutRequestedByInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationUpdateManyWithWhereWithoutRequestedByInput({
    required this.where,
    required this.data,
  });

  final _i2.ConsultationScalarWhereInput where;

  final _i1.PrismaUnion<
    _i2.ConsultationUpdateManyMutationInput,
    _i2.ConsultationUncheckedUpdateManyWithoutConsultationRequestsInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class ConsultationUncheckedUpdateManyWithoutRequestedByNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationUncheckedUpdateManyWithoutRequestedByNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.ConsultationCreateWithoutRequestedByInput,
    _i1.PrismaUnion<
      Iterable<_i2.ConsultationCreateWithoutRequestedByInput>,
      _i1.PrismaUnion<
        _i2.ConsultationUncheckedCreateWithoutRequestedByInput,
        Iterable<_i2.ConsultationUncheckedCreateWithoutRequestedByInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.ConsultationCreateOrConnectWithoutRequestedByInput,
    Iterable<_i2.ConsultationCreateOrConnectWithoutRequestedByInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.ConsultationUpsertWithWhereUniqueWithoutRequestedByInput,
    Iterable<_i2.ConsultationUpsertWithWhereUniqueWithoutRequestedByInput>
  >?
  upsert;

  final _i2.ConsultationCreateManyRequestedByInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.ConsultationWhereUniqueInput,
    Iterable<_i2.ConsultationWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.ConsultationWhereUniqueInput,
    Iterable<_i2.ConsultationWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.ConsultationWhereUniqueInput,
    Iterable<_i2.ConsultationWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.ConsultationWhereUniqueInput,
    Iterable<_i2.ConsultationWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.ConsultationUpdateWithWhereUniqueWithoutRequestedByInput,
    Iterable<_i2.ConsultationUpdateWithWhereUniqueWithoutRequestedByInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.ConsultationUpdateManyWithWhereWithoutRequestedByInput,
    Iterable<_i2.ConsultationUpdateManyWithWhereWithoutRequestedByInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.ConsultationScalarWhereInput,
    Iterable<_i2.ConsultationScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class SubscriptionUncheckedUpdateWithoutRequestedByInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionUncheckedUpdateWithoutRequestedByInput({
    this.id,
    this.startDate,
    this.endDate,
    this.requestStatus,
    this.requestedAt,
    this.requestNotes,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.subscriptionPlanId,
    this.createdAt,
    this.updatedAt,
    this.appointments,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  startDate;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  endDate;

  final _i1.PrismaUnion<
    _i3.RequestStatus,
    _i2.EnumRequestStatusFieldUpdateOperationsInput
  >?
  requestStatus;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  requestedAt;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  requestNotes;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackFromConsultee;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackFromConsultant;

  final _i1.PrismaUnion<
    double,
    _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  rating;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  subscriptionPlanId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.AppointmentUncheckedUpdateManyWithoutSubscriptionNestedInput?
  appointments;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'requestStatus': requestStatus,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'subscriptionPlanId': subscriptionPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'appointments': appointments,
  };
}

class SubscriptionUpdateWithWhereUniqueWithoutRequestedByInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionUpdateWithWhereUniqueWithoutRequestedByInput({
    required this.where,
    required this.data,
  });

  final _i2.SubscriptionWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.SubscriptionUpdateWithoutRequestedByInput,
    _i2.SubscriptionUncheckedUpdateWithoutRequestedByInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class SubscriptionUncheckedUpdateManyWithoutSubscriptionRequestsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionUncheckedUpdateManyWithoutSubscriptionRequestsInput({
    this.id,
    this.startDate,
    this.endDate,
    this.requestStatus,
    this.requestedAt,
    this.requestNotes,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.subscriptionPlanId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  startDate;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  endDate;

  final _i1.PrismaUnion<
    _i3.RequestStatus,
    _i2.EnumRequestStatusFieldUpdateOperationsInput
  >?
  requestStatus;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  requestedAt;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  requestNotes;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackFromConsultee;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackFromConsultant;

  final _i1.PrismaUnion<
    double,
    _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  rating;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  subscriptionPlanId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'requestStatus': requestStatus,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'subscriptionPlanId': subscriptionPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SubscriptionUpdateManyWithWhereWithoutRequestedByInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionUpdateManyWithWhereWithoutRequestedByInput({
    required this.where,
    required this.data,
  });

  final _i2.SubscriptionScalarWhereInput where;

  final _i1.PrismaUnion<
    _i2.SubscriptionUpdateManyMutationInput,
    _i2.SubscriptionUncheckedUpdateManyWithoutSubscriptionRequestsInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class SubscriptionUncheckedUpdateManyWithoutRequestedByNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionUncheckedUpdateManyWithoutRequestedByNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.SubscriptionCreateWithoutRequestedByInput,
    _i1.PrismaUnion<
      Iterable<_i2.SubscriptionCreateWithoutRequestedByInput>,
      _i1.PrismaUnion<
        _i2.SubscriptionUncheckedCreateWithoutRequestedByInput,
        Iterable<_i2.SubscriptionUncheckedCreateWithoutRequestedByInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.SubscriptionCreateOrConnectWithoutRequestedByInput,
    Iterable<_i2.SubscriptionCreateOrConnectWithoutRequestedByInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.SubscriptionUpsertWithWhereUniqueWithoutRequestedByInput,
    Iterable<_i2.SubscriptionUpsertWithWhereUniqueWithoutRequestedByInput>
  >?
  upsert;

  final _i2.SubscriptionCreateManyRequestedByInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.SubscriptionWhereUniqueInput,
    Iterable<_i2.SubscriptionWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.SubscriptionWhereUniqueInput,
    Iterable<_i2.SubscriptionWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.SubscriptionWhereUniqueInput,
    Iterable<_i2.SubscriptionWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.SubscriptionWhereUniqueInput,
    Iterable<_i2.SubscriptionWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.SubscriptionUpdateWithWhereUniqueWithoutRequestedByInput,
    Iterable<_i2.SubscriptionUpdateWithWhereUniqueWithoutRequestedByInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.SubscriptionUpdateManyWithWhereWithoutRequestedByInput,
    Iterable<_i2.SubscriptionUpdateManyWithWhereWithoutRequestedByInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.SubscriptionScalarWhereInput,
    Iterable<_i2.SubscriptionScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class ConsultantReviewUncheckedUpdateWithoutConsulteeProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewUncheckedUpdateWithoutConsulteeProfileInput({
    this.id,
    this.rating,
    this.reviewDescription,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? rating;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  reviewDescription;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  consultantProfileId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'rating': rating,
    'reviewDescription': reviewDescription,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultantReviewUpdateWithWhereUniqueWithoutConsulteeProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewUpdateWithWhereUniqueWithoutConsulteeProfileInput({
    required this.where,
    required this.data,
  });

  final _i2.ConsultantReviewWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewUpdateWithoutConsulteeProfileInput,
    _i2.ConsultantReviewUncheckedUpdateWithoutConsulteeProfileInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class ConsultantReviewUncheckedUpdateManyWithoutConsultantReviewsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewUncheckedUpdateManyWithoutConsultantReviewsInput({
    this.id,
    this.rating,
    this.reviewDescription,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? rating;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  reviewDescription;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  consultantProfileId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'rating': rating,
    'reviewDescription': reviewDescription,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultantReviewUpdateManyWithWhereWithoutConsulteeProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewUpdateManyWithWhereWithoutConsulteeProfileInput({
    required this.where,
    required this.data,
  });

  final _i2.ConsultantReviewScalarWhereInput where;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewUpdateManyMutationInput,
    _i2.ConsultantReviewUncheckedUpdateManyWithoutConsultantReviewsInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class ConsultantReviewUncheckedUpdateManyWithoutConsulteeProfileNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewUncheckedUpdateManyWithoutConsulteeProfileNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.ConsultantReviewCreateWithoutConsulteeProfileInput,
    _i1.PrismaUnion<
      Iterable<_i2.ConsultantReviewCreateWithoutConsulteeProfileInput>,
      _i1.PrismaUnion<
        _i2.ConsultantReviewUncheckedCreateWithoutConsulteeProfileInput,
        Iterable<
          _i2.ConsultantReviewUncheckedCreateWithoutConsulteeProfileInput
        >
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewCreateOrConnectWithoutConsulteeProfileInput,
    Iterable<_i2.ConsultantReviewCreateOrConnectWithoutConsulteeProfileInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewUpsertWithWhereUniqueWithoutConsulteeProfileInput,
    Iterable<
      _i2.ConsultantReviewUpsertWithWhereUniqueWithoutConsulteeProfileInput
    >
  >?
  upsert;

  final _i2.ConsultantReviewCreateManyConsulteeProfileInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewWhereUniqueInput,
    Iterable<_i2.ConsultantReviewWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewWhereUniqueInput,
    Iterable<_i2.ConsultantReviewWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewWhereUniqueInput,
    Iterable<_i2.ConsultantReviewWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewWhereUniqueInput,
    Iterable<_i2.ConsultantReviewWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewUpdateWithWhereUniqueWithoutConsulteeProfileInput,
    Iterable<
      _i2.ConsultantReviewUpdateWithWhereUniqueWithoutConsulteeProfileInput
    >
  >?
  update;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewUpdateManyWithWhereWithoutConsulteeProfileInput,
    Iterable<
      _i2.ConsultantReviewUpdateManyWithWhereWithoutConsulteeProfileInput
    >
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewScalarWhereInput,
    Iterable<_i2.ConsultantReviewScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class ConsulteeProfileUncheckedUpdateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileUncheckedUpdateWithoutUserInput({
    this.id,
    this.education,
    this.occupation,
    this.aboutMe,
    this.preferredCommunicationMethod,
    this.preferredLanguage,
    this.specialRequirements,
    this.interests,
    this.goals,
    this.createdAt,
    this.updatedAt,
    this.consultationRequests,
    this.subscriptionRequests,
    this.consultantReviews,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  education;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  occupation;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  aboutMe;

  final _i1.PrismaUnion<
    _i3.ConsultationMode,
    _i1.PrismaUnion<
      _i2.NullableEnumConsultationModeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  preferredCommunicationMethod;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  preferredLanguage;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  specialRequirements;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  interests;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  goals;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.ConsultationUncheckedUpdateManyWithoutRequestedByNestedInput?
  consultationRequests;

  final _i2.SubscriptionUncheckedUpdateManyWithoutRequestedByNestedInput?
  subscriptionRequests;

  final _i2.ConsultantReviewUncheckedUpdateManyWithoutConsulteeProfileNestedInput?
  consultantReviews;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'education': education,
    'occupation': occupation,
    'aboutMe': aboutMe,
    'preferredCommunicationMethod': preferredCommunicationMethod,
    'preferredLanguage': preferredLanguage,
    'specialRequirements': specialRequirements,
    'interests': interests,
    'goals': goals,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultationRequests': consultationRequests,
    'subscriptionRequests': subscriptionRequests,
    'consultantReviews': consultantReviews,
  };
}

class ConsulteeProfileUpsertWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileUpsertWithoutUserInput({
    required this.update,
    required this.create,
  });

  final _i1.PrismaUnion<
    _i2.ConsulteeProfileUpdateWithoutUserInput,
    _i2.ConsulteeProfileUncheckedUpdateWithoutUserInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.ConsulteeProfileCreateWithoutUserInput,
    _i2.ConsulteeProfileUncheckedCreateWithoutUserInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'update': update, 'create': create};
}

class ConsulteeProfileUpdateOneWithoutUserNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileUpdateOneWithoutUserNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.ConsulteeProfileCreateWithoutUserInput,
    _i2.ConsulteeProfileUncheckedCreateWithoutUserInput
  >?
  create;

  final _i2.ConsulteeProfileCreateOrConnectWithoutUserInput? connectOrCreate;

  final _i2.ConsulteeProfileUpsertWithoutUserInput? upsert;

  final bool? disconnect;

  final bool? delete;

  final _i2.ConsulteeProfileWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.ConsulteeProfileUpdateWithoutUserInput,
    _i2.ConsulteeProfileUncheckedUpdateWithoutUserInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
  };
}

class UserUpdateWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpdateWithoutConsultantProfileInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.cookiePreferences,
    this.notificationPreferences,
    this.payment,
    this.consulteeProfile,
    this.staffProfile,
    this.slotsOfAppointment,
    this.waitlist,
    this.feedbacks,
    this.supportTickets,
    this.supportResponses,
    this.accounts,
    this.sessions,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  name;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  email;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  emailVerified;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  image;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  phone;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  address;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  password;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetToken;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetExpires;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? onlineStatus;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  currentTimezone;

  final _i1.PrismaUnion<
    bool,
    _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  onboardingCompleted;

  final _i1.PrismaUnion<
    _i3.UserRole,
    _i1.PrismaUnion<
      _i2.NullableEnumUserRoleFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  role;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consultantProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consulteeProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  staffProfileId;

  final _i2.CookiePreferenceUpdateOneWithoutUserNestedInput? cookiePreferences;

  final _i2.NotificationPreferenceUpdateOneWithoutUserNestedInput?
  notificationPreferences;

  final _i2.PaymentUpdateManyWithoutUserNestedInput? payment;

  final _i2.ConsulteeProfileUpdateOneWithoutUserNestedInput? consulteeProfile;

  final _i2.StaffProfileUpdateOneWithoutUserNestedInput? staffProfile;

  final _i2.SlotOfAppointmentUpdateManyWithoutUserNestedInput?
  slotsOfAppointment;

  final _i2.WaitlistUpdateManyWithoutUserNestedInput? waitlist;

  final _i2.FeedbackUpdateManyWithoutUserNestedInput? feedbacks;

  final _i2.SupportTicketUpdateManyWithoutUserNestedInput? supportTickets;

  final _i2.SupportResponseUpdateManyWithoutUserNestedInput? supportResponses;

  final _i2.AccountUpdateManyWithoutUserNestedInput? accounts;

  final _i2.SessionUpdateManyWithoutUserNestedInput? sessions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'cookiePreferences': cookiePreferences,
    'notificationPreferences': notificationPreferences,
    'Payment': payment,
    'consulteeProfile': consulteeProfile,
    'staffProfile': staffProfile,
    'slotsOfAppointment': slotsOfAppointment,
    'Waitlist': waitlist,
    'feedbacks': feedbacks,
    'supportTickets': supportTickets,
    'supportResponses': supportResponses,
    'accounts': accounts,
    'sessions': sessions,
  };
}

class UserUncheckedUpdateWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUncheckedUpdateWithoutConsultantProfileInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.cookiePreferences,
    this.notificationPreferences,
    this.payment,
    this.consulteeProfile,
    this.staffProfile,
    this.slotsOfAppointment,
    this.waitlist,
    this.feedbacks,
    this.supportTickets,
    this.supportResponses,
    this.accounts,
    this.sessions,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  name;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  email;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  emailVerified;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  image;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  phone;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  address;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  password;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetToken;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetExpires;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? onlineStatus;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  currentTimezone;

  final _i1.PrismaUnion<
    bool,
    _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  onboardingCompleted;

  final _i1.PrismaUnion<
    _i3.UserRole,
    _i1.PrismaUnion<
      _i2.NullableEnumUserRoleFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  role;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consultantProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consulteeProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  staffProfileId;

  final _i2.CookiePreferenceUncheckedUpdateOneWithoutUserNestedInput?
  cookiePreferences;

  final _i2.NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput?
  notificationPreferences;

  final _i2.PaymentUncheckedUpdateManyWithoutUserNestedInput? payment;

  final _i2.ConsulteeProfileUncheckedUpdateOneWithoutUserNestedInput?
  consulteeProfile;

  final _i2.StaffProfileUncheckedUpdateOneWithoutUserNestedInput? staffProfile;

  final _i2.SlotOfAppointmentUncheckedUpdateManyWithoutUserNestedInput?
  slotsOfAppointment;

  final _i2.WaitlistUncheckedUpdateManyWithoutUserNestedInput? waitlist;

  final _i2.FeedbackUncheckedUpdateManyWithoutUserNestedInput? feedbacks;

  final _i2.SupportTicketUncheckedUpdateManyWithoutUserNestedInput?
  supportTickets;

  final _i2.SupportResponseUncheckedUpdateManyWithoutUserNestedInput?
  supportResponses;

  final _i2.AccountUncheckedUpdateManyWithoutUserNestedInput? accounts;

  final _i2.SessionUncheckedUpdateManyWithoutUserNestedInput? sessions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'cookiePreferences': cookiePreferences,
    'notificationPreferences': notificationPreferences,
    'Payment': payment,
    'consulteeProfile': consulteeProfile,
    'staffProfile': staffProfile,
    'slotsOfAppointment': slotsOfAppointment,
    'Waitlist': waitlist,
    'feedbacks': feedbacks,
    'supportTickets': supportTickets,
    'supportResponses': supportResponses,
    'accounts': accounts,
    'sessions': sessions,
  };
}

class UserUpsertWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpsertWithoutConsultantProfileInput({
    required this.update,
    required this.create,
  });

  final _i1.PrismaUnion<
    _i2.UserUpdateWithoutConsultantProfileInput,
    _i2.UserUncheckedUpdateWithoutConsultantProfileInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.UserCreateWithoutConsultantProfileInput,
    _i2.UserUncheckedCreateWithoutConsultantProfileInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'update': update, 'create': create};
}

class UserUpdateOneRequiredWithoutConsultantProfileNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpdateOneRequiredWithoutConsultantProfileNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.UserCreateWithoutConsultantProfileInput,
    _i2.UserUncheckedCreateWithoutConsultantProfileInput
  >?
  create;

  final _i2.UserCreateOrConnectWithoutConsultantProfileInput? connectOrCreate;

  final _i2.UserUpsertWithoutConsultantProfileInput? upsert;

  final _i2.UserWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.UserUpdateWithoutConsultantProfileInput,
    _i2.UserUncheckedUpdateWithoutConsultantProfileInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'connect': connect,
    'update': update,
  };
}

class ConsultantProfileUpdateWithoutClassPlansInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUpdateWithoutClassPlansInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    this.scheduleType,
    this.createdAt,
    this.updatedAt,
    this.domain,
    this.subDomains,
    this.tags,
    this.reviews,
    this.slotsOfAvailabilityWeekly,
    this.slotsOfAvailabilityCustom,
    this.consultationPlans,
    this.subscriptionPlans,
    this.webinarPlans,
    this.user,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  qualifications;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  specialization;

  final _i1.PrismaUnion<
    double,
    _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  experience;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? rating;

  final _i1.PrismaUnion<
    _i3.ScheduleType,
    _i2.EnumScheduleTypeFieldUpdateOperationsInput
  >?
  scheduleType;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.DomainUpdateOneRequiredWithoutConsultantProfilesNestedInput? domain;

  final _i2.SubDomainUpdateManyWithoutConsultantProfilesNestedInput? subDomains;

  final _i2.TagUpdateManyWithoutConsultantProfilesNestedInput? tags;

  final _i2.ConsultantReviewUpdateManyWithoutConsultantProfileNestedInput?
  reviews;

  final _i2.SlotOfAvailabilityWeeklyUpdateManyWithoutConsultantProfileNestedInput?
  slotsOfAvailabilityWeekly;

  final _i2.SlotOfAvailabilityCustomUpdateManyWithoutConsultantProfileNestedInput?
  slotsOfAvailabilityCustom;

  final _i2.ConsultationPlanUpdateManyWithoutConsultantProfileNestedInput?
  consultationPlans;

  final _i2.SubscriptionPlanUpdateManyWithoutConsultantProfileNestedInput?
  subscriptionPlans;

  final _i2.WebinarPlanUpdateManyWithoutConsultantProfileNestedInput?
  webinarPlans;

  final _i2.UserUpdateOneRequiredWithoutConsultantProfileNestedInput? user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'scheduleType': scheduleType,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'domain': domain,
    'subDomains': subDomains,
    'tags': tags,
    'reviews': reviews,
    'slotsOfAvailabilityWeekly': slotsOfAvailabilityWeekly,
    'slotsOfAvailabilityCustom': slotsOfAvailabilityCustom,
    'consultationPlans': consultationPlans,
    'subscriptionPlans': subscriptionPlans,
    'webinarPlans': webinarPlans,
    'user': user,
  };
}

class ConsultantProfileUncheckedUpdateWithoutClassPlansInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUncheckedUpdateWithoutClassPlansInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    this.domainId,
    this.scheduleType,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.subDomains,
    this.tags,
    this.reviews,
    this.slotsOfAvailabilityWeekly,
    this.slotsOfAvailabilityCustom,
    this.consultationPlans,
    this.subscriptionPlans,
    this.webinarPlans,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  qualifications;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  specialization;

  final _i1.PrismaUnion<
    double,
    _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  experience;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? rating;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? domainId;

  final _i1.PrismaUnion<
    _i3.ScheduleType,
    _i2.EnumScheduleTypeFieldUpdateOperationsInput
  >?
  scheduleType;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.SubDomainUncheckedUpdateManyWithoutConsultantProfilesNestedInput?
  subDomains;

  final _i2.TagUncheckedUpdateManyWithoutConsultantProfilesNestedInput? tags;

  final _i2.ConsultantReviewUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  reviews;

  final _i2.SlotOfAvailabilityWeeklyUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  slotsOfAvailabilityWeekly;

  final _i2.SlotOfAvailabilityCustomUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  slotsOfAvailabilityCustom;

  final _i2.ConsultationPlanUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  consultationPlans;

  final _i2.SubscriptionPlanUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  subscriptionPlans;

  final _i2.WebinarPlanUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  webinarPlans;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'domainId': domainId,
    'scheduleType': scheduleType,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'subDomains': subDomains,
    'tags': tags,
    'reviews': reviews,
    'slotsOfAvailabilityWeekly': slotsOfAvailabilityWeekly,
    'slotsOfAvailabilityCustom': slotsOfAvailabilityCustom,
    'consultationPlans': consultationPlans,
    'subscriptionPlans': subscriptionPlans,
    'webinarPlans': webinarPlans,
  };
}

class ConsultantProfileUpsertWithoutClassPlansInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUpsertWithoutClassPlansInput({
    required this.update,
    required this.create,
  });

  final _i1.PrismaUnion<
    _i2.ConsultantProfileUpdateWithoutClassPlansInput,
    _i2.ConsultantProfileUncheckedUpdateWithoutClassPlansInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateWithoutClassPlansInput,
    _i2.ConsultantProfileUncheckedCreateWithoutClassPlansInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'update': update, 'create': create};
}

class ConsultantProfileUpdateOneWithoutClassPlansNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUpdateOneWithoutClassPlansNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateWithoutClassPlansInput,
    _i2.ConsultantProfileUncheckedCreateWithoutClassPlansInput
  >?
  create;

  final _i2.ConsultantProfileCreateOrConnectWithoutClassPlansInput?
  connectOrCreate;

  final _i2.ConsultantProfileUpsertWithoutClassPlansInput? upsert;

  final bool? disconnect;

  final bool? delete;

  final _i2.ConsultantProfileWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileUpdateWithoutClassPlansInput,
    _i2.ConsultantProfileUncheckedUpdateWithoutClassPlansInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
  };
}

class ClassPlanUpdateWithoutTopicsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanUpdateWithoutTopicsInput({
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInMonths,
    this.callsPerWeek,
    this.videoMeetings,
    this.emailSupport,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.createdAt,
    this.updatedAt,
    this.classContents,
    this.consultantProfile,
    this.classes,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  description;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? price;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  priceCurrency;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
  certificateProvided;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
  durationInMonths;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? callsPerWeek;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? videoMeetings;

  final _i1.PrismaUnion<
    _i3.PlanEmailSupport,
    _i2.EnumPlanEmailSupportFieldUpdateOperationsInput
  >?
  emailSupport;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
  maxParticipants;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  language;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  level;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  prerequisites;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  materialProvided;

  final _i1.PrismaUnion<
    _i2.ClassPlanUpdatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.ClassContentUpdateManyWithoutClassPlanNestedInput? classContents;

  final _i2.ConsultantProfileUpdateOneWithoutClassPlansNestedInput?
  consultantProfile;

  final _i2.ClassUpdateManyWithoutClassPlanNestedInput? classes;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInMonths': durationInMonths,
    'callsPerWeek': callsPerWeek,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'classContents': classContents,
    'consultantProfile': consultantProfile,
    'classes': classes,
  };
}

class ClassPlanUpsertWithWhereUniqueWithoutTopicsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanUpsertWithWhereUniqueWithoutTopicsInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.ClassPlanWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.ClassPlanUpdateWithoutTopicsInput,
    _i2.ClassPlanUncheckedUpdateWithoutTopicsInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.ClassPlanCreateWithoutTopicsInput,
    _i2.ClassPlanUncheckedCreateWithoutTopicsInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'update': update,
    'create': create,
  };
}

class ClassPlanUpdateManyWithoutTopicsNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanUpdateManyWithoutTopicsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.ClassPlanCreateWithoutTopicsInput,
    _i1.PrismaUnion<
      Iterable<_i2.ClassPlanCreateWithoutTopicsInput>,
      _i1.PrismaUnion<
        _i2.ClassPlanUncheckedCreateWithoutTopicsInput,
        Iterable<_i2.ClassPlanUncheckedCreateWithoutTopicsInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.ClassPlanCreateOrConnectWithoutTopicsInput,
    Iterable<_i2.ClassPlanCreateOrConnectWithoutTopicsInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.ClassPlanUpsertWithWhereUniqueWithoutTopicsInput,
    Iterable<_i2.ClassPlanUpsertWithWhereUniqueWithoutTopicsInput>
  >?
  upsert;

  final _i1.PrismaUnion<
    _i2.ClassPlanWhereUniqueInput,
    Iterable<_i2.ClassPlanWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.ClassPlanWhereUniqueInput,
    Iterable<_i2.ClassPlanWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.ClassPlanWhereUniqueInput,
    Iterable<_i2.ClassPlanWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.ClassPlanWhereUniqueInput,
    Iterable<_i2.ClassPlanWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.ClassPlanUpdateWithWhereUniqueWithoutTopicsInput,
    Iterable<_i2.ClassPlanUpdateWithWhereUniqueWithoutTopicsInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.ClassPlanUpdateManyWithWhereWithoutTopicsInput,
    Iterable<_i2.ClassPlanUpdateManyWithWhereWithoutTopicsInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.ClassPlanScalarWhereInput,
    Iterable<_i2.ClassPlanScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class TopicUpdateWithoutWebinarPlansInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TopicUpdateWithoutWebinarPlansInput({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
    this.classPlans,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.ClassPlanUpdateManyWithoutTopicsNestedInput? classPlans;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'classPlans': classPlans,
  };
}

class TopicUpsertWithWhereUniqueWithoutWebinarPlansInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TopicUpsertWithWhereUniqueWithoutWebinarPlansInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.TopicWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.TopicUpdateWithoutWebinarPlansInput,
    _i2.TopicUncheckedUpdateWithoutWebinarPlansInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.TopicCreateWithoutWebinarPlansInput,
    _i2.TopicUncheckedCreateWithoutWebinarPlansInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'update': update,
    'create': create,
  };
}

class TopicUpdateManyWithoutWebinarPlansNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TopicUpdateManyWithoutWebinarPlansNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.TopicCreateWithoutWebinarPlansInput,
    _i1.PrismaUnion<
      Iterable<_i2.TopicCreateWithoutWebinarPlansInput>,
      _i1.PrismaUnion<
        _i2.TopicUncheckedCreateWithoutWebinarPlansInput,
        Iterable<_i2.TopicUncheckedCreateWithoutWebinarPlansInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.TopicCreateOrConnectWithoutWebinarPlansInput,
    Iterable<_i2.TopicCreateOrConnectWithoutWebinarPlansInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.TopicUpsertWithWhereUniqueWithoutWebinarPlansInput,
    Iterable<_i2.TopicUpsertWithWhereUniqueWithoutWebinarPlansInput>
  >?
  upsert;

  final _i1.PrismaUnion<
    _i2.TopicWhereUniqueInput,
    Iterable<_i2.TopicWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.TopicWhereUniqueInput,
    Iterable<_i2.TopicWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.TopicWhereUniqueInput,
    Iterable<_i2.TopicWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.TopicWhereUniqueInput,
    Iterable<_i2.TopicWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.TopicUpdateWithWhereUniqueWithoutWebinarPlansInput,
    Iterable<_i2.TopicUpdateWithWhereUniqueWithoutWebinarPlansInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.TopicUpdateManyWithWhereWithoutWebinarPlansInput,
    Iterable<_i2.TopicUpdateManyWithWhereWithoutWebinarPlansInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.TopicScalarWhereInput,
    Iterable<_i2.TopicScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class WebinarPlanUpdateWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanUpdateWithoutConsultantProfileInput({
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInHours,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.createdAt,
    this.updatedAt,
    this.topics,
    this.webinars,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? price;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  priceCurrency;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
  certificateProvided;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
  durationInHours;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
  maxParticipants;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  language;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  level;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  prerequisites;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  materialProvided;

  final _i1.PrismaUnion<
    _i2.WebinarPlanUpdatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.TopicUpdateManyWithoutWebinarPlansNestedInput? topics;

  final _i2.WebinarUpdateManyWithoutWebinarPlanNestedInput? webinars;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInHours': durationInHours,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'topics': topics,
    'webinars': webinars,
  };
}

class WebinarPlanUpsertWithWhereUniqueWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanUpsertWithWhereUniqueWithoutConsultantProfileInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.WebinarPlanWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.WebinarPlanUpdateWithoutConsultantProfileInput,
    _i2.WebinarPlanUncheckedUpdateWithoutConsultantProfileInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.WebinarPlanCreateWithoutConsultantProfileInput,
    _i2.WebinarPlanUncheckedCreateWithoutConsultantProfileInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'update': update,
    'create': create,
  };
}

class WebinarPlanUpdateManyWithoutConsultantProfileNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanUpdateManyWithoutConsultantProfileNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.WebinarPlanCreateWithoutConsultantProfileInput,
    _i1.PrismaUnion<
      Iterable<_i2.WebinarPlanCreateWithoutConsultantProfileInput>,
      _i1.PrismaUnion<
        _i2.WebinarPlanUncheckedCreateWithoutConsultantProfileInput,
        Iterable<_i2.WebinarPlanUncheckedCreateWithoutConsultantProfileInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.WebinarPlanCreateOrConnectWithoutConsultantProfileInput,
    Iterable<_i2.WebinarPlanCreateOrConnectWithoutConsultantProfileInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.WebinarPlanUpsertWithWhereUniqueWithoutConsultantProfileInput,
    Iterable<_i2.WebinarPlanUpsertWithWhereUniqueWithoutConsultantProfileInput>
  >?
  upsert;

  final _i2.WebinarPlanCreateManyConsultantProfileInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.WebinarPlanWhereUniqueInput,
    Iterable<_i2.WebinarPlanWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.WebinarPlanWhereUniqueInput,
    Iterable<_i2.WebinarPlanWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.WebinarPlanWhereUniqueInput,
    Iterable<_i2.WebinarPlanWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.WebinarPlanWhereUniqueInput,
    Iterable<_i2.WebinarPlanWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.WebinarPlanUpdateWithWhereUniqueWithoutConsultantProfileInput,
    Iterable<_i2.WebinarPlanUpdateWithWhereUniqueWithoutConsultantProfileInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.WebinarPlanUpdateManyWithWhereWithoutConsultantProfileInput,
    Iterable<_i2.WebinarPlanUpdateManyWithWhereWithoutConsultantProfileInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.WebinarPlanScalarWhereInput,
    Iterable<_i2.WebinarPlanScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class ConsultantProfileUpdateWithoutSubscriptionPlansInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUpdateWithoutSubscriptionPlansInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    this.scheduleType,
    this.createdAt,
    this.updatedAt,
    this.domain,
    this.subDomains,
    this.tags,
    this.reviews,
    this.slotsOfAvailabilityWeekly,
    this.slotsOfAvailabilityCustom,
    this.consultationPlans,
    this.webinarPlans,
    this.classPlans,
    this.user,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  qualifications;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  specialization;

  final _i1.PrismaUnion<
    double,
    _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  experience;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? rating;

  final _i1.PrismaUnion<
    _i3.ScheduleType,
    _i2.EnumScheduleTypeFieldUpdateOperationsInput
  >?
  scheduleType;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.DomainUpdateOneRequiredWithoutConsultantProfilesNestedInput? domain;

  final _i2.SubDomainUpdateManyWithoutConsultantProfilesNestedInput? subDomains;

  final _i2.TagUpdateManyWithoutConsultantProfilesNestedInput? tags;

  final _i2.ConsultantReviewUpdateManyWithoutConsultantProfileNestedInput?
  reviews;

  final _i2.SlotOfAvailabilityWeeklyUpdateManyWithoutConsultantProfileNestedInput?
  slotsOfAvailabilityWeekly;

  final _i2.SlotOfAvailabilityCustomUpdateManyWithoutConsultantProfileNestedInput?
  slotsOfAvailabilityCustom;

  final _i2.ConsultationPlanUpdateManyWithoutConsultantProfileNestedInput?
  consultationPlans;

  final _i2.WebinarPlanUpdateManyWithoutConsultantProfileNestedInput?
  webinarPlans;

  final _i2.ClassPlanUpdateManyWithoutConsultantProfileNestedInput? classPlans;

  final _i2.UserUpdateOneRequiredWithoutConsultantProfileNestedInput? user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'scheduleType': scheduleType,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'domain': domain,
    'subDomains': subDomains,
    'tags': tags,
    'reviews': reviews,
    'slotsOfAvailabilityWeekly': slotsOfAvailabilityWeekly,
    'slotsOfAvailabilityCustom': slotsOfAvailabilityCustom,
    'consultationPlans': consultationPlans,
    'webinarPlans': webinarPlans,
    'classPlans': classPlans,
    'user': user,
  };
}

class ConsultantProfileUncheckedUpdateWithoutSubscriptionPlansInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUncheckedUpdateWithoutSubscriptionPlansInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    this.domainId,
    this.scheduleType,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.subDomains,
    this.tags,
    this.reviews,
    this.slotsOfAvailabilityWeekly,
    this.slotsOfAvailabilityCustom,
    this.consultationPlans,
    this.webinarPlans,
    this.classPlans,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  qualifications;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  specialization;

  final _i1.PrismaUnion<
    double,
    _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  experience;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? rating;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? domainId;

  final _i1.PrismaUnion<
    _i3.ScheduleType,
    _i2.EnumScheduleTypeFieldUpdateOperationsInput
  >?
  scheduleType;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.SubDomainUncheckedUpdateManyWithoutConsultantProfilesNestedInput?
  subDomains;

  final _i2.TagUncheckedUpdateManyWithoutConsultantProfilesNestedInput? tags;

  final _i2.ConsultantReviewUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  reviews;

  final _i2.SlotOfAvailabilityWeeklyUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  slotsOfAvailabilityWeekly;

  final _i2.SlotOfAvailabilityCustomUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  slotsOfAvailabilityCustom;

  final _i2.ConsultationPlanUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  consultationPlans;

  final _i2.WebinarPlanUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  webinarPlans;

  final _i2.ClassPlanUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  classPlans;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'domainId': domainId,
    'scheduleType': scheduleType,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'subDomains': subDomains,
    'tags': tags,
    'reviews': reviews,
    'slotsOfAvailabilityWeekly': slotsOfAvailabilityWeekly,
    'slotsOfAvailabilityCustom': slotsOfAvailabilityCustom,
    'consultationPlans': consultationPlans,
    'webinarPlans': webinarPlans,
    'classPlans': classPlans,
  };
}

class ConsultantProfileUpsertWithoutSubscriptionPlansInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUpsertWithoutSubscriptionPlansInput({
    required this.update,
    required this.create,
  });

  final _i1.PrismaUnion<
    _i2.ConsultantProfileUpdateWithoutSubscriptionPlansInput,
    _i2.ConsultantProfileUncheckedUpdateWithoutSubscriptionPlansInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateWithoutSubscriptionPlansInput,
    _i2.ConsultantProfileUncheckedCreateWithoutSubscriptionPlansInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'update': update, 'create': create};
}

class ConsultantProfileUpdateOneRequiredWithoutSubscriptionPlansNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUpdateOneRequiredWithoutSubscriptionPlansNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateWithoutSubscriptionPlansInput,
    _i2.ConsultantProfileUncheckedCreateWithoutSubscriptionPlansInput
  >?
  create;

  final _i2.ConsultantProfileCreateOrConnectWithoutSubscriptionPlansInput?
  connectOrCreate;

  final _i2.ConsultantProfileUpsertWithoutSubscriptionPlansInput? upsert;

  final _i2.ConsultantProfileWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileUpdateWithoutSubscriptionPlansInput,
    _i2.ConsultantProfileUncheckedUpdateWithoutSubscriptionPlansInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'connect': connect,
    'update': update,
  };
}

class SubscriptionPlanUpdateWithoutSubscriptionsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanUpdateWithoutSubscriptionsInput({
    this.id,
    this.title,
    this.description,
    this.durationInMonths,
    this.price,
    this.callsPerWeek,
    this.sessionDurationInHours,
    this.videoMeetings,
    this.emailSupport,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.createdAt,
    this.updatedAt,
    this.consultantProfile,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
  durationInMonths;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? price;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? callsPerWeek;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
  sessionDurationInHours;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? videoMeetings;

  final _i1.PrismaUnion<
    _i3.PlanEmailSupport,
    _i2.EnumPlanEmailSupportFieldUpdateOperationsInput
  >?
  emailSupport;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? language;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? level;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  prerequisites;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  materialProvided;

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanUpdatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.ConsultantProfileUpdateOneRequiredWithoutSubscriptionPlansNestedInput?
  consultantProfile;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInMonths': durationInMonths,
    'price': price,
    'callsPerWeek': callsPerWeek,
    'sessionDurationInHours': sessionDurationInHours,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultantProfile': consultantProfile,
  };
}

class SubscriptionPlanUncheckedUpdateWithoutSubscriptionsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanUncheckedUpdateWithoutSubscriptionsInput({
    this.id,
    this.title,
    this.description,
    this.durationInMonths,
    this.price,
    this.callsPerWeek,
    this.sessionDurationInHours,
    this.videoMeetings,
    this.emailSupport,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
  durationInMonths;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? price;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? callsPerWeek;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
  sessionDurationInHours;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? videoMeetings;

  final _i1.PrismaUnion<
    _i3.PlanEmailSupport,
    _i2.EnumPlanEmailSupportFieldUpdateOperationsInput
  >?
  emailSupport;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? language;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? level;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  prerequisites;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  materialProvided;

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanUpdatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  consultantProfileId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInMonths': durationInMonths,
    'price': price,
    'callsPerWeek': callsPerWeek,
    'sessionDurationInHours': sessionDurationInHours,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SubscriptionPlanUpsertWithoutSubscriptionsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanUpsertWithoutSubscriptionsInput({
    required this.update,
    required this.create,
  });

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanUpdateWithoutSubscriptionsInput,
    _i2.SubscriptionPlanUncheckedUpdateWithoutSubscriptionsInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanCreateWithoutSubscriptionsInput,
    _i2.SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'update': update, 'create': create};
}

class SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanCreateWithoutSubscriptionsInput,
    _i2.SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput
  >?
  create;

  final _i2.SubscriptionPlanCreateOrConnectWithoutSubscriptionsInput?
  connectOrCreate;

  final _i2.SubscriptionPlanUpsertWithoutSubscriptionsInput? upsert;

  final _i2.SubscriptionPlanWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanUpdateWithoutSubscriptionsInput,
    _i2.SubscriptionPlanUncheckedUpdateWithoutSubscriptionsInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'connect': connect,
    'update': update,
  };
}

class AppointmentUpdateManyWithoutSubscriptionNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentUpdateManyWithoutSubscriptionNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.AppointmentCreateWithoutSubscriptionInput,
    _i1.PrismaUnion<
      Iterable<_i2.AppointmentCreateWithoutSubscriptionInput>,
      _i1.PrismaUnion<
        _i2.AppointmentUncheckedCreateWithoutSubscriptionInput,
        Iterable<_i2.AppointmentUncheckedCreateWithoutSubscriptionInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.AppointmentCreateOrConnectWithoutSubscriptionInput,
    Iterable<_i2.AppointmentCreateOrConnectWithoutSubscriptionInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.AppointmentUpsertWithWhereUniqueWithoutSubscriptionInput,
    Iterable<_i2.AppointmentUpsertWithWhereUniqueWithoutSubscriptionInput>
  >?
  upsert;

  final _i2.AppointmentCreateManySubscriptionInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.AppointmentWhereUniqueInput,
    Iterable<_i2.AppointmentWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.AppointmentWhereUniqueInput,
    Iterable<_i2.AppointmentWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.AppointmentWhereUniqueInput,
    Iterable<_i2.AppointmentWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.AppointmentWhereUniqueInput,
    Iterable<_i2.AppointmentWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.AppointmentUpdateWithWhereUniqueWithoutSubscriptionInput,
    Iterable<_i2.AppointmentUpdateWithWhereUniqueWithoutSubscriptionInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.AppointmentUpdateManyWithWhereWithoutSubscriptionInput,
    Iterable<_i2.AppointmentUpdateManyWithWhereWithoutSubscriptionInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.AppointmentScalarWhereInput,
    Iterable<_i2.AppointmentScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class SubscriptionUpdateWithoutRequestedByInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionUpdateWithoutRequestedByInput({
    this.id,
    this.startDate,
    this.endDate,
    this.requestStatus,
    this.requestedAt,
    this.requestNotes,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.createdAt,
    this.updatedAt,
    this.subscriptionPlan,
    this.appointments,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  startDate;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  endDate;

  final _i1.PrismaUnion<
    _i3.RequestStatus,
    _i2.EnumRequestStatusFieldUpdateOperationsInput
  >?
  requestStatus;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  requestedAt;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  requestNotes;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackFromConsultee;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackFromConsultant;

  final _i1.PrismaUnion<
    double,
    _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  rating;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInput?
  subscriptionPlan;

  final _i2.AppointmentUpdateManyWithoutSubscriptionNestedInput? appointments;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'requestStatus': requestStatus,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'subscriptionPlan': subscriptionPlan,
    'appointments': appointments,
  };
}

class SubscriptionUpsertWithWhereUniqueWithoutRequestedByInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionUpsertWithWhereUniqueWithoutRequestedByInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.SubscriptionWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.SubscriptionUpdateWithoutRequestedByInput,
    _i2.SubscriptionUncheckedUpdateWithoutRequestedByInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.SubscriptionCreateWithoutRequestedByInput,
    _i2.SubscriptionUncheckedCreateWithoutRequestedByInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'update': update,
    'create': create,
  };
}

class SubscriptionUpdateManyWithoutRequestedByNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionUpdateManyWithoutRequestedByNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.SubscriptionCreateWithoutRequestedByInput,
    _i1.PrismaUnion<
      Iterable<_i2.SubscriptionCreateWithoutRequestedByInput>,
      _i1.PrismaUnion<
        _i2.SubscriptionUncheckedCreateWithoutRequestedByInput,
        Iterable<_i2.SubscriptionUncheckedCreateWithoutRequestedByInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.SubscriptionCreateOrConnectWithoutRequestedByInput,
    Iterable<_i2.SubscriptionCreateOrConnectWithoutRequestedByInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.SubscriptionUpsertWithWhereUniqueWithoutRequestedByInput,
    Iterable<_i2.SubscriptionUpsertWithWhereUniqueWithoutRequestedByInput>
  >?
  upsert;

  final _i2.SubscriptionCreateManyRequestedByInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.SubscriptionWhereUniqueInput,
    Iterable<_i2.SubscriptionWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.SubscriptionWhereUniqueInput,
    Iterable<_i2.SubscriptionWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.SubscriptionWhereUniqueInput,
    Iterable<_i2.SubscriptionWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.SubscriptionWhereUniqueInput,
    Iterable<_i2.SubscriptionWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.SubscriptionUpdateWithWhereUniqueWithoutRequestedByInput,
    Iterable<_i2.SubscriptionUpdateWithWhereUniqueWithoutRequestedByInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.SubscriptionUpdateManyWithWhereWithoutRequestedByInput,
    Iterable<_i2.SubscriptionUpdateManyWithWhereWithoutRequestedByInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.SubscriptionScalarWhereInput,
    Iterable<_i2.SubscriptionScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class UserUpdateWithoutConsulteeProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpdateWithoutConsulteeProfileInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.cookiePreferences,
    this.notificationPreferences,
    this.payment,
    this.consultantProfile,
    this.staffProfile,
    this.slotsOfAppointment,
    this.waitlist,
    this.feedbacks,
    this.supportTickets,
    this.supportResponses,
    this.accounts,
    this.sessions,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  name;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  email;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  emailVerified;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  image;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  phone;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  address;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  password;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetToken;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetExpires;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? onlineStatus;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  currentTimezone;

  final _i1.PrismaUnion<
    bool,
    _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  onboardingCompleted;

  final _i1.PrismaUnion<
    _i3.UserRole,
    _i1.PrismaUnion<
      _i2.NullableEnumUserRoleFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  role;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consultantProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consulteeProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  staffProfileId;

  final _i2.CookiePreferenceUpdateOneWithoutUserNestedInput? cookiePreferences;

  final _i2.NotificationPreferenceUpdateOneWithoutUserNestedInput?
  notificationPreferences;

  final _i2.PaymentUpdateManyWithoutUserNestedInput? payment;

  final _i2.ConsultantProfileUpdateOneWithoutUserNestedInput? consultantProfile;

  final _i2.StaffProfileUpdateOneWithoutUserNestedInput? staffProfile;

  final _i2.SlotOfAppointmentUpdateManyWithoutUserNestedInput?
  slotsOfAppointment;

  final _i2.WaitlistUpdateManyWithoutUserNestedInput? waitlist;

  final _i2.FeedbackUpdateManyWithoutUserNestedInput? feedbacks;

  final _i2.SupportTicketUpdateManyWithoutUserNestedInput? supportTickets;

  final _i2.SupportResponseUpdateManyWithoutUserNestedInput? supportResponses;

  final _i2.AccountUpdateManyWithoutUserNestedInput? accounts;

  final _i2.SessionUpdateManyWithoutUserNestedInput? sessions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'cookiePreferences': cookiePreferences,
    'notificationPreferences': notificationPreferences,
    'Payment': payment,
    'consultantProfile': consultantProfile,
    'staffProfile': staffProfile,
    'slotsOfAppointment': slotsOfAppointment,
    'Waitlist': waitlist,
    'feedbacks': feedbacks,
    'supportTickets': supportTickets,
    'supportResponses': supportResponses,
    'accounts': accounts,
    'sessions': sessions,
  };
}

class UserUncheckedUpdateWithoutConsulteeProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUncheckedUpdateWithoutConsulteeProfileInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.cookiePreferences,
    this.notificationPreferences,
    this.payment,
    this.consultantProfile,
    this.staffProfile,
    this.slotsOfAppointment,
    this.waitlist,
    this.feedbacks,
    this.supportTickets,
    this.supportResponses,
    this.accounts,
    this.sessions,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  name;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  email;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  emailVerified;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  image;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  phone;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  address;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  password;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetToken;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetExpires;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? onlineStatus;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  currentTimezone;

  final _i1.PrismaUnion<
    bool,
    _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  onboardingCompleted;

  final _i1.PrismaUnion<
    _i3.UserRole,
    _i1.PrismaUnion<
      _i2.NullableEnumUserRoleFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  role;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consultantProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consulteeProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  staffProfileId;

  final _i2.CookiePreferenceUncheckedUpdateOneWithoutUserNestedInput?
  cookiePreferences;

  final _i2.NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput?
  notificationPreferences;

  final _i2.PaymentUncheckedUpdateManyWithoutUserNestedInput? payment;

  final _i2.ConsultantProfileUncheckedUpdateOneWithoutUserNestedInput?
  consultantProfile;

  final _i2.StaffProfileUncheckedUpdateOneWithoutUserNestedInput? staffProfile;

  final _i2.SlotOfAppointmentUncheckedUpdateManyWithoutUserNestedInput?
  slotsOfAppointment;

  final _i2.WaitlistUncheckedUpdateManyWithoutUserNestedInput? waitlist;

  final _i2.FeedbackUncheckedUpdateManyWithoutUserNestedInput? feedbacks;

  final _i2.SupportTicketUncheckedUpdateManyWithoutUserNestedInput?
  supportTickets;

  final _i2.SupportResponseUncheckedUpdateManyWithoutUserNestedInput?
  supportResponses;

  final _i2.AccountUncheckedUpdateManyWithoutUserNestedInput? accounts;

  final _i2.SessionUncheckedUpdateManyWithoutUserNestedInput? sessions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'cookiePreferences': cookiePreferences,
    'notificationPreferences': notificationPreferences,
    'Payment': payment,
    'consultantProfile': consultantProfile,
    'staffProfile': staffProfile,
    'slotsOfAppointment': slotsOfAppointment,
    'Waitlist': waitlist,
    'feedbacks': feedbacks,
    'supportTickets': supportTickets,
    'supportResponses': supportResponses,
    'accounts': accounts,
    'sessions': sessions,
  };
}

class UserUpsertWithoutConsulteeProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpsertWithoutConsulteeProfileInput({
    required this.update,
    required this.create,
  });

  final _i1.PrismaUnion<
    _i2.UserUpdateWithoutConsulteeProfileInput,
    _i2.UserUncheckedUpdateWithoutConsulteeProfileInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.UserCreateWithoutConsulteeProfileInput,
    _i2.UserUncheckedCreateWithoutConsulteeProfileInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'update': update, 'create': create};
}

class UserUpdateOneRequiredWithoutConsulteeProfileNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpdateOneRequiredWithoutConsulteeProfileNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.UserCreateWithoutConsulteeProfileInput,
    _i2.UserUncheckedCreateWithoutConsulteeProfileInput
  >?
  create;

  final _i2.UserCreateOrConnectWithoutConsulteeProfileInput? connectOrCreate;

  final _i2.UserUpsertWithoutConsulteeProfileInput? upsert;

  final _i2.UserWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.UserUpdateWithoutConsulteeProfileInput,
    _i2.UserUncheckedUpdateWithoutConsulteeProfileInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'connect': connect,
    'update': update,
  };
}

class ConsulteeProfileUpdateWithoutConsultationRequestsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileUpdateWithoutConsultationRequestsInput({
    this.id,
    this.education,
    this.occupation,
    this.aboutMe,
    this.preferredCommunicationMethod,
    this.preferredLanguage,
    this.specialRequirements,
    this.interests,
    this.goals,
    this.createdAt,
    this.updatedAt,
    this.subscriptionRequests,
    this.consultantReviews,
    this.user,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  education;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  occupation;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  aboutMe;

  final _i1.PrismaUnion<
    _i3.ConsultationMode,
    _i1.PrismaUnion<
      _i2.NullableEnumConsultationModeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  preferredCommunicationMethod;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  preferredLanguage;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  specialRequirements;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  interests;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  goals;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.SubscriptionUpdateManyWithoutRequestedByNestedInput?
  subscriptionRequests;

  final _i2.ConsultantReviewUpdateManyWithoutConsulteeProfileNestedInput?
  consultantReviews;

  final _i2.UserUpdateOneRequiredWithoutConsulteeProfileNestedInput? user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'education': education,
    'occupation': occupation,
    'aboutMe': aboutMe,
    'preferredCommunicationMethod': preferredCommunicationMethod,
    'preferredLanguage': preferredLanguage,
    'specialRequirements': specialRequirements,
    'interests': interests,
    'goals': goals,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'subscriptionRequests': subscriptionRequests,
    'consultantReviews': consultantReviews,
    'user': user,
  };
}

class ConsulteeProfileUncheckedUpdateWithoutConsultationRequestsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileUncheckedUpdateWithoutConsultationRequestsInput({
    this.id,
    this.education,
    this.occupation,
    this.aboutMe,
    this.preferredCommunicationMethod,
    this.preferredLanguage,
    this.specialRequirements,
    this.interests,
    this.goals,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.subscriptionRequests,
    this.consultantReviews,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  education;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  occupation;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  aboutMe;

  final _i1.PrismaUnion<
    _i3.ConsultationMode,
    _i1.PrismaUnion<
      _i2.NullableEnumConsultationModeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  preferredCommunicationMethod;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  preferredLanguage;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  specialRequirements;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  interests;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  goals;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.SubscriptionUncheckedUpdateManyWithoutRequestedByNestedInput?
  subscriptionRequests;

  final _i2.ConsultantReviewUncheckedUpdateManyWithoutConsulteeProfileNestedInput?
  consultantReviews;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'education': education,
    'occupation': occupation,
    'aboutMe': aboutMe,
    'preferredCommunicationMethod': preferredCommunicationMethod,
    'preferredLanguage': preferredLanguage,
    'specialRequirements': specialRequirements,
    'interests': interests,
    'goals': goals,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'subscriptionRequests': subscriptionRequests,
    'consultantReviews': consultantReviews,
  };
}

class ConsulteeProfileUpsertWithoutConsultationRequestsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileUpsertWithoutConsultationRequestsInput({
    required this.update,
    required this.create,
  });

  final _i1.PrismaUnion<
    _i2.ConsulteeProfileUpdateWithoutConsultationRequestsInput,
    _i2.ConsulteeProfileUncheckedUpdateWithoutConsultationRequestsInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.ConsulteeProfileCreateWithoutConsultationRequestsInput,
    _i2.ConsulteeProfileUncheckedCreateWithoutConsultationRequestsInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'update': update, 'create': create};
}

class ConsulteeProfileUpdateOneRequiredWithoutConsultationRequestsNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileUpdateOneRequiredWithoutConsultationRequestsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.ConsulteeProfileCreateWithoutConsultationRequestsInput,
    _i2.ConsulteeProfileUncheckedCreateWithoutConsultationRequestsInput
  >?
  create;

  final _i2.ConsulteeProfileCreateOrConnectWithoutConsultationRequestsInput?
  connectOrCreate;

  final _i2.ConsulteeProfileUpsertWithoutConsultationRequestsInput? upsert;

  final _i2.ConsulteeProfileWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.ConsulteeProfileUpdateWithoutConsultationRequestsInput,
    _i2.ConsulteeProfileUncheckedUpdateWithoutConsultationRequestsInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'connect': connect,
    'update': update,
  };
}

class AppointmentUpdateOneWithoutConsultationNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentUpdateOneWithoutConsultationNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.AppointmentCreateWithoutConsultationInput,
    _i2.AppointmentUncheckedCreateWithoutConsultationInput
  >?
  create;

  final _i2.AppointmentCreateOrConnectWithoutConsultationInput? connectOrCreate;

  final _i2.AppointmentUpsertWithoutConsultationInput? upsert;

  final bool? disconnect;

  final bool? delete;

  final _i2.AppointmentWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.AppointmentUpdateWithoutConsultationInput,
    _i2.AppointmentUncheckedUpdateWithoutConsultationInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
  };
}

class ConsultationUpdateWithoutConsultationPlanInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationUpdateWithoutConsultationPlanInput({
    this.id,
    this.requestStatus,
    this.requestedAt,
    this.requestNotes,
    this.directlyBooked,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.createdAt,
    this.updatedAt,
    this.requestedBy,
    this.appointment,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    _i3.RequestStatus,
    _i2.EnumRequestStatusFieldUpdateOperationsInput
  >?
  requestStatus;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  requestedAt;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  requestNotes;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
  directlyBooked;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackFromConsultee;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackFromConsultant;

  final _i1.PrismaUnion<
    double,
    _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  rating;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.ConsulteeProfileUpdateOneRequiredWithoutConsultationRequestsNestedInput?
  requestedBy;

  final _i2.AppointmentUpdateOneWithoutConsultationNestedInput? appointment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'requestStatus': requestStatus,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'directlyBooked': directlyBooked,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'requestedBy': requestedBy,
    'appointment': appointment,
  };
}

class ConsultationUpsertWithWhereUniqueWithoutConsultationPlanInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationUpsertWithWhereUniqueWithoutConsultationPlanInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.ConsultationWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.ConsultationUpdateWithoutConsultationPlanInput,
    _i2.ConsultationUncheckedUpdateWithoutConsultationPlanInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.ConsultationCreateWithoutConsultationPlanInput,
    _i2.ConsultationUncheckedCreateWithoutConsultationPlanInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'update': update,
    'create': create,
  };
}

class ConsultationUpdateManyWithoutConsultationPlanNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationUpdateManyWithoutConsultationPlanNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.ConsultationCreateWithoutConsultationPlanInput,
    _i1.PrismaUnion<
      Iterable<_i2.ConsultationCreateWithoutConsultationPlanInput>,
      _i1.PrismaUnion<
        _i2.ConsultationUncheckedCreateWithoutConsultationPlanInput,
        Iterable<_i2.ConsultationUncheckedCreateWithoutConsultationPlanInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.ConsultationCreateOrConnectWithoutConsultationPlanInput,
    Iterable<_i2.ConsultationCreateOrConnectWithoutConsultationPlanInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.ConsultationUpsertWithWhereUniqueWithoutConsultationPlanInput,
    Iterable<_i2.ConsultationUpsertWithWhereUniqueWithoutConsultationPlanInput>
  >?
  upsert;

  final _i2.ConsultationCreateManyConsultationPlanInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.ConsultationWhereUniqueInput,
    Iterable<_i2.ConsultationWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.ConsultationWhereUniqueInput,
    Iterable<_i2.ConsultationWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.ConsultationWhereUniqueInput,
    Iterable<_i2.ConsultationWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.ConsultationWhereUniqueInput,
    Iterable<_i2.ConsultationWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.ConsultationUpdateWithWhereUniqueWithoutConsultationPlanInput,
    Iterable<_i2.ConsultationUpdateWithWhereUniqueWithoutConsultationPlanInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.ConsultationUpdateManyWithWhereWithoutConsultationPlanInput,
    Iterable<_i2.ConsultationUpdateManyWithWhereWithoutConsultationPlanInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.ConsultationScalarWhereInput,
    Iterable<_i2.ConsultationScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class ConsultationPlanUpdateWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanUpdateWithoutConsultantProfileInput({
    this.id,
    this.title,
    this.description,
    this.durationInHours,
    this.price,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.createdAt,
    this.updatedAt,
    this.consultations,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
  durationInHours;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? price;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? language;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? level;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  prerequisites;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  materialProvided;

  final _i1.PrismaUnion<
    _i2.ConsultationPlanUpdatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.ConsultationUpdateManyWithoutConsultationPlanNestedInput?
  consultations;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInHours': durationInHours,
    'price': price,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultations': consultations,
  };
}

class ConsultationPlanUpsertWithWhereUniqueWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanUpsertWithWhereUniqueWithoutConsultantProfileInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.ConsultationPlanWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.ConsultationPlanUpdateWithoutConsultantProfileInput,
    _i2.ConsultationPlanUncheckedUpdateWithoutConsultantProfileInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.ConsultationPlanCreateWithoutConsultantProfileInput,
    _i2.ConsultationPlanUncheckedCreateWithoutConsultantProfileInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'update': update,
    'create': create,
  };
}

class ConsultationPlanUpdateManyWithoutConsultantProfileNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanUpdateManyWithoutConsultantProfileNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.ConsultationPlanCreateWithoutConsultantProfileInput,
    _i1.PrismaUnion<
      Iterable<_i2.ConsultationPlanCreateWithoutConsultantProfileInput>,
      _i1.PrismaUnion<
        _i2.ConsultationPlanUncheckedCreateWithoutConsultantProfileInput,
        Iterable<
          _i2.ConsultationPlanUncheckedCreateWithoutConsultantProfileInput
        >
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.ConsultationPlanCreateOrConnectWithoutConsultantProfileInput,
    Iterable<_i2.ConsultationPlanCreateOrConnectWithoutConsultantProfileInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.ConsultationPlanUpsertWithWhereUniqueWithoutConsultantProfileInput,
    Iterable<
      _i2.ConsultationPlanUpsertWithWhereUniqueWithoutConsultantProfileInput
    >
  >?
  upsert;

  final _i2.ConsultationPlanCreateManyConsultantProfileInputEnvelope?
  createMany;

  final _i1.PrismaUnion<
    _i2.ConsultationPlanWhereUniqueInput,
    Iterable<_i2.ConsultationPlanWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.ConsultationPlanWhereUniqueInput,
    Iterable<_i2.ConsultationPlanWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.ConsultationPlanWhereUniqueInput,
    Iterable<_i2.ConsultationPlanWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.ConsultationPlanWhereUniqueInput,
    Iterable<_i2.ConsultationPlanWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.ConsultationPlanUpdateWithWhereUniqueWithoutConsultantProfileInput,
    Iterable<
      _i2.ConsultationPlanUpdateWithWhereUniqueWithoutConsultantProfileInput
    >
  >?
  update;

  final _i1.PrismaUnion<
    _i2.ConsultationPlanUpdateManyWithWhereWithoutConsultantProfileInput,
    Iterable<
      _i2.ConsultationPlanUpdateManyWithWhereWithoutConsultantProfileInput
    >
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.ConsultationPlanScalarWhereInput,
    Iterable<_i2.ConsultationPlanScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class ConsultantProfileUpdateWithoutReviewsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUpdateWithoutReviewsInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    this.scheduleType,
    this.createdAt,
    this.updatedAt,
    this.domain,
    this.subDomains,
    this.tags,
    this.slotsOfAvailabilityWeekly,
    this.slotsOfAvailabilityCustom,
    this.consultationPlans,
    this.subscriptionPlans,
    this.webinarPlans,
    this.classPlans,
    this.user,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  qualifications;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  specialization;

  final _i1.PrismaUnion<
    double,
    _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  experience;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? rating;

  final _i1.PrismaUnion<
    _i3.ScheduleType,
    _i2.EnumScheduleTypeFieldUpdateOperationsInput
  >?
  scheduleType;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.DomainUpdateOneRequiredWithoutConsultantProfilesNestedInput? domain;

  final _i2.SubDomainUpdateManyWithoutConsultantProfilesNestedInput? subDomains;

  final _i2.TagUpdateManyWithoutConsultantProfilesNestedInput? tags;

  final _i2.SlotOfAvailabilityWeeklyUpdateManyWithoutConsultantProfileNestedInput?
  slotsOfAvailabilityWeekly;

  final _i2.SlotOfAvailabilityCustomUpdateManyWithoutConsultantProfileNestedInput?
  slotsOfAvailabilityCustom;

  final _i2.ConsultationPlanUpdateManyWithoutConsultantProfileNestedInput?
  consultationPlans;

  final _i2.SubscriptionPlanUpdateManyWithoutConsultantProfileNestedInput?
  subscriptionPlans;

  final _i2.WebinarPlanUpdateManyWithoutConsultantProfileNestedInput?
  webinarPlans;

  final _i2.ClassPlanUpdateManyWithoutConsultantProfileNestedInput? classPlans;

  final _i2.UserUpdateOneRequiredWithoutConsultantProfileNestedInput? user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'scheduleType': scheduleType,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'domain': domain,
    'subDomains': subDomains,
    'tags': tags,
    'slotsOfAvailabilityWeekly': slotsOfAvailabilityWeekly,
    'slotsOfAvailabilityCustom': slotsOfAvailabilityCustom,
    'consultationPlans': consultationPlans,
    'subscriptionPlans': subscriptionPlans,
    'webinarPlans': webinarPlans,
    'classPlans': classPlans,
    'user': user,
  };
}

class ConsultantProfileUncheckedUpdateWithoutReviewsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUncheckedUpdateWithoutReviewsInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    this.domainId,
    this.scheduleType,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.subDomains,
    this.tags,
    this.slotsOfAvailabilityWeekly,
    this.slotsOfAvailabilityCustom,
    this.consultationPlans,
    this.subscriptionPlans,
    this.webinarPlans,
    this.classPlans,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  qualifications;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  specialization;

  final _i1.PrismaUnion<
    double,
    _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  experience;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? rating;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? domainId;

  final _i1.PrismaUnion<
    _i3.ScheduleType,
    _i2.EnumScheduleTypeFieldUpdateOperationsInput
  >?
  scheduleType;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.SubDomainUncheckedUpdateManyWithoutConsultantProfilesNestedInput?
  subDomains;

  final _i2.TagUncheckedUpdateManyWithoutConsultantProfilesNestedInput? tags;

  final _i2.SlotOfAvailabilityWeeklyUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  slotsOfAvailabilityWeekly;

  final _i2.SlotOfAvailabilityCustomUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  slotsOfAvailabilityCustom;

  final _i2.ConsultationPlanUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  consultationPlans;

  final _i2.SubscriptionPlanUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  subscriptionPlans;

  final _i2.WebinarPlanUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  webinarPlans;

  final _i2.ClassPlanUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  classPlans;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'domainId': domainId,
    'scheduleType': scheduleType,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'subDomains': subDomains,
    'tags': tags,
    'slotsOfAvailabilityWeekly': slotsOfAvailabilityWeekly,
    'slotsOfAvailabilityCustom': slotsOfAvailabilityCustom,
    'consultationPlans': consultationPlans,
    'subscriptionPlans': subscriptionPlans,
    'webinarPlans': webinarPlans,
    'classPlans': classPlans,
  };
}

class ConsultantProfileUpsertWithoutReviewsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUpsertWithoutReviewsInput({
    required this.update,
    required this.create,
  });

  final _i1.PrismaUnion<
    _i2.ConsultantProfileUpdateWithoutReviewsInput,
    _i2.ConsultantProfileUncheckedUpdateWithoutReviewsInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateWithoutReviewsInput,
    _i2.ConsultantProfileUncheckedCreateWithoutReviewsInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'update': update, 'create': create};
}

class ConsultantProfileUpdateOneRequiredWithoutReviewsNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUpdateOneRequiredWithoutReviewsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateWithoutReviewsInput,
    _i2.ConsultantProfileUncheckedCreateWithoutReviewsInput
  >?
  create;

  final _i2.ConsultantProfileCreateOrConnectWithoutReviewsInput?
  connectOrCreate;

  final _i2.ConsultantProfileUpsertWithoutReviewsInput? upsert;

  final _i2.ConsultantProfileWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileUpdateWithoutReviewsInput,
    _i2.ConsultantProfileUncheckedUpdateWithoutReviewsInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'connect': connect,
    'update': update,
  };
}

class ConsultantReviewUpdateWithoutConsulteeProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewUpdateWithoutConsulteeProfileInput({
    this.id,
    this.rating,
    this.reviewDescription,
    this.createdAt,
    this.updatedAt,
    this.consultantProfile,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? rating;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  reviewDescription;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.ConsultantProfileUpdateOneRequiredWithoutReviewsNestedInput?
  consultantProfile;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'rating': rating,
    'reviewDescription': reviewDescription,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultantProfile': consultantProfile,
  };
}

class ConsultantReviewUpsertWithWhereUniqueWithoutConsulteeProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewUpsertWithWhereUniqueWithoutConsulteeProfileInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.ConsultantReviewWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewUpdateWithoutConsulteeProfileInput,
    _i2.ConsultantReviewUncheckedUpdateWithoutConsulteeProfileInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewCreateWithoutConsulteeProfileInput,
    _i2.ConsultantReviewUncheckedCreateWithoutConsulteeProfileInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'update': update,
    'create': create,
  };
}

class ConsultantReviewUpdateManyWithoutConsulteeProfileNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewUpdateManyWithoutConsulteeProfileNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.ConsultantReviewCreateWithoutConsulteeProfileInput,
    _i1.PrismaUnion<
      Iterable<_i2.ConsultantReviewCreateWithoutConsulteeProfileInput>,
      _i1.PrismaUnion<
        _i2.ConsultantReviewUncheckedCreateWithoutConsulteeProfileInput,
        Iterable<
          _i2.ConsultantReviewUncheckedCreateWithoutConsulteeProfileInput
        >
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewCreateOrConnectWithoutConsulteeProfileInput,
    Iterable<_i2.ConsultantReviewCreateOrConnectWithoutConsulteeProfileInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewUpsertWithWhereUniqueWithoutConsulteeProfileInput,
    Iterable<
      _i2.ConsultantReviewUpsertWithWhereUniqueWithoutConsulteeProfileInput
    >
  >?
  upsert;

  final _i2.ConsultantReviewCreateManyConsulteeProfileInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewWhereUniqueInput,
    Iterable<_i2.ConsultantReviewWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewWhereUniqueInput,
    Iterable<_i2.ConsultantReviewWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewWhereUniqueInput,
    Iterable<_i2.ConsultantReviewWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewWhereUniqueInput,
    Iterable<_i2.ConsultantReviewWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewUpdateWithWhereUniqueWithoutConsulteeProfileInput,
    Iterable<
      _i2.ConsultantReviewUpdateWithWhereUniqueWithoutConsulteeProfileInput
    >
  >?
  update;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewUpdateManyWithWhereWithoutConsulteeProfileInput,
    Iterable<
      _i2.ConsultantReviewUpdateManyWithWhereWithoutConsulteeProfileInput
    >
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewScalarWhereInput,
    Iterable<_i2.ConsultantReviewScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class ConsulteeProfileUpdateWithoutSubscriptionRequestsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileUpdateWithoutSubscriptionRequestsInput({
    this.id,
    this.education,
    this.occupation,
    this.aboutMe,
    this.preferredCommunicationMethod,
    this.preferredLanguage,
    this.specialRequirements,
    this.interests,
    this.goals,
    this.createdAt,
    this.updatedAt,
    this.consultationRequests,
    this.consultantReviews,
    this.user,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  education;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  occupation;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  aboutMe;

  final _i1.PrismaUnion<
    _i3.ConsultationMode,
    _i1.PrismaUnion<
      _i2.NullableEnumConsultationModeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  preferredCommunicationMethod;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  preferredLanguage;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  specialRequirements;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  interests;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  goals;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.ConsultationUpdateManyWithoutRequestedByNestedInput?
  consultationRequests;

  final _i2.ConsultantReviewUpdateManyWithoutConsulteeProfileNestedInput?
  consultantReviews;

  final _i2.UserUpdateOneRequiredWithoutConsulteeProfileNestedInput? user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'education': education,
    'occupation': occupation,
    'aboutMe': aboutMe,
    'preferredCommunicationMethod': preferredCommunicationMethod,
    'preferredLanguage': preferredLanguage,
    'specialRequirements': specialRequirements,
    'interests': interests,
    'goals': goals,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultationRequests': consultationRequests,
    'consultantReviews': consultantReviews,
    'user': user,
  };
}

class ConsulteeProfileUncheckedUpdateWithoutSubscriptionRequestsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileUncheckedUpdateWithoutSubscriptionRequestsInput({
    this.id,
    this.education,
    this.occupation,
    this.aboutMe,
    this.preferredCommunicationMethod,
    this.preferredLanguage,
    this.specialRequirements,
    this.interests,
    this.goals,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.consultationRequests,
    this.consultantReviews,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  education;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  occupation;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  aboutMe;

  final _i1.PrismaUnion<
    _i3.ConsultationMode,
    _i1.PrismaUnion<
      _i2.NullableEnumConsultationModeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  preferredCommunicationMethod;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  preferredLanguage;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  specialRequirements;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  interests;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  goals;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.ConsultationUncheckedUpdateManyWithoutRequestedByNestedInput?
  consultationRequests;

  final _i2.ConsultantReviewUncheckedUpdateManyWithoutConsulteeProfileNestedInput?
  consultantReviews;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'education': education,
    'occupation': occupation,
    'aboutMe': aboutMe,
    'preferredCommunicationMethod': preferredCommunicationMethod,
    'preferredLanguage': preferredLanguage,
    'specialRequirements': specialRequirements,
    'interests': interests,
    'goals': goals,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultationRequests': consultationRequests,
    'consultantReviews': consultantReviews,
  };
}

class ConsulteeProfileUpsertWithoutSubscriptionRequestsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileUpsertWithoutSubscriptionRequestsInput({
    required this.update,
    required this.create,
  });

  final _i1.PrismaUnion<
    _i2.ConsulteeProfileUpdateWithoutSubscriptionRequestsInput,
    _i2.ConsulteeProfileUncheckedUpdateWithoutSubscriptionRequestsInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.ConsulteeProfileCreateWithoutSubscriptionRequestsInput,
    _i2.ConsulteeProfileUncheckedCreateWithoutSubscriptionRequestsInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'update': update, 'create': create};
}

class ConsulteeProfileUpdateOneRequiredWithoutSubscriptionRequestsNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileUpdateOneRequiredWithoutSubscriptionRequestsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.ConsulteeProfileCreateWithoutSubscriptionRequestsInput,
    _i2.ConsulteeProfileUncheckedCreateWithoutSubscriptionRequestsInput
  >?
  create;

  final _i2.ConsulteeProfileCreateOrConnectWithoutSubscriptionRequestsInput?
  connectOrCreate;

  final _i2.ConsulteeProfileUpsertWithoutSubscriptionRequestsInput? upsert;

  final _i2.ConsulteeProfileWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.ConsulteeProfileUpdateWithoutSubscriptionRequestsInput,
    _i2.ConsulteeProfileUncheckedUpdateWithoutSubscriptionRequestsInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'connect': connect,
    'update': update,
  };
}

class SubscriptionUpdateWithoutSubscriptionPlanInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionUpdateWithoutSubscriptionPlanInput({
    this.id,
    this.startDate,
    this.endDate,
    this.requestStatus,
    this.requestedAt,
    this.requestNotes,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.createdAt,
    this.updatedAt,
    this.requestedBy,
    this.appointments,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  startDate;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  endDate;

  final _i1.PrismaUnion<
    _i3.RequestStatus,
    _i2.EnumRequestStatusFieldUpdateOperationsInput
  >?
  requestStatus;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  requestedAt;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  requestNotes;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackFromConsultee;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackFromConsultant;

  final _i1.PrismaUnion<
    double,
    _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  rating;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.ConsulteeProfileUpdateOneRequiredWithoutSubscriptionRequestsNestedInput?
  requestedBy;

  final _i2.AppointmentUpdateManyWithoutSubscriptionNestedInput? appointments;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'requestStatus': requestStatus,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'requestedBy': requestedBy,
    'appointments': appointments,
  };
}

class SubscriptionUpsertWithWhereUniqueWithoutSubscriptionPlanInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionUpsertWithWhereUniqueWithoutSubscriptionPlanInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.SubscriptionWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.SubscriptionUpdateWithoutSubscriptionPlanInput,
    _i2.SubscriptionUncheckedUpdateWithoutSubscriptionPlanInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.SubscriptionCreateWithoutSubscriptionPlanInput,
    _i2.SubscriptionUncheckedCreateWithoutSubscriptionPlanInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'update': update,
    'create': create,
  };
}

class SubscriptionUpdateManyWithoutSubscriptionPlanNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionUpdateManyWithoutSubscriptionPlanNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.SubscriptionCreateWithoutSubscriptionPlanInput,
    _i1.PrismaUnion<
      Iterable<_i2.SubscriptionCreateWithoutSubscriptionPlanInput>,
      _i1.PrismaUnion<
        _i2.SubscriptionUncheckedCreateWithoutSubscriptionPlanInput,
        Iterable<_i2.SubscriptionUncheckedCreateWithoutSubscriptionPlanInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.SubscriptionCreateOrConnectWithoutSubscriptionPlanInput,
    Iterable<_i2.SubscriptionCreateOrConnectWithoutSubscriptionPlanInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.SubscriptionUpsertWithWhereUniqueWithoutSubscriptionPlanInput,
    Iterable<_i2.SubscriptionUpsertWithWhereUniqueWithoutSubscriptionPlanInput>
  >?
  upsert;

  final _i2.SubscriptionCreateManySubscriptionPlanInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.SubscriptionWhereUniqueInput,
    Iterable<_i2.SubscriptionWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.SubscriptionWhereUniqueInput,
    Iterable<_i2.SubscriptionWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.SubscriptionWhereUniqueInput,
    Iterable<_i2.SubscriptionWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.SubscriptionWhereUniqueInput,
    Iterable<_i2.SubscriptionWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.SubscriptionUpdateWithWhereUniqueWithoutSubscriptionPlanInput,
    Iterable<_i2.SubscriptionUpdateWithWhereUniqueWithoutSubscriptionPlanInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.SubscriptionUpdateManyWithWhereWithoutSubscriptionPlanInput,
    Iterable<_i2.SubscriptionUpdateManyWithWhereWithoutSubscriptionPlanInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.SubscriptionScalarWhereInput,
    Iterable<_i2.SubscriptionScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class SubscriptionPlanUpdateWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanUpdateWithoutConsultantProfileInput({
    this.id,
    this.title,
    this.description,
    this.durationInMonths,
    this.price,
    this.callsPerWeek,
    this.sessionDurationInHours,
    this.videoMeetings,
    this.emailSupport,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.createdAt,
    this.updatedAt,
    this.subscriptions,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
  durationInMonths;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? price;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? callsPerWeek;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
  sessionDurationInHours;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? videoMeetings;

  final _i1.PrismaUnion<
    _i3.PlanEmailSupport,
    _i2.EnumPlanEmailSupportFieldUpdateOperationsInput
  >?
  emailSupport;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? language;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? level;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  prerequisites;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  materialProvided;

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanUpdatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.SubscriptionUpdateManyWithoutSubscriptionPlanNestedInput?
  subscriptions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInMonths': durationInMonths,
    'price': price,
    'callsPerWeek': callsPerWeek,
    'sessionDurationInHours': sessionDurationInHours,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'subscriptions': subscriptions,
  };
}

class SubscriptionPlanUpsertWithWhereUniqueWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanUpsertWithWhereUniqueWithoutConsultantProfileInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.SubscriptionPlanWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanUpdateWithoutConsultantProfileInput,
    _i2.SubscriptionPlanUncheckedUpdateWithoutConsultantProfileInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanCreateWithoutConsultantProfileInput,
    _i2.SubscriptionPlanUncheckedCreateWithoutConsultantProfileInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'update': update,
    'create': create,
  };
}

class SubscriptionPlanUpdateManyWithoutConsultantProfileNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanUpdateManyWithoutConsultantProfileNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanCreateWithoutConsultantProfileInput,
    _i1.PrismaUnion<
      Iterable<_i2.SubscriptionPlanCreateWithoutConsultantProfileInput>,
      _i1.PrismaUnion<
        _i2.SubscriptionPlanUncheckedCreateWithoutConsultantProfileInput,
        Iterable<
          _i2.SubscriptionPlanUncheckedCreateWithoutConsultantProfileInput
        >
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanCreateOrConnectWithoutConsultantProfileInput,
    Iterable<_i2.SubscriptionPlanCreateOrConnectWithoutConsultantProfileInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanUpsertWithWhereUniqueWithoutConsultantProfileInput,
    Iterable<
      _i2.SubscriptionPlanUpsertWithWhereUniqueWithoutConsultantProfileInput
    >
  >?
  upsert;

  final _i2.SubscriptionPlanCreateManyConsultantProfileInputEnvelope?
  createMany;

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanWhereUniqueInput,
    Iterable<_i2.SubscriptionPlanWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanWhereUniqueInput,
    Iterable<_i2.SubscriptionPlanWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanWhereUniqueInput,
    Iterable<_i2.SubscriptionPlanWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanWhereUniqueInput,
    Iterable<_i2.SubscriptionPlanWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanUpdateWithWhereUniqueWithoutConsultantProfileInput,
    Iterable<
      _i2.SubscriptionPlanUpdateWithWhereUniqueWithoutConsultantProfileInput
    >
  >?
  update;

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanUpdateManyWithWhereWithoutConsultantProfileInput,
    Iterable<
      _i2.SubscriptionPlanUpdateManyWithWhereWithoutConsultantProfileInput
    >
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanScalarWhereInput,
    Iterable<_i2.SubscriptionPlanScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class ConsultantProfileUpdateWithoutConsultationPlansInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUpdateWithoutConsultationPlansInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    this.scheduleType,
    this.createdAt,
    this.updatedAt,
    this.domain,
    this.subDomains,
    this.tags,
    this.reviews,
    this.slotsOfAvailabilityWeekly,
    this.slotsOfAvailabilityCustom,
    this.subscriptionPlans,
    this.webinarPlans,
    this.classPlans,
    this.user,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  qualifications;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  specialization;

  final _i1.PrismaUnion<
    double,
    _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  experience;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? rating;

  final _i1.PrismaUnion<
    _i3.ScheduleType,
    _i2.EnumScheduleTypeFieldUpdateOperationsInput
  >?
  scheduleType;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.DomainUpdateOneRequiredWithoutConsultantProfilesNestedInput? domain;

  final _i2.SubDomainUpdateManyWithoutConsultantProfilesNestedInput? subDomains;

  final _i2.TagUpdateManyWithoutConsultantProfilesNestedInput? tags;

  final _i2.ConsultantReviewUpdateManyWithoutConsultantProfileNestedInput?
  reviews;

  final _i2.SlotOfAvailabilityWeeklyUpdateManyWithoutConsultantProfileNestedInput?
  slotsOfAvailabilityWeekly;

  final _i2.SlotOfAvailabilityCustomUpdateManyWithoutConsultantProfileNestedInput?
  slotsOfAvailabilityCustom;

  final _i2.SubscriptionPlanUpdateManyWithoutConsultantProfileNestedInput?
  subscriptionPlans;

  final _i2.WebinarPlanUpdateManyWithoutConsultantProfileNestedInput?
  webinarPlans;

  final _i2.ClassPlanUpdateManyWithoutConsultantProfileNestedInput? classPlans;

  final _i2.UserUpdateOneRequiredWithoutConsultantProfileNestedInput? user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'scheduleType': scheduleType,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'domain': domain,
    'subDomains': subDomains,
    'tags': tags,
    'reviews': reviews,
    'slotsOfAvailabilityWeekly': slotsOfAvailabilityWeekly,
    'slotsOfAvailabilityCustom': slotsOfAvailabilityCustom,
    'subscriptionPlans': subscriptionPlans,
    'webinarPlans': webinarPlans,
    'classPlans': classPlans,
    'user': user,
  };
}

class ConsultantProfileUncheckedUpdateWithoutConsultationPlansInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUncheckedUpdateWithoutConsultationPlansInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    this.domainId,
    this.scheduleType,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.subDomains,
    this.tags,
    this.reviews,
    this.slotsOfAvailabilityWeekly,
    this.slotsOfAvailabilityCustom,
    this.subscriptionPlans,
    this.webinarPlans,
    this.classPlans,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  qualifications;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  specialization;

  final _i1.PrismaUnion<
    double,
    _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  experience;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? rating;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? domainId;

  final _i1.PrismaUnion<
    _i3.ScheduleType,
    _i2.EnumScheduleTypeFieldUpdateOperationsInput
  >?
  scheduleType;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.SubDomainUncheckedUpdateManyWithoutConsultantProfilesNestedInput?
  subDomains;

  final _i2.TagUncheckedUpdateManyWithoutConsultantProfilesNestedInput? tags;

  final _i2.ConsultantReviewUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  reviews;

  final _i2.SlotOfAvailabilityWeeklyUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  slotsOfAvailabilityWeekly;

  final _i2.SlotOfAvailabilityCustomUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  slotsOfAvailabilityCustom;

  final _i2.SubscriptionPlanUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  subscriptionPlans;

  final _i2.WebinarPlanUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  webinarPlans;

  final _i2.ClassPlanUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  classPlans;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'domainId': domainId,
    'scheduleType': scheduleType,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'subDomains': subDomains,
    'tags': tags,
    'reviews': reviews,
    'slotsOfAvailabilityWeekly': slotsOfAvailabilityWeekly,
    'slotsOfAvailabilityCustom': slotsOfAvailabilityCustom,
    'subscriptionPlans': subscriptionPlans,
    'webinarPlans': webinarPlans,
    'classPlans': classPlans,
  };
}

class ConsultantProfileUpsertWithoutConsultationPlansInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUpsertWithoutConsultationPlansInput({
    required this.update,
    required this.create,
  });

  final _i1.PrismaUnion<
    _i2.ConsultantProfileUpdateWithoutConsultationPlansInput,
    _i2.ConsultantProfileUncheckedUpdateWithoutConsultationPlansInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateWithoutConsultationPlansInput,
    _i2.ConsultantProfileUncheckedCreateWithoutConsultationPlansInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'update': update, 'create': create};
}

class ConsultantProfileUpdateOneRequiredWithoutConsultationPlansNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUpdateOneRequiredWithoutConsultationPlansNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateWithoutConsultationPlansInput,
    _i2.ConsultantProfileUncheckedCreateWithoutConsultationPlansInput
  >?
  create;

  final _i2.ConsultantProfileCreateOrConnectWithoutConsultationPlansInput?
  connectOrCreate;

  final _i2.ConsultantProfileUpsertWithoutConsultationPlansInput? upsert;

  final _i2.ConsultantProfileWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileUpdateWithoutConsultationPlansInput,
    _i2.ConsultantProfileUncheckedUpdateWithoutConsultationPlansInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'connect': connect,
    'update': update,
  };
}

class ConsultationPlanUpdateWithoutConsultationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanUpdateWithoutConsultationsInput({
    this.id,
    this.title,
    this.description,
    this.durationInHours,
    this.price,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.createdAt,
    this.updatedAt,
    this.consultantProfile,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
  durationInHours;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? price;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? language;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? level;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  prerequisites;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  materialProvided;

  final _i1.PrismaUnion<
    _i2.ConsultationPlanUpdatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.ConsultantProfileUpdateOneRequiredWithoutConsultationPlansNestedInput?
  consultantProfile;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInHours': durationInHours,
    'price': price,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultantProfile': consultantProfile,
  };
}

class ConsultationPlanUncheckedUpdateWithoutConsultationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanUncheckedUpdateWithoutConsultationsInput({
    this.id,
    this.title,
    this.description,
    this.durationInHours,
    this.price,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
  durationInHours;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? price;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? language;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? level;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  prerequisites;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  materialProvided;

  final _i1.PrismaUnion<
    _i2.ConsultationPlanUpdatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  consultantProfileId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInHours': durationInHours,
    'price': price,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultationPlanUpsertWithoutConsultationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanUpsertWithoutConsultationsInput({
    required this.update,
    required this.create,
  });

  final _i1.PrismaUnion<
    _i2.ConsultationPlanUpdateWithoutConsultationsInput,
    _i2.ConsultationPlanUncheckedUpdateWithoutConsultationsInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.ConsultationPlanCreateWithoutConsultationsInput,
    _i2.ConsultationPlanUncheckedCreateWithoutConsultationsInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'update': update, 'create': create};
}

class ConsultationPlanUpdateOneRequiredWithoutConsultationsNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanUpdateOneRequiredWithoutConsultationsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.ConsultationPlanCreateWithoutConsultationsInput,
    _i2.ConsultationPlanUncheckedCreateWithoutConsultationsInput
  >?
  create;

  final _i2.ConsultationPlanCreateOrConnectWithoutConsultationsInput?
  connectOrCreate;

  final _i2.ConsultationPlanUpsertWithoutConsultationsInput? upsert;

  final _i2.ConsultationPlanWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.ConsultationPlanUpdateWithoutConsultationsInput,
    _i2.ConsultationPlanUncheckedUpdateWithoutConsultationsInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'connect': connect,
    'update': update,
  };
}

class ConsultationUpdateWithoutRequestedByInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationUpdateWithoutRequestedByInput({
    this.id,
    this.requestStatus,
    this.requestedAt,
    this.requestNotes,
    this.directlyBooked,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.createdAt,
    this.updatedAt,
    this.consultationPlan,
    this.appointment,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    _i3.RequestStatus,
    _i2.EnumRequestStatusFieldUpdateOperationsInput
  >?
  requestStatus;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  requestedAt;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  requestNotes;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
  directlyBooked;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackFromConsultee;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackFromConsultant;

  final _i1.PrismaUnion<
    double,
    _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  rating;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.ConsultationPlanUpdateOneRequiredWithoutConsultationsNestedInput?
  consultationPlan;

  final _i2.AppointmentUpdateOneWithoutConsultationNestedInput? appointment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'requestStatus': requestStatus,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'directlyBooked': directlyBooked,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultationPlan': consultationPlan,
    'appointment': appointment,
  };
}

class ConsultationUpsertWithWhereUniqueWithoutRequestedByInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationUpsertWithWhereUniqueWithoutRequestedByInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.ConsultationWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.ConsultationUpdateWithoutRequestedByInput,
    _i2.ConsultationUncheckedUpdateWithoutRequestedByInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.ConsultationCreateWithoutRequestedByInput,
    _i2.ConsultationUncheckedCreateWithoutRequestedByInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'update': update,
    'create': create,
  };
}

class ConsultationUpdateManyWithoutRequestedByNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationUpdateManyWithoutRequestedByNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.ConsultationCreateWithoutRequestedByInput,
    _i1.PrismaUnion<
      Iterable<_i2.ConsultationCreateWithoutRequestedByInput>,
      _i1.PrismaUnion<
        _i2.ConsultationUncheckedCreateWithoutRequestedByInput,
        Iterable<_i2.ConsultationUncheckedCreateWithoutRequestedByInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.ConsultationCreateOrConnectWithoutRequestedByInput,
    Iterable<_i2.ConsultationCreateOrConnectWithoutRequestedByInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.ConsultationUpsertWithWhereUniqueWithoutRequestedByInput,
    Iterable<_i2.ConsultationUpsertWithWhereUniqueWithoutRequestedByInput>
  >?
  upsert;

  final _i2.ConsultationCreateManyRequestedByInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.ConsultationWhereUniqueInput,
    Iterable<_i2.ConsultationWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.ConsultationWhereUniqueInput,
    Iterable<_i2.ConsultationWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.ConsultationWhereUniqueInput,
    Iterable<_i2.ConsultationWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.ConsultationWhereUniqueInput,
    Iterable<_i2.ConsultationWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.ConsultationUpdateWithWhereUniqueWithoutRequestedByInput,
    Iterable<_i2.ConsultationUpdateWithWhereUniqueWithoutRequestedByInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.ConsultationUpdateManyWithWhereWithoutRequestedByInput,
    Iterable<_i2.ConsultationUpdateManyWithWhereWithoutRequestedByInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.ConsultationScalarWhereInput,
    Iterable<_i2.ConsultationScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class ConsulteeProfileUpdateWithoutConsultantReviewsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileUpdateWithoutConsultantReviewsInput({
    this.id,
    this.education,
    this.occupation,
    this.aboutMe,
    this.preferredCommunicationMethod,
    this.preferredLanguage,
    this.specialRequirements,
    this.interests,
    this.goals,
    this.createdAt,
    this.updatedAt,
    this.consultationRequests,
    this.subscriptionRequests,
    this.user,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  education;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  occupation;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  aboutMe;

  final _i1.PrismaUnion<
    _i3.ConsultationMode,
    _i1.PrismaUnion<
      _i2.NullableEnumConsultationModeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  preferredCommunicationMethod;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  preferredLanguage;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  specialRequirements;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  interests;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  goals;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.ConsultationUpdateManyWithoutRequestedByNestedInput?
  consultationRequests;

  final _i2.SubscriptionUpdateManyWithoutRequestedByNestedInput?
  subscriptionRequests;

  final _i2.UserUpdateOneRequiredWithoutConsulteeProfileNestedInput? user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'education': education,
    'occupation': occupation,
    'aboutMe': aboutMe,
    'preferredCommunicationMethod': preferredCommunicationMethod,
    'preferredLanguage': preferredLanguage,
    'specialRequirements': specialRequirements,
    'interests': interests,
    'goals': goals,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultationRequests': consultationRequests,
    'subscriptionRequests': subscriptionRequests,
    'user': user,
  };
}

class ConsulteeProfileUncheckedUpdateWithoutConsultantReviewsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileUncheckedUpdateWithoutConsultantReviewsInput({
    this.id,
    this.education,
    this.occupation,
    this.aboutMe,
    this.preferredCommunicationMethod,
    this.preferredLanguage,
    this.specialRequirements,
    this.interests,
    this.goals,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.consultationRequests,
    this.subscriptionRequests,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  education;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  occupation;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  aboutMe;

  final _i1.PrismaUnion<
    _i3.ConsultationMode,
    _i1.PrismaUnion<
      _i2.NullableEnumConsultationModeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  preferredCommunicationMethod;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  preferredLanguage;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  specialRequirements;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  interests;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  goals;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.ConsultationUncheckedUpdateManyWithoutRequestedByNestedInput?
  consultationRequests;

  final _i2.SubscriptionUncheckedUpdateManyWithoutRequestedByNestedInput?
  subscriptionRequests;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'education': education,
    'occupation': occupation,
    'aboutMe': aboutMe,
    'preferredCommunicationMethod': preferredCommunicationMethod,
    'preferredLanguage': preferredLanguage,
    'specialRequirements': specialRequirements,
    'interests': interests,
    'goals': goals,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultationRequests': consultationRequests,
    'subscriptionRequests': subscriptionRequests,
  };
}

class ConsulteeProfileUpsertWithoutConsultantReviewsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileUpsertWithoutConsultantReviewsInput({
    required this.update,
    required this.create,
  });

  final _i1.PrismaUnion<
    _i2.ConsulteeProfileUpdateWithoutConsultantReviewsInput,
    _i2.ConsulteeProfileUncheckedUpdateWithoutConsultantReviewsInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.ConsulteeProfileCreateWithoutConsultantReviewsInput,
    _i2.ConsulteeProfileUncheckedCreateWithoutConsultantReviewsInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'update': update, 'create': create};
}

class ConsulteeProfileUpdateOneRequiredWithoutConsultantReviewsNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileUpdateOneRequiredWithoutConsultantReviewsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.ConsulteeProfileCreateWithoutConsultantReviewsInput,
    _i2.ConsulteeProfileUncheckedCreateWithoutConsultantReviewsInput
  >?
  create;

  final _i2.ConsulteeProfileCreateOrConnectWithoutConsultantReviewsInput?
  connectOrCreate;

  final _i2.ConsulteeProfileUpsertWithoutConsultantReviewsInput? upsert;

  final _i2.ConsulteeProfileWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.ConsulteeProfileUpdateWithoutConsultantReviewsInput,
    _i2.ConsulteeProfileUncheckedUpdateWithoutConsultantReviewsInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'connect': connect,
    'update': update,
  };
}

class ConsultantReviewUpdateWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewUpdateWithoutConsultantProfileInput({
    this.id,
    this.rating,
    this.reviewDescription,
    this.createdAt,
    this.updatedAt,
    this.consulteeProfile,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? rating;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  reviewDescription;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.ConsulteeProfileUpdateOneRequiredWithoutConsultantReviewsNestedInput?
  consulteeProfile;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'rating': rating,
    'reviewDescription': reviewDescription,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consulteeProfile': consulteeProfile,
  };
}

class ConsultantReviewUpsertWithWhereUniqueWithoutConsultantProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewUpsertWithWhereUniqueWithoutConsultantProfileInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.ConsultantReviewWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewUpdateWithoutConsultantProfileInput,
    _i2.ConsultantReviewUncheckedUpdateWithoutConsultantProfileInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewCreateWithoutConsultantProfileInput,
    _i2.ConsultantReviewUncheckedCreateWithoutConsultantProfileInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'update': update,
    'create': create,
  };
}

class ConsultantReviewUpdateManyWithoutConsultantProfileNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewUpdateManyWithoutConsultantProfileNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.ConsultantReviewCreateWithoutConsultantProfileInput,
    _i1.PrismaUnion<
      Iterable<_i2.ConsultantReviewCreateWithoutConsultantProfileInput>,
      _i1.PrismaUnion<
        _i2.ConsultantReviewUncheckedCreateWithoutConsultantProfileInput,
        Iterable<
          _i2.ConsultantReviewUncheckedCreateWithoutConsultantProfileInput
        >
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewCreateOrConnectWithoutConsultantProfileInput,
    Iterable<_i2.ConsultantReviewCreateOrConnectWithoutConsultantProfileInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewUpsertWithWhereUniqueWithoutConsultantProfileInput,
    Iterable<
      _i2.ConsultantReviewUpsertWithWhereUniqueWithoutConsultantProfileInput
    >
  >?
  upsert;

  final _i2.ConsultantReviewCreateManyConsultantProfileInputEnvelope?
  createMany;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewWhereUniqueInput,
    Iterable<_i2.ConsultantReviewWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewWhereUniqueInput,
    Iterable<_i2.ConsultantReviewWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewWhereUniqueInput,
    Iterable<_i2.ConsultantReviewWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewWhereUniqueInput,
    Iterable<_i2.ConsultantReviewWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewUpdateWithWhereUniqueWithoutConsultantProfileInput,
    Iterable<
      _i2.ConsultantReviewUpdateWithWhereUniqueWithoutConsultantProfileInput
    >
  >?
  update;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewUpdateManyWithWhereWithoutConsultantProfileInput,
    Iterable<
      _i2.ConsultantReviewUpdateManyWithWhereWithoutConsultantProfileInput
    >
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewScalarWhereInput,
    Iterable<_i2.ConsultantReviewScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class ConsultantProfileUpdateWithoutTagsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUpdateWithoutTagsInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    this.scheduleType,
    this.createdAt,
    this.updatedAt,
    this.domain,
    this.subDomains,
    this.reviews,
    this.slotsOfAvailabilityWeekly,
    this.slotsOfAvailabilityCustom,
    this.consultationPlans,
    this.subscriptionPlans,
    this.webinarPlans,
    this.classPlans,
    this.user,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  qualifications;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  specialization;

  final _i1.PrismaUnion<
    double,
    _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  experience;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? rating;

  final _i1.PrismaUnion<
    _i3.ScheduleType,
    _i2.EnumScheduleTypeFieldUpdateOperationsInput
  >?
  scheduleType;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.DomainUpdateOneRequiredWithoutConsultantProfilesNestedInput? domain;

  final _i2.SubDomainUpdateManyWithoutConsultantProfilesNestedInput? subDomains;

  final _i2.ConsultantReviewUpdateManyWithoutConsultantProfileNestedInput?
  reviews;

  final _i2.SlotOfAvailabilityWeeklyUpdateManyWithoutConsultantProfileNestedInput?
  slotsOfAvailabilityWeekly;

  final _i2.SlotOfAvailabilityCustomUpdateManyWithoutConsultantProfileNestedInput?
  slotsOfAvailabilityCustom;

  final _i2.ConsultationPlanUpdateManyWithoutConsultantProfileNestedInput?
  consultationPlans;

  final _i2.SubscriptionPlanUpdateManyWithoutConsultantProfileNestedInput?
  subscriptionPlans;

  final _i2.WebinarPlanUpdateManyWithoutConsultantProfileNestedInput?
  webinarPlans;

  final _i2.ClassPlanUpdateManyWithoutConsultantProfileNestedInput? classPlans;

  final _i2.UserUpdateOneRequiredWithoutConsultantProfileNestedInput? user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'scheduleType': scheduleType,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'domain': domain,
    'subDomains': subDomains,
    'reviews': reviews,
    'slotsOfAvailabilityWeekly': slotsOfAvailabilityWeekly,
    'slotsOfAvailabilityCustom': slotsOfAvailabilityCustom,
    'consultationPlans': consultationPlans,
    'subscriptionPlans': subscriptionPlans,
    'webinarPlans': webinarPlans,
    'classPlans': classPlans,
    'user': user,
  };
}

class ConsultantProfileUncheckedUpdateWithoutTagsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUncheckedUpdateWithoutTagsInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    this.domainId,
    this.scheduleType,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.subDomains,
    this.reviews,
    this.slotsOfAvailabilityWeekly,
    this.slotsOfAvailabilityCustom,
    this.consultationPlans,
    this.subscriptionPlans,
    this.webinarPlans,
    this.classPlans,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  qualifications;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  specialization;

  final _i1.PrismaUnion<
    double,
    _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  experience;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? rating;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? domainId;

  final _i1.PrismaUnion<
    _i3.ScheduleType,
    _i2.EnumScheduleTypeFieldUpdateOperationsInput
  >?
  scheduleType;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.SubDomainUncheckedUpdateManyWithoutConsultantProfilesNestedInput?
  subDomains;

  final _i2.ConsultantReviewUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  reviews;

  final _i2.SlotOfAvailabilityWeeklyUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  slotsOfAvailabilityWeekly;

  final _i2.SlotOfAvailabilityCustomUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  slotsOfAvailabilityCustom;

  final _i2.ConsultationPlanUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  consultationPlans;

  final _i2.SubscriptionPlanUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  subscriptionPlans;

  final _i2.WebinarPlanUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  webinarPlans;

  final _i2.ClassPlanUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  classPlans;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'domainId': domainId,
    'scheduleType': scheduleType,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'subDomains': subDomains,
    'reviews': reviews,
    'slotsOfAvailabilityWeekly': slotsOfAvailabilityWeekly,
    'slotsOfAvailabilityCustom': slotsOfAvailabilityCustom,
    'consultationPlans': consultationPlans,
    'subscriptionPlans': subscriptionPlans,
    'webinarPlans': webinarPlans,
    'classPlans': classPlans,
  };
}

class ConsultantProfileUpsertWithWhereUniqueWithoutTagsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUpsertWithWhereUniqueWithoutTagsInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.ConsultantProfileWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileUpdateWithoutTagsInput,
    _i2.ConsultantProfileUncheckedUpdateWithoutTagsInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateWithoutTagsInput,
    _i2.ConsultantProfileUncheckedCreateWithoutTagsInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'update': update,
    'create': create,
  };
}

class ConsultantProfileUpdateWithWhereUniqueWithoutTagsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUpdateWithWhereUniqueWithoutTagsInput({
    required this.where,
    required this.data,
  });

  final _i2.ConsultantProfileWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileUpdateWithoutTagsInput,
    _i2.ConsultantProfileUncheckedUpdateWithoutTagsInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class ConsultantProfileScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    this.domainId,
    this.scheduleType,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
    _i2.ConsultantProfileScalarWhereInput,
    Iterable<_i2.ConsultantProfileScalarWhereInput>
  >?
  AND;

  final Iterable<_i2.ConsultantProfileScalarWhereInput>? OR;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileScalarWhereInput,
    Iterable<_i2.ConsultantProfileScalarWhereInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  description;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  qualifications;

  final _i1.PrismaUnion<
    _i2.StringNullableFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  specialization;

  final _i1.PrismaUnion<
    _i2.FloatNullableFilter,
    _i1.PrismaUnion<double, _i1.PrismaNull>
  >?
  experience;

  final _i1.PrismaUnion<_i2.FloatFilter, double>? rating;

  final _i1.PrismaUnion<_i2.StringFilter, String>? domainId;

  final _i1.PrismaUnion<_i2.EnumScheduleTypeFilter, _i3.ScheduleType>?
  scheduleType;

  final _i1.PrismaUnion<_i2.StringFilter, String>? userId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'domainId': domainId,
    'scheduleType': scheduleType,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultantProfileUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUpdateManyMutationInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    this.scheduleType,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  qualifications;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  specialization;

  final _i1.PrismaUnion<
    double,
    _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  experience;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? rating;

  final _i1.PrismaUnion<
    _i3.ScheduleType,
    _i2.EnumScheduleTypeFieldUpdateOperationsInput
  >?
  scheduleType;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'scheduleType': scheduleType,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultantProfileUncheckedUpdateManyWithoutConsultantProfilesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUncheckedUpdateManyWithoutConsultantProfilesInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    this.scheduleType,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  qualifications;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  specialization;

  final _i1.PrismaUnion<
    double,
    _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  experience;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? rating;

  final _i1.PrismaUnion<
    _i3.ScheduleType,
    _i2.EnumScheduleTypeFieldUpdateOperationsInput
  >?
  scheduleType;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'scheduleType': scheduleType,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultantProfileUpdateManyWithWhereWithoutTagsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUpdateManyWithWhereWithoutTagsInput({
    required this.where,
    required this.data,
  });

  final _i2.ConsultantProfileScalarWhereInput where;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileUpdateManyMutationInput,
    _i2.ConsultantProfileUncheckedUpdateManyWithoutConsultantProfilesInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class ConsultantProfileUpdateManyWithoutTagsNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUpdateManyWithoutTagsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateWithoutTagsInput,
    _i1.PrismaUnion<
      Iterable<_i2.ConsultantProfileCreateWithoutTagsInput>,
      _i1.PrismaUnion<
        _i2.ConsultantProfileUncheckedCreateWithoutTagsInput,
        Iterable<_i2.ConsultantProfileUncheckedCreateWithoutTagsInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateOrConnectWithoutTagsInput,
    Iterable<_i2.ConsultantProfileCreateOrConnectWithoutTagsInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileUpsertWithWhereUniqueWithoutTagsInput,
    Iterable<_i2.ConsultantProfileUpsertWithWhereUniqueWithoutTagsInput>
  >?
  upsert;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileWhereUniqueInput,
    Iterable<_i2.ConsultantProfileWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileWhereUniqueInput,
    Iterable<_i2.ConsultantProfileWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileWhereUniqueInput,
    Iterable<_i2.ConsultantProfileWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileWhereUniqueInput,
    Iterable<_i2.ConsultantProfileWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileUpdateWithWhereUniqueWithoutTagsInput,
    Iterable<_i2.ConsultantProfileUpdateWithWhereUniqueWithoutTagsInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileUpdateManyWithWhereWithoutTagsInput,
    Iterable<_i2.ConsultantProfileUpdateManyWithWhereWithoutTagsInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileScalarWhereInput,
    Iterable<_i2.ConsultantProfileScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class TagUpdateWithoutDomainInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagUpdateWithoutDomainInput({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
    this.consultantProfiles,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.ConsultantProfileUpdateManyWithoutTagsNestedInput?
  consultantProfiles;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultantProfiles': consultantProfiles,
  };
}

class ConsultantProfileUncheckedUpdateManyWithoutTagsNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUncheckedUpdateManyWithoutTagsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateWithoutTagsInput,
    _i1.PrismaUnion<
      Iterable<_i2.ConsultantProfileCreateWithoutTagsInput>,
      _i1.PrismaUnion<
        _i2.ConsultantProfileUncheckedCreateWithoutTagsInput,
        Iterable<_i2.ConsultantProfileUncheckedCreateWithoutTagsInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateOrConnectWithoutTagsInput,
    Iterable<_i2.ConsultantProfileCreateOrConnectWithoutTagsInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileUpsertWithWhereUniqueWithoutTagsInput,
    Iterable<_i2.ConsultantProfileUpsertWithWhereUniqueWithoutTagsInput>
  >?
  upsert;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileWhereUniqueInput,
    Iterable<_i2.ConsultantProfileWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileWhereUniqueInput,
    Iterable<_i2.ConsultantProfileWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileWhereUniqueInput,
    Iterable<_i2.ConsultantProfileWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileWhereUniqueInput,
    Iterable<_i2.ConsultantProfileWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileUpdateWithWhereUniqueWithoutTagsInput,
    Iterable<_i2.ConsultantProfileUpdateWithWhereUniqueWithoutTagsInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileUpdateManyWithWhereWithoutTagsInput,
    Iterable<_i2.ConsultantProfileUpdateManyWithWhereWithoutTagsInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileScalarWhereInput,
    Iterable<_i2.ConsultantProfileScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class TagUncheckedUpdateWithoutDomainInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagUncheckedUpdateWithoutDomainInput({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
    this.consultantProfiles,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.ConsultantProfileUncheckedUpdateManyWithoutTagsNestedInput?
  consultantProfiles;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultantProfiles': consultantProfiles,
  };
}

class TagUpsertWithWhereUniqueWithoutDomainInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagUpsertWithWhereUniqueWithoutDomainInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.TagWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.TagUpdateWithoutDomainInput,
    _i2.TagUncheckedUpdateWithoutDomainInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.TagCreateWithoutDomainInput,
    _i2.TagUncheckedCreateWithoutDomainInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'update': update,
    'create': create,
  };
}

class TagUpdateWithWhereUniqueWithoutDomainInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagUpdateWithWhereUniqueWithoutDomainInput({
    required this.where,
    required this.data,
  });

  final _i2.TagWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.TagUpdateWithoutDomainInput,
    _i2.TagUncheckedUpdateWithoutDomainInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class TagUpdateManyWithWhereWithoutDomainInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagUpdateManyWithWhereWithoutDomainInput({
    required this.where,
    required this.data,
  });

  final _i2.TagScalarWhereInput where;

  final _i1.PrismaUnion<
    _i2.TagUpdateManyMutationInput,
    _i2.TagUncheckedUpdateManyWithoutTagsInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class TagUpdateManyWithoutDomainNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagUpdateManyWithoutDomainNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.TagCreateWithoutDomainInput,
    _i1.PrismaUnion<
      Iterable<_i2.TagCreateWithoutDomainInput>,
      _i1.PrismaUnion<
        _i2.TagUncheckedCreateWithoutDomainInput,
        Iterable<_i2.TagUncheckedCreateWithoutDomainInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.TagCreateOrConnectWithoutDomainInput,
    Iterable<_i2.TagCreateOrConnectWithoutDomainInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.TagUpsertWithWhereUniqueWithoutDomainInput,
    Iterable<_i2.TagUpsertWithWhereUniqueWithoutDomainInput>
  >?
  upsert;

  final _i2.TagCreateManyDomainInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.TagWhereUniqueInput,
    Iterable<_i2.TagWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.TagWhereUniqueInput,
    Iterable<_i2.TagWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.TagWhereUniqueInput,
    Iterable<_i2.TagWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.TagWhereUniqueInput,
    Iterable<_i2.TagWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.TagUpdateWithWhereUniqueWithoutDomainInput,
    Iterable<_i2.TagUpdateWithWhereUniqueWithoutDomainInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.TagUpdateManyWithWhereWithoutDomainInput,
    Iterable<_i2.TagUpdateManyWithWhereWithoutDomainInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.TagScalarWhereInput,
    Iterable<_i2.TagScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class DomainUpdateWithoutSubDomainsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomainUpdateWithoutSubDomainsInput({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
    this.tags,
    this.consultantProfiles,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.TagUpdateManyWithoutDomainNestedInput? tags;

  final _i2.ConsultantProfileUpdateManyWithoutDomainNestedInput?
  consultantProfiles;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'tags': tags,
    'consultantProfiles': consultantProfiles,
  };
}

class TagUncheckedUpdateManyWithoutDomainNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagUncheckedUpdateManyWithoutDomainNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.TagCreateWithoutDomainInput,
    _i1.PrismaUnion<
      Iterable<_i2.TagCreateWithoutDomainInput>,
      _i1.PrismaUnion<
        _i2.TagUncheckedCreateWithoutDomainInput,
        Iterable<_i2.TagUncheckedCreateWithoutDomainInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.TagCreateOrConnectWithoutDomainInput,
    Iterable<_i2.TagCreateOrConnectWithoutDomainInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.TagUpsertWithWhereUniqueWithoutDomainInput,
    Iterable<_i2.TagUpsertWithWhereUniqueWithoutDomainInput>
  >?
  upsert;

  final _i2.TagCreateManyDomainInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.TagWhereUniqueInput,
    Iterable<_i2.TagWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.TagWhereUniqueInput,
    Iterable<_i2.TagWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.TagWhereUniqueInput,
    Iterable<_i2.TagWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.TagWhereUniqueInput,
    Iterable<_i2.TagWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.TagUpdateWithWhereUniqueWithoutDomainInput,
    Iterable<_i2.TagUpdateWithWhereUniqueWithoutDomainInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.TagUpdateManyWithWhereWithoutDomainInput,
    Iterable<_i2.TagUpdateManyWithWhereWithoutDomainInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.TagScalarWhereInput,
    Iterable<_i2.TagScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class ConsultantProfileUncheckedUpdateWithoutDomainInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUncheckedUpdateWithoutDomainInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    this.scheduleType,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.subDomains,
    this.tags,
    this.reviews,
    this.slotsOfAvailabilityWeekly,
    this.slotsOfAvailabilityCustom,
    this.consultationPlans,
    this.subscriptionPlans,
    this.webinarPlans,
    this.classPlans,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  qualifications;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  specialization;

  final _i1.PrismaUnion<
    double,
    _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  experience;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? rating;

  final _i1.PrismaUnion<
    _i3.ScheduleType,
    _i2.EnumScheduleTypeFieldUpdateOperationsInput
  >?
  scheduleType;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.SubDomainUncheckedUpdateManyWithoutConsultantProfilesNestedInput?
  subDomains;

  final _i2.TagUncheckedUpdateManyWithoutConsultantProfilesNestedInput? tags;

  final _i2.ConsultantReviewUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  reviews;

  final _i2.SlotOfAvailabilityWeeklyUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  slotsOfAvailabilityWeekly;

  final _i2.SlotOfAvailabilityCustomUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  slotsOfAvailabilityCustom;

  final _i2.ConsultationPlanUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  consultationPlans;

  final _i2.SubscriptionPlanUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  subscriptionPlans;

  final _i2.WebinarPlanUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  webinarPlans;

  final _i2.ClassPlanUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  classPlans;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'scheduleType': scheduleType,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'subDomains': subDomains,
    'tags': tags,
    'reviews': reviews,
    'slotsOfAvailabilityWeekly': slotsOfAvailabilityWeekly,
    'slotsOfAvailabilityCustom': slotsOfAvailabilityCustom,
    'consultationPlans': consultationPlans,
    'subscriptionPlans': subscriptionPlans,
    'webinarPlans': webinarPlans,
    'classPlans': classPlans,
  };
}

class ConsultantProfileUpdateWithWhereUniqueWithoutDomainInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUpdateWithWhereUniqueWithoutDomainInput({
    required this.where,
    required this.data,
  });

  final _i2.ConsultantProfileWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileUpdateWithoutDomainInput,
    _i2.ConsultantProfileUncheckedUpdateWithoutDomainInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class ConsultantProfileUpdateManyWithWhereWithoutDomainInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUpdateManyWithWhereWithoutDomainInput({
    required this.where,
    required this.data,
  });

  final _i2.ConsultantProfileScalarWhereInput where;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileUpdateManyMutationInput,
    _i2.ConsultantProfileUncheckedUpdateManyWithoutConsultantProfilesInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class ConsultantProfileUncheckedUpdateManyWithoutDomainNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUncheckedUpdateManyWithoutDomainNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateWithoutDomainInput,
    _i1.PrismaUnion<
      Iterable<_i2.ConsultantProfileCreateWithoutDomainInput>,
      _i1.PrismaUnion<
        _i2.ConsultantProfileUncheckedCreateWithoutDomainInput,
        Iterable<_i2.ConsultantProfileUncheckedCreateWithoutDomainInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateOrConnectWithoutDomainInput,
    Iterable<_i2.ConsultantProfileCreateOrConnectWithoutDomainInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileUpsertWithWhereUniqueWithoutDomainInput,
    Iterable<_i2.ConsultantProfileUpsertWithWhereUniqueWithoutDomainInput>
  >?
  upsert;

  final _i2.ConsultantProfileCreateManyDomainInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileWhereUniqueInput,
    Iterable<_i2.ConsultantProfileWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileWhereUniqueInput,
    Iterable<_i2.ConsultantProfileWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileWhereUniqueInput,
    Iterable<_i2.ConsultantProfileWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileWhereUniqueInput,
    Iterable<_i2.ConsultantProfileWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileUpdateWithWhereUniqueWithoutDomainInput,
    Iterable<_i2.ConsultantProfileUpdateWithWhereUniqueWithoutDomainInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileUpdateManyWithWhereWithoutDomainInput,
    Iterable<_i2.ConsultantProfileUpdateManyWithWhereWithoutDomainInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileScalarWhereInput,
    Iterable<_i2.ConsultantProfileScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class DomainUncheckedUpdateWithoutSubDomainsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomainUncheckedUpdateWithoutSubDomainsInput({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
    this.tags,
    this.consultantProfiles,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.TagUncheckedUpdateManyWithoutDomainNestedInput? tags;

  final _i2.ConsultantProfileUncheckedUpdateManyWithoutDomainNestedInput?
  consultantProfiles;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'tags': tags,
    'consultantProfiles': consultantProfiles,
  };
}

class DomainUpsertWithoutSubDomainsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomainUpsertWithoutSubDomainsInput({
    required this.update,
    required this.create,
  });

  final _i1.PrismaUnion<
    _i2.DomainUpdateWithoutSubDomainsInput,
    _i2.DomainUncheckedUpdateWithoutSubDomainsInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.DomainCreateWithoutSubDomainsInput,
    _i2.DomainUncheckedCreateWithoutSubDomainsInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'update': update, 'create': create};
}

class DomainUpdateOneRequiredWithoutSubDomainsNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomainUpdateOneRequiredWithoutSubDomainsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.DomainCreateWithoutSubDomainsInput,
    _i2.DomainUncheckedCreateWithoutSubDomainsInput
  >?
  create;

  final _i2.DomainCreateOrConnectWithoutSubDomainsInput? connectOrCreate;

  final _i2.DomainUpsertWithoutSubDomainsInput? upsert;

  final _i2.DomainWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.DomainUpdateWithoutSubDomainsInput,
    _i2.DomainUncheckedUpdateWithoutSubDomainsInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'connect': connect,
    'update': update,
  };
}

class SubDomainUpdateWithoutConsultantProfilesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainUpdateWithoutConsultantProfilesInput({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
    this.domain,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.DomainUpdateOneRequiredWithoutSubDomainsNestedInput? domain;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'domain': domain,
  };
}

class SubDomainUpsertWithWhereUniqueWithoutConsultantProfilesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainUpsertWithWhereUniqueWithoutConsultantProfilesInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.SubDomainWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.SubDomainUpdateWithoutConsultantProfilesInput,
    _i2.SubDomainUncheckedUpdateWithoutConsultantProfilesInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.SubDomainCreateWithoutConsultantProfilesInput,
    _i2.SubDomainUncheckedCreateWithoutConsultantProfilesInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'update': update,
    'create': create,
  };
}

class SubDomainUpdateManyWithoutConsultantProfilesNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainUpdateManyWithoutConsultantProfilesNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.SubDomainCreateWithoutConsultantProfilesInput,
    _i1.PrismaUnion<
      Iterable<_i2.SubDomainCreateWithoutConsultantProfilesInput>,
      _i1.PrismaUnion<
        _i2.SubDomainUncheckedCreateWithoutConsultantProfilesInput,
        Iterable<_i2.SubDomainUncheckedCreateWithoutConsultantProfilesInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.SubDomainCreateOrConnectWithoutConsultantProfilesInput,
    Iterable<_i2.SubDomainCreateOrConnectWithoutConsultantProfilesInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.SubDomainUpsertWithWhereUniqueWithoutConsultantProfilesInput,
    Iterable<_i2.SubDomainUpsertWithWhereUniqueWithoutConsultantProfilesInput>
  >?
  upsert;

  final _i1.PrismaUnion<
    _i2.SubDomainWhereUniqueInput,
    Iterable<_i2.SubDomainWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.SubDomainWhereUniqueInput,
    Iterable<_i2.SubDomainWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.SubDomainWhereUniqueInput,
    Iterable<_i2.SubDomainWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.SubDomainWhereUniqueInput,
    Iterable<_i2.SubDomainWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.SubDomainUpdateWithWhereUniqueWithoutConsultantProfilesInput,
    Iterable<_i2.SubDomainUpdateWithWhereUniqueWithoutConsultantProfilesInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.SubDomainUpdateManyWithWhereWithoutConsultantProfilesInput,
    Iterable<_i2.SubDomainUpdateManyWithWhereWithoutConsultantProfilesInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.SubDomainScalarWhereInput,
    Iterable<_i2.SubDomainScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class ConsultantProfileUpdateWithoutDomainInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUpdateWithoutDomainInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    this.scheduleType,
    this.createdAt,
    this.updatedAt,
    this.subDomains,
    this.tags,
    this.reviews,
    this.slotsOfAvailabilityWeekly,
    this.slotsOfAvailabilityCustom,
    this.consultationPlans,
    this.subscriptionPlans,
    this.webinarPlans,
    this.classPlans,
    this.user,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  qualifications;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  specialization;

  final _i1.PrismaUnion<
    double,
    _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  experience;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? rating;

  final _i1.PrismaUnion<
    _i3.ScheduleType,
    _i2.EnumScheduleTypeFieldUpdateOperationsInput
  >?
  scheduleType;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.SubDomainUpdateManyWithoutConsultantProfilesNestedInput? subDomains;

  final _i2.TagUpdateManyWithoutConsultantProfilesNestedInput? tags;

  final _i2.ConsultantReviewUpdateManyWithoutConsultantProfileNestedInput?
  reviews;

  final _i2.SlotOfAvailabilityWeeklyUpdateManyWithoutConsultantProfileNestedInput?
  slotsOfAvailabilityWeekly;

  final _i2.SlotOfAvailabilityCustomUpdateManyWithoutConsultantProfileNestedInput?
  slotsOfAvailabilityCustom;

  final _i2.ConsultationPlanUpdateManyWithoutConsultantProfileNestedInput?
  consultationPlans;

  final _i2.SubscriptionPlanUpdateManyWithoutConsultantProfileNestedInput?
  subscriptionPlans;

  final _i2.WebinarPlanUpdateManyWithoutConsultantProfileNestedInput?
  webinarPlans;

  final _i2.ClassPlanUpdateManyWithoutConsultantProfileNestedInput? classPlans;

  final _i2.UserUpdateOneRequiredWithoutConsultantProfileNestedInput? user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'scheduleType': scheduleType,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'subDomains': subDomains,
    'tags': tags,
    'reviews': reviews,
    'slotsOfAvailabilityWeekly': slotsOfAvailabilityWeekly,
    'slotsOfAvailabilityCustom': slotsOfAvailabilityCustom,
    'consultationPlans': consultationPlans,
    'subscriptionPlans': subscriptionPlans,
    'webinarPlans': webinarPlans,
    'classPlans': classPlans,
    'user': user,
  };
}

class ConsultantProfileUpsertWithWhereUniqueWithoutDomainInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUpsertWithWhereUniqueWithoutDomainInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.ConsultantProfileWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileUpdateWithoutDomainInput,
    _i2.ConsultantProfileUncheckedUpdateWithoutDomainInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateWithoutDomainInput,
    _i2.ConsultantProfileUncheckedCreateWithoutDomainInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'update': update,
    'create': create,
  };
}

class ConsultantProfileUpdateManyWithoutDomainNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUpdateManyWithoutDomainNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateWithoutDomainInput,
    _i1.PrismaUnion<
      Iterable<_i2.ConsultantProfileCreateWithoutDomainInput>,
      _i1.PrismaUnion<
        _i2.ConsultantProfileUncheckedCreateWithoutDomainInput,
        Iterable<_i2.ConsultantProfileUncheckedCreateWithoutDomainInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateOrConnectWithoutDomainInput,
    Iterable<_i2.ConsultantProfileCreateOrConnectWithoutDomainInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileUpsertWithWhereUniqueWithoutDomainInput,
    Iterable<_i2.ConsultantProfileUpsertWithWhereUniqueWithoutDomainInput>
  >?
  upsert;

  final _i2.ConsultantProfileCreateManyDomainInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileWhereUniqueInput,
    Iterable<_i2.ConsultantProfileWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileWhereUniqueInput,
    Iterable<_i2.ConsultantProfileWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileWhereUniqueInput,
    Iterable<_i2.ConsultantProfileWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileWhereUniqueInput,
    Iterable<_i2.ConsultantProfileWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileUpdateWithWhereUniqueWithoutDomainInput,
    Iterable<_i2.ConsultantProfileUpdateWithWhereUniqueWithoutDomainInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileUpdateManyWithWhereWithoutDomainInput,
    Iterable<_i2.ConsultantProfileUpdateManyWithWhereWithoutDomainInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileScalarWhereInput,
    Iterable<_i2.ConsultantProfileScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class DomainUpdateWithoutTagsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomainUpdateWithoutTagsInput({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
    this.subDomains,
    this.consultantProfiles,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.SubDomainUpdateManyWithoutDomainNestedInput? subDomains;

  final _i2.ConsultantProfileUpdateManyWithoutDomainNestedInput?
  consultantProfiles;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'subDomains': subDomains,
    'consultantProfiles': consultantProfiles,
  };
}

class ConsultantProfileUncheckedUpdateWithoutSubDomainsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUncheckedUpdateWithoutSubDomainsInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    this.domainId,
    this.scheduleType,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.tags,
    this.reviews,
    this.slotsOfAvailabilityWeekly,
    this.slotsOfAvailabilityCustom,
    this.consultationPlans,
    this.subscriptionPlans,
    this.webinarPlans,
    this.classPlans,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  qualifications;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  specialization;

  final _i1.PrismaUnion<
    double,
    _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  experience;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? rating;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? domainId;

  final _i1.PrismaUnion<
    _i3.ScheduleType,
    _i2.EnumScheduleTypeFieldUpdateOperationsInput
  >?
  scheduleType;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.TagUncheckedUpdateManyWithoutConsultantProfilesNestedInput? tags;

  final _i2.ConsultantReviewUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  reviews;

  final _i2.SlotOfAvailabilityWeeklyUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  slotsOfAvailabilityWeekly;

  final _i2.SlotOfAvailabilityCustomUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  slotsOfAvailabilityCustom;

  final _i2.ConsultationPlanUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  consultationPlans;

  final _i2.SubscriptionPlanUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  subscriptionPlans;

  final _i2.WebinarPlanUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  webinarPlans;

  final _i2.ClassPlanUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  classPlans;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'domainId': domainId,
    'scheduleType': scheduleType,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'tags': tags,
    'reviews': reviews,
    'slotsOfAvailabilityWeekly': slotsOfAvailabilityWeekly,
    'slotsOfAvailabilityCustom': slotsOfAvailabilityCustom,
    'consultationPlans': consultationPlans,
    'subscriptionPlans': subscriptionPlans,
    'webinarPlans': webinarPlans,
    'classPlans': classPlans,
  };
}

class ConsultantProfileUpdateWithWhereUniqueWithoutSubDomainsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUpdateWithWhereUniqueWithoutSubDomainsInput({
    required this.where,
    required this.data,
  });

  final _i2.ConsultantProfileWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileUpdateWithoutSubDomainsInput,
    _i2.ConsultantProfileUncheckedUpdateWithoutSubDomainsInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class ConsultantProfileUpdateManyWithWhereWithoutSubDomainsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUpdateManyWithWhereWithoutSubDomainsInput({
    required this.where,
    required this.data,
  });

  final _i2.ConsultantProfileScalarWhereInput where;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileUpdateManyMutationInput,
    _i2.ConsultantProfileUncheckedUpdateManyWithoutConsultantProfilesInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class ConsultantProfileUncheckedUpdateManyWithoutSubDomainsNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUncheckedUpdateManyWithoutSubDomainsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateWithoutSubDomainsInput,
    _i1.PrismaUnion<
      Iterable<_i2.ConsultantProfileCreateWithoutSubDomainsInput>,
      _i1.PrismaUnion<
        _i2.ConsultantProfileUncheckedCreateWithoutSubDomainsInput,
        Iterable<_i2.ConsultantProfileUncheckedCreateWithoutSubDomainsInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateOrConnectWithoutSubDomainsInput,
    Iterable<_i2.ConsultantProfileCreateOrConnectWithoutSubDomainsInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileUpsertWithWhereUniqueWithoutSubDomainsInput,
    Iterable<_i2.ConsultantProfileUpsertWithWhereUniqueWithoutSubDomainsInput>
  >?
  upsert;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileWhereUniqueInput,
    Iterable<_i2.ConsultantProfileWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileWhereUniqueInput,
    Iterable<_i2.ConsultantProfileWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileWhereUniqueInput,
    Iterable<_i2.ConsultantProfileWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileWhereUniqueInput,
    Iterable<_i2.ConsultantProfileWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileUpdateWithWhereUniqueWithoutSubDomainsInput,
    Iterable<_i2.ConsultantProfileUpdateWithWhereUniqueWithoutSubDomainsInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileUpdateManyWithWhereWithoutSubDomainsInput,
    Iterable<_i2.ConsultantProfileUpdateManyWithWhereWithoutSubDomainsInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileScalarWhereInput,
    Iterable<_i2.ConsultantProfileScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class SubDomainUncheckedUpdateWithoutDomainInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainUncheckedUpdateWithoutDomainInput({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
    this.consultantProfiles,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.ConsultantProfileUncheckedUpdateManyWithoutSubDomainsNestedInput?
  consultantProfiles;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultantProfiles': consultantProfiles,
  };
}

class SubDomainUpdateWithWhereUniqueWithoutDomainInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainUpdateWithWhereUniqueWithoutDomainInput({
    required this.where,
    required this.data,
  });

  final _i2.SubDomainWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.SubDomainUpdateWithoutDomainInput,
    _i2.SubDomainUncheckedUpdateWithoutDomainInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class SubDomainUpdateManyWithWhereWithoutDomainInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainUpdateManyWithWhereWithoutDomainInput({
    required this.where,
    required this.data,
  });

  final _i2.SubDomainScalarWhereInput where;

  final _i1.PrismaUnion<
    _i2.SubDomainUpdateManyMutationInput,
    _i2.SubDomainUncheckedUpdateManyWithoutSubDomainsInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class SubDomainUncheckedUpdateManyWithoutDomainNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainUncheckedUpdateManyWithoutDomainNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.SubDomainCreateWithoutDomainInput,
    _i1.PrismaUnion<
      Iterable<_i2.SubDomainCreateWithoutDomainInput>,
      _i1.PrismaUnion<
        _i2.SubDomainUncheckedCreateWithoutDomainInput,
        Iterable<_i2.SubDomainUncheckedCreateWithoutDomainInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.SubDomainCreateOrConnectWithoutDomainInput,
    Iterable<_i2.SubDomainCreateOrConnectWithoutDomainInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.SubDomainUpsertWithWhereUniqueWithoutDomainInput,
    Iterable<_i2.SubDomainUpsertWithWhereUniqueWithoutDomainInput>
  >?
  upsert;

  final _i2.SubDomainCreateManyDomainInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.SubDomainWhereUniqueInput,
    Iterable<_i2.SubDomainWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.SubDomainWhereUniqueInput,
    Iterable<_i2.SubDomainWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.SubDomainWhereUniqueInput,
    Iterable<_i2.SubDomainWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.SubDomainWhereUniqueInput,
    Iterable<_i2.SubDomainWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.SubDomainUpdateWithWhereUniqueWithoutDomainInput,
    Iterable<_i2.SubDomainUpdateWithWhereUniqueWithoutDomainInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.SubDomainUpdateManyWithWhereWithoutDomainInput,
    Iterable<_i2.SubDomainUpdateManyWithWhereWithoutDomainInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.SubDomainScalarWhereInput,
    Iterable<_i2.SubDomainScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class DomainUncheckedUpdateWithoutTagsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomainUncheckedUpdateWithoutTagsInput({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
    this.subDomains,
    this.consultantProfiles,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.SubDomainUncheckedUpdateManyWithoutDomainNestedInput? subDomains;

  final _i2.ConsultantProfileUncheckedUpdateManyWithoutDomainNestedInput?
  consultantProfiles;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'subDomains': subDomains,
    'consultantProfiles': consultantProfiles,
  };
}

class DomainUpsertWithoutTagsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomainUpsertWithoutTagsInput({
    required this.update,
    required this.create,
  });

  final _i1.PrismaUnion<
    _i2.DomainUpdateWithoutTagsInput,
    _i2.DomainUncheckedUpdateWithoutTagsInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.DomainCreateWithoutTagsInput,
    _i2.DomainUncheckedCreateWithoutTagsInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'update': update, 'create': create};
}

class DomainUpdateOneRequiredWithoutTagsNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomainUpdateOneRequiredWithoutTagsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.DomainCreateWithoutTagsInput,
    _i2.DomainUncheckedCreateWithoutTagsInput
  >?
  create;

  final _i2.DomainCreateOrConnectWithoutTagsInput? connectOrCreate;

  final _i2.DomainUpsertWithoutTagsInput? upsert;

  final _i2.DomainWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.DomainUpdateWithoutTagsInput,
    _i2.DomainUncheckedUpdateWithoutTagsInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'connect': connect,
    'update': update,
  };
}

class TagUpdateWithoutConsultantProfilesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagUpdateWithoutConsultantProfilesInput({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
    this.domain,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.DomainUpdateOneRequiredWithoutTagsNestedInput? domain;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'domain': domain,
  };
}

class TagUpsertWithWhereUniqueWithoutConsultantProfilesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagUpsertWithWhereUniqueWithoutConsultantProfilesInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.TagWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.TagUpdateWithoutConsultantProfilesInput,
    _i2.TagUncheckedUpdateWithoutConsultantProfilesInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.TagCreateWithoutConsultantProfilesInput,
    _i2.TagUncheckedCreateWithoutConsultantProfilesInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'update': update,
    'create': create,
  };
}

class TagUpdateManyWithoutConsultantProfilesNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagUpdateManyWithoutConsultantProfilesNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.TagCreateWithoutConsultantProfilesInput,
    _i1.PrismaUnion<
      Iterable<_i2.TagCreateWithoutConsultantProfilesInput>,
      _i1.PrismaUnion<
        _i2.TagUncheckedCreateWithoutConsultantProfilesInput,
        Iterable<_i2.TagUncheckedCreateWithoutConsultantProfilesInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.TagCreateOrConnectWithoutConsultantProfilesInput,
    Iterable<_i2.TagCreateOrConnectWithoutConsultantProfilesInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.TagUpsertWithWhereUniqueWithoutConsultantProfilesInput,
    Iterable<_i2.TagUpsertWithWhereUniqueWithoutConsultantProfilesInput>
  >?
  upsert;

  final _i1.PrismaUnion<
    _i2.TagWhereUniqueInput,
    Iterable<_i2.TagWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.TagWhereUniqueInput,
    Iterable<_i2.TagWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.TagWhereUniqueInput,
    Iterable<_i2.TagWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.TagWhereUniqueInput,
    Iterable<_i2.TagWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.TagUpdateWithWhereUniqueWithoutConsultantProfilesInput,
    Iterable<_i2.TagUpdateWithWhereUniqueWithoutConsultantProfilesInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.TagUpdateManyWithWhereWithoutConsultantProfilesInput,
    Iterable<_i2.TagUpdateManyWithWhereWithoutConsultantProfilesInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.TagScalarWhereInput,
    Iterable<_i2.TagScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class ConsultantProfileUpdateWithoutSubDomainsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUpdateWithoutSubDomainsInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    this.scheduleType,
    this.createdAt,
    this.updatedAt,
    this.domain,
    this.tags,
    this.reviews,
    this.slotsOfAvailabilityWeekly,
    this.slotsOfAvailabilityCustom,
    this.consultationPlans,
    this.subscriptionPlans,
    this.webinarPlans,
    this.classPlans,
    this.user,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  qualifications;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  specialization;

  final _i1.PrismaUnion<
    double,
    _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  experience;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? rating;

  final _i1.PrismaUnion<
    _i3.ScheduleType,
    _i2.EnumScheduleTypeFieldUpdateOperationsInput
  >?
  scheduleType;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.DomainUpdateOneRequiredWithoutConsultantProfilesNestedInput? domain;

  final _i2.TagUpdateManyWithoutConsultantProfilesNestedInput? tags;

  final _i2.ConsultantReviewUpdateManyWithoutConsultantProfileNestedInput?
  reviews;

  final _i2.SlotOfAvailabilityWeeklyUpdateManyWithoutConsultantProfileNestedInput?
  slotsOfAvailabilityWeekly;

  final _i2.SlotOfAvailabilityCustomUpdateManyWithoutConsultantProfileNestedInput?
  slotsOfAvailabilityCustom;

  final _i2.ConsultationPlanUpdateManyWithoutConsultantProfileNestedInput?
  consultationPlans;

  final _i2.SubscriptionPlanUpdateManyWithoutConsultantProfileNestedInput?
  subscriptionPlans;

  final _i2.WebinarPlanUpdateManyWithoutConsultantProfileNestedInput?
  webinarPlans;

  final _i2.ClassPlanUpdateManyWithoutConsultantProfileNestedInput? classPlans;

  final _i2.UserUpdateOneRequiredWithoutConsultantProfileNestedInput? user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'scheduleType': scheduleType,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'domain': domain,
    'tags': tags,
    'reviews': reviews,
    'slotsOfAvailabilityWeekly': slotsOfAvailabilityWeekly,
    'slotsOfAvailabilityCustom': slotsOfAvailabilityCustom,
    'consultationPlans': consultationPlans,
    'subscriptionPlans': subscriptionPlans,
    'webinarPlans': webinarPlans,
    'classPlans': classPlans,
    'user': user,
  };
}

class ConsultantProfileUpsertWithWhereUniqueWithoutSubDomainsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUpsertWithWhereUniqueWithoutSubDomainsInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.ConsultantProfileWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileUpdateWithoutSubDomainsInput,
    _i2.ConsultantProfileUncheckedUpdateWithoutSubDomainsInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateWithoutSubDomainsInput,
    _i2.ConsultantProfileUncheckedCreateWithoutSubDomainsInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'update': update,
    'create': create,
  };
}

class ConsultantProfileUpdateManyWithoutSubDomainsNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUpdateManyWithoutSubDomainsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateWithoutSubDomainsInput,
    _i1.PrismaUnion<
      Iterable<_i2.ConsultantProfileCreateWithoutSubDomainsInput>,
      _i1.PrismaUnion<
        _i2.ConsultantProfileUncheckedCreateWithoutSubDomainsInput,
        Iterable<_i2.ConsultantProfileUncheckedCreateWithoutSubDomainsInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateOrConnectWithoutSubDomainsInput,
    Iterable<_i2.ConsultantProfileCreateOrConnectWithoutSubDomainsInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileUpsertWithWhereUniqueWithoutSubDomainsInput,
    Iterable<_i2.ConsultantProfileUpsertWithWhereUniqueWithoutSubDomainsInput>
  >?
  upsert;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileWhereUniqueInput,
    Iterable<_i2.ConsultantProfileWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileWhereUniqueInput,
    Iterable<_i2.ConsultantProfileWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileWhereUniqueInput,
    Iterable<_i2.ConsultantProfileWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileWhereUniqueInput,
    Iterable<_i2.ConsultantProfileWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileUpdateWithWhereUniqueWithoutSubDomainsInput,
    Iterable<_i2.ConsultantProfileUpdateWithWhereUniqueWithoutSubDomainsInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileUpdateManyWithWhereWithoutSubDomainsInput,
    Iterable<_i2.ConsultantProfileUpdateManyWithWhereWithoutSubDomainsInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileScalarWhereInput,
    Iterable<_i2.ConsultantProfileScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class SubDomainUpdateWithoutDomainInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainUpdateWithoutDomainInput({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
    this.consultantProfiles,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.ConsultantProfileUpdateManyWithoutSubDomainsNestedInput?
  consultantProfiles;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultantProfiles': consultantProfiles,
  };
}

class SubDomainUpsertWithWhereUniqueWithoutDomainInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainUpsertWithWhereUniqueWithoutDomainInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.SubDomainWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.SubDomainUpdateWithoutDomainInput,
    _i2.SubDomainUncheckedUpdateWithoutDomainInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.SubDomainCreateWithoutDomainInput,
    _i2.SubDomainUncheckedCreateWithoutDomainInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'update': update,
    'create': create,
  };
}

class SubDomainUpdateManyWithoutDomainNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainUpdateManyWithoutDomainNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.SubDomainCreateWithoutDomainInput,
    _i1.PrismaUnion<
      Iterable<_i2.SubDomainCreateWithoutDomainInput>,
      _i1.PrismaUnion<
        _i2.SubDomainUncheckedCreateWithoutDomainInput,
        Iterable<_i2.SubDomainUncheckedCreateWithoutDomainInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.SubDomainCreateOrConnectWithoutDomainInput,
    Iterable<_i2.SubDomainCreateOrConnectWithoutDomainInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.SubDomainUpsertWithWhereUniqueWithoutDomainInput,
    Iterable<_i2.SubDomainUpsertWithWhereUniqueWithoutDomainInput>
  >?
  upsert;

  final _i2.SubDomainCreateManyDomainInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.SubDomainWhereUniqueInput,
    Iterable<_i2.SubDomainWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.SubDomainWhereUniqueInput,
    Iterable<_i2.SubDomainWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.SubDomainWhereUniqueInput,
    Iterable<_i2.SubDomainWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.SubDomainWhereUniqueInput,
    Iterable<_i2.SubDomainWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.SubDomainUpdateWithWhereUniqueWithoutDomainInput,
    Iterable<_i2.SubDomainUpdateWithWhereUniqueWithoutDomainInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.SubDomainUpdateManyWithWhereWithoutDomainInput,
    Iterable<_i2.SubDomainUpdateManyWithWhereWithoutDomainInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.SubDomainScalarWhereInput,
    Iterable<_i2.SubDomainScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class DomainUpdateWithoutConsultantProfilesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomainUpdateWithoutConsultantProfilesInput({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
    this.subDomains,
    this.tags,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.SubDomainUpdateManyWithoutDomainNestedInput? subDomains;

  final _i2.TagUpdateManyWithoutDomainNestedInput? tags;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'subDomains': subDomains,
    'tags': tags,
  };
}

class DomainUncheckedUpdateWithoutConsultantProfilesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomainUncheckedUpdateWithoutConsultantProfilesInput({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
    this.subDomains,
    this.tags,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.SubDomainUncheckedUpdateManyWithoutDomainNestedInput? subDomains;

  final _i2.TagUncheckedUpdateManyWithoutDomainNestedInput? tags;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'subDomains': subDomains,
    'tags': tags,
  };
}

class DomainUpsertWithoutConsultantProfilesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomainUpsertWithoutConsultantProfilesInput({
    required this.update,
    required this.create,
  });

  final _i1.PrismaUnion<
    _i2.DomainUpdateWithoutConsultantProfilesInput,
    _i2.DomainUncheckedUpdateWithoutConsultantProfilesInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.DomainCreateWithoutConsultantProfilesInput,
    _i2.DomainUncheckedCreateWithoutConsultantProfilesInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'update': update, 'create': create};
}

class DomainUpdateOneRequiredWithoutConsultantProfilesNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomainUpdateOneRequiredWithoutConsultantProfilesNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.DomainCreateWithoutConsultantProfilesInput,
    _i2.DomainUncheckedCreateWithoutConsultantProfilesInput
  >?
  create;

  final _i2.DomainCreateOrConnectWithoutConsultantProfilesInput?
  connectOrCreate;

  final _i2.DomainUpsertWithoutConsultantProfilesInput? upsert;

  final _i2.DomainWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.DomainUpdateWithoutConsultantProfilesInput,
    _i2.DomainUncheckedUpdateWithoutConsultantProfilesInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'connect': connect,
    'update': update,
  };
}

class ConsultantProfileUpdateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUpdateWithoutUserInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    this.scheduleType,
    this.createdAt,
    this.updatedAt,
    this.domain,
    this.subDomains,
    this.tags,
    this.reviews,
    this.slotsOfAvailabilityWeekly,
    this.slotsOfAvailabilityCustom,
    this.consultationPlans,
    this.subscriptionPlans,
    this.webinarPlans,
    this.classPlans,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  qualifications;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  specialization;

  final _i1.PrismaUnion<
    double,
    _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  experience;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? rating;

  final _i1.PrismaUnion<
    _i3.ScheduleType,
    _i2.EnumScheduleTypeFieldUpdateOperationsInput
  >?
  scheduleType;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.DomainUpdateOneRequiredWithoutConsultantProfilesNestedInput? domain;

  final _i2.SubDomainUpdateManyWithoutConsultantProfilesNestedInput? subDomains;

  final _i2.TagUpdateManyWithoutConsultantProfilesNestedInput? tags;

  final _i2.ConsultantReviewUpdateManyWithoutConsultantProfileNestedInput?
  reviews;

  final _i2.SlotOfAvailabilityWeeklyUpdateManyWithoutConsultantProfileNestedInput?
  slotsOfAvailabilityWeekly;

  final _i2.SlotOfAvailabilityCustomUpdateManyWithoutConsultantProfileNestedInput?
  slotsOfAvailabilityCustom;

  final _i2.ConsultationPlanUpdateManyWithoutConsultantProfileNestedInput?
  consultationPlans;

  final _i2.SubscriptionPlanUpdateManyWithoutConsultantProfileNestedInput?
  subscriptionPlans;

  final _i2.WebinarPlanUpdateManyWithoutConsultantProfileNestedInput?
  webinarPlans;

  final _i2.ClassPlanUpdateManyWithoutConsultantProfileNestedInput? classPlans;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'scheduleType': scheduleType,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'domain': domain,
    'subDomains': subDomains,
    'tags': tags,
    'reviews': reviews,
    'slotsOfAvailabilityWeekly': slotsOfAvailabilityWeekly,
    'slotsOfAvailabilityCustom': slotsOfAvailabilityCustom,
    'consultationPlans': consultationPlans,
    'subscriptionPlans': subscriptionPlans,
    'webinarPlans': webinarPlans,
    'classPlans': classPlans,
  };
}

class ConsultantProfileUpsertWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUpsertWithoutUserInput({
    required this.update,
    required this.create,
  });

  final _i1.PrismaUnion<
    _i2.ConsultantProfileUpdateWithoutUserInput,
    _i2.ConsultantProfileUncheckedUpdateWithoutUserInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateWithoutUserInput,
    _i2.ConsultantProfileUncheckedCreateWithoutUserInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'update': update, 'create': create};
}

class ConsultantProfileUpdateOneWithoutUserNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUpdateOneWithoutUserNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateWithoutUserInput,
    _i2.ConsultantProfileUncheckedCreateWithoutUserInput
  >?
  create;

  final _i2.ConsultantProfileCreateOrConnectWithoutUserInput? connectOrCreate;

  final _i2.ConsultantProfileUpsertWithoutUserInput? upsert;

  final bool? disconnect;

  final bool? delete;

  final _i2.ConsultantProfileWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileUpdateWithoutUserInput,
    _i2.ConsultantProfileUncheckedUpdateWithoutUserInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
  };
}

class UserUpdateWithoutSlotsOfAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpdateWithoutSlotsOfAppointmentInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.cookiePreferences,
    this.notificationPreferences,
    this.payment,
    this.consultantProfile,
    this.consulteeProfile,
    this.staffProfile,
    this.waitlist,
    this.feedbacks,
    this.supportTickets,
    this.supportResponses,
    this.accounts,
    this.sessions,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  name;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  email;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  emailVerified;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  image;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  phone;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  address;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  password;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetToken;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetExpires;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? onlineStatus;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  currentTimezone;

  final _i1.PrismaUnion<
    bool,
    _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  onboardingCompleted;

  final _i1.PrismaUnion<
    _i3.UserRole,
    _i1.PrismaUnion<
      _i2.NullableEnumUserRoleFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  role;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consultantProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consulteeProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  staffProfileId;

  final _i2.CookiePreferenceUpdateOneWithoutUserNestedInput? cookiePreferences;

  final _i2.NotificationPreferenceUpdateOneWithoutUserNestedInput?
  notificationPreferences;

  final _i2.PaymentUpdateManyWithoutUserNestedInput? payment;

  final _i2.ConsultantProfileUpdateOneWithoutUserNestedInput? consultantProfile;

  final _i2.ConsulteeProfileUpdateOneWithoutUserNestedInput? consulteeProfile;

  final _i2.StaffProfileUpdateOneWithoutUserNestedInput? staffProfile;

  final _i2.WaitlistUpdateManyWithoutUserNestedInput? waitlist;

  final _i2.FeedbackUpdateManyWithoutUserNestedInput? feedbacks;

  final _i2.SupportTicketUpdateManyWithoutUserNestedInput? supportTickets;

  final _i2.SupportResponseUpdateManyWithoutUserNestedInput? supportResponses;

  final _i2.AccountUpdateManyWithoutUserNestedInput? accounts;

  final _i2.SessionUpdateManyWithoutUserNestedInput? sessions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'cookiePreferences': cookiePreferences,
    'notificationPreferences': notificationPreferences,
    'Payment': payment,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
    'staffProfile': staffProfile,
    'Waitlist': waitlist,
    'feedbacks': feedbacks,
    'supportTickets': supportTickets,
    'supportResponses': supportResponses,
    'accounts': accounts,
    'sessions': sessions,
  };
}

class UserUpsertWithWhereUniqueWithoutSlotsOfAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpsertWithWhereUniqueWithoutSlotsOfAppointmentInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.UserWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.UserUpdateWithoutSlotsOfAppointmentInput,
    _i2.UserUncheckedUpdateWithoutSlotsOfAppointmentInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.UserCreateWithoutSlotsOfAppointmentInput,
    _i2.UserUncheckedCreateWithoutSlotsOfAppointmentInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'update': update,
    'create': create,
  };
}

class UserUpdateManyWithoutSlotsOfAppointmentNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpdateManyWithoutSlotsOfAppointmentNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.UserCreateWithoutSlotsOfAppointmentInput,
    _i1.PrismaUnion<
      Iterable<_i2.UserCreateWithoutSlotsOfAppointmentInput>,
      _i1.PrismaUnion<
        _i2.UserUncheckedCreateWithoutSlotsOfAppointmentInput,
        Iterable<_i2.UserUncheckedCreateWithoutSlotsOfAppointmentInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.UserCreateOrConnectWithoutSlotsOfAppointmentInput,
    Iterable<_i2.UserCreateOrConnectWithoutSlotsOfAppointmentInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.UserUpsertWithWhereUniqueWithoutSlotsOfAppointmentInput,
    Iterable<_i2.UserUpsertWithWhereUniqueWithoutSlotsOfAppointmentInput>
  >?
  upsert;

  final _i1.PrismaUnion<
    _i2.UserWhereUniqueInput,
    Iterable<_i2.UserWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.UserWhereUniqueInput,
    Iterable<_i2.UserWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.UserWhereUniqueInput,
    Iterable<_i2.UserWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.UserWhereUniqueInput,
    Iterable<_i2.UserWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.UserUpdateWithWhereUniqueWithoutSlotsOfAppointmentInput,
    Iterable<_i2.UserUpdateWithWhereUniqueWithoutSlotsOfAppointmentInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.UserUpdateManyWithWhereWithoutSlotsOfAppointmentInput,
    Iterable<_i2.UserUpdateManyWithWhereWithoutSlotsOfAppointmentInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.UserScalarWhereInput,
    Iterable<_i2.UserScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class SlotOfAppointmentUpdateWithoutAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentUpdateWithoutAppointmentInput({
    this.id,
    this.slotStartTimeInUTC,
    this.slotEndTimeInUTC,
    this.isTentative,
    this.createdAt,
    this.updatedAt,
    this.user,
    this.meetingSession,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  slotStartTimeInUTC;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  slotEndTimeInUTC;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? isTentative;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.UserUpdateManyWithoutSlotsOfAppointmentNestedInput? user;

  final _i2.MeetingSessionUpdateOneWithoutSlotOfAppointmentNestedInput?
  meetingSession;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'isTentative': isTentative,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'user': user,
    'meetingSession': meetingSession,
  };
}

class SlotOfAppointmentUpsertWithWhereUniqueWithoutAppointmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentUpsertWithWhereUniqueWithoutAppointmentInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.SlotOfAppointmentWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentUpdateWithoutAppointmentInput,
    _i2.SlotOfAppointmentUncheckedUpdateWithoutAppointmentInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentCreateWithoutAppointmentInput,
    _i2.SlotOfAppointmentUncheckedCreateWithoutAppointmentInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'update': update,
    'create': create,
  };
}

class SlotOfAppointmentUpdateManyWithoutAppointmentNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentUpdateManyWithoutAppointmentNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentCreateWithoutAppointmentInput,
    _i1.PrismaUnion<
      Iterable<_i2.SlotOfAppointmentCreateWithoutAppointmentInput>,
      _i1.PrismaUnion<
        _i2.SlotOfAppointmentUncheckedCreateWithoutAppointmentInput,
        Iterable<_i2.SlotOfAppointmentUncheckedCreateWithoutAppointmentInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentCreateOrConnectWithoutAppointmentInput,
    Iterable<_i2.SlotOfAppointmentCreateOrConnectWithoutAppointmentInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentUpsertWithWhereUniqueWithoutAppointmentInput,
    Iterable<_i2.SlotOfAppointmentUpsertWithWhereUniqueWithoutAppointmentInput>
  >?
  upsert;

  final _i2.SlotOfAppointmentCreateManyAppointmentInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentWhereUniqueInput,
    Iterable<_i2.SlotOfAppointmentWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentWhereUniqueInput,
    Iterable<_i2.SlotOfAppointmentWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentWhereUniqueInput,
    Iterable<_i2.SlotOfAppointmentWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentWhereUniqueInput,
    Iterable<_i2.SlotOfAppointmentWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentUpdateWithWhereUniqueWithoutAppointmentInput,
    Iterable<_i2.SlotOfAppointmentUpdateWithWhereUniqueWithoutAppointmentInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentUpdateManyWithWhereWithoutAppointmentInput,
    Iterable<_i2.SlotOfAppointmentUpdateManyWithWhereWithoutAppointmentInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentScalarWhereInput,
    Iterable<_i2.SlotOfAppointmentScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class AppointmentUpdateWithoutPaymentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentUpdateWithoutPaymentInput({
    this.id,
    this.appointmentType,
    this.createdAt,
    this.updatedAt,
    this.slotsOfAppointment,
    this.consultation,
    this.subscription,
    this.webinar,
    this.$class,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    _i3.AppointmentsType,
    _i2.EnumAppointmentsTypeFieldUpdateOperationsInput
  >?
  appointmentType;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.SlotOfAppointmentUpdateManyWithoutAppointmentNestedInput?
  slotsOfAppointment;

  final _i2.ConsultationUpdateOneWithoutAppointmentNestedInput? consultation;

  final _i2.SubscriptionUpdateOneWithoutAppointmentsNestedInput? subscription;

  final _i2.WebinarUpdateOneWithoutAppointmentNestedInput? webinar;

  final _i2.ClassUpdateOneWithoutAppointmentsNestedInput? $class;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'appointmentType': appointmentType,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'slotsOfAppointment': slotsOfAppointment,
    'consultation': consultation,
    'subscription': subscription,
    'webinar': webinar,
    'class': $class,
  };
}

class AppointmentUncheckedUpdateWithoutPaymentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentUncheckedUpdateWithoutPaymentInput({
    this.id,
    this.appointmentType,
    this.consultationId,
    this.subscriptionId,
    this.webinarId,
    this.classId,
    this.createdAt,
    this.updatedAt,
    this.slotsOfAppointment,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    _i3.AppointmentsType,
    _i2.EnumAppointmentsTypeFieldUpdateOperationsInput
  >?
  appointmentType;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consultationId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  subscriptionId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  webinarId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  classId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.SlotOfAppointmentUncheckedUpdateManyWithoutAppointmentNestedInput?
  slotsOfAppointment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'appointmentType': appointmentType,
    'consultationId': consultationId,
    'subscriptionId': subscriptionId,
    'webinarId': webinarId,
    'classId': classId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'slotsOfAppointment': slotsOfAppointment,
  };
}

class AppointmentUpsertWithoutPaymentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentUpsertWithoutPaymentInput({
    required this.update,
    required this.create,
  });

  final _i1.PrismaUnion<
    _i2.AppointmentUpdateWithoutPaymentInput,
    _i2.AppointmentUncheckedUpdateWithoutPaymentInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.AppointmentCreateWithoutPaymentInput,
    _i2.AppointmentUncheckedCreateWithoutPaymentInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'update': update, 'create': create};
}

class AppointmentUpdateOneWithoutPaymentNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentUpdateOneWithoutPaymentNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.AppointmentCreateWithoutPaymentInput,
    _i2.AppointmentUncheckedCreateWithoutPaymentInput
  >?
  create;

  final _i2.AppointmentCreateOrConnectWithoutPaymentInput? connectOrCreate;

  final _i2.AppointmentUpsertWithoutPaymentInput? upsert;

  final bool? disconnect;

  final bool? delete;

  final _i2.AppointmentWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.AppointmentUpdateWithoutPaymentInput,
    _i2.AppointmentUncheckedUpdateWithoutPaymentInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
  };
}

class PaymentUpdateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentUpdateWithoutUserInput({
    this.id,
    this.amount,
    this.currency,
    this.description,
    this.receiptUrl,
    this.paymentMethod,
    this.paymentIntent,
    this.paymentGateway,
    this.paymentStatus,
    this.expiresAt,
    this.createdAt,
    this.updatedAt,
    this.appointment,
    this.discountCode,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? amount;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? currency;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  receiptUrl;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  paymentMethod;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  paymentIntent;

  final _i1.PrismaUnion<
    _i3.PaymentGateway,
    _i2.EnumPaymentGatewayFieldUpdateOperationsInput
  >?
  paymentGateway;

  final _i1.PrismaUnion<
    _i3.PaymentStatus,
    _i2.EnumPaymentStatusFieldUpdateOperationsInput
  >?
  paymentStatus;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  expiresAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.AppointmentUpdateOneWithoutPaymentNestedInput? appointment;

  final _i2.DiscountCodeUpdateOneWithoutPaymentNestedInput? discountCode;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'amount': amount,
    'currency': currency,
    'description': description,
    'receiptUrl': receiptUrl,
    'paymentMethod': paymentMethod,
    'paymentIntent': paymentIntent,
    'paymentGateway': paymentGateway,
    'paymentStatus': paymentStatus,
    'expiresAt': expiresAt,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'appointment': appointment,
    'discountCode': discountCode,
  };
}

class PaymentUpsertWithWhereUniqueWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentUpsertWithWhereUniqueWithoutUserInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.PaymentWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.PaymentUpdateWithoutUserInput,
    _i2.PaymentUncheckedUpdateWithoutUserInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.PaymentCreateWithoutUserInput,
    _i2.PaymentUncheckedCreateWithoutUserInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'update': update,
    'create': create,
  };
}

class PaymentUpdateManyWithoutUserNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentUpdateManyWithoutUserNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.PaymentCreateWithoutUserInput,
    _i1.PrismaUnion<
      Iterable<_i2.PaymentCreateWithoutUserInput>,
      _i1.PrismaUnion<
        _i2.PaymentUncheckedCreateWithoutUserInput,
        Iterable<_i2.PaymentUncheckedCreateWithoutUserInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.PaymentCreateOrConnectWithoutUserInput,
    Iterable<_i2.PaymentCreateOrConnectWithoutUserInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.PaymentUpsertWithWhereUniqueWithoutUserInput,
    Iterable<_i2.PaymentUpsertWithWhereUniqueWithoutUserInput>
  >?
  upsert;

  final _i2.PaymentCreateManyUserInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.PaymentWhereUniqueInput,
    Iterable<_i2.PaymentWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.PaymentWhereUniqueInput,
    Iterable<_i2.PaymentWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.PaymentWhereUniqueInput,
    Iterable<_i2.PaymentWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.PaymentWhereUniqueInput,
    Iterable<_i2.PaymentWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.PaymentUpdateWithWhereUniqueWithoutUserInput,
    Iterable<_i2.PaymentUpdateWithWhereUniqueWithoutUserInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.PaymentUpdateManyWithWhereWithoutUserInput,
    Iterable<_i2.PaymentUpdateManyWithWhereWithoutUserInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.PaymentScalarWhereInput,
    Iterable<_i2.PaymentScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class UserUpdateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpdateInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.cookiePreferences,
    this.notificationPreferences,
    this.payment,
    this.consultantProfile,
    this.consulteeProfile,
    this.staffProfile,
    this.slotsOfAppointment,
    this.waitlist,
    this.feedbacks,
    this.supportTickets,
    this.supportResponses,
    this.accounts,
    this.sessions,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  name;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  email;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  emailVerified;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  image;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  phone;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  address;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  password;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetToken;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetExpires;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? onlineStatus;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  currentTimezone;

  final _i1.PrismaUnion<
    bool,
    _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  onboardingCompleted;

  final _i1.PrismaUnion<
    _i3.UserRole,
    _i1.PrismaUnion<
      _i2.NullableEnumUserRoleFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  role;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consultantProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consulteeProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  staffProfileId;

  final _i2.CookiePreferenceUpdateOneWithoutUserNestedInput? cookiePreferences;

  final _i2.NotificationPreferenceUpdateOneWithoutUserNestedInput?
  notificationPreferences;

  final _i2.PaymentUpdateManyWithoutUserNestedInput? payment;

  final _i2.ConsultantProfileUpdateOneWithoutUserNestedInput? consultantProfile;

  final _i2.ConsulteeProfileUpdateOneWithoutUserNestedInput? consulteeProfile;

  final _i2.StaffProfileUpdateOneWithoutUserNestedInput? staffProfile;

  final _i2.SlotOfAppointmentUpdateManyWithoutUserNestedInput?
  slotsOfAppointment;

  final _i2.WaitlistUpdateManyWithoutUserNestedInput? waitlist;

  final _i2.FeedbackUpdateManyWithoutUserNestedInput? feedbacks;

  final _i2.SupportTicketUpdateManyWithoutUserNestedInput? supportTickets;

  final _i2.SupportResponseUpdateManyWithoutUserNestedInput? supportResponses;

  final _i2.AccountUpdateManyWithoutUserNestedInput? accounts;

  final _i2.SessionUpdateManyWithoutUserNestedInput? sessions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'cookiePreferences': cookiePreferences,
    'notificationPreferences': notificationPreferences,
    'Payment': payment,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
    'staffProfile': staffProfile,
    'slotsOfAppointment': slotsOfAppointment,
    'Waitlist': waitlist,
    'feedbacks': feedbacks,
    'supportTickets': supportTickets,
    'supportResponses': supportResponses,
    'accounts': accounts,
    'sessions': sessions,
  };
}

class UserUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUncheckedUpdateInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.cookiePreferences,
    this.notificationPreferences,
    this.payment,
    this.consultantProfile,
    this.consulteeProfile,
    this.staffProfile,
    this.slotsOfAppointment,
    this.waitlist,
    this.feedbacks,
    this.supportTickets,
    this.supportResponses,
    this.accounts,
    this.sessions,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  name;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  email;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  emailVerified;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  image;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  phone;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  address;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  password;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetToken;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetExpires;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? onlineStatus;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  currentTimezone;

  final _i1.PrismaUnion<
    bool,
    _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  onboardingCompleted;

  final _i1.PrismaUnion<
    _i3.UserRole,
    _i1.PrismaUnion<
      _i2.NullableEnumUserRoleFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  role;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consultantProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consulteeProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  staffProfileId;

  final _i2.CookiePreferenceUncheckedUpdateOneWithoutUserNestedInput?
  cookiePreferences;

  final _i2.NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput?
  notificationPreferences;

  final _i2.PaymentUncheckedUpdateManyWithoutUserNestedInput? payment;

  final _i2.ConsultantProfileUncheckedUpdateOneWithoutUserNestedInput?
  consultantProfile;

  final _i2.ConsulteeProfileUncheckedUpdateOneWithoutUserNestedInput?
  consulteeProfile;

  final _i2.StaffProfileUncheckedUpdateOneWithoutUserNestedInput? staffProfile;

  final _i2.SlotOfAppointmentUncheckedUpdateManyWithoutUserNestedInput?
  slotsOfAppointment;

  final _i2.WaitlistUncheckedUpdateManyWithoutUserNestedInput? waitlist;

  final _i2.FeedbackUncheckedUpdateManyWithoutUserNestedInput? feedbacks;

  final _i2.SupportTicketUncheckedUpdateManyWithoutUserNestedInput?
  supportTickets;

  final _i2.SupportResponseUncheckedUpdateManyWithoutUserNestedInput?
  supportResponses;

  final _i2.AccountUncheckedUpdateManyWithoutUserNestedInput? accounts;

  final _i2.SessionUncheckedUpdateManyWithoutUserNestedInput? sessions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'cookiePreferences': cookiePreferences,
    'notificationPreferences': notificationPreferences,
    'Payment': payment,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
    'staffProfile': staffProfile,
    'slotsOfAppointment': slotsOfAppointment,
    'Waitlist': waitlist,
    'feedbacks': feedbacks,
    'supportTickets': supportTickets,
    'supportResponses': supportResponses,
    'accounts': accounts,
    'sessions': sessions,
  };
}

class UserUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUncheckedUpdateManyInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  name;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  email;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  emailVerified;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  image;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  phone;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  address;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  password;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetToken;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetExpires;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? onlineStatus;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  currentTimezone;

  final _i1.PrismaUnion<
    bool,
    _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  onboardingCompleted;

  final _i1.PrismaUnion<
    _i3.UserRole,
    _i1.PrismaUnion<
      _i2.NullableEnumUserRoleFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  role;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consultantProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consulteeProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  staffProfileId;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
  };
}

class UserCountAggregateOutputType {
  const UserCountAggregateOutputType({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.$all,
  });

  factory UserCountAggregateOutputType.fromJson(Map json) =>
      UserCountAggregateOutputType(
        id: json['id'],
        name: json['name'],
        email: json['email'],
        emailVerified: json['emailVerified'],
        image: json['image'],
        phone: json['phone'],
        address: json['address'],
        password: json['password'],
        passwordResetToken: json['passwordResetToken'],
        passwordResetExpires: json['passwordResetExpires'],
        onlineStatus: json['onlineStatus'],
        currentTimezone: json['currentTimezone'],
        onboardingCompleted: json['onboardingCompleted'],
        role: json['role'],
        consultantProfileId: json['consultantProfileId'],
        consulteeProfileId: json['consulteeProfileId'],
        staffProfileId: json['staffProfileId'],
        $all: json['_all'],
      );

  final int? id;

  final int? name;

  final int? email;

  final int? emailVerified;

  final int? image;

  final int? phone;

  final int? address;

  final int? password;

  final int? passwordResetToken;

  final int? passwordResetExpires;

  final int? onlineStatus;

  final int? currentTimezone;

  final int? onboardingCompleted;

  final int? role;

  final int? consultantProfileId;

  final int? consulteeProfileId;

  final int? staffProfileId;

  final int? $all;

  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    '_all': $all,
  };
}

class UserMinAggregateOutputType {
  const UserMinAggregateOutputType({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
  });

  factory UserMinAggregateOutputType.fromJson(Map json) =>
      UserMinAggregateOutputType(
        id: json['id'],
        name: json['name'],
        email: json['email'],
        emailVerified: switch (json['emailVerified']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['emailVerified'],
        },
        image: json['image'],
        phone: json['phone'],
        address: json['address'],
        password: json['password'],
        passwordResetToken: json['passwordResetToken'],
        passwordResetExpires: switch (json['passwordResetExpires']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['passwordResetExpires'],
        },
        onlineStatus: json['onlineStatus'],
        currentTimezone: json['currentTimezone'],
        onboardingCompleted: json['onboardingCompleted'],
        role: json['role'] != null
            ? _i3.UserRole.values.firstWhere((e) => e.name == json['role'])
            : null,
        consultantProfileId: json['consultantProfileId'],
        consulteeProfileId: json['consulteeProfileId'],
        staffProfileId: json['staffProfileId'],
      );

  final String? id;

  final String? name;

  final String? email;

  final DateTime? emailVerified;

  final String? image;

  final String? phone;

  final String? address;

  final String? password;

  final String? passwordResetToken;

  final DateTime? passwordResetExpires;

  final bool? onlineStatus;

  final String? currentTimezone;

  final bool? onboardingCompleted;

  final _i3.UserRole? role;

  final String? consultantProfileId;

  final String? consulteeProfileId;

  final String? staffProfileId;

  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified?.toIso8601String(),
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires?.toIso8601String(),
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role?.name,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
  };
}

class UserMaxAggregateOutputType {
  const UserMaxAggregateOutputType({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
  });

  factory UserMaxAggregateOutputType.fromJson(Map json) =>
      UserMaxAggregateOutputType(
        id: json['id'],
        name: json['name'],
        email: json['email'],
        emailVerified: switch (json['emailVerified']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['emailVerified'],
        },
        image: json['image'],
        phone: json['phone'],
        address: json['address'],
        password: json['password'],
        passwordResetToken: json['passwordResetToken'],
        passwordResetExpires: switch (json['passwordResetExpires']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['passwordResetExpires'],
        },
        onlineStatus: json['onlineStatus'],
        currentTimezone: json['currentTimezone'],
        onboardingCompleted: json['onboardingCompleted'],
        role: json['role'] != null
            ? _i3.UserRole.values.firstWhere((e) => e.name == json['role'])
            : null,
        consultantProfileId: json['consultantProfileId'],
        consulteeProfileId: json['consulteeProfileId'],
        staffProfileId: json['staffProfileId'],
      );

  final String? id;

  final String? name;

  final String? email;

  final DateTime? emailVerified;

  final String? image;

  final String? phone;

  final String? address;

  final String? password;

  final String? passwordResetToken;

  final DateTime? passwordResetExpires;

  final bool? onlineStatus;

  final String? currentTimezone;

  final bool? onboardingCompleted;

  final _i3.UserRole? role;

  final String? consultantProfileId;

  final String? consulteeProfileId;

  final String? staffProfileId;

  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified?.toIso8601String(),
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires?.toIso8601String(),
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role?.name,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
  };
}

class UserGroupByOutputType {
  const UserGroupByOutputType({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.$count,
    this.$min,
    this.$max,
  });

  factory UserGroupByOutputType.fromJson(Map json) => UserGroupByOutputType(
    id: json['id'],
    name: json['name'],
    email: json['email'],
    emailVerified: switch (json['emailVerified']) {
      DateTime value => value,
      String value => DateTime.parse(value),
      _ => json['emailVerified'],
    },
    image: json['image'],
    phone: json['phone'],
    address: json['address'],
    password: json['password'],
    passwordResetToken: json['passwordResetToken'],
    passwordResetExpires: switch (json['passwordResetExpires']) {
      DateTime value => value,
      String value => DateTime.parse(value),
      _ => json['passwordResetExpires'],
    },
    onlineStatus: json['onlineStatus'],
    currentTimezone: json['currentTimezone'],
    onboardingCompleted: json['onboardingCompleted'],
    role: json['role'] != null
        ? _i3.UserRole.values.firstWhere((e) => e.name == json['role'])
        : null,
    consultantProfileId: json['consultantProfileId'],
    consulteeProfileId: json['consulteeProfileId'],
    staffProfileId: json['staffProfileId'],
    $count: json['_count'] is Map
        ? _i2.UserCountAggregateOutputType.fromJson(json['_count'])
        : null,
    $min: json['_min'] is Map
        ? _i2.UserMinAggregateOutputType.fromJson(json['_min'])
        : null,
    $max: json['_max'] is Map
        ? _i2.UserMaxAggregateOutputType.fromJson(json['_max'])
        : null,
  );

  final String? id;

  final String? name;

  final String? email;

  final DateTime? emailVerified;

  final String? image;

  final String? phone;

  final String? address;

  final String? password;

  final String? passwordResetToken;

  final DateTime? passwordResetExpires;

  final bool? onlineStatus;

  final String? currentTimezone;

  final bool? onboardingCompleted;

  final _i3.UserRole? role;

  final String? consultantProfileId;

  final String? consulteeProfileId;

  final String? staffProfileId;

  final _i2.UserCountAggregateOutputType? $count;

  final _i2.UserMinAggregateOutputType? $min;

  final _i2.UserMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified?.toIso8601String(),
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires?.toIso8601String(),
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role?.name,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    '_count': $count?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class UserCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCountOrderByAggregateInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? name;

  final _i2.SortOrder? email;

  final _i2.SortOrder? emailVerified;

  final _i2.SortOrder? image;

  final _i2.SortOrder? phone;

  final _i2.SortOrder? address;

  final _i2.SortOrder? password;

  final _i2.SortOrder? passwordResetToken;

  final _i2.SortOrder? passwordResetExpires;

  final _i2.SortOrder? onlineStatus;

  final _i2.SortOrder? currentTimezone;

  final _i2.SortOrder? onboardingCompleted;

  final _i2.SortOrder? role;

  final _i2.SortOrder? consultantProfileId;

  final _i2.SortOrder? consulteeProfileId;

  final _i2.SortOrder? staffProfileId;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
  };
}

class UserMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserMaxOrderByAggregateInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? name;

  final _i2.SortOrder? email;

  final _i2.SortOrder? emailVerified;

  final _i2.SortOrder? image;

  final _i2.SortOrder? phone;

  final _i2.SortOrder? address;

  final _i2.SortOrder? password;

  final _i2.SortOrder? passwordResetToken;

  final _i2.SortOrder? passwordResetExpires;

  final _i2.SortOrder? onlineStatus;

  final _i2.SortOrder? currentTimezone;

  final _i2.SortOrder? onboardingCompleted;

  final _i2.SortOrder? role;

  final _i2.SortOrder? consultantProfileId;

  final _i2.SortOrder? consulteeProfileId;

  final _i2.SortOrder? staffProfileId;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
  };
}

class UserMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserMinOrderByAggregateInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? name;

  final _i2.SortOrder? email;

  final _i2.SortOrder? emailVerified;

  final _i2.SortOrder? image;

  final _i2.SortOrder? phone;

  final _i2.SortOrder? address;

  final _i2.SortOrder? password;

  final _i2.SortOrder? passwordResetToken;

  final _i2.SortOrder? passwordResetExpires;

  final _i2.SortOrder? onlineStatus;

  final _i2.SortOrder? currentTimezone;

  final _i2.SortOrder? onboardingCompleted;

  final _i2.SortOrder? role;

  final _i2.SortOrder? consultantProfileId;

  final _i2.SortOrder? consulteeProfileId;

  final _i2.SortOrder? staffProfileId;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
  };
}

class UserOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserOrderByWithAggregationInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.$count,
    this.$max,
    this.$min,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? name;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? email;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? emailVerified;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? image;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? phone;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? address;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? password;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? passwordResetToken;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>?
  passwordResetExpires;

  final _i2.SortOrder? onlineStatus;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? currentTimezone;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? onboardingCompleted;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? role;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? consultantProfileId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? consulteeProfileId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? staffProfileId;

  final _i2.UserCountOrderByAggregateInput? $count;

  final _i2.UserMaxOrderByAggregateInput? $max;

  final _i2.UserMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    '_count': $count,
    '_max': $max,
    '_min': $min,
  };
}

class NestedStringWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedStringWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.contains,
    this.startsWith,
    this.endsWith,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final String? equals;

  final _i1.PrismaUnion<Iterable<String>, String>? $in;

  final _i1.PrismaUnion<Iterable<String>, String>? notIn;

  final String? lt;

  final String? lte;

  final String? gt;

  final String? gte;

  final String? contains;

  final String? startsWith;

  final String? endsWith;

  final _i1.PrismaUnion<String, _i2.NestedStringWithAggregatesFilter>? not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedStringFilter? $min;

  final _i2.NestedStringFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'lt': lt,
    'lte': lte,
    'gt': gt,
    'gte': gte,
    'contains': contains,
    'startsWith': startsWith,
    'endsWith': endsWith,
    'not': not,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class StringWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StringWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.contains,
    this.startsWith,
    this.endsWith,
    this.mode,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final String? equals;

  final _i1.PrismaUnion<Iterable<String>, String>? $in;

  final _i1.PrismaUnion<Iterable<String>, String>? notIn;

  final String? lt;

  final String? lte;

  final String? gt;

  final String? gte;

  final String? contains;

  final String? startsWith;

  final String? endsWith;

  final _i2.QueryMode? mode;

  final _i1.PrismaUnion<String, _i2.NestedStringWithAggregatesFilter>? not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedStringFilter? $min;

  final _i2.NestedStringFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'lt': lt,
    'lte': lte,
    'gt': gt,
    'gte': gte,
    'contains': contains,
    'startsWith': startsWith,
    'endsWith': endsWith,
    'mode': mode,
    'not': not,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class NestedStringNullableWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedStringNullableWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.contains,
    this.startsWith,
    this.endsWith,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<String, _i1.PrismaNull>? equals;

  final _i1.PrismaUnion<
    Iterable<String>,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  $in;

  final _i1.PrismaUnion<
    Iterable<String>,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  notIn;

  final String? lt;

  final String? lte;

  final String? gt;

  final String? gte;

  final String? contains;

  final String? startsWith;

  final String? endsWith;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NestedStringNullableWithAggregatesFilter,
      _i1.PrismaNull
    >
  >?
  not;

  final _i2.NestedIntNullableFilter? $count;

  final _i2.NestedStringNullableFilter? $min;

  final _i2.NestedStringNullableFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'lt': lt,
    'lte': lte,
    'gt': gt,
    'gte': gte,
    'contains': contains,
    'startsWith': startsWith,
    'endsWith': endsWith,
    'not': not,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class StringNullableWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StringNullableWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.contains,
    this.startsWith,
    this.endsWith,
    this.mode,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<String, _i1.PrismaNull>? equals;

  final _i1.PrismaUnion<
    Iterable<String>,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  $in;

  final _i1.PrismaUnion<
    Iterable<String>,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  notIn;

  final String? lt;

  final String? lte;

  final String? gt;

  final String? gte;

  final String? contains;

  final String? startsWith;

  final String? endsWith;

  final _i2.QueryMode? mode;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NestedStringNullableWithAggregatesFilter,
      _i1.PrismaNull
    >
  >?
  not;

  final _i2.NestedIntNullableFilter? $count;

  final _i2.NestedStringNullableFilter? $min;

  final _i2.NestedStringNullableFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'lt': lt,
    'lte': lte,
    'gt': gt,
    'gte': gte,
    'contains': contains,
    'startsWith': startsWith,
    'endsWith': endsWith,
    'mode': mode,
    'not': not,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class NestedDateTimeNullableWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedDateTimeNullableWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? equals;

  final _i1.PrismaUnion<
    Iterable<DateTime>,
    _i1.PrismaUnion<DateTime, _i1.PrismaNull>
  >?
  $in;

  final _i1.PrismaUnion<
    Iterable<DateTime>,
    _i1.PrismaUnion<DateTime, _i1.PrismaNull>
  >?
  notIn;

  final DateTime? lt;

  final DateTime? lte;

  final DateTime? gt;

  final DateTime? gte;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NestedDateTimeNullableWithAggregatesFilter,
      _i1.PrismaNull
    >
  >?
  not;

  final _i2.NestedIntNullableFilter? $count;

  final _i2.NestedDateTimeNullableFilter? $min;

  final _i2.NestedDateTimeNullableFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'lt': lt,
    'lte': lte,
    'gt': gt,
    'gte': gte,
    'not': not,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class DateTimeNullableWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DateTimeNullableWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? equals;

  final _i1.PrismaUnion<
    Iterable<DateTime>,
    _i1.PrismaUnion<DateTime, _i1.PrismaNull>
  >?
  $in;

  final _i1.PrismaUnion<
    Iterable<DateTime>,
    _i1.PrismaUnion<DateTime, _i1.PrismaNull>
  >?
  notIn;

  final DateTime? lt;

  final DateTime? lte;

  final DateTime? gt;

  final DateTime? gte;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NestedDateTimeNullableWithAggregatesFilter,
      _i1.PrismaNull
    >
  >?
  not;

  final _i2.NestedIntNullableFilter? $count;

  final _i2.NestedDateTimeNullableFilter? $min;

  final _i2.NestedDateTimeNullableFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'lt': lt,
    'lte': lte,
    'gt': gt,
    'gte': gte,
    'not': not,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class NestedBoolWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedBoolWithAggregatesFilter({
    this.equals,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? equals;

  final _i1.PrismaUnion<bool, _i2.NestedBoolWithAggregatesFilter>? not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedBoolFilter? $min;

  final _i2.NestedBoolFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'not': not,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class BoolWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BoolWithAggregatesFilter({
    this.equals,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? equals;

  final _i1.PrismaUnion<bool, _i2.NestedBoolWithAggregatesFilter>? not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedBoolFilter? $min;

  final _i2.NestedBoolFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'not': not,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class NestedBoolNullableWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedBoolNullableWithAggregatesFilter({
    this.equals,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? equals;

  final _i1.PrismaUnion<
    bool,
    _i1.PrismaUnion<_i2.NestedBoolNullableWithAggregatesFilter, _i1.PrismaNull>
  >?
  not;

  final _i2.NestedIntNullableFilter? $count;

  final _i2.NestedBoolNullableFilter? $min;

  final _i2.NestedBoolNullableFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'not': not,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class BoolNullableWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BoolNullableWithAggregatesFilter({
    this.equals,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? equals;

  final _i1.PrismaUnion<
    bool,
    _i1.PrismaUnion<_i2.NestedBoolNullableWithAggregatesFilter, _i1.PrismaNull>
  >?
  not;

  final _i2.NestedIntNullableFilter? $count;

  final _i2.NestedBoolNullableFilter? $min;

  final _i2.NestedBoolNullableFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'not': not,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class NestedEnumUserRoleNullableWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedEnumUserRoleNullableWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<_i3.UserRole, _i1.PrismaNull>? equals;

  final _i1.PrismaUnion<
    Iterable<_i3.UserRole>,
    _i1.PrismaUnion<_i3.UserRole, _i1.PrismaNull>
  >?
  $in;

  final _i1.PrismaUnion<
    Iterable<_i3.UserRole>,
    _i1.PrismaUnion<_i3.UserRole, _i1.PrismaNull>
  >?
  notIn;

  final _i1.PrismaUnion<
    _i3.UserRole,
    _i1.PrismaUnion<
      _i2.NestedEnumUserRoleNullableWithAggregatesFilter,
      _i1.PrismaNull
    >
  >?
  not;

  final _i2.NestedIntNullableFilter? $count;

  final _i2.NestedEnumUserRoleNullableFilter? $min;

  final _i2.NestedEnumUserRoleNullableFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class EnumUserRoleNullableWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumUserRoleNullableWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<_i3.UserRole, _i1.PrismaNull>? equals;

  final _i1.PrismaUnion<
    Iterable<_i3.UserRole>,
    _i1.PrismaUnion<_i3.UserRole, _i1.PrismaNull>
  >?
  $in;

  final _i1.PrismaUnion<
    Iterable<_i3.UserRole>,
    _i1.PrismaUnion<_i3.UserRole, _i1.PrismaNull>
  >?
  notIn;

  final _i1.PrismaUnion<
    _i3.UserRole,
    _i1.PrismaUnion<
      _i2.NestedEnumUserRoleNullableWithAggregatesFilter,
      _i1.PrismaNull
    >
  >?
  not;

  final _i2.NestedIntNullableFilter? $count;

  final _i2.NestedEnumUserRoleNullableFilter? $min;

  final _i2.NestedEnumUserRoleNullableFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class UserScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
  });

  final _i1.PrismaUnion<
    _i2.UserScalarWhereWithAggregatesInput,
    Iterable<_i2.UserScalarWhereWithAggregatesInput>
  >?
  AND;

  final Iterable<_i2.UserScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<
    _i2.UserScalarWhereWithAggregatesInput,
    Iterable<_i2.UserScalarWhereWithAggregatesInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? id;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  name;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  email;

  final _i1.PrismaUnion<
    _i2.DateTimeNullableWithAggregatesFilter,
    _i1.PrismaUnion<DateTime, _i1.PrismaNull>
  >?
  emailVerified;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  image;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  phone;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  address;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  password;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  passwordResetToken;

  final _i1.PrismaUnion<
    _i2.DateTimeNullableWithAggregatesFilter,
    _i1.PrismaUnion<DateTime, _i1.PrismaNull>
  >?
  passwordResetExpires;

  final _i1.PrismaUnion<_i2.BoolWithAggregatesFilter, bool>? onlineStatus;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  currentTimezone;

  final _i1.PrismaUnion<
    _i2.BoolNullableWithAggregatesFilter,
    _i1.PrismaUnion<bool, _i1.PrismaNull>
  >?
  onboardingCompleted;

  final _i1.PrismaUnion<
    _i2.EnumUserRoleNullableWithAggregatesFilter,
    _i1.PrismaUnion<_i3.UserRole, _i1.PrismaNull>
  >?
  role;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  consultantProfileId;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  consulteeProfileId;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  staffProfileId;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
  };
}

class UserCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCountAggregateOutputTypeSelect({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.$all,
  });

  final bool? id;

  final bool? name;

  final bool? email;

  final bool? emailVerified;

  final bool? image;

  final bool? phone;

  final bool? address;

  final bool? password;

  final bool? passwordResetToken;

  final bool? passwordResetExpires;

  final bool? onlineStatus;

  final bool? currentTimezone;

  final bool? onboardingCompleted;

  final bool? role;

  final bool? consultantProfileId;

  final bool? consulteeProfileId;

  final bool? staffProfileId;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    '_all': $all,
  };
}

class UserGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserGroupByOutputTypeCountArgs({this.select});

  final _i2.UserCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class UserMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserMinAggregateOutputTypeSelect({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
  });

  final bool? id;

  final bool? name;

  final bool? email;

  final bool? emailVerified;

  final bool? image;

  final bool? phone;

  final bool? address;

  final bool? password;

  final bool? passwordResetToken;

  final bool? passwordResetExpires;

  final bool? onlineStatus;

  final bool? currentTimezone;

  final bool? onboardingCompleted;

  final bool? role;

  final bool? consultantProfileId;

  final bool? consulteeProfileId;

  final bool? staffProfileId;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
  };
}

class UserGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserGroupByOutputTypeMinArgs({this.select});

  final _i2.UserMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class UserMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserMaxAggregateOutputTypeSelect({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
  });

  final bool? id;

  final bool? name;

  final bool? email;

  final bool? emailVerified;

  final bool? image;

  final bool? phone;

  final bool? address;

  final bool? password;

  final bool? passwordResetToken;

  final bool? passwordResetExpires;

  final bool? onlineStatus;

  final bool? currentTimezone;

  final bool? onboardingCompleted;

  final bool? role;

  final bool? consultantProfileId;

  final bool? consulteeProfileId;

  final bool? staffProfileId;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
  };
}

class UserGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserGroupByOutputTypeMaxArgs({this.select});

  final _i2.UserMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class UserGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserGroupByOutputTypeSelect({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? name;

  final bool? email;

  final bool? emailVerified;

  final bool? image;

  final bool? phone;

  final bool? address;

  final bool? password;

  final bool? passwordResetToken;

  final bool? passwordResetExpires;

  final bool? onlineStatus;

  final bool? currentTimezone;

  final bool? onboardingCompleted;

  final bool? role;

  final bool? consultantProfileId;

  final bool? consulteeProfileId;

  final bool? staffProfileId;

  final _i1.PrismaUnion<bool, _i2.UserGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.UserGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.UserGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class AggregateUser {
  const AggregateUser({this.$count, this.$min, this.$max});

  factory AggregateUser.fromJson(Map json) => AggregateUser(
    $count: json['_count'] is Map
        ? _i2.UserCountAggregateOutputType.fromJson(json['_count'])
        : null,
    $min: json['_min'] is Map
        ? _i2.UserMinAggregateOutputType.fromJson(json['_min'])
        : null,
    $max: json['_max'] is Map
        ? _i2.UserMaxAggregateOutputType.fromJson(json['_max'])
        : null,
  );

  final _i2.UserCountAggregateOutputType? $count;

  final _i2.UserMinAggregateOutputType? $min;

  final _i2.UserMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    '_count': $count?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class AggregateUserCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateUserCountArgs({this.select});

  final _i2.UserCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateUserMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateUserMinArgs({this.select});

  final _i2.UserMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateUserMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateUserMaxArgs({this.select});

  final _i2.UserMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateUserSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateUserSelect({this.$count, this.$min, this.$max});

  final _i1.PrismaUnion<bool, _i2.AggregateUserCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateUserMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateUserMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class UserCreateWithoutFeedbacksInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateWithoutFeedbacksInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.cookiePreferences,
    this.notificationPreferences,
    this.payment,
    this.consultantProfile,
    this.consulteeProfile,
    this.staffProfile,
    this.slotsOfAppointment,
    this.waitlist,
    this.supportTickets,
    this.supportResponses,
    this.accounts,
    this.sessions,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? email;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? emailVerified;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? image;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? address;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? password;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? passwordResetToken;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? passwordResetExpires;

  final bool? onlineStatus;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? currentTimezone;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? onboardingCompleted;

  final _i1.PrismaUnion<_i3.UserRole, _i1.PrismaNull>? role;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consultantProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consulteeProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? staffProfileId;

  final _i2.CookiePreferenceCreateNestedOneWithoutUserInput? cookiePreferences;

  final _i2.NotificationPreferenceCreateNestedOneWithoutUserInput?
  notificationPreferences;

  final _i2.PaymentCreateNestedManyWithoutUserInput? payment;

  final _i2.ConsultantProfileCreateNestedOneWithoutUserInput? consultantProfile;

  final _i2.ConsulteeProfileCreateNestedOneWithoutUserInput? consulteeProfile;

  final _i2.StaffProfileCreateNestedOneWithoutUserInput? staffProfile;

  final _i2.SlotOfAppointmentCreateNestedManyWithoutUserInput?
  slotsOfAppointment;

  final _i2.WaitlistCreateNestedManyWithoutUserInput? waitlist;

  final _i2.SupportTicketCreateNestedManyWithoutUserInput? supportTickets;

  final _i2.SupportResponseCreateNestedManyWithoutUserInput? supportResponses;

  final _i2.AccountCreateNestedManyWithoutUserInput? accounts;

  final _i2.SessionCreateNestedManyWithoutUserInput? sessions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'cookiePreferences': cookiePreferences,
    'notificationPreferences': notificationPreferences,
    'Payment': payment,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
    'staffProfile': staffProfile,
    'slotsOfAppointment': slotsOfAppointment,
    'Waitlist': waitlist,
    'supportTickets': supportTickets,
    'supportResponses': supportResponses,
    'accounts': accounts,
    'sessions': sessions,
  };
}

class UserUncheckedCreateWithoutFeedbacksInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUncheckedCreateWithoutFeedbacksInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.cookiePreferences,
    this.notificationPreferences,
    this.payment,
    this.consultantProfile,
    this.consulteeProfile,
    this.staffProfile,
    this.slotsOfAppointment,
    this.waitlist,
    this.supportTickets,
    this.supportResponses,
    this.accounts,
    this.sessions,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? email;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? emailVerified;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? image;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? address;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? password;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? passwordResetToken;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? passwordResetExpires;

  final bool? onlineStatus;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? currentTimezone;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? onboardingCompleted;

  final _i1.PrismaUnion<_i3.UserRole, _i1.PrismaNull>? role;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consultantProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consulteeProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? staffProfileId;

  final _i2.CookiePreferenceUncheckedCreateNestedOneWithoutUserInput?
  cookiePreferences;

  final _i2.NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput?
  notificationPreferences;

  final _i2.PaymentUncheckedCreateNestedManyWithoutUserInput? payment;

  final _i2.ConsultantProfileUncheckedCreateNestedOneWithoutUserInput?
  consultantProfile;

  final _i2.ConsulteeProfileUncheckedCreateNestedOneWithoutUserInput?
  consulteeProfile;

  final _i2.StaffProfileUncheckedCreateNestedOneWithoutUserInput? staffProfile;

  final _i2.SlotOfAppointmentUncheckedCreateNestedManyWithoutUserInput?
  slotsOfAppointment;

  final _i2.WaitlistUncheckedCreateNestedManyWithoutUserInput? waitlist;

  final _i2.SupportTicketUncheckedCreateNestedManyWithoutUserInput?
  supportTickets;

  final _i2.SupportResponseUncheckedCreateNestedManyWithoutUserInput?
  supportResponses;

  final _i2.AccountUncheckedCreateNestedManyWithoutUserInput? accounts;

  final _i2.SessionUncheckedCreateNestedManyWithoutUserInput? sessions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'cookiePreferences': cookiePreferences,
    'notificationPreferences': notificationPreferences,
    'Payment': payment,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
    'staffProfile': staffProfile,
    'slotsOfAppointment': slotsOfAppointment,
    'Waitlist': waitlist,
    'supportTickets': supportTickets,
    'supportResponses': supportResponses,
    'accounts': accounts,
    'sessions': sessions,
  };
}

class UserCreateOrConnectWithoutFeedbacksInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateOrConnectWithoutFeedbacksInput({
    required this.where,
    required this.create,
  });

  final _i2.UserWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.UserCreateWithoutFeedbacksInput,
    _i2.UserUncheckedCreateWithoutFeedbacksInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class UserCreateNestedOneWithoutFeedbacksInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateNestedOneWithoutFeedbacksInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.UserCreateWithoutFeedbacksInput,
    _i2.UserUncheckedCreateWithoutFeedbacksInput
  >?
  create;

  final _i2.UserCreateOrConnectWithoutFeedbacksInput? connectOrCreate;

  final _i2.UserWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class FeedbackCreateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FeedbackCreateInput({
    this.id,
    required this.title,
    required this.description,
    this.rating,
    this.category,
    this.status,
    this.createdAt,
    this.updatedAt,
    required this.user,
  });

  final String? id;

  final String title;

  final String description;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? rating;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? category;

  final _i3.FeedbackStatus? status;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.UserCreateNestedOneWithoutFeedbacksInput user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'rating': rating,
    'category': category,
    'status': status,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'user': user,
  };
}

class FeedbackUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FeedbackUncheckedCreateInput({
    this.id,
    required this.title,
    required this.description,
    this.rating,
    this.category,
    this.status,
    required this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final String title;

  final String description;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? rating;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? category;

  final _i3.FeedbackStatus? status;

  final String userId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'rating': rating,
    'category': category,
    'status': status,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class FeedbackCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FeedbackCreateManyInput({
    this.id,
    required this.title,
    required this.description,
    this.rating,
    this.category,
    this.status,
    required this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final String title;

  final String description;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? rating;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? category;

  final _i3.FeedbackStatus? status;

  final String userId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'rating': rating,
    'category': category,
    'status': status,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class UserUpdateWithoutFeedbacksInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpdateWithoutFeedbacksInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.cookiePreferences,
    this.notificationPreferences,
    this.payment,
    this.consultantProfile,
    this.consulteeProfile,
    this.staffProfile,
    this.slotsOfAppointment,
    this.waitlist,
    this.supportTickets,
    this.supportResponses,
    this.accounts,
    this.sessions,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  name;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  email;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  emailVerified;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  image;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  phone;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  address;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  password;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetToken;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetExpires;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? onlineStatus;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  currentTimezone;

  final _i1.PrismaUnion<
    bool,
    _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  onboardingCompleted;

  final _i1.PrismaUnion<
    _i3.UserRole,
    _i1.PrismaUnion<
      _i2.NullableEnumUserRoleFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  role;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consultantProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consulteeProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  staffProfileId;

  final _i2.CookiePreferenceUpdateOneWithoutUserNestedInput? cookiePreferences;

  final _i2.NotificationPreferenceUpdateOneWithoutUserNestedInput?
  notificationPreferences;

  final _i2.PaymentUpdateManyWithoutUserNestedInput? payment;

  final _i2.ConsultantProfileUpdateOneWithoutUserNestedInput? consultantProfile;

  final _i2.ConsulteeProfileUpdateOneWithoutUserNestedInput? consulteeProfile;

  final _i2.StaffProfileUpdateOneWithoutUserNestedInput? staffProfile;

  final _i2.SlotOfAppointmentUpdateManyWithoutUserNestedInput?
  slotsOfAppointment;

  final _i2.WaitlistUpdateManyWithoutUserNestedInput? waitlist;

  final _i2.SupportTicketUpdateManyWithoutUserNestedInput? supportTickets;

  final _i2.SupportResponseUpdateManyWithoutUserNestedInput? supportResponses;

  final _i2.AccountUpdateManyWithoutUserNestedInput? accounts;

  final _i2.SessionUpdateManyWithoutUserNestedInput? sessions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'cookiePreferences': cookiePreferences,
    'notificationPreferences': notificationPreferences,
    'Payment': payment,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
    'staffProfile': staffProfile,
    'slotsOfAppointment': slotsOfAppointment,
    'Waitlist': waitlist,
    'supportTickets': supportTickets,
    'supportResponses': supportResponses,
    'accounts': accounts,
    'sessions': sessions,
  };
}

class UserUncheckedUpdateWithoutFeedbacksInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUncheckedUpdateWithoutFeedbacksInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.cookiePreferences,
    this.notificationPreferences,
    this.payment,
    this.consultantProfile,
    this.consulteeProfile,
    this.staffProfile,
    this.slotsOfAppointment,
    this.waitlist,
    this.supportTickets,
    this.supportResponses,
    this.accounts,
    this.sessions,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  name;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  email;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  emailVerified;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  image;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  phone;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  address;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  password;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetToken;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetExpires;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? onlineStatus;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  currentTimezone;

  final _i1.PrismaUnion<
    bool,
    _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  onboardingCompleted;

  final _i1.PrismaUnion<
    _i3.UserRole,
    _i1.PrismaUnion<
      _i2.NullableEnumUserRoleFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  role;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consultantProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consulteeProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  staffProfileId;

  final _i2.CookiePreferenceUncheckedUpdateOneWithoutUserNestedInput?
  cookiePreferences;

  final _i2.NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput?
  notificationPreferences;

  final _i2.PaymentUncheckedUpdateManyWithoutUserNestedInput? payment;

  final _i2.ConsultantProfileUncheckedUpdateOneWithoutUserNestedInput?
  consultantProfile;

  final _i2.ConsulteeProfileUncheckedUpdateOneWithoutUserNestedInput?
  consulteeProfile;

  final _i2.StaffProfileUncheckedUpdateOneWithoutUserNestedInput? staffProfile;

  final _i2.SlotOfAppointmentUncheckedUpdateManyWithoutUserNestedInput?
  slotsOfAppointment;

  final _i2.WaitlistUncheckedUpdateManyWithoutUserNestedInput? waitlist;

  final _i2.SupportTicketUncheckedUpdateManyWithoutUserNestedInput?
  supportTickets;

  final _i2.SupportResponseUncheckedUpdateManyWithoutUserNestedInput?
  supportResponses;

  final _i2.AccountUncheckedUpdateManyWithoutUserNestedInput? accounts;

  final _i2.SessionUncheckedUpdateManyWithoutUserNestedInput? sessions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'cookiePreferences': cookiePreferences,
    'notificationPreferences': notificationPreferences,
    'Payment': payment,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
    'staffProfile': staffProfile,
    'slotsOfAppointment': slotsOfAppointment,
    'Waitlist': waitlist,
    'supportTickets': supportTickets,
    'supportResponses': supportResponses,
    'accounts': accounts,
    'sessions': sessions,
  };
}

class UserUpsertWithoutFeedbacksInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpsertWithoutFeedbacksInput({
    required this.update,
    required this.create,
  });

  final _i1.PrismaUnion<
    _i2.UserUpdateWithoutFeedbacksInput,
    _i2.UserUncheckedUpdateWithoutFeedbacksInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.UserCreateWithoutFeedbacksInput,
    _i2.UserUncheckedCreateWithoutFeedbacksInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'update': update, 'create': create};
}

class UserUpdateOneRequiredWithoutFeedbacksNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpdateOneRequiredWithoutFeedbacksNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.UserCreateWithoutFeedbacksInput,
    _i2.UserUncheckedCreateWithoutFeedbacksInput
  >?
  create;

  final _i2.UserCreateOrConnectWithoutFeedbacksInput? connectOrCreate;

  final _i2.UserUpsertWithoutFeedbacksInput? upsert;

  final _i2.UserWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.UserUpdateWithoutFeedbacksInput,
    _i2.UserUncheckedUpdateWithoutFeedbacksInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'connect': connect,
    'update': update,
  };
}

class FeedbackUpdateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FeedbackUpdateInput({
    this.id,
    this.title,
    this.description,
    this.rating,
    this.category,
    this.status,
    this.createdAt,
    this.updatedAt,
    this.user,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  description;

  final _i1.PrismaUnion<
    int,
    _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  rating;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  category;

  final _i1.PrismaUnion<
    _i3.FeedbackStatus,
    _i2.EnumFeedbackStatusFieldUpdateOperationsInput
  >?
  status;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.UserUpdateOneRequiredWithoutFeedbacksNestedInput? user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'rating': rating,
    'category': category,
    'status': status,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'user': user,
  };
}

class FeedbackUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FeedbackUncheckedUpdateInput({
    this.id,
    this.title,
    this.description,
    this.rating,
    this.category,
    this.status,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  description;

  final _i1.PrismaUnion<
    int,
    _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  rating;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  category;

  final _i1.PrismaUnion<
    _i3.FeedbackStatus,
    _i2.EnumFeedbackStatusFieldUpdateOperationsInput
  >?
  status;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'rating': rating,
    'category': category,
    'status': status,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class FeedbackUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FeedbackUncheckedUpdateManyInput({
    this.id,
    this.title,
    this.description,
    this.rating,
    this.category,
    this.status,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  description;

  final _i1.PrismaUnion<
    int,
    _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  rating;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  category;

  final _i1.PrismaUnion<
    _i3.FeedbackStatus,
    _i2.EnumFeedbackStatusFieldUpdateOperationsInput
  >?
  status;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'rating': rating,
    'category': category,
    'status': status,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class FeedbackCountAggregateOutputType {
  const FeedbackCountAggregateOutputType({
    this.id,
    this.title,
    this.description,
    this.rating,
    this.category,
    this.status,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  factory FeedbackCountAggregateOutputType.fromJson(Map json) =>
      FeedbackCountAggregateOutputType(
        id: json['id'],
        title: json['title'],
        description: json['description'],
        rating: json['rating'],
        category: json['category'],
        status: json['status'],
        userId: json['userId'],
        createdAt: json['createdAt'],
        updatedAt: json['updatedAt'],
        $all: json['_all'],
      );

  final int? id;

  final int? title;

  final int? description;

  final int? rating;

  final int? category;

  final int? status;

  final int? userId;

  final int? createdAt;

  final int? updatedAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'rating': rating,
    'category': category,
    'status': status,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class FeedbackAvgAggregateOutputType {
  const FeedbackAvgAggregateOutputType({this.rating});

  factory FeedbackAvgAggregateOutputType.fromJson(Map json) =>
      FeedbackAvgAggregateOutputType(rating: json['rating']);

  final double? rating;

  Map<String, dynamic> toJson() => {'rating': rating};
}

class FeedbackSumAggregateOutputType {
  const FeedbackSumAggregateOutputType({this.rating});

  factory FeedbackSumAggregateOutputType.fromJson(Map json) =>
      FeedbackSumAggregateOutputType(rating: json['rating']);

  final int? rating;

  Map<String, dynamic> toJson() => {'rating': rating};
}

class FeedbackMinAggregateOutputType {
  const FeedbackMinAggregateOutputType({
    this.id,
    this.title,
    this.description,
    this.rating,
    this.category,
    this.status,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  factory FeedbackMinAggregateOutputType.fromJson(Map json) =>
      FeedbackMinAggregateOutputType(
        id: json['id'],
        title: json['title'],
        description: json['description'],
        rating: json['rating'],
        category: json['category'],
        status: json['status'] != null
            ? _i3.FeedbackStatus.values.firstWhere(
                (e) => e.name == json['status'],
              )
            : null,
        userId: json['userId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final String? title;

  final String? description;

  final int? rating;

  final String? category;

  final _i3.FeedbackStatus? status;

  final String? userId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'rating': rating,
    'category': category,
    'status': status?.name,
    'userId': userId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class FeedbackMaxAggregateOutputType {
  const FeedbackMaxAggregateOutputType({
    this.id,
    this.title,
    this.description,
    this.rating,
    this.category,
    this.status,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  factory FeedbackMaxAggregateOutputType.fromJson(Map json) =>
      FeedbackMaxAggregateOutputType(
        id: json['id'],
        title: json['title'],
        description: json['description'],
        rating: json['rating'],
        category: json['category'],
        status: json['status'] != null
            ? _i3.FeedbackStatus.values.firstWhere(
                (e) => e.name == json['status'],
              )
            : null,
        userId: json['userId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final String? title;

  final String? description;

  final int? rating;

  final String? category;

  final _i3.FeedbackStatus? status;

  final String? userId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'rating': rating,
    'category': category,
    'status': status?.name,
    'userId': userId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class FeedbackGroupByOutputType {
  const FeedbackGroupByOutputType({
    this.id,
    this.title,
    this.description,
    this.rating,
    this.category,
    this.status,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory FeedbackGroupByOutputType.fromJson(Map json) =>
      FeedbackGroupByOutputType(
        id: json['id'],
        title: json['title'],
        description: json['description'],
        rating: json['rating'],
        category: json['category'],
        status: json['status'] != null
            ? _i3.FeedbackStatus.values.firstWhere(
                (e) => e.name == json['status'],
              )
            : null,
        userId: json['userId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
        $count: json['_count'] is Map
            ? _i2.FeedbackCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.FeedbackAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.FeedbackSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.FeedbackMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.FeedbackMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? id;

  final String? title;

  final String? description;

  final int? rating;

  final String? category;

  final _i3.FeedbackStatus? status;

  final String? userId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.FeedbackCountAggregateOutputType? $count;

  final _i2.FeedbackAvgAggregateOutputType? $avg;

  final _i2.FeedbackSumAggregateOutputType? $sum;

  final _i2.FeedbackMinAggregateOutputType? $min;

  final _i2.FeedbackMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'rating': rating,
    'category': category,
    'status': status?.name,
    'userId': userId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
    '_count': $count?.toJson(),
    '_avg': $avg?.toJson(),
    '_sum': $sum?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class FeedbackCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FeedbackCountOrderByAggregateInput({
    this.id,
    this.title,
    this.description,
    this.rating,
    this.category,
    this.status,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? title;

  final _i2.SortOrder? description;

  final _i2.SortOrder? rating;

  final _i2.SortOrder? category;

  final _i2.SortOrder? status;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'rating': rating,
    'category': category,
    'status': status,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class FeedbackAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FeedbackAvgOrderByAggregateInput({this.rating});

  final _i2.SortOrder? rating;

  @override
  Map<String, dynamic> toJson() => {'rating': rating};
}

class FeedbackMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FeedbackMaxOrderByAggregateInput({
    this.id,
    this.title,
    this.description,
    this.rating,
    this.category,
    this.status,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? title;

  final _i2.SortOrder? description;

  final _i2.SortOrder? rating;

  final _i2.SortOrder? category;

  final _i2.SortOrder? status;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'rating': rating,
    'category': category,
    'status': status,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class FeedbackMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FeedbackMinOrderByAggregateInput({
    this.id,
    this.title,
    this.description,
    this.rating,
    this.category,
    this.status,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? title;

  final _i2.SortOrder? description;

  final _i2.SortOrder? rating;

  final _i2.SortOrder? category;

  final _i2.SortOrder? status;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'rating': rating,
    'category': category,
    'status': status,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class FeedbackSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FeedbackSumOrderByAggregateInput({this.rating});

  final _i2.SortOrder? rating;

  @override
  Map<String, dynamic> toJson() => {'rating': rating};
}

class FeedbackOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FeedbackOrderByWithAggregationInput({
    this.id,
    this.title,
    this.description,
    this.rating,
    this.category,
    this.status,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? title;

  final _i2.SortOrder? description;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? rating;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? category;

  final _i2.SortOrder? status;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.FeedbackCountOrderByAggregateInput? $count;

  final _i2.FeedbackAvgOrderByAggregateInput? $avg;

  final _i2.FeedbackMaxOrderByAggregateInput? $max;

  final _i2.FeedbackMinOrderByAggregateInput? $min;

  final _i2.FeedbackSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'rating': rating,
    'category': category,
    'status': status,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_avg': $avg,
    '_max': $max,
    '_min': $min,
    '_sum': $sum,
  };
}

class NestedIntNullableWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedIntNullableWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<int, _i1.PrismaNull>? equals;

  final _i1.PrismaUnion<Iterable<int>, _i1.PrismaUnion<int, _i1.PrismaNull>>?
  $in;

  final _i1.PrismaUnion<Iterable<int>, _i1.PrismaUnion<int, _i1.PrismaNull>>?
  notIn;

  final int? lt;

  final int? lte;

  final int? gt;

  final int? gte;

  final _i1.PrismaUnion<
    int,
    _i1.PrismaUnion<_i2.NestedIntNullableWithAggregatesFilter, _i1.PrismaNull>
  >?
  not;

  final _i2.NestedIntNullableFilter? $count;

  final _i2.NestedFloatNullableFilter? $avg;

  final _i2.NestedIntNullableFilter? $sum;

  final _i2.NestedIntNullableFilter? $min;

  final _i2.NestedIntNullableFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'lt': lt,
    'lte': lte,
    'gt': gt,
    'gte': gte,
    'not': not,
    '_count': $count,
    '_avg': $avg,
    '_sum': $sum,
    '_min': $min,
    '_max': $max,
  };
}

class IntNullableWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IntNullableWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<int, _i1.PrismaNull>? equals;

  final _i1.PrismaUnion<Iterable<int>, _i1.PrismaUnion<int, _i1.PrismaNull>>?
  $in;

  final _i1.PrismaUnion<Iterable<int>, _i1.PrismaUnion<int, _i1.PrismaNull>>?
  notIn;

  final int? lt;

  final int? lte;

  final int? gt;

  final int? gte;

  final _i1.PrismaUnion<
    int,
    _i1.PrismaUnion<_i2.NestedIntNullableWithAggregatesFilter, _i1.PrismaNull>
  >?
  not;

  final _i2.NestedIntNullableFilter? $count;

  final _i2.NestedFloatNullableFilter? $avg;

  final _i2.NestedIntNullableFilter? $sum;

  final _i2.NestedIntNullableFilter? $min;

  final _i2.NestedIntNullableFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'lt': lt,
    'lte': lte,
    'gt': gt,
    'gte': gte,
    'not': not,
    '_count': $count,
    '_avg': $avg,
    '_sum': $sum,
    '_min': $min,
    '_max': $max,
  };
}

class NestedEnumFeedbackStatusWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedEnumFeedbackStatusWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i3.FeedbackStatus? equals;

  final _i1.PrismaUnion<Iterable<_i3.FeedbackStatus>, _i3.FeedbackStatus>? $in;

  final _i1.PrismaUnion<Iterable<_i3.FeedbackStatus>, _i3.FeedbackStatus>?
  notIn;

  final _i1.PrismaUnion<
    _i3.FeedbackStatus,
    _i2.NestedEnumFeedbackStatusWithAggregatesFilter
  >?
  not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedEnumFeedbackStatusFilter? $min;

  final _i2.NestedEnumFeedbackStatusFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class EnumFeedbackStatusWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumFeedbackStatusWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i3.FeedbackStatus? equals;

  final _i1.PrismaUnion<Iterable<_i3.FeedbackStatus>, _i3.FeedbackStatus>? $in;

  final _i1.PrismaUnion<Iterable<_i3.FeedbackStatus>, _i3.FeedbackStatus>?
  notIn;

  final _i1.PrismaUnion<
    _i3.FeedbackStatus,
    _i2.NestedEnumFeedbackStatusWithAggregatesFilter
  >?
  not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedEnumFeedbackStatusFilter? $min;

  final _i2.NestedEnumFeedbackStatusFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class NestedDateTimeWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedDateTimeWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final DateTime? equals;

  final _i1.PrismaUnion<Iterable<DateTime>, DateTime>? $in;

  final _i1.PrismaUnion<Iterable<DateTime>, DateTime>? notIn;

  final DateTime? lt;

  final DateTime? lte;

  final DateTime? gt;

  final DateTime? gte;

  final _i1.PrismaUnion<DateTime, _i2.NestedDateTimeWithAggregatesFilter>? not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedDateTimeFilter? $min;

  final _i2.NestedDateTimeFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'lt': lt,
    'lte': lte,
    'gt': gt,
    'gte': gte,
    'not': not,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class DateTimeWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DateTimeWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final DateTime? equals;

  final _i1.PrismaUnion<Iterable<DateTime>, DateTime>? $in;

  final _i1.PrismaUnion<Iterable<DateTime>, DateTime>? notIn;

  final DateTime? lt;

  final DateTime? lte;

  final DateTime? gt;

  final DateTime? gte;

  final _i1.PrismaUnion<DateTime, _i2.NestedDateTimeWithAggregatesFilter>? not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedDateTimeFilter? $min;

  final _i2.NestedDateTimeFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'lt': lt,
    'lte': lte,
    'gt': gt,
    'gte': gte,
    'not': not,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class FeedbackScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FeedbackScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.title,
    this.description,
    this.rating,
    this.category,
    this.status,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
    _i2.FeedbackScalarWhereWithAggregatesInput,
    Iterable<_i2.FeedbackScalarWhereWithAggregatesInput>
  >?
  AND;

  final Iterable<_i2.FeedbackScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<
    _i2.FeedbackScalarWhereWithAggregatesInput,
    Iterable<_i2.FeedbackScalarWhereWithAggregatesInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? title;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? description;

  final _i1.PrismaUnion<
    _i2.IntNullableWithAggregatesFilter,
    _i1.PrismaUnion<int, _i1.PrismaNull>
  >?
  rating;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  category;

  final _i1.PrismaUnion<
    _i2.EnumFeedbackStatusWithAggregatesFilter,
    _i3.FeedbackStatus
  >?
  status;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? userId;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'title': title,
    'description': description,
    'rating': rating,
    'category': category,
    'status': status,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class FeedbackCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FeedbackCountAggregateOutputTypeSelect({
    this.id,
    this.title,
    this.description,
    this.rating,
    this.category,
    this.status,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  final bool? id;

  final bool? title;

  final bool? description;

  final bool? rating;

  final bool? category;

  final bool? status;

  final bool? userId;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'rating': rating,
    'category': category,
    'status': status,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class FeedbackGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FeedbackGroupByOutputTypeCountArgs({this.select});

  final _i2.FeedbackCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class FeedbackAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FeedbackAvgAggregateOutputTypeSelect({this.rating});

  final bool? rating;

  @override
  Map<String, dynamic> toJson() => {'rating': rating};
}

class FeedbackGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FeedbackGroupByOutputTypeAvgArgs({this.select});

  final _i2.FeedbackAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class FeedbackSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FeedbackSumAggregateOutputTypeSelect({this.rating});

  final bool? rating;

  @override
  Map<String, dynamic> toJson() => {'rating': rating};
}

class FeedbackGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FeedbackGroupByOutputTypeSumArgs({this.select});

  final _i2.FeedbackSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class FeedbackMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FeedbackMinAggregateOutputTypeSelect({
    this.id,
    this.title,
    this.description,
    this.rating,
    this.category,
    this.status,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? title;

  final bool? description;

  final bool? rating;

  final bool? category;

  final bool? status;

  final bool? userId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'rating': rating,
    'category': category,
    'status': status,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class FeedbackGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FeedbackGroupByOutputTypeMinArgs({this.select});

  final _i2.FeedbackMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class FeedbackMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FeedbackMaxAggregateOutputTypeSelect({
    this.id,
    this.title,
    this.description,
    this.rating,
    this.category,
    this.status,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? title;

  final bool? description;

  final bool? rating;

  final bool? category;

  final bool? status;

  final bool? userId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'rating': rating,
    'category': category,
    'status': status,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class FeedbackGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FeedbackGroupByOutputTypeMaxArgs({this.select});

  final _i2.FeedbackMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class FeedbackGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FeedbackGroupByOutputTypeSelect({
    this.id,
    this.title,
    this.description,
    this.rating,
    this.category,
    this.status,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? title;

  final bool? description;

  final bool? rating;

  final bool? category;

  final bool? status;

  final bool? userId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.FeedbackGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.FeedbackGroupByOutputTypeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.FeedbackGroupByOutputTypeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.FeedbackGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.FeedbackGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'rating': rating,
    'category': category,
    'status': status,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_avg': $avg,
    '_sum': $sum,
    '_min': $min,
    '_max': $max,
  };
}

class AggregateFeedback {
  const AggregateFeedback({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateFeedback.fromJson(Map json) => AggregateFeedback(
    $count: json['_count'] is Map
        ? _i2.FeedbackCountAggregateOutputType.fromJson(json['_count'])
        : null,
    $avg: json['_avg'] is Map
        ? _i2.FeedbackAvgAggregateOutputType.fromJson(json['_avg'])
        : null,
    $sum: json['_sum'] is Map
        ? _i2.FeedbackSumAggregateOutputType.fromJson(json['_sum'])
        : null,
    $min: json['_min'] is Map
        ? _i2.FeedbackMinAggregateOutputType.fromJson(json['_min'])
        : null,
    $max: json['_max'] is Map
        ? _i2.FeedbackMaxAggregateOutputType.fromJson(json['_max'])
        : null,
  );

  final _i2.FeedbackCountAggregateOutputType? $count;

  final _i2.FeedbackAvgAggregateOutputType? $avg;

  final _i2.FeedbackSumAggregateOutputType? $sum;

  final _i2.FeedbackMinAggregateOutputType? $min;

  final _i2.FeedbackMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    '_count': $count?.toJson(),
    '_avg': $avg?.toJson(),
    '_sum': $sum?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class AggregateFeedbackCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateFeedbackCountArgs({this.select});

  final _i2.FeedbackCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateFeedbackAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateFeedbackAvgArgs({this.select});

  final _i2.FeedbackAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateFeedbackSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateFeedbackSumArgs({this.select});

  final _i2.FeedbackSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateFeedbackMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateFeedbackMinArgs({this.select});

  final _i2.FeedbackMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateFeedbackMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateFeedbackMaxArgs({this.select});

  final _i2.FeedbackMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateFeedbackSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateFeedbackSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateFeedbackCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateFeedbackAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateFeedbackSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateFeedbackMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateFeedbackMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    '_count': $count,
    '_avg': $avg,
    '_sum': $sum,
    '_min': $min,
    '_max': $max,
  };
}

class SupportTicketCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportTicketCreateInput({
    this.id,
    required this.title,
    required this.description,
    this.priority,
    this.status,
    this.category,
    this.createdAt,
    this.updatedAt,
    required this.user,
    this.responses,
  });

  final String? id;

  final String title;

  final String description;

  final _i3.SupportPriority? priority;

  final _i3.SupportTicketStatus? status;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? category;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.UserCreateNestedOneWithoutSupportTicketsInput user;

  final _i2.SupportResponseCreateNestedManyWithoutSupportTicketInput? responses;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'priority': priority,
    'status': status,
    'category': category,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'user': user,
    'responses': responses,
  };
}

class SupportTicketUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportTicketUncheckedCreateInput({
    this.id,
    required this.title,
    required this.description,
    this.priority,
    this.status,
    this.category,
    required this.userId,
    this.createdAt,
    this.updatedAt,
    this.responses,
  });

  final String? id;

  final String title;

  final String description;

  final _i3.SupportPriority? priority;

  final _i3.SupportTicketStatus? status;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? category;

  final String userId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.SupportResponseUncheckedCreateNestedManyWithoutSupportTicketInput?
  responses;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'priority': priority,
    'status': status,
    'category': category,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'responses': responses,
  };
}

class SupportTicketCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportTicketCreateManyInput({
    this.id,
    required this.title,
    required this.description,
    this.priority,
    this.status,
    this.category,
    required this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final String title;

  final String description;

  final _i3.SupportPriority? priority;

  final _i3.SupportTicketStatus? status;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? category;

  final String userId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'priority': priority,
    'status': status,
    'category': category,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SupportTicketUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportTicketUpdateInput({
    this.id,
    this.title,
    this.description,
    this.priority,
    this.status,
    this.category,
    this.createdAt,
    this.updatedAt,
    this.user,
    this.responses,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  description;

  final _i1.PrismaUnion<
    _i3.SupportPriority,
    _i2.EnumSupportPriorityFieldUpdateOperationsInput
  >?
  priority;

  final _i1.PrismaUnion<
    _i3.SupportTicketStatus,
    _i2.EnumSupportTicketStatusFieldUpdateOperationsInput
  >?
  status;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  category;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.UserUpdateOneRequiredWithoutSupportTicketsNestedInput? user;

  final _i2.SupportResponseUpdateManyWithoutSupportTicketNestedInput? responses;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'priority': priority,
    'status': status,
    'category': category,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'user': user,
    'responses': responses,
  };
}

class SupportTicketUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportTicketUncheckedUpdateInput({
    this.id,
    this.title,
    this.description,
    this.priority,
    this.status,
    this.category,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.responses,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  description;

  final _i1.PrismaUnion<
    _i3.SupportPriority,
    _i2.EnumSupportPriorityFieldUpdateOperationsInput
  >?
  priority;

  final _i1.PrismaUnion<
    _i3.SupportTicketStatus,
    _i2.EnumSupportTicketStatusFieldUpdateOperationsInput
  >?
  status;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  category;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.SupportResponseUncheckedUpdateManyWithoutSupportTicketNestedInput?
  responses;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'priority': priority,
    'status': status,
    'category': category,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'responses': responses,
  };
}

class SupportTicketUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportTicketUncheckedUpdateManyInput({
    this.id,
    this.title,
    this.description,
    this.priority,
    this.status,
    this.category,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  description;

  final _i1.PrismaUnion<
    _i3.SupportPriority,
    _i2.EnumSupportPriorityFieldUpdateOperationsInput
  >?
  priority;

  final _i1.PrismaUnion<
    _i3.SupportTicketStatus,
    _i2.EnumSupportTicketStatusFieldUpdateOperationsInput
  >?
  status;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  category;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'priority': priority,
    'status': status,
    'category': category,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SupportTicketCountAggregateOutputType {
  const SupportTicketCountAggregateOutputType({
    this.id,
    this.title,
    this.description,
    this.priority,
    this.status,
    this.category,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  factory SupportTicketCountAggregateOutputType.fromJson(Map json) =>
      SupportTicketCountAggregateOutputType(
        id: json['id'],
        title: json['title'],
        description: json['description'],
        priority: json['priority'],
        status: json['status'],
        category: json['category'],
        userId: json['userId'],
        createdAt: json['createdAt'],
        updatedAt: json['updatedAt'],
        $all: json['_all'],
      );

  final int? id;

  final int? title;

  final int? description;

  final int? priority;

  final int? status;

  final int? category;

  final int? userId;

  final int? createdAt;

  final int? updatedAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'priority': priority,
    'status': status,
    'category': category,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class SupportTicketMinAggregateOutputType {
  const SupportTicketMinAggregateOutputType({
    this.id,
    this.title,
    this.description,
    this.priority,
    this.status,
    this.category,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  factory SupportTicketMinAggregateOutputType.fromJson(Map json) =>
      SupportTicketMinAggregateOutputType(
        id: json['id'],
        title: json['title'],
        description: json['description'],
        priority: json['priority'] != null
            ? _i3.SupportPriority.values.firstWhere(
                (e) => e.name == json['priority'],
              )
            : null,
        status: json['status'] != null
            ? _i3.SupportTicketStatus.values.firstWhere(
                (e) => e.name == json['status'],
              )
            : null,
        category: json['category'],
        userId: json['userId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final String? title;

  final String? description;

  final _i3.SupportPriority? priority;

  final _i3.SupportTicketStatus? status;

  final String? category;

  final String? userId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'priority': priority?.name,
    'status': status?.name,
    'category': category,
    'userId': userId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class SupportTicketMaxAggregateOutputType {
  const SupportTicketMaxAggregateOutputType({
    this.id,
    this.title,
    this.description,
    this.priority,
    this.status,
    this.category,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  factory SupportTicketMaxAggregateOutputType.fromJson(Map json) =>
      SupportTicketMaxAggregateOutputType(
        id: json['id'],
        title: json['title'],
        description: json['description'],
        priority: json['priority'] != null
            ? _i3.SupportPriority.values.firstWhere(
                (e) => e.name == json['priority'],
              )
            : null,
        status: json['status'] != null
            ? _i3.SupportTicketStatus.values.firstWhere(
                (e) => e.name == json['status'],
              )
            : null,
        category: json['category'],
        userId: json['userId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final String? title;

  final String? description;

  final _i3.SupportPriority? priority;

  final _i3.SupportTicketStatus? status;

  final String? category;

  final String? userId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'priority': priority?.name,
    'status': status?.name,
    'category': category,
    'userId': userId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class SupportTicketGroupByOutputType {
  const SupportTicketGroupByOutputType({
    this.id,
    this.title,
    this.description,
    this.priority,
    this.status,
    this.category,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$min,
    this.$max,
  });

  factory SupportTicketGroupByOutputType.fromJson(Map json) =>
      SupportTicketGroupByOutputType(
        id: json['id'],
        title: json['title'],
        description: json['description'],
        priority: json['priority'] != null
            ? _i3.SupportPriority.values.firstWhere(
                (e) => e.name == json['priority'],
              )
            : null,
        status: json['status'] != null
            ? _i3.SupportTicketStatus.values.firstWhere(
                (e) => e.name == json['status'],
              )
            : null,
        category: json['category'],
        userId: json['userId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
        $count: json['_count'] is Map
            ? _i2.SupportTicketCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.SupportTicketMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.SupportTicketMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? id;

  final String? title;

  final String? description;

  final _i3.SupportPriority? priority;

  final _i3.SupportTicketStatus? status;

  final String? category;

  final String? userId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.SupportTicketCountAggregateOutputType? $count;

  final _i2.SupportTicketMinAggregateOutputType? $min;

  final _i2.SupportTicketMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'priority': priority?.name,
    'status': status?.name,
    'category': category,
    'userId': userId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
    '_count': $count?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class SupportTicketCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportTicketCountOrderByAggregateInput({
    this.id,
    this.title,
    this.description,
    this.priority,
    this.status,
    this.category,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? title;

  final _i2.SortOrder? description;

  final _i2.SortOrder? priority;

  final _i2.SortOrder? status;

  final _i2.SortOrder? category;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'priority': priority,
    'status': status,
    'category': category,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SupportTicketMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportTicketMaxOrderByAggregateInput({
    this.id,
    this.title,
    this.description,
    this.priority,
    this.status,
    this.category,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? title;

  final _i2.SortOrder? description;

  final _i2.SortOrder? priority;

  final _i2.SortOrder? status;

  final _i2.SortOrder? category;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'priority': priority,
    'status': status,
    'category': category,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SupportTicketMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportTicketMinOrderByAggregateInput({
    this.id,
    this.title,
    this.description,
    this.priority,
    this.status,
    this.category,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? title;

  final _i2.SortOrder? description;

  final _i2.SortOrder? priority;

  final _i2.SortOrder? status;

  final _i2.SortOrder? category;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'priority': priority,
    'status': status,
    'category': category,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SupportTicketOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportTicketOrderByWithAggregationInput({
    this.id,
    this.title,
    this.description,
    this.priority,
    this.status,
    this.category,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$max,
    this.$min,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? title;

  final _i2.SortOrder? description;

  final _i2.SortOrder? priority;

  final _i2.SortOrder? status;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? category;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.SupportTicketCountOrderByAggregateInput? $count;

  final _i2.SupportTicketMaxOrderByAggregateInput? $max;

  final _i2.SupportTicketMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'priority': priority,
    'status': status,
    'category': category,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_max': $max,
    '_min': $min,
  };
}

class NestedEnumSupportPriorityWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedEnumSupportPriorityWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i3.SupportPriority? equals;

  final _i1.PrismaUnion<Iterable<_i3.SupportPriority>, _i3.SupportPriority>?
  $in;

  final _i1.PrismaUnion<Iterable<_i3.SupportPriority>, _i3.SupportPriority>?
  notIn;

  final _i1.PrismaUnion<
    _i3.SupportPriority,
    _i2.NestedEnumSupportPriorityWithAggregatesFilter
  >?
  not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedEnumSupportPriorityFilter? $min;

  final _i2.NestedEnumSupportPriorityFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class EnumSupportPriorityWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumSupportPriorityWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i3.SupportPriority? equals;

  final _i1.PrismaUnion<Iterable<_i3.SupportPriority>, _i3.SupportPriority>?
  $in;

  final _i1.PrismaUnion<Iterable<_i3.SupportPriority>, _i3.SupportPriority>?
  notIn;

  final _i1.PrismaUnion<
    _i3.SupportPriority,
    _i2.NestedEnumSupportPriorityWithAggregatesFilter
  >?
  not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedEnumSupportPriorityFilter? $min;

  final _i2.NestedEnumSupportPriorityFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class NestedEnumSupportTicketStatusWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedEnumSupportTicketStatusWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i3.SupportTicketStatus? equals;

  final _i1.PrismaUnion<
    Iterable<_i3.SupportTicketStatus>,
    _i3.SupportTicketStatus
  >?
  $in;

  final _i1.PrismaUnion<
    Iterable<_i3.SupportTicketStatus>,
    _i3.SupportTicketStatus
  >?
  notIn;

  final _i1.PrismaUnion<
    _i3.SupportTicketStatus,
    _i2.NestedEnumSupportTicketStatusWithAggregatesFilter
  >?
  not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedEnumSupportTicketStatusFilter? $min;

  final _i2.NestedEnumSupportTicketStatusFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class EnumSupportTicketStatusWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumSupportTicketStatusWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i3.SupportTicketStatus? equals;

  final _i1.PrismaUnion<
    Iterable<_i3.SupportTicketStatus>,
    _i3.SupportTicketStatus
  >?
  $in;

  final _i1.PrismaUnion<
    Iterable<_i3.SupportTicketStatus>,
    _i3.SupportTicketStatus
  >?
  notIn;

  final _i1.PrismaUnion<
    _i3.SupportTicketStatus,
    _i2.NestedEnumSupportTicketStatusWithAggregatesFilter
  >?
  not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedEnumSupportTicketStatusFilter? $min;

  final _i2.NestedEnumSupportTicketStatusFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class SupportTicketScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportTicketScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.title,
    this.description,
    this.priority,
    this.status,
    this.category,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
    _i2.SupportTicketScalarWhereWithAggregatesInput,
    Iterable<_i2.SupportTicketScalarWhereWithAggregatesInput>
  >?
  AND;

  final Iterable<_i2.SupportTicketScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<
    _i2.SupportTicketScalarWhereWithAggregatesInput,
    Iterable<_i2.SupportTicketScalarWhereWithAggregatesInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? title;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? description;

  final _i1.PrismaUnion<
    _i2.EnumSupportPriorityWithAggregatesFilter,
    _i3.SupportPriority
  >?
  priority;

  final _i1.PrismaUnion<
    _i2.EnumSupportTicketStatusWithAggregatesFilter,
    _i3.SupportTicketStatus
  >?
  status;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  category;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? userId;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'title': title,
    'description': description,
    'priority': priority,
    'status': status,
    'category': category,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SupportTicketCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportTicketCountAggregateOutputTypeSelect({
    this.id,
    this.title,
    this.description,
    this.priority,
    this.status,
    this.category,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  final bool? id;

  final bool? title;

  final bool? description;

  final bool? priority;

  final bool? status;

  final bool? category;

  final bool? userId;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'priority': priority,
    'status': status,
    'category': category,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class SupportTicketGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportTicketGroupByOutputTypeCountArgs({this.select});

  final _i2.SupportTicketCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SupportTicketMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportTicketMinAggregateOutputTypeSelect({
    this.id,
    this.title,
    this.description,
    this.priority,
    this.status,
    this.category,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? title;

  final bool? description;

  final bool? priority;

  final bool? status;

  final bool? category;

  final bool? userId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'priority': priority,
    'status': status,
    'category': category,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SupportTicketGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportTicketGroupByOutputTypeMinArgs({this.select});

  final _i2.SupportTicketMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SupportTicketMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportTicketMaxAggregateOutputTypeSelect({
    this.id,
    this.title,
    this.description,
    this.priority,
    this.status,
    this.category,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? title;

  final bool? description;

  final bool? priority;

  final bool? status;

  final bool? category;

  final bool? userId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'priority': priority,
    'status': status,
    'category': category,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SupportTicketGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportTicketGroupByOutputTypeMaxArgs({this.select});

  final _i2.SupportTicketMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SupportTicketGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportTicketGroupByOutputTypeSelect({
    this.id,
    this.title,
    this.description,
    this.priority,
    this.status,
    this.category,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? title;

  final bool? description;

  final bool? priority;

  final bool? status;

  final bool? category;

  final bool? userId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.SupportTicketGroupByOutputTypeCountArgs>?
  $count;

  final _i1.PrismaUnion<bool, _i2.SupportTicketGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.SupportTicketGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'priority': priority,
    'status': status,
    'category': category,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class AggregateSupportTicket {
  const AggregateSupportTicket({this.$count, this.$min, this.$max});

  factory AggregateSupportTicket.fromJson(Map json) => AggregateSupportTicket(
    $count: json['_count'] is Map
        ? _i2.SupportTicketCountAggregateOutputType.fromJson(json['_count'])
        : null,
    $min: json['_min'] is Map
        ? _i2.SupportTicketMinAggregateOutputType.fromJson(json['_min'])
        : null,
    $max: json['_max'] is Map
        ? _i2.SupportTicketMaxAggregateOutputType.fromJson(json['_max'])
        : null,
  );

  final _i2.SupportTicketCountAggregateOutputType? $count;

  final _i2.SupportTicketMinAggregateOutputType? $min;

  final _i2.SupportTicketMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    '_count': $count?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class AggregateSupportTicketCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSupportTicketCountArgs({this.select});

  final _i2.SupportTicketCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateSupportTicketMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSupportTicketMinArgs({this.select});

  final _i2.SupportTicketMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateSupportTicketMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSupportTicketMaxArgs({this.select});

  final _i2.SupportTicketMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateSupportTicketSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSupportTicketSelect({this.$count, this.$min, this.$max});

  final _i1.PrismaUnion<bool, _i2.AggregateSupportTicketCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateSupportTicketMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateSupportTicketMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class SupportResponseCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseCreateInput({
    this.id,
    required this.message,
    this.createdAt,
    this.updatedAt,
    required this.supportTicket,
    required this.user,
  });

  final String? id;

  final String message;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.SupportTicketCreateNestedOneWithoutResponsesInput supportTicket;

  final _i2.UserCreateNestedOneWithoutSupportResponsesInput user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'message': message,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'supportTicket': supportTicket,
    'user': user,
  };
}

class SupportResponseUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseUncheckedCreateInput({
    this.id,
    required this.message,
    required this.supportTicketId,
    required this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final String message;

  final String supportTicketId;

  final String userId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'message': message,
    'supportTicketId': supportTicketId,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SupportResponseCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseCreateManyInput({
    this.id,
    required this.message,
    required this.supportTicketId,
    required this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final String message;

  final String supportTicketId;

  final String userId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'message': message,
    'supportTicketId': supportTicketId,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SupportResponseUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseUpdateInput({
    this.id,
    this.message,
    this.createdAt,
    this.updatedAt,
    this.supportTicket,
    this.user,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? message;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.SupportTicketUpdateOneRequiredWithoutResponsesNestedInput?
  supportTicket;

  final _i2.UserUpdateOneRequiredWithoutSupportResponsesNestedInput? user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'message': message,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'supportTicket': supportTicket,
    'user': user,
  };
}

class SupportResponseUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseUncheckedUpdateInput({
    this.id,
    this.message,
    this.supportTicketId,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? message;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  supportTicketId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'message': message,
    'supportTicketId': supportTicketId,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SupportResponseUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseUncheckedUpdateManyInput({
    this.id,
    this.message,
    this.supportTicketId,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? message;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  supportTicketId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'message': message,
    'supportTicketId': supportTicketId,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SupportResponseCountAggregateOutputType {
  const SupportResponseCountAggregateOutputType({
    this.id,
    this.message,
    this.supportTicketId,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  factory SupportResponseCountAggregateOutputType.fromJson(Map json) =>
      SupportResponseCountAggregateOutputType(
        id: json['id'],
        message: json['message'],
        supportTicketId: json['supportTicketId'],
        userId: json['userId'],
        createdAt: json['createdAt'],
        updatedAt: json['updatedAt'],
        $all: json['_all'],
      );

  final int? id;

  final int? message;

  final int? supportTicketId;

  final int? userId;

  final int? createdAt;

  final int? updatedAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
    'id': id,
    'message': message,
    'supportTicketId': supportTicketId,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class SupportResponseMinAggregateOutputType {
  const SupportResponseMinAggregateOutputType({
    this.id,
    this.message,
    this.supportTicketId,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  factory SupportResponseMinAggregateOutputType.fromJson(Map json) =>
      SupportResponseMinAggregateOutputType(
        id: json['id'],
        message: json['message'],
        supportTicketId: json['supportTicketId'],
        userId: json['userId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final String? message;

  final String? supportTicketId;

  final String? userId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'message': message,
    'supportTicketId': supportTicketId,
    'userId': userId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class SupportResponseMaxAggregateOutputType {
  const SupportResponseMaxAggregateOutputType({
    this.id,
    this.message,
    this.supportTicketId,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  factory SupportResponseMaxAggregateOutputType.fromJson(Map json) =>
      SupportResponseMaxAggregateOutputType(
        id: json['id'],
        message: json['message'],
        supportTicketId: json['supportTicketId'],
        userId: json['userId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final String? message;

  final String? supportTicketId;

  final String? userId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'message': message,
    'supportTicketId': supportTicketId,
    'userId': userId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class SupportResponseGroupByOutputType {
  const SupportResponseGroupByOutputType({
    this.id,
    this.message,
    this.supportTicketId,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$min,
    this.$max,
  });

  factory SupportResponseGroupByOutputType.fromJson(Map json) =>
      SupportResponseGroupByOutputType(
        id: json['id'],
        message: json['message'],
        supportTicketId: json['supportTicketId'],
        userId: json['userId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
        $count: json['_count'] is Map
            ? _i2.SupportResponseCountAggregateOutputType.fromJson(
                json['_count'],
              )
            : null,
        $min: json['_min'] is Map
            ? _i2.SupportResponseMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.SupportResponseMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? id;

  final String? message;

  final String? supportTicketId;

  final String? userId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.SupportResponseCountAggregateOutputType? $count;

  final _i2.SupportResponseMinAggregateOutputType? $min;

  final _i2.SupportResponseMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    'id': id,
    'message': message,
    'supportTicketId': supportTicketId,
    'userId': userId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
    '_count': $count?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class SupportResponseCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseCountOrderByAggregateInput({
    this.id,
    this.message,
    this.supportTicketId,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? message;

  final _i2.SortOrder? supportTicketId;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'message': message,
    'supportTicketId': supportTicketId,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SupportResponseMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseMaxOrderByAggregateInput({
    this.id,
    this.message,
    this.supportTicketId,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? message;

  final _i2.SortOrder? supportTicketId;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'message': message,
    'supportTicketId': supportTicketId,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SupportResponseMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseMinOrderByAggregateInput({
    this.id,
    this.message,
    this.supportTicketId,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? message;

  final _i2.SortOrder? supportTicketId;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'message': message,
    'supportTicketId': supportTicketId,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SupportResponseOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseOrderByWithAggregationInput({
    this.id,
    this.message,
    this.supportTicketId,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$max,
    this.$min,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? message;

  final _i2.SortOrder? supportTicketId;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.SupportResponseCountOrderByAggregateInput? $count;

  final _i2.SupportResponseMaxOrderByAggregateInput? $max;

  final _i2.SupportResponseMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'message': message,
    'supportTicketId': supportTicketId,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_max': $max,
    '_min': $min,
  };
}

class SupportResponseScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.message,
    this.supportTicketId,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
    _i2.SupportResponseScalarWhereWithAggregatesInput,
    Iterable<_i2.SupportResponseScalarWhereWithAggregatesInput>
  >?
  AND;

  final Iterable<_i2.SupportResponseScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<
    _i2.SupportResponseScalarWhereWithAggregatesInput,
    Iterable<_i2.SupportResponseScalarWhereWithAggregatesInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? message;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>?
  supportTicketId;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? userId;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'message': message,
    'supportTicketId': supportTicketId,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SupportResponseCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseCountAggregateOutputTypeSelect({
    this.id,
    this.message,
    this.supportTicketId,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  final bool? id;

  final bool? message;

  final bool? supportTicketId;

  final bool? userId;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'message': message,
    'supportTicketId': supportTicketId,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class SupportResponseGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseGroupByOutputTypeCountArgs({this.select});

  final _i2.SupportResponseCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SupportResponseMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseMinAggregateOutputTypeSelect({
    this.id,
    this.message,
    this.supportTicketId,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? message;

  final bool? supportTicketId;

  final bool? userId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'message': message,
    'supportTicketId': supportTicketId,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SupportResponseGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseGroupByOutputTypeMinArgs({this.select});

  final _i2.SupportResponseMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SupportResponseMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseMaxAggregateOutputTypeSelect({
    this.id,
    this.message,
    this.supportTicketId,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? message;

  final bool? supportTicketId;

  final bool? userId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'message': message,
    'supportTicketId': supportTicketId,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SupportResponseGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseGroupByOutputTypeMaxArgs({this.select});

  final _i2.SupportResponseMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SupportResponseGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SupportResponseGroupByOutputTypeSelect({
    this.id,
    this.message,
    this.supportTicketId,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? message;

  final bool? supportTicketId;

  final bool? userId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.SupportResponseGroupByOutputTypeCountArgs>?
  $count;

  final _i1.PrismaUnion<bool, _i2.SupportResponseGroupByOutputTypeMinArgs>?
  $min;

  final _i1.PrismaUnion<bool, _i2.SupportResponseGroupByOutputTypeMaxArgs>?
  $max;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'message': message,
    'supportTicketId': supportTicketId,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class AggregateSupportResponse {
  const AggregateSupportResponse({this.$count, this.$min, this.$max});

  factory AggregateSupportResponse.fromJson(Map json) =>
      AggregateSupportResponse(
        $count: json['_count'] is Map
            ? _i2.SupportResponseCountAggregateOutputType.fromJson(
                json['_count'],
              )
            : null,
        $min: json['_min'] is Map
            ? _i2.SupportResponseMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.SupportResponseMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.SupportResponseCountAggregateOutputType? $count;

  final _i2.SupportResponseMinAggregateOutputType? $min;

  final _i2.SupportResponseMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    '_count': $count?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class AggregateSupportResponseCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSupportResponseCountArgs({this.select});

  final _i2.SupportResponseCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateSupportResponseMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSupportResponseMinArgs({this.select});

  final _i2.SupportResponseMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateSupportResponseMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSupportResponseMaxArgs({this.select});

  final _i2.SupportResponseMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateSupportResponseSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSupportResponseSelect({this.$count, this.$min, this.$max});

  final _i1.PrismaUnion<bool, _i2.AggregateSupportResponseCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateSupportResponseMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateSupportResponseMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

enum CookiePreferenceScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<String>('id', 'CookiePreference'),
  userId<String>('userId', 'CookiePreference'),
  essential<bool>('essential', 'CookiePreference'),
  analytics<bool>('analytics', 'CookiePreference'),
  marketing<bool>('marketing', 'CookiePreference');

  const CookiePreferenceScalar(this.name, this.model);

  @override
  final String name;

  @override
  final String model;
}

class UserCreateWithoutCookiePreferencesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateWithoutCookiePreferencesInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.notificationPreferences,
    this.payment,
    this.consultantProfile,
    this.consulteeProfile,
    this.staffProfile,
    this.slotsOfAppointment,
    this.waitlist,
    this.feedbacks,
    this.supportTickets,
    this.supportResponses,
    this.accounts,
    this.sessions,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? email;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? emailVerified;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? image;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? address;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? password;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? passwordResetToken;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? passwordResetExpires;

  final bool? onlineStatus;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? currentTimezone;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? onboardingCompleted;

  final _i1.PrismaUnion<_i3.UserRole, _i1.PrismaNull>? role;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consultantProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consulteeProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? staffProfileId;

  final _i2.NotificationPreferenceCreateNestedOneWithoutUserInput?
  notificationPreferences;

  final _i2.PaymentCreateNestedManyWithoutUserInput? payment;

  final _i2.ConsultantProfileCreateNestedOneWithoutUserInput? consultantProfile;

  final _i2.ConsulteeProfileCreateNestedOneWithoutUserInput? consulteeProfile;

  final _i2.StaffProfileCreateNestedOneWithoutUserInput? staffProfile;

  final _i2.SlotOfAppointmentCreateNestedManyWithoutUserInput?
  slotsOfAppointment;

  final _i2.WaitlistCreateNestedManyWithoutUserInput? waitlist;

  final _i2.FeedbackCreateNestedManyWithoutUserInput? feedbacks;

  final _i2.SupportTicketCreateNestedManyWithoutUserInput? supportTickets;

  final _i2.SupportResponseCreateNestedManyWithoutUserInput? supportResponses;

  final _i2.AccountCreateNestedManyWithoutUserInput? accounts;

  final _i2.SessionCreateNestedManyWithoutUserInput? sessions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'notificationPreferences': notificationPreferences,
    'Payment': payment,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
    'staffProfile': staffProfile,
    'slotsOfAppointment': slotsOfAppointment,
    'Waitlist': waitlist,
    'feedbacks': feedbacks,
    'supportTickets': supportTickets,
    'supportResponses': supportResponses,
    'accounts': accounts,
    'sessions': sessions,
  };
}

class UserUncheckedCreateWithoutCookiePreferencesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUncheckedCreateWithoutCookiePreferencesInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.notificationPreferences,
    this.payment,
    this.consultantProfile,
    this.consulteeProfile,
    this.staffProfile,
    this.slotsOfAppointment,
    this.waitlist,
    this.feedbacks,
    this.supportTickets,
    this.supportResponses,
    this.accounts,
    this.sessions,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? email;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? emailVerified;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? image;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? address;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? password;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? passwordResetToken;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? passwordResetExpires;

  final bool? onlineStatus;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? currentTimezone;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? onboardingCompleted;

  final _i1.PrismaUnion<_i3.UserRole, _i1.PrismaNull>? role;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consultantProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consulteeProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? staffProfileId;

  final _i2.NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput?
  notificationPreferences;

  final _i2.PaymentUncheckedCreateNestedManyWithoutUserInput? payment;

  final _i2.ConsultantProfileUncheckedCreateNestedOneWithoutUserInput?
  consultantProfile;

  final _i2.ConsulteeProfileUncheckedCreateNestedOneWithoutUserInput?
  consulteeProfile;

  final _i2.StaffProfileUncheckedCreateNestedOneWithoutUserInput? staffProfile;

  final _i2.SlotOfAppointmentUncheckedCreateNestedManyWithoutUserInput?
  slotsOfAppointment;

  final _i2.WaitlistUncheckedCreateNestedManyWithoutUserInput? waitlist;

  final _i2.FeedbackUncheckedCreateNestedManyWithoutUserInput? feedbacks;

  final _i2.SupportTicketUncheckedCreateNestedManyWithoutUserInput?
  supportTickets;

  final _i2.SupportResponseUncheckedCreateNestedManyWithoutUserInput?
  supportResponses;

  final _i2.AccountUncheckedCreateNestedManyWithoutUserInput? accounts;

  final _i2.SessionUncheckedCreateNestedManyWithoutUserInput? sessions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'notificationPreferences': notificationPreferences,
    'Payment': payment,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
    'staffProfile': staffProfile,
    'slotsOfAppointment': slotsOfAppointment,
    'Waitlist': waitlist,
    'feedbacks': feedbacks,
    'supportTickets': supportTickets,
    'supportResponses': supportResponses,
    'accounts': accounts,
    'sessions': sessions,
  };
}

class UserCreateOrConnectWithoutCookiePreferencesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateOrConnectWithoutCookiePreferencesInput({
    required this.where,
    required this.create,
  });

  final _i2.UserWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.UserCreateWithoutCookiePreferencesInput,
    _i2.UserUncheckedCreateWithoutCookiePreferencesInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class UserCreateNestedOneWithoutCookiePreferencesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateNestedOneWithoutCookiePreferencesInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.UserCreateWithoutCookiePreferencesInput,
    _i2.UserUncheckedCreateWithoutCookiePreferencesInput
  >?
  create;

  final _i2.UserCreateOrConnectWithoutCookiePreferencesInput? connectOrCreate;

  final _i2.UserWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class CookiePreferenceCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CookiePreferenceCreateInput({
    this.id,
    this.essential,
    this.analytics,
    this.marketing,
    required this.user,
  });

  final String? id;

  final bool? essential;

  final bool? analytics;

  final bool? marketing;

  final _i2.UserCreateNestedOneWithoutCookiePreferencesInput user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'essential': essential,
    'analytics': analytics,
    'marketing': marketing,
    'user': user,
  };
}

class CookiePreferenceUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CookiePreferenceUncheckedCreateInput({
    this.id,
    required this.userId,
    this.essential,
    this.analytics,
    this.marketing,
  });

  final String? id;

  final String userId;

  final bool? essential;

  final bool? analytics;

  final bool? marketing;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'essential': essential,
    'analytics': analytics,
    'marketing': marketing,
  };
}

class CookiePreferenceCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CookiePreferenceCreateManyInput({
    this.id,
    required this.userId,
    this.essential,
    this.analytics,
    this.marketing,
  });

  final String? id;

  final String userId;

  final bool? essential;

  final bool? analytics;

  final bool? marketing;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'essential': essential,
    'analytics': analytics,
    'marketing': marketing,
  };
}

class UserUpdateWithoutCookiePreferencesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpdateWithoutCookiePreferencesInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.notificationPreferences,
    this.payment,
    this.consultantProfile,
    this.consulteeProfile,
    this.staffProfile,
    this.slotsOfAppointment,
    this.waitlist,
    this.feedbacks,
    this.supportTickets,
    this.supportResponses,
    this.accounts,
    this.sessions,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  name;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  email;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  emailVerified;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  image;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  phone;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  address;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  password;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetToken;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetExpires;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? onlineStatus;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  currentTimezone;

  final _i1.PrismaUnion<
    bool,
    _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  onboardingCompleted;

  final _i1.PrismaUnion<
    _i3.UserRole,
    _i1.PrismaUnion<
      _i2.NullableEnumUserRoleFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  role;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consultantProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consulteeProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  staffProfileId;

  final _i2.NotificationPreferenceUpdateOneWithoutUserNestedInput?
  notificationPreferences;

  final _i2.PaymentUpdateManyWithoutUserNestedInput? payment;

  final _i2.ConsultantProfileUpdateOneWithoutUserNestedInput? consultantProfile;

  final _i2.ConsulteeProfileUpdateOneWithoutUserNestedInput? consulteeProfile;

  final _i2.StaffProfileUpdateOneWithoutUserNestedInput? staffProfile;

  final _i2.SlotOfAppointmentUpdateManyWithoutUserNestedInput?
  slotsOfAppointment;

  final _i2.WaitlistUpdateManyWithoutUserNestedInput? waitlist;

  final _i2.FeedbackUpdateManyWithoutUserNestedInput? feedbacks;

  final _i2.SupportTicketUpdateManyWithoutUserNestedInput? supportTickets;

  final _i2.SupportResponseUpdateManyWithoutUserNestedInput? supportResponses;

  final _i2.AccountUpdateManyWithoutUserNestedInput? accounts;

  final _i2.SessionUpdateManyWithoutUserNestedInput? sessions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'notificationPreferences': notificationPreferences,
    'Payment': payment,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
    'staffProfile': staffProfile,
    'slotsOfAppointment': slotsOfAppointment,
    'Waitlist': waitlist,
    'feedbacks': feedbacks,
    'supportTickets': supportTickets,
    'supportResponses': supportResponses,
    'accounts': accounts,
    'sessions': sessions,
  };
}

class UserUncheckedUpdateWithoutCookiePreferencesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUncheckedUpdateWithoutCookiePreferencesInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.notificationPreferences,
    this.payment,
    this.consultantProfile,
    this.consulteeProfile,
    this.staffProfile,
    this.slotsOfAppointment,
    this.waitlist,
    this.feedbacks,
    this.supportTickets,
    this.supportResponses,
    this.accounts,
    this.sessions,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  name;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  email;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  emailVerified;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  image;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  phone;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  address;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  password;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetToken;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetExpires;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? onlineStatus;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  currentTimezone;

  final _i1.PrismaUnion<
    bool,
    _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  onboardingCompleted;

  final _i1.PrismaUnion<
    _i3.UserRole,
    _i1.PrismaUnion<
      _i2.NullableEnumUserRoleFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  role;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consultantProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consulteeProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  staffProfileId;

  final _i2.NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput?
  notificationPreferences;

  final _i2.PaymentUncheckedUpdateManyWithoutUserNestedInput? payment;

  final _i2.ConsultantProfileUncheckedUpdateOneWithoutUserNestedInput?
  consultantProfile;

  final _i2.ConsulteeProfileUncheckedUpdateOneWithoutUserNestedInput?
  consulteeProfile;

  final _i2.StaffProfileUncheckedUpdateOneWithoutUserNestedInput? staffProfile;

  final _i2.SlotOfAppointmentUncheckedUpdateManyWithoutUserNestedInput?
  slotsOfAppointment;

  final _i2.WaitlistUncheckedUpdateManyWithoutUserNestedInput? waitlist;

  final _i2.FeedbackUncheckedUpdateManyWithoutUserNestedInput? feedbacks;

  final _i2.SupportTicketUncheckedUpdateManyWithoutUserNestedInput?
  supportTickets;

  final _i2.SupportResponseUncheckedUpdateManyWithoutUserNestedInput?
  supportResponses;

  final _i2.AccountUncheckedUpdateManyWithoutUserNestedInput? accounts;

  final _i2.SessionUncheckedUpdateManyWithoutUserNestedInput? sessions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'notificationPreferences': notificationPreferences,
    'Payment': payment,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
    'staffProfile': staffProfile,
    'slotsOfAppointment': slotsOfAppointment,
    'Waitlist': waitlist,
    'feedbacks': feedbacks,
    'supportTickets': supportTickets,
    'supportResponses': supportResponses,
    'accounts': accounts,
    'sessions': sessions,
  };
}

class UserUpsertWithoutCookiePreferencesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpsertWithoutCookiePreferencesInput({
    required this.update,
    required this.create,
  });

  final _i1.PrismaUnion<
    _i2.UserUpdateWithoutCookiePreferencesInput,
    _i2.UserUncheckedUpdateWithoutCookiePreferencesInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.UserCreateWithoutCookiePreferencesInput,
    _i2.UserUncheckedCreateWithoutCookiePreferencesInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'update': update, 'create': create};
}

class UserUpdateOneRequiredWithoutCookiePreferencesNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpdateOneRequiredWithoutCookiePreferencesNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.UserCreateWithoutCookiePreferencesInput,
    _i2.UserUncheckedCreateWithoutCookiePreferencesInput
  >?
  create;

  final _i2.UserCreateOrConnectWithoutCookiePreferencesInput? connectOrCreate;

  final _i2.UserUpsertWithoutCookiePreferencesInput? upsert;

  final _i2.UserWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.UserUpdateWithoutCookiePreferencesInput,
    _i2.UserUncheckedUpdateWithoutCookiePreferencesInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'connect': connect,
    'update': update,
  };
}

class CookiePreferenceUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CookiePreferenceUpdateInput({
    this.id,
    this.essential,
    this.analytics,
    this.marketing,
    this.user,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? essential;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? analytics;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? marketing;

  final _i2.UserUpdateOneRequiredWithoutCookiePreferencesNestedInput? user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'essential': essential,
    'analytics': analytics,
    'marketing': marketing,
    'user': user,
  };
}

class CookiePreferenceUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CookiePreferenceUncheckedUpdateInput({
    this.id,
    this.userId,
    this.essential,
    this.analytics,
    this.marketing,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? essential;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? analytics;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? marketing;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'essential': essential,
    'analytics': analytics,
    'marketing': marketing,
  };
}

class CookiePreferenceUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CookiePreferenceUpdateManyMutationInput({
    this.id,
    this.essential,
    this.analytics,
    this.marketing,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? essential;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? analytics;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? marketing;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'essential': essential,
    'analytics': analytics,
    'marketing': marketing,
  };
}

class CookiePreferenceUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CookiePreferenceUncheckedUpdateManyInput({
    this.id,
    this.userId,
    this.essential,
    this.analytics,
    this.marketing,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? essential;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? analytics;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? marketing;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'essential': essential,
    'analytics': analytics,
    'marketing': marketing,
  };
}

class CookiePreferenceCountAggregateOutputType {
  const CookiePreferenceCountAggregateOutputType({
    this.id,
    this.userId,
    this.essential,
    this.analytics,
    this.marketing,
    this.$all,
  });

  factory CookiePreferenceCountAggregateOutputType.fromJson(Map json) =>
      CookiePreferenceCountAggregateOutputType(
        id: json['id'],
        userId: json['userId'],
        essential: json['essential'],
        analytics: json['analytics'],
        marketing: json['marketing'],
        $all: json['_all'],
      );

  final int? id;

  final int? userId;

  final int? essential;

  final int? analytics;

  final int? marketing;

  final int? $all;

  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'essential': essential,
    'analytics': analytics,
    'marketing': marketing,
    '_all': $all,
  };
}

class CookiePreferenceMinAggregateOutputType {
  const CookiePreferenceMinAggregateOutputType({
    this.id,
    this.userId,
    this.essential,
    this.analytics,
    this.marketing,
  });

  factory CookiePreferenceMinAggregateOutputType.fromJson(Map json) =>
      CookiePreferenceMinAggregateOutputType(
        id: json['id'],
        userId: json['userId'],
        essential: json['essential'],
        analytics: json['analytics'],
        marketing: json['marketing'],
      );

  final String? id;

  final String? userId;

  final bool? essential;

  final bool? analytics;

  final bool? marketing;

  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'essential': essential,
    'analytics': analytics,
    'marketing': marketing,
  };
}

class CookiePreferenceMaxAggregateOutputType {
  const CookiePreferenceMaxAggregateOutputType({
    this.id,
    this.userId,
    this.essential,
    this.analytics,
    this.marketing,
  });

  factory CookiePreferenceMaxAggregateOutputType.fromJson(Map json) =>
      CookiePreferenceMaxAggregateOutputType(
        id: json['id'],
        userId: json['userId'],
        essential: json['essential'],
        analytics: json['analytics'],
        marketing: json['marketing'],
      );

  final String? id;

  final String? userId;

  final bool? essential;

  final bool? analytics;

  final bool? marketing;

  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'essential': essential,
    'analytics': analytics,
    'marketing': marketing,
  };
}

class CookiePreferenceGroupByOutputType {
  const CookiePreferenceGroupByOutputType({
    this.id,
    this.userId,
    this.essential,
    this.analytics,
    this.marketing,
    this.$count,
    this.$min,
    this.$max,
  });

  factory CookiePreferenceGroupByOutputType.fromJson(Map json) =>
      CookiePreferenceGroupByOutputType(
        id: json['id'],
        userId: json['userId'],
        essential: json['essential'],
        analytics: json['analytics'],
        marketing: json['marketing'],
        $count: json['_count'] is Map
            ? _i2.CookiePreferenceCountAggregateOutputType.fromJson(
                json['_count'],
              )
            : null,
        $min: json['_min'] is Map
            ? _i2.CookiePreferenceMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.CookiePreferenceMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? id;

  final String? userId;

  final bool? essential;

  final bool? analytics;

  final bool? marketing;

  final _i2.CookiePreferenceCountAggregateOutputType? $count;

  final _i2.CookiePreferenceMinAggregateOutputType? $min;

  final _i2.CookiePreferenceMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'essential': essential,
    'analytics': analytics,
    'marketing': marketing,
    '_count': $count?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class CookiePreferenceCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CookiePreferenceCountOrderByAggregateInput({
    this.id,
    this.userId,
    this.essential,
    this.analytics,
    this.marketing,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? essential;

  final _i2.SortOrder? analytics;

  final _i2.SortOrder? marketing;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'essential': essential,
    'analytics': analytics,
    'marketing': marketing,
  };
}

class CookiePreferenceMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CookiePreferenceMaxOrderByAggregateInput({
    this.id,
    this.userId,
    this.essential,
    this.analytics,
    this.marketing,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? essential;

  final _i2.SortOrder? analytics;

  final _i2.SortOrder? marketing;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'essential': essential,
    'analytics': analytics,
    'marketing': marketing,
  };
}

class CookiePreferenceMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CookiePreferenceMinOrderByAggregateInput({
    this.id,
    this.userId,
    this.essential,
    this.analytics,
    this.marketing,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? essential;

  final _i2.SortOrder? analytics;

  final _i2.SortOrder? marketing;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'essential': essential,
    'analytics': analytics,
    'marketing': marketing,
  };
}

class CookiePreferenceOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CookiePreferenceOrderByWithAggregationInput({
    this.id,
    this.userId,
    this.essential,
    this.analytics,
    this.marketing,
    this.$count,
    this.$max,
    this.$min,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? essential;

  final _i2.SortOrder? analytics;

  final _i2.SortOrder? marketing;

  final _i2.CookiePreferenceCountOrderByAggregateInput? $count;

  final _i2.CookiePreferenceMaxOrderByAggregateInput? $max;

  final _i2.CookiePreferenceMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'essential': essential,
    'analytics': analytics,
    'marketing': marketing,
    '_count': $count,
    '_max': $max,
    '_min': $min,
  };
}

class CookiePreferenceScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CookiePreferenceScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.userId,
    this.essential,
    this.analytics,
    this.marketing,
  });

  final _i1.PrismaUnion<
    _i2.CookiePreferenceScalarWhereWithAggregatesInput,
    Iterable<_i2.CookiePreferenceScalarWhereWithAggregatesInput>
  >?
  AND;

  final Iterable<_i2.CookiePreferenceScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<
    _i2.CookiePreferenceScalarWhereWithAggregatesInput,
    Iterable<_i2.CookiePreferenceScalarWhereWithAggregatesInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? userId;

  final _i1.PrismaUnion<_i2.BoolWithAggregatesFilter, bool>? essential;

  final _i1.PrismaUnion<_i2.BoolWithAggregatesFilter, bool>? analytics;

  final _i1.PrismaUnion<_i2.BoolWithAggregatesFilter, bool>? marketing;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'userId': userId,
    'essential': essential,
    'analytics': analytics,
    'marketing': marketing,
  };
}

class CookiePreferenceCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CookiePreferenceCountAggregateOutputTypeSelect({
    this.id,
    this.userId,
    this.essential,
    this.analytics,
    this.marketing,
    this.$all,
  });

  final bool? id;

  final bool? userId;

  final bool? essential;

  final bool? analytics;

  final bool? marketing;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'essential': essential,
    'analytics': analytics,
    'marketing': marketing,
    '_all': $all,
  };
}

class CookiePreferenceGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CookiePreferenceGroupByOutputTypeCountArgs({this.select});

  final _i2.CookiePreferenceCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class CookiePreferenceMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CookiePreferenceMinAggregateOutputTypeSelect({
    this.id,
    this.userId,
    this.essential,
    this.analytics,
    this.marketing,
  });

  final bool? id;

  final bool? userId;

  final bool? essential;

  final bool? analytics;

  final bool? marketing;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'essential': essential,
    'analytics': analytics,
    'marketing': marketing,
  };
}

class CookiePreferenceGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CookiePreferenceGroupByOutputTypeMinArgs({this.select});

  final _i2.CookiePreferenceMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class CookiePreferenceMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CookiePreferenceMaxAggregateOutputTypeSelect({
    this.id,
    this.userId,
    this.essential,
    this.analytics,
    this.marketing,
  });

  final bool? id;

  final bool? userId;

  final bool? essential;

  final bool? analytics;

  final bool? marketing;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'essential': essential,
    'analytics': analytics,
    'marketing': marketing,
  };
}

class CookiePreferenceGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CookiePreferenceGroupByOutputTypeMaxArgs({this.select});

  final _i2.CookiePreferenceMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class CookiePreferenceGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CookiePreferenceGroupByOutputTypeSelect({
    this.id,
    this.userId,
    this.essential,
    this.analytics,
    this.marketing,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? userId;

  final bool? essential;

  final bool? analytics;

  final bool? marketing;

  final _i1.PrismaUnion<bool, _i2.CookiePreferenceGroupByOutputTypeCountArgs>?
  $count;

  final _i1.PrismaUnion<bool, _i2.CookiePreferenceGroupByOutputTypeMinArgs>?
  $min;

  final _i1.PrismaUnion<bool, _i2.CookiePreferenceGroupByOutputTypeMaxArgs>?
  $max;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'essential': essential,
    'analytics': analytics,
    'marketing': marketing,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class AggregateCookiePreference {
  const AggregateCookiePreference({this.$count, this.$min, this.$max});

  factory AggregateCookiePreference.fromJson(Map json) =>
      AggregateCookiePreference(
        $count: json['_count'] is Map
            ? _i2.CookiePreferenceCountAggregateOutputType.fromJson(
                json['_count'],
              )
            : null,
        $min: json['_min'] is Map
            ? _i2.CookiePreferenceMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.CookiePreferenceMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.CookiePreferenceCountAggregateOutputType? $count;

  final _i2.CookiePreferenceMinAggregateOutputType? $min;

  final _i2.CookiePreferenceMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    '_count': $count?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class AggregateCookiePreferenceCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateCookiePreferenceCountArgs({this.select});

  final _i2.CookiePreferenceCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateCookiePreferenceMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateCookiePreferenceMinArgs({this.select});

  final _i2.CookiePreferenceMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateCookiePreferenceMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateCookiePreferenceMaxArgs({this.select});

  final _i2.CookiePreferenceMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateCookiePreferenceSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateCookiePreferenceSelect({this.$count, this.$min, this.$max});

  final _i1.PrismaUnion<bool, _i2.AggregateCookiePreferenceCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateCookiePreferenceMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateCookiePreferenceMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

enum NotificationPreferenceScalar<T>
    implements _i1.PrismaEnum, _i1.Reference<T> {
  id<String>('id', 'NotificationPreference'),
  userId<String>('userId', 'NotificationPreference'),
  allNotifications<bool>('allNotifications', 'NotificationPreference'),
  mentions<bool>('mentions', 'NotificationPreference'),
  directMessages<bool>('directMessages', 'NotificationPreference'),
  updates<bool>('updates', 'NotificationPreference');

  const NotificationPreferenceScalar(this.name, this.model);

  @override
  final String name;

  @override
  final String model;
}

class UserCreateWithoutNotificationPreferencesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateWithoutNotificationPreferencesInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.cookiePreferences,
    this.payment,
    this.consultantProfile,
    this.consulteeProfile,
    this.staffProfile,
    this.slotsOfAppointment,
    this.waitlist,
    this.feedbacks,
    this.supportTickets,
    this.supportResponses,
    this.accounts,
    this.sessions,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? email;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? emailVerified;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? image;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? address;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? password;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? passwordResetToken;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? passwordResetExpires;

  final bool? onlineStatus;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? currentTimezone;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? onboardingCompleted;

  final _i1.PrismaUnion<_i3.UserRole, _i1.PrismaNull>? role;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consultantProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consulteeProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? staffProfileId;

  final _i2.CookiePreferenceCreateNestedOneWithoutUserInput? cookiePreferences;

  final _i2.PaymentCreateNestedManyWithoutUserInput? payment;

  final _i2.ConsultantProfileCreateNestedOneWithoutUserInput? consultantProfile;

  final _i2.ConsulteeProfileCreateNestedOneWithoutUserInput? consulteeProfile;

  final _i2.StaffProfileCreateNestedOneWithoutUserInput? staffProfile;

  final _i2.SlotOfAppointmentCreateNestedManyWithoutUserInput?
  slotsOfAppointment;

  final _i2.WaitlistCreateNestedManyWithoutUserInput? waitlist;

  final _i2.FeedbackCreateNestedManyWithoutUserInput? feedbacks;

  final _i2.SupportTicketCreateNestedManyWithoutUserInput? supportTickets;

  final _i2.SupportResponseCreateNestedManyWithoutUserInput? supportResponses;

  final _i2.AccountCreateNestedManyWithoutUserInput? accounts;

  final _i2.SessionCreateNestedManyWithoutUserInput? sessions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'cookiePreferences': cookiePreferences,
    'Payment': payment,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
    'staffProfile': staffProfile,
    'slotsOfAppointment': slotsOfAppointment,
    'Waitlist': waitlist,
    'feedbacks': feedbacks,
    'supportTickets': supportTickets,
    'supportResponses': supportResponses,
    'accounts': accounts,
    'sessions': sessions,
  };
}

class UserUncheckedCreateWithoutNotificationPreferencesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUncheckedCreateWithoutNotificationPreferencesInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.cookiePreferences,
    this.payment,
    this.consultantProfile,
    this.consulteeProfile,
    this.staffProfile,
    this.slotsOfAppointment,
    this.waitlist,
    this.feedbacks,
    this.supportTickets,
    this.supportResponses,
    this.accounts,
    this.sessions,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? email;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? emailVerified;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? image;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? address;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? password;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? passwordResetToken;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? passwordResetExpires;

  final bool? onlineStatus;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? currentTimezone;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? onboardingCompleted;

  final _i1.PrismaUnion<_i3.UserRole, _i1.PrismaNull>? role;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consultantProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consulteeProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? staffProfileId;

  final _i2.CookiePreferenceUncheckedCreateNestedOneWithoutUserInput?
  cookiePreferences;

  final _i2.PaymentUncheckedCreateNestedManyWithoutUserInput? payment;

  final _i2.ConsultantProfileUncheckedCreateNestedOneWithoutUserInput?
  consultantProfile;

  final _i2.ConsulteeProfileUncheckedCreateNestedOneWithoutUserInput?
  consulteeProfile;

  final _i2.StaffProfileUncheckedCreateNestedOneWithoutUserInput? staffProfile;

  final _i2.SlotOfAppointmentUncheckedCreateNestedManyWithoutUserInput?
  slotsOfAppointment;

  final _i2.WaitlistUncheckedCreateNestedManyWithoutUserInput? waitlist;

  final _i2.FeedbackUncheckedCreateNestedManyWithoutUserInput? feedbacks;

  final _i2.SupportTicketUncheckedCreateNestedManyWithoutUserInput?
  supportTickets;

  final _i2.SupportResponseUncheckedCreateNestedManyWithoutUserInput?
  supportResponses;

  final _i2.AccountUncheckedCreateNestedManyWithoutUserInput? accounts;

  final _i2.SessionUncheckedCreateNestedManyWithoutUserInput? sessions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'cookiePreferences': cookiePreferences,
    'Payment': payment,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
    'staffProfile': staffProfile,
    'slotsOfAppointment': slotsOfAppointment,
    'Waitlist': waitlist,
    'feedbacks': feedbacks,
    'supportTickets': supportTickets,
    'supportResponses': supportResponses,
    'accounts': accounts,
    'sessions': sessions,
  };
}

class UserCreateOrConnectWithoutNotificationPreferencesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateOrConnectWithoutNotificationPreferencesInput({
    required this.where,
    required this.create,
  });

  final _i2.UserWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.UserCreateWithoutNotificationPreferencesInput,
    _i2.UserUncheckedCreateWithoutNotificationPreferencesInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class UserCreateNestedOneWithoutNotificationPreferencesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateNestedOneWithoutNotificationPreferencesInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.UserCreateWithoutNotificationPreferencesInput,
    _i2.UserUncheckedCreateWithoutNotificationPreferencesInput
  >?
  create;

  final _i2.UserCreateOrConnectWithoutNotificationPreferencesInput?
  connectOrCreate;

  final _i2.UserWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class NotificationPreferenceCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NotificationPreferenceCreateInput({
    this.id,
    this.allNotifications,
    this.mentions,
    this.directMessages,
    this.updates,
    required this.user,
  });

  final String? id;

  final bool? allNotifications;

  final bool? mentions;

  final bool? directMessages;

  final bool? updates;

  final _i2.UserCreateNestedOneWithoutNotificationPreferencesInput user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'allNotifications': allNotifications,
    'mentions': mentions,
    'directMessages': directMessages,
    'updates': updates,
    'user': user,
  };
}

class NotificationPreferenceUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NotificationPreferenceUncheckedCreateInput({
    this.id,
    required this.userId,
    this.allNotifications,
    this.mentions,
    this.directMessages,
    this.updates,
  });

  final String? id;

  final String userId;

  final bool? allNotifications;

  final bool? mentions;

  final bool? directMessages;

  final bool? updates;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'allNotifications': allNotifications,
    'mentions': mentions,
    'directMessages': directMessages,
    'updates': updates,
  };
}

class NotificationPreferenceCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NotificationPreferenceCreateManyInput({
    this.id,
    required this.userId,
    this.allNotifications,
    this.mentions,
    this.directMessages,
    this.updates,
  });

  final String? id;

  final String userId;

  final bool? allNotifications;

  final bool? mentions;

  final bool? directMessages;

  final bool? updates;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'allNotifications': allNotifications,
    'mentions': mentions,
    'directMessages': directMessages,
    'updates': updates,
  };
}

class UserUpdateWithoutNotificationPreferencesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpdateWithoutNotificationPreferencesInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.cookiePreferences,
    this.payment,
    this.consultantProfile,
    this.consulteeProfile,
    this.staffProfile,
    this.slotsOfAppointment,
    this.waitlist,
    this.feedbacks,
    this.supportTickets,
    this.supportResponses,
    this.accounts,
    this.sessions,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  name;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  email;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  emailVerified;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  image;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  phone;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  address;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  password;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetToken;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetExpires;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? onlineStatus;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  currentTimezone;

  final _i1.PrismaUnion<
    bool,
    _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  onboardingCompleted;

  final _i1.PrismaUnion<
    _i3.UserRole,
    _i1.PrismaUnion<
      _i2.NullableEnumUserRoleFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  role;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consultantProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consulteeProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  staffProfileId;

  final _i2.CookiePreferenceUpdateOneWithoutUserNestedInput? cookiePreferences;

  final _i2.PaymentUpdateManyWithoutUserNestedInput? payment;

  final _i2.ConsultantProfileUpdateOneWithoutUserNestedInput? consultantProfile;

  final _i2.ConsulteeProfileUpdateOneWithoutUserNestedInput? consulteeProfile;

  final _i2.StaffProfileUpdateOneWithoutUserNestedInput? staffProfile;

  final _i2.SlotOfAppointmentUpdateManyWithoutUserNestedInput?
  slotsOfAppointment;

  final _i2.WaitlistUpdateManyWithoutUserNestedInput? waitlist;

  final _i2.FeedbackUpdateManyWithoutUserNestedInput? feedbacks;

  final _i2.SupportTicketUpdateManyWithoutUserNestedInput? supportTickets;

  final _i2.SupportResponseUpdateManyWithoutUserNestedInput? supportResponses;

  final _i2.AccountUpdateManyWithoutUserNestedInput? accounts;

  final _i2.SessionUpdateManyWithoutUserNestedInput? sessions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'cookiePreferences': cookiePreferences,
    'Payment': payment,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
    'staffProfile': staffProfile,
    'slotsOfAppointment': slotsOfAppointment,
    'Waitlist': waitlist,
    'feedbacks': feedbacks,
    'supportTickets': supportTickets,
    'supportResponses': supportResponses,
    'accounts': accounts,
    'sessions': sessions,
  };
}

class UserUncheckedUpdateWithoutNotificationPreferencesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUncheckedUpdateWithoutNotificationPreferencesInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.cookiePreferences,
    this.payment,
    this.consultantProfile,
    this.consulteeProfile,
    this.staffProfile,
    this.slotsOfAppointment,
    this.waitlist,
    this.feedbacks,
    this.supportTickets,
    this.supportResponses,
    this.accounts,
    this.sessions,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  name;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  email;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  emailVerified;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  image;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  phone;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  address;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  password;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetToken;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetExpires;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? onlineStatus;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  currentTimezone;

  final _i1.PrismaUnion<
    bool,
    _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  onboardingCompleted;

  final _i1.PrismaUnion<
    _i3.UserRole,
    _i1.PrismaUnion<
      _i2.NullableEnumUserRoleFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  role;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consultantProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consulteeProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  staffProfileId;

  final _i2.CookiePreferenceUncheckedUpdateOneWithoutUserNestedInput?
  cookiePreferences;

  final _i2.PaymentUncheckedUpdateManyWithoutUserNestedInput? payment;

  final _i2.ConsultantProfileUncheckedUpdateOneWithoutUserNestedInput?
  consultantProfile;

  final _i2.ConsulteeProfileUncheckedUpdateOneWithoutUserNestedInput?
  consulteeProfile;

  final _i2.StaffProfileUncheckedUpdateOneWithoutUserNestedInput? staffProfile;

  final _i2.SlotOfAppointmentUncheckedUpdateManyWithoutUserNestedInput?
  slotsOfAppointment;

  final _i2.WaitlistUncheckedUpdateManyWithoutUserNestedInput? waitlist;

  final _i2.FeedbackUncheckedUpdateManyWithoutUserNestedInput? feedbacks;

  final _i2.SupportTicketUncheckedUpdateManyWithoutUserNestedInput?
  supportTickets;

  final _i2.SupportResponseUncheckedUpdateManyWithoutUserNestedInput?
  supportResponses;

  final _i2.AccountUncheckedUpdateManyWithoutUserNestedInput? accounts;

  final _i2.SessionUncheckedUpdateManyWithoutUserNestedInput? sessions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'cookiePreferences': cookiePreferences,
    'Payment': payment,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
    'staffProfile': staffProfile,
    'slotsOfAppointment': slotsOfAppointment,
    'Waitlist': waitlist,
    'feedbacks': feedbacks,
    'supportTickets': supportTickets,
    'supportResponses': supportResponses,
    'accounts': accounts,
    'sessions': sessions,
  };
}

class UserUpsertWithoutNotificationPreferencesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpsertWithoutNotificationPreferencesInput({
    required this.update,
    required this.create,
  });

  final _i1.PrismaUnion<
    _i2.UserUpdateWithoutNotificationPreferencesInput,
    _i2.UserUncheckedUpdateWithoutNotificationPreferencesInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.UserCreateWithoutNotificationPreferencesInput,
    _i2.UserUncheckedCreateWithoutNotificationPreferencesInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'update': update, 'create': create};
}

class UserUpdateOneRequiredWithoutNotificationPreferencesNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpdateOneRequiredWithoutNotificationPreferencesNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.UserCreateWithoutNotificationPreferencesInput,
    _i2.UserUncheckedCreateWithoutNotificationPreferencesInput
  >?
  create;

  final _i2.UserCreateOrConnectWithoutNotificationPreferencesInput?
  connectOrCreate;

  final _i2.UserUpsertWithoutNotificationPreferencesInput? upsert;

  final _i2.UserWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.UserUpdateWithoutNotificationPreferencesInput,
    _i2.UserUncheckedUpdateWithoutNotificationPreferencesInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'connect': connect,
    'update': update,
  };
}

class NotificationPreferenceUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NotificationPreferenceUpdateInput({
    this.id,
    this.allNotifications,
    this.mentions,
    this.directMessages,
    this.updates,
    this.user,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
  allNotifications;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? mentions;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
  directMessages;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? updates;

  final _i2.UserUpdateOneRequiredWithoutNotificationPreferencesNestedInput?
  user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'allNotifications': allNotifications,
    'mentions': mentions,
    'directMessages': directMessages,
    'updates': updates,
    'user': user,
  };
}

class NotificationPreferenceUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NotificationPreferenceUncheckedUpdateInput({
    this.id,
    this.userId,
    this.allNotifications,
    this.mentions,
    this.directMessages,
    this.updates,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
  allNotifications;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? mentions;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
  directMessages;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? updates;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'allNotifications': allNotifications,
    'mentions': mentions,
    'directMessages': directMessages,
    'updates': updates,
  };
}

class NotificationPreferenceUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NotificationPreferenceUpdateManyMutationInput({
    this.id,
    this.allNotifications,
    this.mentions,
    this.directMessages,
    this.updates,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
  allNotifications;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? mentions;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
  directMessages;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? updates;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'allNotifications': allNotifications,
    'mentions': mentions,
    'directMessages': directMessages,
    'updates': updates,
  };
}

class NotificationPreferenceUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NotificationPreferenceUncheckedUpdateManyInput({
    this.id,
    this.userId,
    this.allNotifications,
    this.mentions,
    this.directMessages,
    this.updates,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
  allNotifications;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? mentions;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
  directMessages;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? updates;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'allNotifications': allNotifications,
    'mentions': mentions,
    'directMessages': directMessages,
    'updates': updates,
  };
}

class NotificationPreferenceCountAggregateOutputType {
  const NotificationPreferenceCountAggregateOutputType({
    this.id,
    this.userId,
    this.allNotifications,
    this.mentions,
    this.directMessages,
    this.updates,
    this.$all,
  });

  factory NotificationPreferenceCountAggregateOutputType.fromJson(Map json) =>
      NotificationPreferenceCountAggregateOutputType(
        id: json['id'],
        userId: json['userId'],
        allNotifications: json['allNotifications'],
        mentions: json['mentions'],
        directMessages: json['directMessages'],
        updates: json['updates'],
        $all: json['_all'],
      );

  final int? id;

  final int? userId;

  final int? allNotifications;

  final int? mentions;

  final int? directMessages;

  final int? updates;

  final int? $all;

  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'allNotifications': allNotifications,
    'mentions': mentions,
    'directMessages': directMessages,
    'updates': updates,
    '_all': $all,
  };
}

class NotificationPreferenceMinAggregateOutputType {
  const NotificationPreferenceMinAggregateOutputType({
    this.id,
    this.userId,
    this.allNotifications,
    this.mentions,
    this.directMessages,
    this.updates,
  });

  factory NotificationPreferenceMinAggregateOutputType.fromJson(Map json) =>
      NotificationPreferenceMinAggregateOutputType(
        id: json['id'],
        userId: json['userId'],
        allNotifications: json['allNotifications'],
        mentions: json['mentions'],
        directMessages: json['directMessages'],
        updates: json['updates'],
      );

  final String? id;

  final String? userId;

  final bool? allNotifications;

  final bool? mentions;

  final bool? directMessages;

  final bool? updates;

  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'allNotifications': allNotifications,
    'mentions': mentions,
    'directMessages': directMessages,
    'updates': updates,
  };
}

class NotificationPreferenceMaxAggregateOutputType {
  const NotificationPreferenceMaxAggregateOutputType({
    this.id,
    this.userId,
    this.allNotifications,
    this.mentions,
    this.directMessages,
    this.updates,
  });

  factory NotificationPreferenceMaxAggregateOutputType.fromJson(Map json) =>
      NotificationPreferenceMaxAggregateOutputType(
        id: json['id'],
        userId: json['userId'],
        allNotifications: json['allNotifications'],
        mentions: json['mentions'],
        directMessages: json['directMessages'],
        updates: json['updates'],
      );

  final String? id;

  final String? userId;

  final bool? allNotifications;

  final bool? mentions;

  final bool? directMessages;

  final bool? updates;

  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'allNotifications': allNotifications,
    'mentions': mentions,
    'directMessages': directMessages,
    'updates': updates,
  };
}

class NotificationPreferenceGroupByOutputType {
  const NotificationPreferenceGroupByOutputType({
    this.id,
    this.userId,
    this.allNotifications,
    this.mentions,
    this.directMessages,
    this.updates,
    this.$count,
    this.$min,
    this.$max,
  });

  factory NotificationPreferenceGroupByOutputType.fromJson(Map json) =>
      NotificationPreferenceGroupByOutputType(
        id: json['id'],
        userId: json['userId'],
        allNotifications: json['allNotifications'],
        mentions: json['mentions'],
        directMessages: json['directMessages'],
        updates: json['updates'],
        $count: json['_count'] is Map
            ? _i2.NotificationPreferenceCountAggregateOutputType.fromJson(
                json['_count'],
              )
            : null,
        $min: json['_min'] is Map
            ? _i2.NotificationPreferenceMinAggregateOutputType.fromJson(
                json['_min'],
              )
            : null,
        $max: json['_max'] is Map
            ? _i2.NotificationPreferenceMaxAggregateOutputType.fromJson(
                json['_max'],
              )
            : null,
      );

  final String? id;

  final String? userId;

  final bool? allNotifications;

  final bool? mentions;

  final bool? directMessages;

  final bool? updates;

  final _i2.NotificationPreferenceCountAggregateOutputType? $count;

  final _i2.NotificationPreferenceMinAggregateOutputType? $min;

  final _i2.NotificationPreferenceMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'allNotifications': allNotifications,
    'mentions': mentions,
    'directMessages': directMessages,
    'updates': updates,
    '_count': $count?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class NotificationPreferenceCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NotificationPreferenceCountOrderByAggregateInput({
    this.id,
    this.userId,
    this.allNotifications,
    this.mentions,
    this.directMessages,
    this.updates,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? allNotifications;

  final _i2.SortOrder? mentions;

  final _i2.SortOrder? directMessages;

  final _i2.SortOrder? updates;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'allNotifications': allNotifications,
    'mentions': mentions,
    'directMessages': directMessages,
    'updates': updates,
  };
}

class NotificationPreferenceMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NotificationPreferenceMaxOrderByAggregateInput({
    this.id,
    this.userId,
    this.allNotifications,
    this.mentions,
    this.directMessages,
    this.updates,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? allNotifications;

  final _i2.SortOrder? mentions;

  final _i2.SortOrder? directMessages;

  final _i2.SortOrder? updates;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'allNotifications': allNotifications,
    'mentions': mentions,
    'directMessages': directMessages,
    'updates': updates,
  };
}

class NotificationPreferenceMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NotificationPreferenceMinOrderByAggregateInput({
    this.id,
    this.userId,
    this.allNotifications,
    this.mentions,
    this.directMessages,
    this.updates,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? allNotifications;

  final _i2.SortOrder? mentions;

  final _i2.SortOrder? directMessages;

  final _i2.SortOrder? updates;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'allNotifications': allNotifications,
    'mentions': mentions,
    'directMessages': directMessages,
    'updates': updates,
  };
}

class NotificationPreferenceOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NotificationPreferenceOrderByWithAggregationInput({
    this.id,
    this.userId,
    this.allNotifications,
    this.mentions,
    this.directMessages,
    this.updates,
    this.$count,
    this.$max,
    this.$min,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? allNotifications;

  final _i2.SortOrder? mentions;

  final _i2.SortOrder? directMessages;

  final _i2.SortOrder? updates;

  final _i2.NotificationPreferenceCountOrderByAggregateInput? $count;

  final _i2.NotificationPreferenceMaxOrderByAggregateInput? $max;

  final _i2.NotificationPreferenceMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'allNotifications': allNotifications,
    'mentions': mentions,
    'directMessages': directMessages,
    'updates': updates,
    '_count': $count,
    '_max': $max,
    '_min': $min,
  };
}

class NotificationPreferenceScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NotificationPreferenceScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.userId,
    this.allNotifications,
    this.mentions,
    this.directMessages,
    this.updates,
  });

  final _i1.PrismaUnion<
    _i2.NotificationPreferenceScalarWhereWithAggregatesInput,
    Iterable<_i2.NotificationPreferenceScalarWhereWithAggregatesInput>
  >?
  AND;

  final Iterable<_i2.NotificationPreferenceScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<
    _i2.NotificationPreferenceScalarWhereWithAggregatesInput,
    Iterable<_i2.NotificationPreferenceScalarWhereWithAggregatesInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? userId;

  final _i1.PrismaUnion<_i2.BoolWithAggregatesFilter, bool>? allNotifications;

  final _i1.PrismaUnion<_i2.BoolWithAggregatesFilter, bool>? mentions;

  final _i1.PrismaUnion<_i2.BoolWithAggregatesFilter, bool>? directMessages;

  final _i1.PrismaUnion<_i2.BoolWithAggregatesFilter, bool>? updates;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'userId': userId,
    'allNotifications': allNotifications,
    'mentions': mentions,
    'directMessages': directMessages,
    'updates': updates,
  };
}

class NotificationPreferenceCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NotificationPreferenceCountAggregateOutputTypeSelect({
    this.id,
    this.userId,
    this.allNotifications,
    this.mentions,
    this.directMessages,
    this.updates,
    this.$all,
  });

  final bool? id;

  final bool? userId;

  final bool? allNotifications;

  final bool? mentions;

  final bool? directMessages;

  final bool? updates;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'allNotifications': allNotifications,
    'mentions': mentions,
    'directMessages': directMessages,
    'updates': updates,
    '_all': $all,
  };
}

class NotificationPreferenceGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NotificationPreferenceGroupByOutputTypeCountArgs({this.select});

  final _i2.NotificationPreferenceCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class NotificationPreferenceMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NotificationPreferenceMinAggregateOutputTypeSelect({
    this.id,
    this.userId,
    this.allNotifications,
    this.mentions,
    this.directMessages,
    this.updates,
  });

  final bool? id;

  final bool? userId;

  final bool? allNotifications;

  final bool? mentions;

  final bool? directMessages;

  final bool? updates;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'allNotifications': allNotifications,
    'mentions': mentions,
    'directMessages': directMessages,
    'updates': updates,
  };
}

class NotificationPreferenceGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NotificationPreferenceGroupByOutputTypeMinArgs({this.select});

  final _i2.NotificationPreferenceMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class NotificationPreferenceMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NotificationPreferenceMaxAggregateOutputTypeSelect({
    this.id,
    this.userId,
    this.allNotifications,
    this.mentions,
    this.directMessages,
    this.updates,
  });

  final bool? id;

  final bool? userId;

  final bool? allNotifications;

  final bool? mentions;

  final bool? directMessages;

  final bool? updates;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'allNotifications': allNotifications,
    'mentions': mentions,
    'directMessages': directMessages,
    'updates': updates,
  };
}

class NotificationPreferenceGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NotificationPreferenceGroupByOutputTypeMaxArgs({this.select});

  final _i2.NotificationPreferenceMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class NotificationPreferenceGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NotificationPreferenceGroupByOutputTypeSelect({
    this.id,
    this.userId,
    this.allNotifications,
    this.mentions,
    this.directMessages,
    this.updates,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? userId;

  final bool? allNotifications;

  final bool? mentions;

  final bool? directMessages;

  final bool? updates;

  final _i1.PrismaUnion<
    bool,
    _i2.NotificationPreferenceGroupByOutputTypeCountArgs
  >?
  $count;

  final _i1.PrismaUnion<
    bool,
    _i2.NotificationPreferenceGroupByOutputTypeMinArgs
  >?
  $min;

  final _i1.PrismaUnion<
    bool,
    _i2.NotificationPreferenceGroupByOutputTypeMaxArgs
  >?
  $max;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'allNotifications': allNotifications,
    'mentions': mentions,
    'directMessages': directMessages,
    'updates': updates,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class AggregateNotificationPreference {
  const AggregateNotificationPreference({this.$count, this.$min, this.$max});

  factory AggregateNotificationPreference.fromJson(Map json) =>
      AggregateNotificationPreference(
        $count: json['_count'] is Map
            ? _i2.NotificationPreferenceCountAggregateOutputType.fromJson(
                json['_count'],
              )
            : null,
        $min: json['_min'] is Map
            ? _i2.NotificationPreferenceMinAggregateOutputType.fromJson(
                json['_min'],
              )
            : null,
        $max: json['_max'] is Map
            ? _i2.NotificationPreferenceMaxAggregateOutputType.fromJson(
                json['_max'],
              )
            : null,
      );

  final _i2.NotificationPreferenceCountAggregateOutputType? $count;

  final _i2.NotificationPreferenceMinAggregateOutputType? $min;

  final _i2.NotificationPreferenceMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    '_count': $count?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class AggregateNotificationPreferenceCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateNotificationPreferenceCountArgs({this.select});

  final _i2.NotificationPreferenceCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateNotificationPreferenceMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateNotificationPreferenceMinArgs({this.select});

  final _i2.NotificationPreferenceMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateNotificationPreferenceMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateNotificationPreferenceMaxArgs({this.select});

  final _i2.NotificationPreferenceMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateNotificationPreferenceSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateNotificationPreferenceSelect({
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateNotificationPreferenceCountArgs>?
  $count;

  final _i1.PrismaUnion<bool, _i2.AggregateNotificationPreferenceMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateNotificationPreferenceMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class UserCreateWithoutAccountsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateWithoutAccountsInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.cookiePreferences,
    this.notificationPreferences,
    this.payment,
    this.consultantProfile,
    this.consulteeProfile,
    this.staffProfile,
    this.slotsOfAppointment,
    this.waitlist,
    this.feedbacks,
    this.supportTickets,
    this.supportResponses,
    this.sessions,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? email;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? emailVerified;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? image;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? address;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? password;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? passwordResetToken;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? passwordResetExpires;

  final bool? onlineStatus;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? currentTimezone;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? onboardingCompleted;

  final _i1.PrismaUnion<_i3.UserRole, _i1.PrismaNull>? role;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consultantProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consulteeProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? staffProfileId;

  final _i2.CookiePreferenceCreateNestedOneWithoutUserInput? cookiePreferences;

  final _i2.NotificationPreferenceCreateNestedOneWithoutUserInput?
  notificationPreferences;

  final _i2.PaymentCreateNestedManyWithoutUserInput? payment;

  final _i2.ConsultantProfileCreateNestedOneWithoutUserInput? consultantProfile;

  final _i2.ConsulteeProfileCreateNestedOneWithoutUserInput? consulteeProfile;

  final _i2.StaffProfileCreateNestedOneWithoutUserInput? staffProfile;

  final _i2.SlotOfAppointmentCreateNestedManyWithoutUserInput?
  slotsOfAppointment;

  final _i2.WaitlistCreateNestedManyWithoutUserInput? waitlist;

  final _i2.FeedbackCreateNestedManyWithoutUserInput? feedbacks;

  final _i2.SupportTicketCreateNestedManyWithoutUserInput? supportTickets;

  final _i2.SupportResponseCreateNestedManyWithoutUserInput? supportResponses;

  final _i2.SessionCreateNestedManyWithoutUserInput? sessions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'cookiePreferences': cookiePreferences,
    'notificationPreferences': notificationPreferences,
    'Payment': payment,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
    'staffProfile': staffProfile,
    'slotsOfAppointment': slotsOfAppointment,
    'Waitlist': waitlist,
    'feedbacks': feedbacks,
    'supportTickets': supportTickets,
    'supportResponses': supportResponses,
    'sessions': sessions,
  };
}

class UserUncheckedCreateWithoutAccountsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUncheckedCreateWithoutAccountsInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.cookiePreferences,
    this.notificationPreferences,
    this.payment,
    this.consultantProfile,
    this.consulteeProfile,
    this.staffProfile,
    this.slotsOfAppointment,
    this.waitlist,
    this.feedbacks,
    this.supportTickets,
    this.supportResponses,
    this.sessions,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? email;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? emailVerified;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? image;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? address;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? password;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? passwordResetToken;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? passwordResetExpires;

  final bool? onlineStatus;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? currentTimezone;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? onboardingCompleted;

  final _i1.PrismaUnion<_i3.UserRole, _i1.PrismaNull>? role;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consultantProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consulteeProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? staffProfileId;

  final _i2.CookiePreferenceUncheckedCreateNestedOneWithoutUserInput?
  cookiePreferences;

  final _i2.NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput?
  notificationPreferences;

  final _i2.PaymentUncheckedCreateNestedManyWithoutUserInput? payment;

  final _i2.ConsultantProfileUncheckedCreateNestedOneWithoutUserInput?
  consultantProfile;

  final _i2.ConsulteeProfileUncheckedCreateNestedOneWithoutUserInput?
  consulteeProfile;

  final _i2.StaffProfileUncheckedCreateNestedOneWithoutUserInput? staffProfile;

  final _i2.SlotOfAppointmentUncheckedCreateNestedManyWithoutUserInput?
  slotsOfAppointment;

  final _i2.WaitlistUncheckedCreateNestedManyWithoutUserInput? waitlist;

  final _i2.FeedbackUncheckedCreateNestedManyWithoutUserInput? feedbacks;

  final _i2.SupportTicketUncheckedCreateNestedManyWithoutUserInput?
  supportTickets;

  final _i2.SupportResponseUncheckedCreateNestedManyWithoutUserInput?
  supportResponses;

  final _i2.SessionUncheckedCreateNestedManyWithoutUserInput? sessions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'cookiePreferences': cookiePreferences,
    'notificationPreferences': notificationPreferences,
    'Payment': payment,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
    'staffProfile': staffProfile,
    'slotsOfAppointment': slotsOfAppointment,
    'Waitlist': waitlist,
    'feedbacks': feedbacks,
    'supportTickets': supportTickets,
    'supportResponses': supportResponses,
    'sessions': sessions,
  };
}

class UserCreateOrConnectWithoutAccountsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateOrConnectWithoutAccountsInput({
    required this.where,
    required this.create,
  });

  final _i2.UserWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.UserCreateWithoutAccountsInput,
    _i2.UserUncheckedCreateWithoutAccountsInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class UserCreateNestedOneWithoutAccountsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateNestedOneWithoutAccountsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.UserCreateWithoutAccountsInput,
    _i2.UserUncheckedCreateWithoutAccountsInput
  >?
  create;

  final _i2.UserCreateOrConnectWithoutAccountsInput? connectOrCreate;

  final _i2.UserWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class AccountCreateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AccountCreateInput({
    this.id,
    required this.type,
    required this.provider,
    required this.providerAccountId,
    this.refreshToken,
    this.accessToken,
    this.expiresAt,
    this.tokenType,
    this.scope,
    this.idToken,
    this.sessionState,
    required this.user,
  });

  final String? id;

  final String type;

  final String provider;

  final String providerAccountId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? refreshToken;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? accessToken;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? expiresAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? tokenType;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? scope;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? idToken;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? sessionState;

  final _i2.UserCreateNestedOneWithoutAccountsInput user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'type': type,
    'provider': provider,
    'providerAccountId': providerAccountId,
    'refresh_token': refreshToken,
    'access_token': accessToken,
    'expires_at': expiresAt,
    'token_type': tokenType,
    'scope': scope,
    'id_token': idToken,
    'session_state': sessionState,
    'user': user,
  };
}

class AccountUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AccountUncheckedCreateInput({
    this.id,
    required this.userId,
    required this.type,
    required this.provider,
    required this.providerAccountId,
    this.refreshToken,
    this.accessToken,
    this.expiresAt,
    this.tokenType,
    this.scope,
    this.idToken,
    this.sessionState,
  });

  final String? id;

  final String userId;

  final String type;

  final String provider;

  final String providerAccountId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? refreshToken;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? accessToken;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? expiresAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? tokenType;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? scope;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? idToken;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? sessionState;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'type': type,
    'provider': provider,
    'providerAccountId': providerAccountId,
    'refresh_token': refreshToken,
    'access_token': accessToken,
    'expires_at': expiresAt,
    'token_type': tokenType,
    'scope': scope,
    'id_token': idToken,
    'session_state': sessionState,
  };
}

class AccountCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AccountCreateManyInput({
    this.id,
    required this.userId,
    required this.type,
    required this.provider,
    required this.providerAccountId,
    this.refreshToken,
    this.accessToken,
    this.expiresAt,
    this.tokenType,
    this.scope,
    this.idToken,
    this.sessionState,
  });

  final String? id;

  final String userId;

  final String type;

  final String provider;

  final String providerAccountId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? refreshToken;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? accessToken;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? expiresAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? tokenType;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? scope;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? idToken;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? sessionState;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'type': type,
    'provider': provider,
    'providerAccountId': providerAccountId,
    'refresh_token': refreshToken,
    'access_token': accessToken,
    'expires_at': expiresAt,
    'token_type': tokenType,
    'scope': scope,
    'id_token': idToken,
    'session_state': sessionState,
  };
}

class UserUpdateWithoutAccountsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpdateWithoutAccountsInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.cookiePreferences,
    this.notificationPreferences,
    this.payment,
    this.consultantProfile,
    this.consulteeProfile,
    this.staffProfile,
    this.slotsOfAppointment,
    this.waitlist,
    this.feedbacks,
    this.supportTickets,
    this.supportResponses,
    this.sessions,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  name;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  email;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  emailVerified;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  image;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  phone;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  address;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  password;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetToken;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetExpires;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? onlineStatus;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  currentTimezone;

  final _i1.PrismaUnion<
    bool,
    _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  onboardingCompleted;

  final _i1.PrismaUnion<
    _i3.UserRole,
    _i1.PrismaUnion<
      _i2.NullableEnumUserRoleFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  role;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consultantProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consulteeProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  staffProfileId;

  final _i2.CookiePreferenceUpdateOneWithoutUserNestedInput? cookiePreferences;

  final _i2.NotificationPreferenceUpdateOneWithoutUserNestedInput?
  notificationPreferences;

  final _i2.PaymentUpdateManyWithoutUserNestedInput? payment;

  final _i2.ConsultantProfileUpdateOneWithoutUserNestedInput? consultantProfile;

  final _i2.ConsulteeProfileUpdateOneWithoutUserNestedInput? consulteeProfile;

  final _i2.StaffProfileUpdateOneWithoutUserNestedInput? staffProfile;

  final _i2.SlotOfAppointmentUpdateManyWithoutUserNestedInput?
  slotsOfAppointment;

  final _i2.WaitlistUpdateManyWithoutUserNestedInput? waitlist;

  final _i2.FeedbackUpdateManyWithoutUserNestedInput? feedbacks;

  final _i2.SupportTicketUpdateManyWithoutUserNestedInput? supportTickets;

  final _i2.SupportResponseUpdateManyWithoutUserNestedInput? supportResponses;

  final _i2.SessionUpdateManyWithoutUserNestedInput? sessions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'cookiePreferences': cookiePreferences,
    'notificationPreferences': notificationPreferences,
    'Payment': payment,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
    'staffProfile': staffProfile,
    'slotsOfAppointment': slotsOfAppointment,
    'Waitlist': waitlist,
    'feedbacks': feedbacks,
    'supportTickets': supportTickets,
    'supportResponses': supportResponses,
    'sessions': sessions,
  };
}

class UserUncheckedUpdateWithoutAccountsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUncheckedUpdateWithoutAccountsInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.cookiePreferences,
    this.notificationPreferences,
    this.payment,
    this.consultantProfile,
    this.consulteeProfile,
    this.staffProfile,
    this.slotsOfAppointment,
    this.waitlist,
    this.feedbacks,
    this.supportTickets,
    this.supportResponses,
    this.sessions,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  name;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  email;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  emailVerified;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  image;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  phone;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  address;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  password;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetToken;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetExpires;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? onlineStatus;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  currentTimezone;

  final _i1.PrismaUnion<
    bool,
    _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  onboardingCompleted;

  final _i1.PrismaUnion<
    _i3.UserRole,
    _i1.PrismaUnion<
      _i2.NullableEnumUserRoleFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  role;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consultantProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consulteeProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  staffProfileId;

  final _i2.CookiePreferenceUncheckedUpdateOneWithoutUserNestedInput?
  cookiePreferences;

  final _i2.NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput?
  notificationPreferences;

  final _i2.PaymentUncheckedUpdateManyWithoutUserNestedInput? payment;

  final _i2.ConsultantProfileUncheckedUpdateOneWithoutUserNestedInput?
  consultantProfile;

  final _i2.ConsulteeProfileUncheckedUpdateOneWithoutUserNestedInput?
  consulteeProfile;

  final _i2.StaffProfileUncheckedUpdateOneWithoutUserNestedInput? staffProfile;

  final _i2.SlotOfAppointmentUncheckedUpdateManyWithoutUserNestedInput?
  slotsOfAppointment;

  final _i2.WaitlistUncheckedUpdateManyWithoutUserNestedInput? waitlist;

  final _i2.FeedbackUncheckedUpdateManyWithoutUserNestedInput? feedbacks;

  final _i2.SupportTicketUncheckedUpdateManyWithoutUserNestedInput?
  supportTickets;

  final _i2.SupportResponseUncheckedUpdateManyWithoutUserNestedInput?
  supportResponses;

  final _i2.SessionUncheckedUpdateManyWithoutUserNestedInput? sessions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'cookiePreferences': cookiePreferences,
    'notificationPreferences': notificationPreferences,
    'Payment': payment,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
    'staffProfile': staffProfile,
    'slotsOfAppointment': slotsOfAppointment,
    'Waitlist': waitlist,
    'feedbacks': feedbacks,
    'supportTickets': supportTickets,
    'supportResponses': supportResponses,
    'sessions': sessions,
  };
}

class UserUpsertWithoutAccountsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpsertWithoutAccountsInput({
    required this.update,
    required this.create,
  });

  final _i1.PrismaUnion<
    _i2.UserUpdateWithoutAccountsInput,
    _i2.UserUncheckedUpdateWithoutAccountsInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.UserCreateWithoutAccountsInput,
    _i2.UserUncheckedCreateWithoutAccountsInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'update': update, 'create': create};
}

class UserUpdateOneRequiredWithoutAccountsNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpdateOneRequiredWithoutAccountsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.UserCreateWithoutAccountsInput,
    _i2.UserUncheckedCreateWithoutAccountsInput
  >?
  create;

  final _i2.UserCreateOrConnectWithoutAccountsInput? connectOrCreate;

  final _i2.UserUpsertWithoutAccountsInput? upsert;

  final _i2.UserWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.UserUpdateWithoutAccountsInput,
    _i2.UserUncheckedUpdateWithoutAccountsInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'connect': connect,
    'update': update,
  };
}

class AccountUpdateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AccountUpdateInput({
    this.id,
    this.type,
    this.provider,
    this.providerAccountId,
    this.refreshToken,
    this.accessToken,
    this.expiresAt,
    this.tokenType,
    this.scope,
    this.idToken,
    this.sessionState,
    this.user,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? type;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? provider;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  providerAccountId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  refreshToken;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  accessToken;

  final _i1.PrismaUnion<
    int,
    _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  expiresAt;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  tokenType;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  scope;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  idToken;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  sessionState;

  final _i2.UserUpdateOneRequiredWithoutAccountsNestedInput? user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'type': type,
    'provider': provider,
    'providerAccountId': providerAccountId,
    'refresh_token': refreshToken,
    'access_token': accessToken,
    'expires_at': expiresAt,
    'token_type': tokenType,
    'scope': scope,
    'id_token': idToken,
    'session_state': sessionState,
    'user': user,
  };
}

class AccountUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AccountUncheckedUpdateInput({
    this.id,
    this.userId,
    this.type,
    this.provider,
    this.providerAccountId,
    this.refreshToken,
    this.accessToken,
    this.expiresAt,
    this.tokenType,
    this.scope,
    this.idToken,
    this.sessionState,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? type;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? provider;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  providerAccountId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  refreshToken;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  accessToken;

  final _i1.PrismaUnion<
    int,
    _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  expiresAt;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  tokenType;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  scope;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  idToken;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  sessionState;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'type': type,
    'provider': provider,
    'providerAccountId': providerAccountId,
    'refresh_token': refreshToken,
    'access_token': accessToken,
    'expires_at': expiresAt,
    'token_type': tokenType,
    'scope': scope,
    'id_token': idToken,
    'session_state': sessionState,
  };
}

class AccountUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AccountUncheckedUpdateManyInput({
    this.id,
    this.userId,
    this.type,
    this.provider,
    this.providerAccountId,
    this.refreshToken,
    this.accessToken,
    this.expiresAt,
    this.tokenType,
    this.scope,
    this.idToken,
    this.sessionState,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? type;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? provider;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  providerAccountId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  refreshToken;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  accessToken;

  final _i1.PrismaUnion<
    int,
    _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  expiresAt;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  tokenType;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  scope;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  idToken;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  sessionState;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'type': type,
    'provider': provider,
    'providerAccountId': providerAccountId,
    'refresh_token': refreshToken,
    'access_token': accessToken,
    'expires_at': expiresAt,
    'token_type': tokenType,
    'scope': scope,
    'id_token': idToken,
    'session_state': sessionState,
  };
}

class AccountCountAggregateOutputType {
  const AccountCountAggregateOutputType({
    this.id,
    this.userId,
    this.type,
    this.provider,
    this.providerAccountId,
    this.refreshToken,
    this.accessToken,
    this.expiresAt,
    this.tokenType,
    this.scope,
    this.idToken,
    this.sessionState,
    this.$all,
  });

  factory AccountCountAggregateOutputType.fromJson(Map json) =>
      AccountCountAggregateOutputType(
        id: json['id'],
        userId: json['userId'],
        type: json['type'],
        provider: json['provider'],
        providerAccountId: json['providerAccountId'],
        refreshToken: json['refresh_token'],
        accessToken: json['access_token'],
        expiresAt: json['expires_at'],
        tokenType: json['token_type'],
        scope: json['scope'],
        idToken: json['id_token'],
        sessionState: json['session_state'],
        $all: json['_all'],
      );

  final int? id;

  final int? userId;

  final int? type;

  final int? provider;

  final int? providerAccountId;

  final int? refreshToken;

  final int? accessToken;

  final int? expiresAt;

  final int? tokenType;

  final int? scope;

  final int? idToken;

  final int? sessionState;

  final int? $all;

  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'type': type,
    'provider': provider,
    'providerAccountId': providerAccountId,
    'refresh_token': refreshToken,
    'access_token': accessToken,
    'expires_at': expiresAt,
    'token_type': tokenType,
    'scope': scope,
    'id_token': idToken,
    'session_state': sessionState,
    '_all': $all,
  };
}

class AccountAvgAggregateOutputType {
  const AccountAvgAggregateOutputType({this.expiresAt});

  factory AccountAvgAggregateOutputType.fromJson(Map json) =>
      AccountAvgAggregateOutputType(expiresAt: json['expires_at']);

  final double? expiresAt;

  Map<String, dynamic> toJson() => {'expires_at': expiresAt};
}

class AccountSumAggregateOutputType {
  const AccountSumAggregateOutputType({this.expiresAt});

  factory AccountSumAggregateOutputType.fromJson(Map json) =>
      AccountSumAggregateOutputType(expiresAt: json['expires_at']);

  final int? expiresAt;

  Map<String, dynamic> toJson() => {'expires_at': expiresAt};
}

class AccountMinAggregateOutputType {
  const AccountMinAggregateOutputType({
    this.id,
    this.userId,
    this.type,
    this.provider,
    this.providerAccountId,
    this.refreshToken,
    this.accessToken,
    this.expiresAt,
    this.tokenType,
    this.scope,
    this.idToken,
    this.sessionState,
  });

  factory AccountMinAggregateOutputType.fromJson(Map json) =>
      AccountMinAggregateOutputType(
        id: json['id'],
        userId: json['userId'],
        type: json['type'],
        provider: json['provider'],
        providerAccountId: json['providerAccountId'],
        refreshToken: json['refresh_token'],
        accessToken: json['access_token'],
        expiresAt: json['expires_at'],
        tokenType: json['token_type'],
        scope: json['scope'],
        idToken: json['id_token'],
        sessionState: json['session_state'],
      );

  final String? id;

  final String? userId;

  final String? type;

  final String? provider;

  final String? providerAccountId;

  final String? refreshToken;

  final String? accessToken;

  final int? expiresAt;

  final String? tokenType;

  final String? scope;

  final String? idToken;

  final String? sessionState;

  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'type': type,
    'provider': provider,
    'providerAccountId': providerAccountId,
    'refresh_token': refreshToken,
    'access_token': accessToken,
    'expires_at': expiresAt,
    'token_type': tokenType,
    'scope': scope,
    'id_token': idToken,
    'session_state': sessionState,
  };
}

class AccountMaxAggregateOutputType {
  const AccountMaxAggregateOutputType({
    this.id,
    this.userId,
    this.type,
    this.provider,
    this.providerAccountId,
    this.refreshToken,
    this.accessToken,
    this.expiresAt,
    this.tokenType,
    this.scope,
    this.idToken,
    this.sessionState,
  });

  factory AccountMaxAggregateOutputType.fromJson(Map json) =>
      AccountMaxAggregateOutputType(
        id: json['id'],
        userId: json['userId'],
        type: json['type'],
        provider: json['provider'],
        providerAccountId: json['providerAccountId'],
        refreshToken: json['refresh_token'],
        accessToken: json['access_token'],
        expiresAt: json['expires_at'],
        tokenType: json['token_type'],
        scope: json['scope'],
        idToken: json['id_token'],
        sessionState: json['session_state'],
      );

  final String? id;

  final String? userId;

  final String? type;

  final String? provider;

  final String? providerAccountId;

  final String? refreshToken;

  final String? accessToken;

  final int? expiresAt;

  final String? tokenType;

  final String? scope;

  final String? idToken;

  final String? sessionState;

  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'type': type,
    'provider': provider,
    'providerAccountId': providerAccountId,
    'refresh_token': refreshToken,
    'access_token': accessToken,
    'expires_at': expiresAt,
    'token_type': tokenType,
    'scope': scope,
    'id_token': idToken,
    'session_state': sessionState,
  };
}

class AccountGroupByOutputType {
  const AccountGroupByOutputType({
    this.id,
    this.userId,
    this.type,
    this.provider,
    this.providerAccountId,
    this.refreshToken,
    this.accessToken,
    this.expiresAt,
    this.tokenType,
    this.scope,
    this.idToken,
    this.sessionState,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AccountGroupByOutputType.fromJson(Map json) =>
      AccountGroupByOutputType(
        id: json['id'],
        userId: json['userId'],
        type: json['type'],
        provider: json['provider'],
        providerAccountId: json['providerAccountId'],
        refreshToken: json['refresh_token'],
        accessToken: json['access_token'],
        expiresAt: json['expires_at'],
        tokenType: json['token_type'],
        scope: json['scope'],
        idToken: json['id_token'],
        sessionState: json['session_state'],
        $count: json['_count'] is Map
            ? _i2.AccountCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.AccountAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.AccountSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.AccountMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.AccountMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? id;

  final String? userId;

  final String? type;

  final String? provider;

  final String? providerAccountId;

  final String? refreshToken;

  final String? accessToken;

  final int? expiresAt;

  final String? tokenType;

  final String? scope;

  final String? idToken;

  final String? sessionState;

  final _i2.AccountCountAggregateOutputType? $count;

  final _i2.AccountAvgAggregateOutputType? $avg;

  final _i2.AccountSumAggregateOutputType? $sum;

  final _i2.AccountMinAggregateOutputType? $min;

  final _i2.AccountMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'type': type,
    'provider': provider,
    'providerAccountId': providerAccountId,
    'refresh_token': refreshToken,
    'access_token': accessToken,
    'expires_at': expiresAt,
    'token_type': tokenType,
    'scope': scope,
    'id_token': idToken,
    'session_state': sessionState,
    '_count': $count?.toJson(),
    '_avg': $avg?.toJson(),
    '_sum': $sum?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class AccountCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AccountCountOrderByAggregateInput({
    this.id,
    this.userId,
    this.type,
    this.provider,
    this.providerAccountId,
    this.refreshToken,
    this.accessToken,
    this.expiresAt,
    this.tokenType,
    this.scope,
    this.idToken,
    this.sessionState,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? type;

  final _i2.SortOrder? provider;

  final _i2.SortOrder? providerAccountId;

  final _i2.SortOrder? refreshToken;

  final _i2.SortOrder? accessToken;

  final _i2.SortOrder? expiresAt;

  final _i2.SortOrder? tokenType;

  final _i2.SortOrder? scope;

  final _i2.SortOrder? idToken;

  final _i2.SortOrder? sessionState;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'type': type,
    'provider': provider,
    'providerAccountId': providerAccountId,
    'refresh_token': refreshToken,
    'access_token': accessToken,
    'expires_at': expiresAt,
    'token_type': tokenType,
    'scope': scope,
    'id_token': idToken,
    'session_state': sessionState,
  };
}

class AccountAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AccountAvgOrderByAggregateInput({this.expiresAt});

  final _i2.SortOrder? expiresAt;

  @override
  Map<String, dynamic> toJson() => {'expires_at': expiresAt};
}

class AccountMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AccountMaxOrderByAggregateInput({
    this.id,
    this.userId,
    this.type,
    this.provider,
    this.providerAccountId,
    this.refreshToken,
    this.accessToken,
    this.expiresAt,
    this.tokenType,
    this.scope,
    this.idToken,
    this.sessionState,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? type;

  final _i2.SortOrder? provider;

  final _i2.SortOrder? providerAccountId;

  final _i2.SortOrder? refreshToken;

  final _i2.SortOrder? accessToken;

  final _i2.SortOrder? expiresAt;

  final _i2.SortOrder? tokenType;

  final _i2.SortOrder? scope;

  final _i2.SortOrder? idToken;

  final _i2.SortOrder? sessionState;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'type': type,
    'provider': provider,
    'providerAccountId': providerAccountId,
    'refresh_token': refreshToken,
    'access_token': accessToken,
    'expires_at': expiresAt,
    'token_type': tokenType,
    'scope': scope,
    'id_token': idToken,
    'session_state': sessionState,
  };
}

class AccountMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AccountMinOrderByAggregateInput({
    this.id,
    this.userId,
    this.type,
    this.provider,
    this.providerAccountId,
    this.refreshToken,
    this.accessToken,
    this.expiresAt,
    this.tokenType,
    this.scope,
    this.idToken,
    this.sessionState,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? type;

  final _i2.SortOrder? provider;

  final _i2.SortOrder? providerAccountId;

  final _i2.SortOrder? refreshToken;

  final _i2.SortOrder? accessToken;

  final _i2.SortOrder? expiresAt;

  final _i2.SortOrder? tokenType;

  final _i2.SortOrder? scope;

  final _i2.SortOrder? idToken;

  final _i2.SortOrder? sessionState;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'type': type,
    'provider': provider,
    'providerAccountId': providerAccountId,
    'refresh_token': refreshToken,
    'access_token': accessToken,
    'expires_at': expiresAt,
    'token_type': tokenType,
    'scope': scope,
    'id_token': idToken,
    'session_state': sessionState,
  };
}

class AccountSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AccountSumOrderByAggregateInput({this.expiresAt});

  final _i2.SortOrder? expiresAt;

  @override
  Map<String, dynamic> toJson() => {'expires_at': expiresAt};
}

class AccountOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AccountOrderByWithAggregationInput({
    this.id,
    this.userId,
    this.type,
    this.provider,
    this.providerAccountId,
    this.refreshToken,
    this.accessToken,
    this.expiresAt,
    this.tokenType,
    this.scope,
    this.idToken,
    this.sessionState,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? type;

  final _i2.SortOrder? provider;

  final _i2.SortOrder? providerAccountId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? refreshToken;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? accessToken;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? expiresAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? tokenType;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? scope;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? idToken;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? sessionState;

  final _i2.AccountCountOrderByAggregateInput? $count;

  final _i2.AccountAvgOrderByAggregateInput? $avg;

  final _i2.AccountMaxOrderByAggregateInput? $max;

  final _i2.AccountMinOrderByAggregateInput? $min;

  final _i2.AccountSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'type': type,
    'provider': provider,
    'providerAccountId': providerAccountId,
    'refresh_token': refreshToken,
    'access_token': accessToken,
    'expires_at': expiresAt,
    'token_type': tokenType,
    'scope': scope,
    'id_token': idToken,
    'session_state': sessionState,
    '_count': $count,
    '_avg': $avg,
    '_max': $max,
    '_min': $min,
    '_sum': $sum,
  };
}

class AccountScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AccountScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.userId,
    this.type,
    this.provider,
    this.providerAccountId,
    this.refreshToken,
    this.accessToken,
    this.expiresAt,
    this.tokenType,
    this.scope,
    this.idToken,
    this.sessionState,
  });

  final _i1.PrismaUnion<
    _i2.AccountScalarWhereWithAggregatesInput,
    Iterable<_i2.AccountScalarWhereWithAggregatesInput>
  >?
  AND;

  final Iterable<_i2.AccountScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<
    _i2.AccountScalarWhereWithAggregatesInput,
    Iterable<_i2.AccountScalarWhereWithAggregatesInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? userId;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? type;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? provider;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>?
  providerAccountId;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  refreshToken;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  accessToken;

  final _i1.PrismaUnion<
    _i2.IntNullableWithAggregatesFilter,
    _i1.PrismaUnion<int, _i1.PrismaNull>
  >?
  expiresAt;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  tokenType;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  scope;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  idToken;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  sessionState;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'userId': userId,
    'type': type,
    'provider': provider,
    'providerAccountId': providerAccountId,
    'refresh_token': refreshToken,
    'access_token': accessToken,
    'expires_at': expiresAt,
    'token_type': tokenType,
    'scope': scope,
    'id_token': idToken,
    'session_state': sessionState,
  };
}

class AccountCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AccountCountAggregateOutputTypeSelect({
    this.id,
    this.userId,
    this.type,
    this.provider,
    this.providerAccountId,
    this.refreshToken,
    this.accessToken,
    this.expiresAt,
    this.tokenType,
    this.scope,
    this.idToken,
    this.sessionState,
    this.$all,
  });

  final bool? id;

  final bool? userId;

  final bool? type;

  final bool? provider;

  final bool? providerAccountId;

  final bool? refreshToken;

  final bool? accessToken;

  final bool? expiresAt;

  final bool? tokenType;

  final bool? scope;

  final bool? idToken;

  final bool? sessionState;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'type': type,
    'provider': provider,
    'providerAccountId': providerAccountId,
    'refresh_token': refreshToken,
    'access_token': accessToken,
    'expires_at': expiresAt,
    'token_type': tokenType,
    'scope': scope,
    'id_token': idToken,
    'session_state': sessionState,
    '_all': $all,
  };
}

class AccountGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AccountGroupByOutputTypeCountArgs({this.select});

  final _i2.AccountCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AccountAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AccountAvgAggregateOutputTypeSelect({this.expiresAt});

  final bool? expiresAt;

  @override
  Map<String, dynamic> toJson() => {'expires_at': expiresAt};
}

class AccountGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AccountGroupByOutputTypeAvgArgs({this.select});

  final _i2.AccountAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AccountSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AccountSumAggregateOutputTypeSelect({this.expiresAt});

  final bool? expiresAt;

  @override
  Map<String, dynamic> toJson() => {'expires_at': expiresAt};
}

class AccountGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AccountGroupByOutputTypeSumArgs({this.select});

  final _i2.AccountSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AccountMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AccountMinAggregateOutputTypeSelect({
    this.id,
    this.userId,
    this.type,
    this.provider,
    this.providerAccountId,
    this.refreshToken,
    this.accessToken,
    this.expiresAt,
    this.tokenType,
    this.scope,
    this.idToken,
    this.sessionState,
  });

  final bool? id;

  final bool? userId;

  final bool? type;

  final bool? provider;

  final bool? providerAccountId;

  final bool? refreshToken;

  final bool? accessToken;

  final bool? expiresAt;

  final bool? tokenType;

  final bool? scope;

  final bool? idToken;

  final bool? sessionState;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'type': type,
    'provider': provider,
    'providerAccountId': providerAccountId,
    'refresh_token': refreshToken,
    'access_token': accessToken,
    'expires_at': expiresAt,
    'token_type': tokenType,
    'scope': scope,
    'id_token': idToken,
    'session_state': sessionState,
  };
}

class AccountGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AccountGroupByOutputTypeMinArgs({this.select});

  final _i2.AccountMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AccountMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AccountMaxAggregateOutputTypeSelect({
    this.id,
    this.userId,
    this.type,
    this.provider,
    this.providerAccountId,
    this.refreshToken,
    this.accessToken,
    this.expiresAt,
    this.tokenType,
    this.scope,
    this.idToken,
    this.sessionState,
  });

  final bool? id;

  final bool? userId;

  final bool? type;

  final bool? provider;

  final bool? providerAccountId;

  final bool? refreshToken;

  final bool? accessToken;

  final bool? expiresAt;

  final bool? tokenType;

  final bool? scope;

  final bool? idToken;

  final bool? sessionState;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'type': type,
    'provider': provider,
    'providerAccountId': providerAccountId,
    'refresh_token': refreshToken,
    'access_token': accessToken,
    'expires_at': expiresAt,
    'token_type': tokenType,
    'scope': scope,
    'id_token': idToken,
    'session_state': sessionState,
  };
}

class AccountGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AccountGroupByOutputTypeMaxArgs({this.select});

  final _i2.AccountMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AccountGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AccountGroupByOutputTypeSelect({
    this.id,
    this.userId,
    this.type,
    this.provider,
    this.providerAccountId,
    this.refreshToken,
    this.accessToken,
    this.expiresAt,
    this.tokenType,
    this.scope,
    this.idToken,
    this.sessionState,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? userId;

  final bool? type;

  final bool? provider;

  final bool? providerAccountId;

  final bool? refreshToken;

  final bool? accessToken;

  final bool? expiresAt;

  final bool? tokenType;

  final bool? scope;

  final bool? idToken;

  final bool? sessionState;

  final _i1.PrismaUnion<bool, _i2.AccountGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AccountGroupByOutputTypeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AccountGroupByOutputTypeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AccountGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AccountGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'type': type,
    'provider': provider,
    'providerAccountId': providerAccountId,
    'refresh_token': refreshToken,
    'access_token': accessToken,
    'expires_at': expiresAt,
    'token_type': tokenType,
    'scope': scope,
    'id_token': idToken,
    'session_state': sessionState,
    '_count': $count,
    '_avg': $avg,
    '_sum': $sum,
    '_min': $min,
    '_max': $max,
  };
}

class AggregateAccount {
  const AggregateAccount({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateAccount.fromJson(Map json) => AggregateAccount(
    $count: json['_count'] is Map
        ? _i2.AccountCountAggregateOutputType.fromJson(json['_count'])
        : null,
    $avg: json['_avg'] is Map
        ? _i2.AccountAvgAggregateOutputType.fromJson(json['_avg'])
        : null,
    $sum: json['_sum'] is Map
        ? _i2.AccountSumAggregateOutputType.fromJson(json['_sum'])
        : null,
    $min: json['_min'] is Map
        ? _i2.AccountMinAggregateOutputType.fromJson(json['_min'])
        : null,
    $max: json['_max'] is Map
        ? _i2.AccountMaxAggregateOutputType.fromJson(json['_max'])
        : null,
  );

  final _i2.AccountCountAggregateOutputType? $count;

  final _i2.AccountAvgAggregateOutputType? $avg;

  final _i2.AccountSumAggregateOutputType? $sum;

  final _i2.AccountMinAggregateOutputType? $min;

  final _i2.AccountMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    '_count': $count?.toJson(),
    '_avg': $avg?.toJson(),
    '_sum': $sum?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class AggregateAccountCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateAccountCountArgs({this.select});

  final _i2.AccountCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateAccountAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateAccountAvgArgs({this.select});

  final _i2.AccountAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateAccountSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateAccountSumArgs({this.select});

  final _i2.AccountSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateAccountMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateAccountMinArgs({this.select});

  final _i2.AccountMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateAccountMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateAccountMaxArgs({this.select});

  final _i2.AccountMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateAccountSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateAccountSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateAccountCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateAccountAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateAccountSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateAccountMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateAccountMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    '_count': $count,
    '_avg': $avg,
    '_sum': $sum,
    '_min': $min,
    '_max': $max,
  };
}

class UserCreateWithoutSessionsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateWithoutSessionsInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.cookiePreferences,
    this.notificationPreferences,
    this.payment,
    this.consultantProfile,
    this.consulteeProfile,
    this.staffProfile,
    this.slotsOfAppointment,
    this.waitlist,
    this.feedbacks,
    this.supportTickets,
    this.supportResponses,
    this.accounts,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? email;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? emailVerified;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? image;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? address;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? password;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? passwordResetToken;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? passwordResetExpires;

  final bool? onlineStatus;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? currentTimezone;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? onboardingCompleted;

  final _i1.PrismaUnion<_i3.UserRole, _i1.PrismaNull>? role;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consultantProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consulteeProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? staffProfileId;

  final _i2.CookiePreferenceCreateNestedOneWithoutUserInput? cookiePreferences;

  final _i2.NotificationPreferenceCreateNestedOneWithoutUserInput?
  notificationPreferences;

  final _i2.PaymentCreateNestedManyWithoutUserInput? payment;

  final _i2.ConsultantProfileCreateNestedOneWithoutUserInput? consultantProfile;

  final _i2.ConsulteeProfileCreateNestedOneWithoutUserInput? consulteeProfile;

  final _i2.StaffProfileCreateNestedOneWithoutUserInput? staffProfile;

  final _i2.SlotOfAppointmentCreateNestedManyWithoutUserInput?
  slotsOfAppointment;

  final _i2.WaitlistCreateNestedManyWithoutUserInput? waitlist;

  final _i2.FeedbackCreateNestedManyWithoutUserInput? feedbacks;

  final _i2.SupportTicketCreateNestedManyWithoutUserInput? supportTickets;

  final _i2.SupportResponseCreateNestedManyWithoutUserInput? supportResponses;

  final _i2.AccountCreateNestedManyWithoutUserInput? accounts;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'cookiePreferences': cookiePreferences,
    'notificationPreferences': notificationPreferences,
    'Payment': payment,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
    'staffProfile': staffProfile,
    'slotsOfAppointment': slotsOfAppointment,
    'Waitlist': waitlist,
    'feedbacks': feedbacks,
    'supportTickets': supportTickets,
    'supportResponses': supportResponses,
    'accounts': accounts,
  };
}

class UserUncheckedCreateWithoutSessionsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUncheckedCreateWithoutSessionsInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.cookiePreferences,
    this.notificationPreferences,
    this.payment,
    this.consultantProfile,
    this.consulteeProfile,
    this.staffProfile,
    this.slotsOfAppointment,
    this.waitlist,
    this.feedbacks,
    this.supportTickets,
    this.supportResponses,
    this.accounts,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? email;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? emailVerified;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? image;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? address;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? password;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? passwordResetToken;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? passwordResetExpires;

  final bool? onlineStatus;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? currentTimezone;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? onboardingCompleted;

  final _i1.PrismaUnion<_i3.UserRole, _i1.PrismaNull>? role;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consultantProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consulteeProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? staffProfileId;

  final _i2.CookiePreferenceUncheckedCreateNestedOneWithoutUserInput?
  cookiePreferences;

  final _i2.NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput?
  notificationPreferences;

  final _i2.PaymentUncheckedCreateNestedManyWithoutUserInput? payment;

  final _i2.ConsultantProfileUncheckedCreateNestedOneWithoutUserInput?
  consultantProfile;

  final _i2.ConsulteeProfileUncheckedCreateNestedOneWithoutUserInput?
  consulteeProfile;

  final _i2.StaffProfileUncheckedCreateNestedOneWithoutUserInput? staffProfile;

  final _i2.SlotOfAppointmentUncheckedCreateNestedManyWithoutUserInput?
  slotsOfAppointment;

  final _i2.WaitlistUncheckedCreateNestedManyWithoutUserInput? waitlist;

  final _i2.FeedbackUncheckedCreateNestedManyWithoutUserInput? feedbacks;

  final _i2.SupportTicketUncheckedCreateNestedManyWithoutUserInput?
  supportTickets;

  final _i2.SupportResponseUncheckedCreateNestedManyWithoutUserInput?
  supportResponses;

  final _i2.AccountUncheckedCreateNestedManyWithoutUserInput? accounts;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'cookiePreferences': cookiePreferences,
    'notificationPreferences': notificationPreferences,
    'Payment': payment,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
    'staffProfile': staffProfile,
    'slotsOfAppointment': slotsOfAppointment,
    'Waitlist': waitlist,
    'feedbacks': feedbacks,
    'supportTickets': supportTickets,
    'supportResponses': supportResponses,
    'accounts': accounts,
  };
}

class UserCreateOrConnectWithoutSessionsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateOrConnectWithoutSessionsInput({
    required this.where,
    required this.create,
  });

  final _i2.UserWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.UserCreateWithoutSessionsInput,
    _i2.UserUncheckedCreateWithoutSessionsInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class UserCreateNestedOneWithoutSessionsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateNestedOneWithoutSessionsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.UserCreateWithoutSessionsInput,
    _i2.UserUncheckedCreateWithoutSessionsInput
  >?
  create;

  final _i2.UserCreateOrConnectWithoutSessionsInput? connectOrCreate;

  final _i2.UserWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class SessionCreateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SessionCreateInput({
    this.id,
    required this.sessionToken,
    required this.expires,
    required this.user,
  });

  final String? id;

  final String sessionToken;

  final DateTime expires;

  final _i2.UserCreateNestedOneWithoutSessionsInput user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'sessionToken': sessionToken,
    'expires': expires,
    'user': user,
  };
}

class SessionUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SessionUncheckedCreateInput({
    this.id,
    required this.sessionToken,
    required this.userId,
    required this.expires,
  });

  final String? id;

  final String sessionToken;

  final String userId;

  final DateTime expires;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'sessionToken': sessionToken,
    'userId': userId,
    'expires': expires,
  };
}

class SessionCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SessionCreateManyInput({
    this.id,
    required this.sessionToken,
    required this.userId,
    required this.expires,
  });

  final String? id;

  final String sessionToken;

  final String userId;

  final DateTime expires;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'sessionToken': sessionToken,
    'userId': userId,
    'expires': expires,
  };
}

class UserUpdateWithoutSessionsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpdateWithoutSessionsInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.cookiePreferences,
    this.notificationPreferences,
    this.payment,
    this.consultantProfile,
    this.consulteeProfile,
    this.staffProfile,
    this.slotsOfAppointment,
    this.waitlist,
    this.feedbacks,
    this.supportTickets,
    this.supportResponses,
    this.accounts,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  name;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  email;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  emailVerified;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  image;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  phone;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  address;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  password;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetToken;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetExpires;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? onlineStatus;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  currentTimezone;

  final _i1.PrismaUnion<
    bool,
    _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  onboardingCompleted;

  final _i1.PrismaUnion<
    _i3.UserRole,
    _i1.PrismaUnion<
      _i2.NullableEnumUserRoleFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  role;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consultantProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consulteeProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  staffProfileId;

  final _i2.CookiePreferenceUpdateOneWithoutUserNestedInput? cookiePreferences;

  final _i2.NotificationPreferenceUpdateOneWithoutUserNestedInput?
  notificationPreferences;

  final _i2.PaymentUpdateManyWithoutUserNestedInput? payment;

  final _i2.ConsultantProfileUpdateOneWithoutUserNestedInput? consultantProfile;

  final _i2.ConsulteeProfileUpdateOneWithoutUserNestedInput? consulteeProfile;

  final _i2.StaffProfileUpdateOneWithoutUserNestedInput? staffProfile;

  final _i2.SlotOfAppointmentUpdateManyWithoutUserNestedInput?
  slotsOfAppointment;

  final _i2.WaitlistUpdateManyWithoutUserNestedInput? waitlist;

  final _i2.FeedbackUpdateManyWithoutUserNestedInput? feedbacks;

  final _i2.SupportTicketUpdateManyWithoutUserNestedInput? supportTickets;

  final _i2.SupportResponseUpdateManyWithoutUserNestedInput? supportResponses;

  final _i2.AccountUpdateManyWithoutUserNestedInput? accounts;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'cookiePreferences': cookiePreferences,
    'notificationPreferences': notificationPreferences,
    'Payment': payment,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
    'staffProfile': staffProfile,
    'slotsOfAppointment': slotsOfAppointment,
    'Waitlist': waitlist,
    'feedbacks': feedbacks,
    'supportTickets': supportTickets,
    'supportResponses': supportResponses,
    'accounts': accounts,
  };
}

class UserUncheckedUpdateWithoutSessionsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUncheckedUpdateWithoutSessionsInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.cookiePreferences,
    this.notificationPreferences,
    this.payment,
    this.consultantProfile,
    this.consulteeProfile,
    this.staffProfile,
    this.slotsOfAppointment,
    this.waitlist,
    this.feedbacks,
    this.supportTickets,
    this.supportResponses,
    this.accounts,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  name;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  email;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  emailVerified;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  image;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  phone;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  address;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  password;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetToken;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetExpires;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? onlineStatus;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  currentTimezone;

  final _i1.PrismaUnion<
    bool,
    _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  onboardingCompleted;

  final _i1.PrismaUnion<
    _i3.UserRole,
    _i1.PrismaUnion<
      _i2.NullableEnumUserRoleFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  role;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consultantProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consulteeProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  staffProfileId;

  final _i2.CookiePreferenceUncheckedUpdateOneWithoutUserNestedInput?
  cookiePreferences;

  final _i2.NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput?
  notificationPreferences;

  final _i2.PaymentUncheckedUpdateManyWithoutUserNestedInput? payment;

  final _i2.ConsultantProfileUncheckedUpdateOneWithoutUserNestedInput?
  consultantProfile;

  final _i2.ConsulteeProfileUncheckedUpdateOneWithoutUserNestedInput?
  consulteeProfile;

  final _i2.StaffProfileUncheckedUpdateOneWithoutUserNestedInput? staffProfile;

  final _i2.SlotOfAppointmentUncheckedUpdateManyWithoutUserNestedInput?
  slotsOfAppointment;

  final _i2.WaitlistUncheckedUpdateManyWithoutUserNestedInput? waitlist;

  final _i2.FeedbackUncheckedUpdateManyWithoutUserNestedInput? feedbacks;

  final _i2.SupportTicketUncheckedUpdateManyWithoutUserNestedInput?
  supportTickets;

  final _i2.SupportResponseUncheckedUpdateManyWithoutUserNestedInput?
  supportResponses;

  final _i2.AccountUncheckedUpdateManyWithoutUserNestedInput? accounts;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'cookiePreferences': cookiePreferences,
    'notificationPreferences': notificationPreferences,
    'Payment': payment,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
    'staffProfile': staffProfile,
    'slotsOfAppointment': slotsOfAppointment,
    'Waitlist': waitlist,
    'feedbacks': feedbacks,
    'supportTickets': supportTickets,
    'supportResponses': supportResponses,
    'accounts': accounts,
  };
}

class UserUpsertWithoutSessionsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpsertWithoutSessionsInput({
    required this.update,
    required this.create,
  });

  final _i1.PrismaUnion<
    _i2.UserUpdateWithoutSessionsInput,
    _i2.UserUncheckedUpdateWithoutSessionsInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.UserCreateWithoutSessionsInput,
    _i2.UserUncheckedCreateWithoutSessionsInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'update': update, 'create': create};
}

class UserUpdateOneRequiredWithoutSessionsNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpdateOneRequiredWithoutSessionsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.UserCreateWithoutSessionsInput,
    _i2.UserUncheckedCreateWithoutSessionsInput
  >?
  create;

  final _i2.UserCreateOrConnectWithoutSessionsInput? connectOrCreate;

  final _i2.UserUpsertWithoutSessionsInput? upsert;

  final _i2.UserWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.UserUpdateWithoutSessionsInput,
    _i2.UserUncheckedUpdateWithoutSessionsInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'connect': connect,
    'update': update,
  };
}

class SessionUpdateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SessionUpdateInput({
    this.id,
    this.sessionToken,
    this.expires,
    this.user,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  sessionToken;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  expires;

  final _i2.UserUpdateOneRequiredWithoutSessionsNestedInput? user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'sessionToken': sessionToken,
    'expires': expires,
    'user': user,
  };
}

class SessionUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SessionUncheckedUpdateInput({
    this.id,
    this.sessionToken,
    this.userId,
    this.expires,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  sessionToken;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  expires;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'sessionToken': sessionToken,
    'userId': userId,
    'expires': expires,
  };
}

class SessionUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SessionUncheckedUpdateManyInput({
    this.id,
    this.sessionToken,
    this.userId,
    this.expires,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  sessionToken;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  expires;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'sessionToken': sessionToken,
    'userId': userId,
    'expires': expires,
  };
}

class SessionCountAggregateOutputType {
  const SessionCountAggregateOutputType({
    this.id,
    this.sessionToken,
    this.userId,
    this.expires,
    this.$all,
  });

  factory SessionCountAggregateOutputType.fromJson(Map json) =>
      SessionCountAggregateOutputType(
        id: json['id'],
        sessionToken: json['sessionToken'],
        userId: json['userId'],
        expires: json['expires'],
        $all: json['_all'],
      );

  final int? id;

  final int? sessionToken;

  final int? userId;

  final int? expires;

  final int? $all;

  Map<String, dynamic> toJson() => {
    'id': id,
    'sessionToken': sessionToken,
    'userId': userId,
    'expires': expires,
    '_all': $all,
  };
}

class SessionMinAggregateOutputType {
  const SessionMinAggregateOutputType({
    this.id,
    this.sessionToken,
    this.userId,
    this.expires,
  });

  factory SessionMinAggregateOutputType.fromJson(Map json) =>
      SessionMinAggregateOutputType(
        id: json['id'],
        sessionToken: json['sessionToken'],
        userId: json['userId'],
        expires: switch (json['expires']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['expires'],
        },
      );

  final String? id;

  final String? sessionToken;

  final String? userId;

  final DateTime? expires;

  Map<String, dynamic> toJson() => {
    'id': id,
    'sessionToken': sessionToken,
    'userId': userId,
    'expires': expires?.toIso8601String(),
  };
}

class SessionMaxAggregateOutputType {
  const SessionMaxAggregateOutputType({
    this.id,
    this.sessionToken,
    this.userId,
    this.expires,
  });

  factory SessionMaxAggregateOutputType.fromJson(Map json) =>
      SessionMaxAggregateOutputType(
        id: json['id'],
        sessionToken: json['sessionToken'],
        userId: json['userId'],
        expires: switch (json['expires']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['expires'],
        },
      );

  final String? id;

  final String? sessionToken;

  final String? userId;

  final DateTime? expires;

  Map<String, dynamic> toJson() => {
    'id': id,
    'sessionToken': sessionToken,
    'userId': userId,
    'expires': expires?.toIso8601String(),
  };
}

class SessionGroupByOutputType {
  const SessionGroupByOutputType({
    this.id,
    this.sessionToken,
    this.userId,
    this.expires,
    this.$count,
    this.$min,
    this.$max,
  });

  factory SessionGroupByOutputType.fromJson(Map json) =>
      SessionGroupByOutputType(
        id: json['id'],
        sessionToken: json['sessionToken'],
        userId: json['userId'],
        expires: switch (json['expires']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['expires'],
        },
        $count: json['_count'] is Map
            ? _i2.SessionCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.SessionMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.SessionMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? id;

  final String? sessionToken;

  final String? userId;

  final DateTime? expires;

  final _i2.SessionCountAggregateOutputType? $count;

  final _i2.SessionMinAggregateOutputType? $min;

  final _i2.SessionMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    'id': id,
    'sessionToken': sessionToken,
    'userId': userId,
    'expires': expires?.toIso8601String(),
    '_count': $count?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class SessionCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SessionCountOrderByAggregateInput({
    this.id,
    this.sessionToken,
    this.userId,
    this.expires,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? sessionToken;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? expires;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'sessionToken': sessionToken,
    'userId': userId,
    'expires': expires,
  };
}

class SessionMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SessionMaxOrderByAggregateInput({
    this.id,
    this.sessionToken,
    this.userId,
    this.expires,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? sessionToken;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? expires;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'sessionToken': sessionToken,
    'userId': userId,
    'expires': expires,
  };
}

class SessionMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SessionMinOrderByAggregateInput({
    this.id,
    this.sessionToken,
    this.userId,
    this.expires,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? sessionToken;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? expires;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'sessionToken': sessionToken,
    'userId': userId,
    'expires': expires,
  };
}

class SessionOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SessionOrderByWithAggregationInput({
    this.id,
    this.sessionToken,
    this.userId,
    this.expires,
    this.$count,
    this.$max,
    this.$min,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? sessionToken;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? expires;

  final _i2.SessionCountOrderByAggregateInput? $count;

  final _i2.SessionMaxOrderByAggregateInput? $max;

  final _i2.SessionMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'sessionToken': sessionToken,
    'userId': userId,
    'expires': expires,
    '_count': $count,
    '_max': $max,
    '_min': $min,
  };
}

class SessionScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SessionScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.sessionToken,
    this.userId,
    this.expires,
  });

  final _i1.PrismaUnion<
    _i2.SessionScalarWhereWithAggregatesInput,
    Iterable<_i2.SessionScalarWhereWithAggregatesInput>
  >?
  AND;

  final Iterable<_i2.SessionScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<
    _i2.SessionScalarWhereWithAggregatesInput,
    Iterable<_i2.SessionScalarWhereWithAggregatesInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? sessionToken;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? userId;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? expires;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'sessionToken': sessionToken,
    'userId': userId,
    'expires': expires,
  };
}

class SessionCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SessionCountAggregateOutputTypeSelect({
    this.id,
    this.sessionToken,
    this.userId,
    this.expires,
    this.$all,
  });

  final bool? id;

  final bool? sessionToken;

  final bool? userId;

  final bool? expires;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'sessionToken': sessionToken,
    'userId': userId,
    'expires': expires,
    '_all': $all,
  };
}

class SessionGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SessionGroupByOutputTypeCountArgs({this.select});

  final _i2.SessionCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SessionMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SessionMinAggregateOutputTypeSelect({
    this.id,
    this.sessionToken,
    this.userId,
    this.expires,
  });

  final bool? id;

  final bool? sessionToken;

  final bool? userId;

  final bool? expires;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'sessionToken': sessionToken,
    'userId': userId,
    'expires': expires,
  };
}

class SessionGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SessionGroupByOutputTypeMinArgs({this.select});

  final _i2.SessionMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SessionMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SessionMaxAggregateOutputTypeSelect({
    this.id,
    this.sessionToken,
    this.userId,
    this.expires,
  });

  final bool? id;

  final bool? sessionToken;

  final bool? userId;

  final bool? expires;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'sessionToken': sessionToken,
    'userId': userId,
    'expires': expires,
  };
}

class SessionGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SessionGroupByOutputTypeMaxArgs({this.select});

  final _i2.SessionMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SessionGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SessionGroupByOutputTypeSelect({
    this.id,
    this.sessionToken,
    this.userId,
    this.expires,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? sessionToken;

  final bool? userId;

  final bool? expires;

  final _i1.PrismaUnion<bool, _i2.SessionGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.SessionGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.SessionGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'sessionToken': sessionToken,
    'userId': userId,
    'expires': expires,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class AggregateSession {
  const AggregateSession({this.$count, this.$min, this.$max});

  factory AggregateSession.fromJson(Map json) => AggregateSession(
    $count: json['_count'] is Map
        ? _i2.SessionCountAggregateOutputType.fromJson(json['_count'])
        : null,
    $min: json['_min'] is Map
        ? _i2.SessionMinAggregateOutputType.fromJson(json['_min'])
        : null,
    $max: json['_max'] is Map
        ? _i2.SessionMaxAggregateOutputType.fromJson(json['_max'])
        : null,
  );

  final _i2.SessionCountAggregateOutputType? $count;

  final _i2.SessionMinAggregateOutputType? $min;

  final _i2.SessionMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    '_count': $count?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class AggregateSessionCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSessionCountArgs({this.select});

  final _i2.SessionCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateSessionMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSessionMinArgs({this.select});

  final _i2.SessionMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateSessionMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSessionMaxArgs({this.select});

  final _i2.SessionMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateSessionSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSessionSelect({this.$count, this.$min, this.$max});

  final _i1.PrismaUnion<bool, _i2.AggregateSessionCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateSessionMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateSessionMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class VerificationTokenIdentifierTokenCompoundUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const VerificationTokenIdentifierTokenCompoundUniqueInput({
    required this.identifier,
    required this.token,
  });

  final String identifier;

  final String token;

  @override
  Map<String, dynamic> toJson() => {'identifier': identifier, 'token': token};
}

class VerificationTokenWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const VerificationTokenWhereUniqueInput({this.token, this.identifierToken});

  final String? token;

  final _i2.VerificationTokenIdentifierTokenCompoundUniqueInput?
  identifierToken;

  @override
  Map<String, dynamic> toJson() => {
    'token': token,
    'identifier_token': identifierToken,
  };
}

class VerificationTokenSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const VerificationTokenSelect({this.identifier, this.token, this.expires});

  final bool? identifier;

  final bool? token;

  final bool? expires;

  @override
  Map<String, dynamic> toJson() => {
    'identifier': identifier,
    'token': token,
    'expires': expires,
  };
}

class VerificationTokenWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const VerificationTokenWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.identifier,
    this.token,
    this.expires,
  });

  final _i1.PrismaUnion<
    _i2.VerificationTokenWhereInput,
    Iterable<_i2.VerificationTokenWhereInput>
  >?
  AND;

  final Iterable<_i2.VerificationTokenWhereInput>? OR;

  final _i1.PrismaUnion<
    _i2.VerificationTokenWhereInput,
    Iterable<_i2.VerificationTokenWhereInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? identifier;

  final _i1.PrismaUnion<_i2.StringFilter, String>? token;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? expires;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'identifier': identifier,
    'token': token,
    'expires': expires,
  };
}

class VerificationTokenOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const VerificationTokenOrderByWithRelationInput({
    this.identifier,
    this.token,
    this.expires,
  });

  final _i2.SortOrder? identifier;

  final _i2.SortOrder? token;

  final _i2.SortOrder? expires;

  @override
  Map<String, dynamic> toJson() => {
    'identifier': identifier,
    'token': token,
    'expires': expires,
  };
}

enum VerificationTokenScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  identifier<String>('identifier', 'VerificationToken'),
  token<String>('token', 'VerificationToken'),
  expires<DateTime>('expires', 'VerificationToken');

  const VerificationTokenScalar(this.name, this.model);

  @override
  final String name;

  @override
  final String model;
}

class VerificationTokenCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const VerificationTokenCreateInput({
    required this.identifier,
    required this.token,
    required this.expires,
  });

  final String identifier;

  final String token;

  final DateTime expires;

  @override
  Map<String, dynamic> toJson() => {
    'identifier': identifier,
    'token': token,
    'expires': expires,
  };
}

class VerificationTokenUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const VerificationTokenUncheckedCreateInput({
    required this.identifier,
    required this.token,
    required this.expires,
  });

  final String identifier;

  final String token;

  final DateTime expires;

  @override
  Map<String, dynamic> toJson() => {
    'identifier': identifier,
    'token': token,
    'expires': expires,
  };
}

class VerificationTokenCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const VerificationTokenCreateManyInput({
    required this.identifier,
    required this.token,
    required this.expires,
  });

  final String identifier;

  final String token;

  final DateTime expires;

  @override
  Map<String, dynamic> toJson() => {
    'identifier': identifier,
    'token': token,
    'expires': expires,
  };
}

class VerificationTokenUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const VerificationTokenUpdateInput({
    this.identifier,
    this.token,
    this.expires,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  identifier;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? token;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  expires;

  @override
  Map<String, dynamic> toJson() => {
    'identifier': identifier,
    'token': token,
    'expires': expires,
  };
}

class VerificationTokenUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const VerificationTokenUncheckedUpdateInput({
    this.identifier,
    this.token,
    this.expires,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  identifier;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? token;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  expires;

  @override
  Map<String, dynamic> toJson() => {
    'identifier': identifier,
    'token': token,
    'expires': expires,
  };
}

class VerificationTokenUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const VerificationTokenUpdateManyMutationInput({
    this.identifier,
    this.token,
    this.expires,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  identifier;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? token;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  expires;

  @override
  Map<String, dynamic> toJson() => {
    'identifier': identifier,
    'token': token,
    'expires': expires,
  };
}

class VerificationTokenUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const VerificationTokenUncheckedUpdateManyInput({
    this.identifier,
    this.token,
    this.expires,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  identifier;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? token;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  expires;

  @override
  Map<String, dynamic> toJson() => {
    'identifier': identifier,
    'token': token,
    'expires': expires,
  };
}

class VerificationTokenCountAggregateOutputType {
  const VerificationTokenCountAggregateOutputType({
    this.identifier,
    this.token,
    this.expires,
    this.$all,
  });

  factory VerificationTokenCountAggregateOutputType.fromJson(Map json) =>
      VerificationTokenCountAggregateOutputType(
        identifier: json['identifier'],
        token: json['token'],
        expires: json['expires'],
        $all: json['_all'],
      );

  final int? identifier;

  final int? token;

  final int? expires;

  final int? $all;

  Map<String, dynamic> toJson() => {
    'identifier': identifier,
    'token': token,
    'expires': expires,
    '_all': $all,
  };
}

class VerificationTokenMinAggregateOutputType {
  const VerificationTokenMinAggregateOutputType({
    this.identifier,
    this.token,
    this.expires,
  });

  factory VerificationTokenMinAggregateOutputType.fromJson(Map json) =>
      VerificationTokenMinAggregateOutputType(
        identifier: json['identifier'],
        token: json['token'],
        expires: switch (json['expires']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['expires'],
        },
      );

  final String? identifier;

  final String? token;

  final DateTime? expires;

  Map<String, dynamic> toJson() => {
    'identifier': identifier,
    'token': token,
    'expires': expires?.toIso8601String(),
  };
}

class VerificationTokenMaxAggregateOutputType {
  const VerificationTokenMaxAggregateOutputType({
    this.identifier,
    this.token,
    this.expires,
  });

  factory VerificationTokenMaxAggregateOutputType.fromJson(Map json) =>
      VerificationTokenMaxAggregateOutputType(
        identifier: json['identifier'],
        token: json['token'],
        expires: switch (json['expires']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['expires'],
        },
      );

  final String? identifier;

  final String? token;

  final DateTime? expires;

  Map<String, dynamic> toJson() => {
    'identifier': identifier,
    'token': token,
    'expires': expires?.toIso8601String(),
  };
}

class VerificationTokenGroupByOutputType {
  const VerificationTokenGroupByOutputType({
    this.identifier,
    this.token,
    this.expires,
    this.$count,
    this.$min,
    this.$max,
  });

  factory VerificationTokenGroupByOutputType.fromJson(Map json) =>
      VerificationTokenGroupByOutputType(
        identifier: json['identifier'],
        token: json['token'],
        expires: switch (json['expires']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['expires'],
        },
        $count: json['_count'] is Map
            ? _i2.VerificationTokenCountAggregateOutputType.fromJson(
                json['_count'],
              )
            : null,
        $min: json['_min'] is Map
            ? _i2.VerificationTokenMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.VerificationTokenMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? identifier;

  final String? token;

  final DateTime? expires;

  final _i2.VerificationTokenCountAggregateOutputType? $count;

  final _i2.VerificationTokenMinAggregateOutputType? $min;

  final _i2.VerificationTokenMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    'identifier': identifier,
    'token': token,
    'expires': expires?.toIso8601String(),
    '_count': $count?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class VerificationTokenCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const VerificationTokenCountOrderByAggregateInput({
    this.identifier,
    this.token,
    this.expires,
  });

  final _i2.SortOrder? identifier;

  final _i2.SortOrder? token;

  final _i2.SortOrder? expires;

  @override
  Map<String, dynamic> toJson() => {
    'identifier': identifier,
    'token': token,
    'expires': expires,
  };
}

class VerificationTokenMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const VerificationTokenMaxOrderByAggregateInput({
    this.identifier,
    this.token,
    this.expires,
  });

  final _i2.SortOrder? identifier;

  final _i2.SortOrder? token;

  final _i2.SortOrder? expires;

  @override
  Map<String, dynamic> toJson() => {
    'identifier': identifier,
    'token': token,
    'expires': expires,
  };
}

class VerificationTokenMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const VerificationTokenMinOrderByAggregateInput({
    this.identifier,
    this.token,
    this.expires,
  });

  final _i2.SortOrder? identifier;

  final _i2.SortOrder? token;

  final _i2.SortOrder? expires;

  @override
  Map<String, dynamic> toJson() => {
    'identifier': identifier,
    'token': token,
    'expires': expires,
  };
}

class VerificationTokenOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const VerificationTokenOrderByWithAggregationInput({
    this.identifier,
    this.token,
    this.expires,
    this.$count,
    this.$max,
    this.$min,
  });

  final _i2.SortOrder? identifier;

  final _i2.SortOrder? token;

  final _i2.SortOrder? expires;

  final _i2.VerificationTokenCountOrderByAggregateInput? $count;

  final _i2.VerificationTokenMaxOrderByAggregateInput? $max;

  final _i2.VerificationTokenMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() => {
    'identifier': identifier,
    'token': token,
    'expires': expires,
    '_count': $count,
    '_max': $max,
    '_min': $min,
  };
}

class VerificationTokenScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const VerificationTokenScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.identifier,
    this.token,
    this.expires,
  });

  final _i1.PrismaUnion<
    _i2.VerificationTokenScalarWhereWithAggregatesInput,
    Iterable<_i2.VerificationTokenScalarWhereWithAggregatesInput>
  >?
  AND;

  final Iterable<_i2.VerificationTokenScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<
    _i2.VerificationTokenScalarWhereWithAggregatesInput,
    Iterable<_i2.VerificationTokenScalarWhereWithAggregatesInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? identifier;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? token;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? expires;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'identifier': identifier,
    'token': token,
    'expires': expires,
  };
}

class VerificationTokenCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const VerificationTokenCountAggregateOutputTypeSelect({
    this.identifier,
    this.token,
    this.expires,
    this.$all,
  });

  final bool? identifier;

  final bool? token;

  final bool? expires;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
    'identifier': identifier,
    'token': token,
    'expires': expires,
    '_all': $all,
  };
}

class VerificationTokenGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const VerificationTokenGroupByOutputTypeCountArgs({this.select});

  final _i2.VerificationTokenCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class VerificationTokenMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const VerificationTokenMinAggregateOutputTypeSelect({
    this.identifier,
    this.token,
    this.expires,
  });

  final bool? identifier;

  final bool? token;

  final bool? expires;

  @override
  Map<String, dynamic> toJson() => {
    'identifier': identifier,
    'token': token,
    'expires': expires,
  };
}

class VerificationTokenGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const VerificationTokenGroupByOutputTypeMinArgs({this.select});

  final _i2.VerificationTokenMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class VerificationTokenMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const VerificationTokenMaxAggregateOutputTypeSelect({
    this.identifier,
    this.token,
    this.expires,
  });

  final bool? identifier;

  final bool? token;

  final bool? expires;

  @override
  Map<String, dynamic> toJson() => {
    'identifier': identifier,
    'token': token,
    'expires': expires,
  };
}

class VerificationTokenGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const VerificationTokenGroupByOutputTypeMaxArgs({this.select});

  final _i2.VerificationTokenMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class VerificationTokenGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const VerificationTokenGroupByOutputTypeSelect({
    this.identifier,
    this.token,
    this.expires,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? identifier;

  final bool? token;

  final bool? expires;

  final _i1.PrismaUnion<bool, _i2.VerificationTokenGroupByOutputTypeCountArgs>?
  $count;

  final _i1.PrismaUnion<bool, _i2.VerificationTokenGroupByOutputTypeMinArgs>?
  $min;

  final _i1.PrismaUnion<bool, _i2.VerificationTokenGroupByOutputTypeMaxArgs>?
  $max;

  @override
  Map<String, dynamic> toJson() => {
    'identifier': identifier,
    'token': token,
    'expires': expires,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class AggregateVerificationToken {
  const AggregateVerificationToken({this.$count, this.$min, this.$max});

  factory AggregateVerificationToken.fromJson(Map json) =>
      AggregateVerificationToken(
        $count: json['_count'] is Map
            ? _i2.VerificationTokenCountAggregateOutputType.fromJson(
                json['_count'],
              )
            : null,
        $min: json['_min'] is Map
            ? _i2.VerificationTokenMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.VerificationTokenMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.VerificationTokenCountAggregateOutputType? $count;

  final _i2.VerificationTokenMinAggregateOutputType? $min;

  final _i2.VerificationTokenMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    '_count': $count?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class AggregateVerificationTokenCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateVerificationTokenCountArgs({this.select});

  final _i2.VerificationTokenCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateVerificationTokenMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateVerificationTokenMinArgs({this.select});

  final _i2.VerificationTokenMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateVerificationTokenMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateVerificationTokenMaxArgs({this.select});

  final _i2.VerificationTokenMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateVerificationTokenSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateVerificationTokenSelect({this.$count, this.$min, this.$max});

  final _i1.PrismaUnion<bool, _i2.AggregateVerificationTokenCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateVerificationTokenMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateVerificationTokenMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class ConsultantProfileCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileCreateInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    required this.scheduleType,
    this.createdAt,
    this.updatedAt,
    required this.domain,
    this.subDomains,
    this.tags,
    this.reviews,
    this.slotsOfAvailabilityWeekly,
    this.slotsOfAvailabilityCustom,
    this.consultationPlans,
    this.subscriptionPlans,
    this.webinarPlans,
    this.classPlans,
    required this.user,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? qualifications;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? specialization;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? experience;

  final double? rating;

  final _i3.ScheduleType scheduleType;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.DomainCreateNestedOneWithoutConsultantProfilesInput domain;

  final _i2.SubDomainCreateNestedManyWithoutConsultantProfilesInput? subDomains;

  final _i2.TagCreateNestedManyWithoutConsultantProfilesInput? tags;

  final _i2.ConsultantReviewCreateNestedManyWithoutConsultantProfileInput?
  reviews;

  final _i2.SlotOfAvailabilityWeeklyCreateNestedManyWithoutConsultantProfileInput?
  slotsOfAvailabilityWeekly;

  final _i2.SlotOfAvailabilityCustomCreateNestedManyWithoutConsultantProfileInput?
  slotsOfAvailabilityCustom;

  final _i2.ConsultationPlanCreateNestedManyWithoutConsultantProfileInput?
  consultationPlans;

  final _i2.SubscriptionPlanCreateNestedManyWithoutConsultantProfileInput?
  subscriptionPlans;

  final _i2.WebinarPlanCreateNestedManyWithoutConsultantProfileInput?
  webinarPlans;

  final _i2.ClassPlanCreateNestedManyWithoutConsultantProfileInput? classPlans;

  final _i2.UserCreateNestedOneWithoutConsultantProfileInput user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'scheduleType': scheduleType,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'domain': domain,
    'subDomains': subDomains,
    'tags': tags,
    'reviews': reviews,
    'slotsOfAvailabilityWeekly': slotsOfAvailabilityWeekly,
    'slotsOfAvailabilityCustom': slotsOfAvailabilityCustom,
    'consultationPlans': consultationPlans,
    'subscriptionPlans': subscriptionPlans,
    'webinarPlans': webinarPlans,
    'classPlans': classPlans,
    'user': user,
  };
}

class ConsultantProfileUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUncheckedCreateInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    required this.domainId,
    required this.scheduleType,
    required this.userId,
    this.createdAt,
    this.updatedAt,
    this.subDomains,
    this.tags,
    this.reviews,
    this.slotsOfAvailabilityWeekly,
    this.slotsOfAvailabilityCustom,
    this.consultationPlans,
    this.subscriptionPlans,
    this.webinarPlans,
    this.classPlans,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? qualifications;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? specialization;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? experience;

  final double? rating;

  final String domainId;

  final _i3.ScheduleType scheduleType;

  final String userId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.SubDomainUncheckedCreateNestedManyWithoutConsultantProfilesInput?
  subDomains;

  final _i2.TagUncheckedCreateNestedManyWithoutConsultantProfilesInput? tags;

  final _i2.ConsultantReviewUncheckedCreateNestedManyWithoutConsultantProfileInput?
  reviews;

  final _i2.SlotOfAvailabilityWeeklyUncheckedCreateNestedManyWithoutConsultantProfileInput?
  slotsOfAvailabilityWeekly;

  final _i2.SlotOfAvailabilityCustomUncheckedCreateNestedManyWithoutConsultantProfileInput?
  slotsOfAvailabilityCustom;

  final _i2.ConsultationPlanUncheckedCreateNestedManyWithoutConsultantProfileInput?
  consultationPlans;

  final _i2.SubscriptionPlanUncheckedCreateNestedManyWithoutConsultantProfileInput?
  subscriptionPlans;

  final _i2.WebinarPlanUncheckedCreateNestedManyWithoutConsultantProfileInput?
  webinarPlans;

  final _i2.ClassPlanUncheckedCreateNestedManyWithoutConsultantProfileInput?
  classPlans;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'domainId': domainId,
    'scheduleType': scheduleType,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'subDomains': subDomains,
    'tags': tags,
    'reviews': reviews,
    'slotsOfAvailabilityWeekly': slotsOfAvailabilityWeekly,
    'slotsOfAvailabilityCustom': slotsOfAvailabilityCustom,
    'consultationPlans': consultationPlans,
    'subscriptionPlans': subscriptionPlans,
    'webinarPlans': webinarPlans,
    'classPlans': classPlans,
  };
}

class ConsultantProfileCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileCreateManyInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    required this.domainId,
    required this.scheduleType,
    required this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? qualifications;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? specialization;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? experience;

  final double? rating;

  final String domainId;

  final _i3.ScheduleType scheduleType;

  final String userId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'domainId': domainId,
    'scheduleType': scheduleType,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultantProfileUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUpdateInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    this.scheduleType,
    this.createdAt,
    this.updatedAt,
    this.domain,
    this.subDomains,
    this.tags,
    this.reviews,
    this.slotsOfAvailabilityWeekly,
    this.slotsOfAvailabilityCustom,
    this.consultationPlans,
    this.subscriptionPlans,
    this.webinarPlans,
    this.classPlans,
    this.user,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  qualifications;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  specialization;

  final _i1.PrismaUnion<
    double,
    _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  experience;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? rating;

  final _i1.PrismaUnion<
    _i3.ScheduleType,
    _i2.EnumScheduleTypeFieldUpdateOperationsInput
  >?
  scheduleType;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.DomainUpdateOneRequiredWithoutConsultantProfilesNestedInput? domain;

  final _i2.SubDomainUpdateManyWithoutConsultantProfilesNestedInput? subDomains;

  final _i2.TagUpdateManyWithoutConsultantProfilesNestedInput? tags;

  final _i2.ConsultantReviewUpdateManyWithoutConsultantProfileNestedInput?
  reviews;

  final _i2.SlotOfAvailabilityWeeklyUpdateManyWithoutConsultantProfileNestedInput?
  slotsOfAvailabilityWeekly;

  final _i2.SlotOfAvailabilityCustomUpdateManyWithoutConsultantProfileNestedInput?
  slotsOfAvailabilityCustom;

  final _i2.ConsultationPlanUpdateManyWithoutConsultantProfileNestedInput?
  consultationPlans;

  final _i2.SubscriptionPlanUpdateManyWithoutConsultantProfileNestedInput?
  subscriptionPlans;

  final _i2.WebinarPlanUpdateManyWithoutConsultantProfileNestedInput?
  webinarPlans;

  final _i2.ClassPlanUpdateManyWithoutConsultantProfileNestedInput? classPlans;

  final _i2.UserUpdateOneRequiredWithoutConsultantProfileNestedInput? user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'scheduleType': scheduleType,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'domain': domain,
    'subDomains': subDomains,
    'tags': tags,
    'reviews': reviews,
    'slotsOfAvailabilityWeekly': slotsOfAvailabilityWeekly,
    'slotsOfAvailabilityCustom': slotsOfAvailabilityCustom,
    'consultationPlans': consultationPlans,
    'subscriptionPlans': subscriptionPlans,
    'webinarPlans': webinarPlans,
    'classPlans': classPlans,
    'user': user,
  };
}

class ConsultantProfileUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUncheckedUpdateInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    this.domainId,
    this.scheduleType,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.subDomains,
    this.tags,
    this.reviews,
    this.slotsOfAvailabilityWeekly,
    this.slotsOfAvailabilityCustom,
    this.consultationPlans,
    this.subscriptionPlans,
    this.webinarPlans,
    this.classPlans,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  qualifications;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  specialization;

  final _i1.PrismaUnion<
    double,
    _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  experience;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? rating;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? domainId;

  final _i1.PrismaUnion<
    _i3.ScheduleType,
    _i2.EnumScheduleTypeFieldUpdateOperationsInput
  >?
  scheduleType;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.SubDomainUncheckedUpdateManyWithoutConsultantProfilesNestedInput?
  subDomains;

  final _i2.TagUncheckedUpdateManyWithoutConsultantProfilesNestedInput? tags;

  final _i2.ConsultantReviewUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  reviews;

  final _i2.SlotOfAvailabilityWeeklyUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  slotsOfAvailabilityWeekly;

  final _i2.SlotOfAvailabilityCustomUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  slotsOfAvailabilityCustom;

  final _i2.ConsultationPlanUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  consultationPlans;

  final _i2.SubscriptionPlanUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  subscriptionPlans;

  final _i2.WebinarPlanUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  webinarPlans;

  final _i2.ClassPlanUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  classPlans;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'domainId': domainId,
    'scheduleType': scheduleType,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'subDomains': subDomains,
    'tags': tags,
    'reviews': reviews,
    'slotsOfAvailabilityWeekly': slotsOfAvailabilityWeekly,
    'slotsOfAvailabilityCustom': slotsOfAvailabilityCustom,
    'consultationPlans': consultationPlans,
    'subscriptionPlans': subscriptionPlans,
    'webinarPlans': webinarPlans,
    'classPlans': classPlans,
  };
}

class ConsultantProfileUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUncheckedUpdateManyInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    this.domainId,
    this.scheduleType,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  qualifications;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  specialization;

  final _i1.PrismaUnion<
    double,
    _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  experience;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? rating;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? domainId;

  final _i1.PrismaUnion<
    _i3.ScheduleType,
    _i2.EnumScheduleTypeFieldUpdateOperationsInput
  >?
  scheduleType;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'domainId': domainId,
    'scheduleType': scheduleType,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultantProfileCountAggregateOutputType {
  const ConsultantProfileCountAggregateOutputType({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    this.domainId,
    this.scheduleType,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  factory ConsultantProfileCountAggregateOutputType.fromJson(Map json) =>
      ConsultantProfileCountAggregateOutputType(
        id: json['id'],
        description: json['description'],
        qualifications: json['qualifications'],
        specialization: json['specialization'],
        experience: json['experience'],
        rating: json['rating'],
        domainId: json['domainId'],
        scheduleType: json['scheduleType'],
        userId: json['userId'],
        createdAt: json['createdAt'],
        updatedAt: json['updatedAt'],
        $all: json['_all'],
      );

  final int? id;

  final int? description;

  final int? qualifications;

  final int? specialization;

  final int? experience;

  final int? rating;

  final int? domainId;

  final int? scheduleType;

  final int? userId;

  final int? createdAt;

  final int? updatedAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'domainId': domainId,
    'scheduleType': scheduleType,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class ConsultantProfileAvgAggregateOutputType {
  const ConsultantProfileAvgAggregateOutputType({this.experience, this.rating});

  factory ConsultantProfileAvgAggregateOutputType.fromJson(Map json) =>
      ConsultantProfileAvgAggregateOutputType(
        experience: json['experience'],
        rating: json['rating'],
      );

  final double? experience;

  final double? rating;

  Map<String, dynamic> toJson() => {'experience': experience, 'rating': rating};
}

class ConsultantProfileSumAggregateOutputType {
  const ConsultantProfileSumAggregateOutputType({this.experience, this.rating});

  factory ConsultantProfileSumAggregateOutputType.fromJson(Map json) =>
      ConsultantProfileSumAggregateOutputType(
        experience: json['experience'],
        rating: json['rating'],
      );

  final double? experience;

  final double? rating;

  Map<String, dynamic> toJson() => {'experience': experience, 'rating': rating};
}

class ConsultantProfileMinAggregateOutputType {
  const ConsultantProfileMinAggregateOutputType({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    this.domainId,
    this.scheduleType,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  factory ConsultantProfileMinAggregateOutputType.fromJson(Map json) =>
      ConsultantProfileMinAggregateOutputType(
        id: json['id'],
        description: json['description'],
        qualifications: json['qualifications'],
        specialization: json['specialization'],
        experience: json['experience'],
        rating: json['rating'],
        domainId: json['domainId'],
        scheduleType: json['scheduleType'] != null
            ? _i3.ScheduleType.values.firstWhere(
                (e) => e.name == json['scheduleType'],
              )
            : null,
        userId: json['userId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final String? description;

  final String? qualifications;

  final String? specialization;

  final double? experience;

  final double? rating;

  final String? domainId;

  final _i3.ScheduleType? scheduleType;

  final String? userId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'domainId': domainId,
    'scheduleType': scheduleType?.name,
    'userId': userId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class ConsultantProfileMaxAggregateOutputType {
  const ConsultantProfileMaxAggregateOutputType({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    this.domainId,
    this.scheduleType,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  factory ConsultantProfileMaxAggregateOutputType.fromJson(Map json) =>
      ConsultantProfileMaxAggregateOutputType(
        id: json['id'],
        description: json['description'],
        qualifications: json['qualifications'],
        specialization: json['specialization'],
        experience: json['experience'],
        rating: json['rating'],
        domainId: json['domainId'],
        scheduleType: json['scheduleType'] != null
            ? _i3.ScheduleType.values.firstWhere(
                (e) => e.name == json['scheduleType'],
              )
            : null,
        userId: json['userId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final String? description;

  final String? qualifications;

  final String? specialization;

  final double? experience;

  final double? rating;

  final String? domainId;

  final _i3.ScheduleType? scheduleType;

  final String? userId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'domainId': domainId,
    'scheduleType': scheduleType?.name,
    'userId': userId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class ConsultantProfileGroupByOutputType {
  const ConsultantProfileGroupByOutputType({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    this.domainId,
    this.scheduleType,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory ConsultantProfileGroupByOutputType.fromJson(Map json) =>
      ConsultantProfileGroupByOutputType(
        id: json['id'],
        description: json['description'],
        qualifications: json['qualifications'],
        specialization: json['specialization'],
        experience: json['experience'],
        rating: json['rating'],
        domainId: json['domainId'],
        scheduleType: json['scheduleType'] != null
            ? _i3.ScheduleType.values.firstWhere(
                (e) => e.name == json['scheduleType'],
              )
            : null,
        userId: json['userId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
        $count: json['_count'] is Map
            ? _i2.ConsultantProfileCountAggregateOutputType.fromJson(
                json['_count'],
              )
            : null,
        $avg: json['_avg'] is Map
            ? _i2.ConsultantProfileAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.ConsultantProfileSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.ConsultantProfileMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.ConsultantProfileMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? id;

  final String? description;

  final String? qualifications;

  final String? specialization;

  final double? experience;

  final double? rating;

  final String? domainId;

  final _i3.ScheduleType? scheduleType;

  final String? userId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ConsultantProfileCountAggregateOutputType? $count;

  final _i2.ConsultantProfileAvgAggregateOutputType? $avg;

  final _i2.ConsultantProfileSumAggregateOutputType? $sum;

  final _i2.ConsultantProfileMinAggregateOutputType? $min;

  final _i2.ConsultantProfileMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'domainId': domainId,
    'scheduleType': scheduleType?.name,
    'userId': userId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
    '_count': $count?.toJson(),
    '_avg': $avg?.toJson(),
    '_sum': $sum?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class ConsultantProfileCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileCountOrderByAggregateInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    this.domainId,
    this.scheduleType,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? description;

  final _i2.SortOrder? qualifications;

  final _i2.SortOrder? specialization;

  final _i2.SortOrder? experience;

  final _i2.SortOrder? rating;

  final _i2.SortOrder? domainId;

  final _i2.SortOrder? scheduleType;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'domainId': domainId,
    'scheduleType': scheduleType,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultantProfileAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileAvgOrderByAggregateInput({
    this.experience,
    this.rating,
  });

  final _i2.SortOrder? experience;

  final _i2.SortOrder? rating;

  @override
  Map<String, dynamic> toJson() => {'experience': experience, 'rating': rating};
}

class ConsultantProfileMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileMaxOrderByAggregateInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    this.domainId,
    this.scheduleType,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? description;

  final _i2.SortOrder? qualifications;

  final _i2.SortOrder? specialization;

  final _i2.SortOrder? experience;

  final _i2.SortOrder? rating;

  final _i2.SortOrder? domainId;

  final _i2.SortOrder? scheduleType;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'domainId': domainId,
    'scheduleType': scheduleType,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultantProfileMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileMinOrderByAggregateInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    this.domainId,
    this.scheduleType,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? description;

  final _i2.SortOrder? qualifications;

  final _i2.SortOrder? specialization;

  final _i2.SortOrder? experience;

  final _i2.SortOrder? rating;

  final _i2.SortOrder? domainId;

  final _i2.SortOrder? scheduleType;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'domainId': domainId,
    'scheduleType': scheduleType,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultantProfileSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileSumOrderByAggregateInput({
    this.experience,
    this.rating,
  });

  final _i2.SortOrder? experience;

  final _i2.SortOrder? rating;

  @override
  Map<String, dynamic> toJson() => {'experience': experience, 'rating': rating};
}

class ConsultantProfileOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileOrderByWithAggregationInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    this.domainId,
    this.scheduleType,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? description;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? qualifications;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? specialization;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? experience;

  final _i2.SortOrder? rating;

  final _i2.SortOrder? domainId;

  final _i2.SortOrder? scheduleType;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.ConsultantProfileCountOrderByAggregateInput? $count;

  final _i2.ConsultantProfileAvgOrderByAggregateInput? $avg;

  final _i2.ConsultantProfileMaxOrderByAggregateInput? $max;

  final _i2.ConsultantProfileMinOrderByAggregateInput? $min;

  final _i2.ConsultantProfileSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'domainId': domainId,
    'scheduleType': scheduleType,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_avg': $avg,
    '_max': $max,
    '_min': $min,
    '_sum': $sum,
  };
}

class NestedFloatNullableWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedFloatNullableWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<double, _i1.PrismaNull>? equals;

  final _i1.PrismaUnion<
    Iterable<double>,
    _i1.PrismaUnion<double, _i1.PrismaNull>
  >?
  $in;

  final _i1.PrismaUnion<
    Iterable<double>,
    _i1.PrismaUnion<double, _i1.PrismaNull>
  >?
  notIn;

  final double? lt;

  final double? lte;

  final double? gt;

  final double? gte;

  final _i1.PrismaUnion<
    double,
    _i1.PrismaUnion<_i2.NestedFloatNullableWithAggregatesFilter, _i1.PrismaNull>
  >?
  not;

  final _i2.NestedIntNullableFilter? $count;

  final _i2.NestedFloatNullableFilter? $avg;

  final _i2.NestedFloatNullableFilter? $sum;

  final _i2.NestedFloatNullableFilter? $min;

  final _i2.NestedFloatNullableFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'lt': lt,
    'lte': lte,
    'gt': gt,
    'gte': gte,
    'not': not,
    '_count': $count,
    '_avg': $avg,
    '_sum': $sum,
    '_min': $min,
    '_max': $max,
  };
}

class FloatNullableWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FloatNullableWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<double, _i1.PrismaNull>? equals;

  final _i1.PrismaUnion<
    Iterable<double>,
    _i1.PrismaUnion<double, _i1.PrismaNull>
  >?
  $in;

  final _i1.PrismaUnion<
    Iterable<double>,
    _i1.PrismaUnion<double, _i1.PrismaNull>
  >?
  notIn;

  final double? lt;

  final double? lte;

  final double? gt;

  final double? gte;

  final _i1.PrismaUnion<
    double,
    _i1.PrismaUnion<_i2.NestedFloatNullableWithAggregatesFilter, _i1.PrismaNull>
  >?
  not;

  final _i2.NestedIntNullableFilter? $count;

  final _i2.NestedFloatNullableFilter? $avg;

  final _i2.NestedFloatNullableFilter? $sum;

  final _i2.NestedFloatNullableFilter? $min;

  final _i2.NestedFloatNullableFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'lt': lt,
    'lte': lte,
    'gt': gt,
    'gte': gte,
    'not': not,
    '_count': $count,
    '_avg': $avg,
    '_sum': $sum,
    '_min': $min,
    '_max': $max,
  };
}

class NestedFloatWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedFloatWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final double? equals;

  final _i1.PrismaUnion<Iterable<double>, double>? $in;

  final _i1.PrismaUnion<Iterable<double>, double>? notIn;

  final double? lt;

  final double? lte;

  final double? gt;

  final double? gte;

  final _i1.PrismaUnion<double, _i2.NestedFloatWithAggregatesFilter>? not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedFloatFilter? $avg;

  final _i2.NestedFloatFilter? $sum;

  final _i2.NestedFloatFilter? $min;

  final _i2.NestedFloatFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'lt': lt,
    'lte': lte,
    'gt': gt,
    'gte': gte,
    'not': not,
    '_count': $count,
    '_avg': $avg,
    '_sum': $sum,
    '_min': $min,
    '_max': $max,
  };
}

class FloatWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FloatWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final double? equals;

  final _i1.PrismaUnion<Iterable<double>, double>? $in;

  final _i1.PrismaUnion<Iterable<double>, double>? notIn;

  final double? lt;

  final double? lte;

  final double? gt;

  final double? gte;

  final _i1.PrismaUnion<double, _i2.NestedFloatWithAggregatesFilter>? not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedFloatFilter? $avg;

  final _i2.NestedFloatFilter? $sum;

  final _i2.NestedFloatFilter? $min;

  final _i2.NestedFloatFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'lt': lt,
    'lte': lte,
    'gt': gt,
    'gte': gte,
    'not': not,
    '_count': $count,
    '_avg': $avg,
    '_sum': $sum,
    '_min': $min,
    '_max': $max,
  };
}

class NestedEnumScheduleTypeWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedEnumScheduleTypeWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i3.ScheduleType? equals;

  final _i1.PrismaUnion<Iterable<_i3.ScheduleType>, _i3.ScheduleType>? $in;

  final _i1.PrismaUnion<Iterable<_i3.ScheduleType>, _i3.ScheduleType>? notIn;

  final _i1.PrismaUnion<
    _i3.ScheduleType,
    _i2.NestedEnumScheduleTypeWithAggregatesFilter
  >?
  not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedEnumScheduleTypeFilter? $min;

  final _i2.NestedEnumScheduleTypeFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class EnumScheduleTypeWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumScheduleTypeWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i3.ScheduleType? equals;

  final _i1.PrismaUnion<Iterable<_i3.ScheduleType>, _i3.ScheduleType>? $in;

  final _i1.PrismaUnion<Iterable<_i3.ScheduleType>, _i3.ScheduleType>? notIn;

  final _i1.PrismaUnion<
    _i3.ScheduleType,
    _i2.NestedEnumScheduleTypeWithAggregatesFilter
  >?
  not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedEnumScheduleTypeFilter? $min;

  final _i2.NestedEnumScheduleTypeFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class ConsultantProfileScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    this.domainId,
    this.scheduleType,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
    _i2.ConsultantProfileScalarWhereWithAggregatesInput,
    Iterable<_i2.ConsultantProfileScalarWhereWithAggregatesInput>
  >?
  AND;

  final Iterable<_i2.ConsultantProfileScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileScalarWhereWithAggregatesInput,
    Iterable<_i2.ConsultantProfileScalarWhereWithAggregatesInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? id;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  description;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  qualifications;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  specialization;

  final _i1.PrismaUnion<
    _i2.FloatNullableWithAggregatesFilter,
    _i1.PrismaUnion<double, _i1.PrismaNull>
  >?
  experience;

  final _i1.PrismaUnion<_i2.FloatWithAggregatesFilter, double>? rating;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? domainId;

  final _i1.PrismaUnion<
    _i2.EnumScheduleTypeWithAggregatesFilter,
    _i3.ScheduleType
  >?
  scheduleType;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? userId;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'domainId': domainId,
    'scheduleType': scheduleType,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultantProfileCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileCountAggregateOutputTypeSelect({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    this.domainId,
    this.scheduleType,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  final bool? id;

  final bool? description;

  final bool? qualifications;

  final bool? specialization;

  final bool? experience;

  final bool? rating;

  final bool? domainId;

  final bool? scheduleType;

  final bool? userId;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'domainId': domainId,
    'scheduleType': scheduleType,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class ConsultantProfileGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileGroupByOutputTypeCountArgs({this.select});

  final _i2.ConsultantProfileCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ConsultantProfileAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileAvgAggregateOutputTypeSelect({
    this.experience,
    this.rating,
  });

  final bool? experience;

  final bool? rating;

  @override
  Map<String, dynamic> toJson() => {'experience': experience, 'rating': rating};
}

class ConsultantProfileGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileGroupByOutputTypeAvgArgs({this.select});

  final _i2.ConsultantProfileAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ConsultantProfileSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileSumAggregateOutputTypeSelect({
    this.experience,
    this.rating,
  });

  final bool? experience;

  final bool? rating;

  @override
  Map<String, dynamic> toJson() => {'experience': experience, 'rating': rating};
}

class ConsultantProfileGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileGroupByOutputTypeSumArgs({this.select});

  final _i2.ConsultantProfileSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ConsultantProfileMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileMinAggregateOutputTypeSelect({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    this.domainId,
    this.scheduleType,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? description;

  final bool? qualifications;

  final bool? specialization;

  final bool? experience;

  final bool? rating;

  final bool? domainId;

  final bool? scheduleType;

  final bool? userId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'domainId': domainId,
    'scheduleType': scheduleType,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultantProfileGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileGroupByOutputTypeMinArgs({this.select});

  final _i2.ConsultantProfileMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ConsultantProfileMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileMaxAggregateOutputTypeSelect({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    this.domainId,
    this.scheduleType,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? description;

  final bool? qualifications;

  final bool? specialization;

  final bool? experience;

  final bool? rating;

  final bool? domainId;

  final bool? scheduleType;

  final bool? userId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'domainId': domainId,
    'scheduleType': scheduleType,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultantProfileGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileGroupByOutputTypeMaxArgs({this.select});

  final _i2.ConsultantProfileMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ConsultantProfileGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileGroupByOutputTypeSelect({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    this.domainId,
    this.scheduleType,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? description;

  final bool? qualifications;

  final bool? specialization;

  final bool? experience;

  final bool? rating;

  final bool? domainId;

  final bool? scheduleType;

  final bool? userId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.ConsultantProfileGroupByOutputTypeCountArgs>?
  $count;

  final _i1.PrismaUnion<bool, _i2.ConsultantProfileGroupByOutputTypeAvgArgs>?
  $avg;

  final _i1.PrismaUnion<bool, _i2.ConsultantProfileGroupByOutputTypeSumArgs>?
  $sum;

  final _i1.PrismaUnion<bool, _i2.ConsultantProfileGroupByOutputTypeMinArgs>?
  $min;

  final _i1.PrismaUnion<bool, _i2.ConsultantProfileGroupByOutputTypeMaxArgs>?
  $max;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'domainId': domainId,
    'scheduleType': scheduleType,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_avg': $avg,
    '_sum': $sum,
    '_min': $min,
    '_max': $max,
  };
}

class AggregateConsultantProfile {
  const AggregateConsultantProfile({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateConsultantProfile.fromJson(Map json) =>
      AggregateConsultantProfile(
        $count: json['_count'] is Map
            ? _i2.ConsultantProfileCountAggregateOutputType.fromJson(
                json['_count'],
              )
            : null,
        $avg: json['_avg'] is Map
            ? _i2.ConsultantProfileAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.ConsultantProfileSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.ConsultantProfileMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.ConsultantProfileMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.ConsultantProfileCountAggregateOutputType? $count;

  final _i2.ConsultantProfileAvgAggregateOutputType? $avg;

  final _i2.ConsultantProfileSumAggregateOutputType? $sum;

  final _i2.ConsultantProfileMinAggregateOutputType? $min;

  final _i2.ConsultantProfileMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    '_count': $count?.toJson(),
    '_avg': $avg?.toJson(),
    '_sum': $sum?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class AggregateConsultantProfileCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateConsultantProfileCountArgs({this.select});

  final _i2.ConsultantProfileCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateConsultantProfileAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateConsultantProfileAvgArgs({this.select});

  final _i2.ConsultantProfileAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateConsultantProfileSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateConsultantProfileSumArgs({this.select});

  final _i2.ConsultantProfileSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateConsultantProfileMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateConsultantProfileMinArgs({this.select});

  final _i2.ConsultantProfileMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateConsultantProfileMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateConsultantProfileMaxArgs({this.select});

  final _i2.ConsultantProfileMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateConsultantProfileSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateConsultantProfileSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateConsultantProfileCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateConsultantProfileAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateConsultantProfileSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateConsultantProfileMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateConsultantProfileMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    '_count': $count,
    '_avg': $avg,
    '_sum': $sum,
    '_min': $min,
    '_max': $max,
  };
}

enum DomainScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<String>('id', 'Domain'),
  name$<String>('name', 'Domain'),
  createdAt<DateTime>('createdAt', 'Domain'),
  updatedAt<DateTime>('updatedAt', 'Domain');

  const DomainScalar(this.name, this.model);

  @override
  final String name;

  @override
  final String model;
}

class DomainCreateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomainCreateInput({
    this.id,
    required this.name,
    this.createdAt,
    this.updatedAt,
    this.subDomains,
    this.tags,
    this.consultantProfiles,
  });

  final String? id;

  final String name;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.SubDomainCreateNestedManyWithoutDomainInput? subDomains;

  final _i2.TagCreateNestedManyWithoutDomainInput? tags;

  final _i2.ConsultantProfileCreateNestedManyWithoutDomainInput?
  consultantProfiles;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'subDomains': subDomains,
    'tags': tags,
    'consultantProfiles': consultantProfiles,
  };
}

class DomainUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomainUncheckedCreateInput({
    this.id,
    required this.name,
    this.createdAt,
    this.updatedAt,
    this.subDomains,
    this.tags,
    this.consultantProfiles,
  });

  final String? id;

  final String name;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.SubDomainUncheckedCreateNestedManyWithoutDomainInput? subDomains;

  final _i2.TagUncheckedCreateNestedManyWithoutDomainInput? tags;

  final _i2.ConsultantProfileUncheckedCreateNestedManyWithoutDomainInput?
  consultantProfiles;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'subDomains': subDomains,
    'tags': tags,
    'consultantProfiles': consultantProfiles,
  };
}

class DomainCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomainCreateManyInput({
    this.id,
    required this.name,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final String name;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class DomainUpdateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomainUpdateInput({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
    this.subDomains,
    this.tags,
    this.consultantProfiles,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.SubDomainUpdateManyWithoutDomainNestedInput? subDomains;

  final _i2.TagUpdateManyWithoutDomainNestedInput? tags;

  final _i2.ConsultantProfileUpdateManyWithoutDomainNestedInput?
  consultantProfiles;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'subDomains': subDomains,
    'tags': tags,
    'consultantProfiles': consultantProfiles,
  };
}

class DomainUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomainUncheckedUpdateInput({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
    this.subDomains,
    this.tags,
    this.consultantProfiles,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.SubDomainUncheckedUpdateManyWithoutDomainNestedInput? subDomains;

  final _i2.TagUncheckedUpdateManyWithoutDomainNestedInput? tags;

  final _i2.ConsultantProfileUncheckedUpdateManyWithoutDomainNestedInput?
  consultantProfiles;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'subDomains': subDomains,
    'tags': tags,
    'consultantProfiles': consultantProfiles,
  };
}

class DomainUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomainUpdateManyMutationInput({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class DomainUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomainUncheckedUpdateManyInput({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class DomainCountAggregateOutputType {
  const DomainCountAggregateOutputType({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  factory DomainCountAggregateOutputType.fromJson(Map json) =>
      DomainCountAggregateOutputType(
        id: json['id'],
        name: json['name'],
        createdAt: json['createdAt'],
        updatedAt: json['updatedAt'],
        $all: json['_all'],
      );

  final int? id;

  final int? name;

  final int? createdAt;

  final int? updatedAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class DomainMinAggregateOutputType {
  const DomainMinAggregateOutputType({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
  });

  factory DomainMinAggregateOutputType.fromJson(Map json) =>
      DomainMinAggregateOutputType(
        id: json['id'],
        name: json['name'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final String? name;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class DomainMaxAggregateOutputType {
  const DomainMaxAggregateOutputType({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
  });

  factory DomainMaxAggregateOutputType.fromJson(Map json) =>
      DomainMaxAggregateOutputType(
        id: json['id'],
        name: json['name'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final String? name;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class DomainGroupByOutputType {
  const DomainGroupByOutputType({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$min,
    this.$max,
  });

  factory DomainGroupByOutputType.fromJson(Map json) => DomainGroupByOutputType(
    id: json['id'],
    name: json['name'],
    createdAt: switch (json['createdAt']) {
      DateTime value => value,
      String value => DateTime.parse(value),
      _ => json['createdAt'],
    },
    updatedAt: switch (json['updatedAt']) {
      DateTime value => value,
      String value => DateTime.parse(value),
      _ => json['updatedAt'],
    },
    $count: json['_count'] is Map
        ? _i2.DomainCountAggregateOutputType.fromJson(json['_count'])
        : null,
    $min: json['_min'] is Map
        ? _i2.DomainMinAggregateOutputType.fromJson(json['_min'])
        : null,
    $max: json['_max'] is Map
        ? _i2.DomainMaxAggregateOutputType.fromJson(json['_max'])
        : null,
  );

  final String? id;

  final String? name;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.DomainCountAggregateOutputType? $count;

  final _i2.DomainMinAggregateOutputType? $min;

  final _i2.DomainMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
    '_count': $count?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class DomainCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomainCountOrderByAggregateInput({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? name;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class DomainMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomainMaxOrderByAggregateInput({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? name;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class DomainMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomainMinOrderByAggregateInput({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? name;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class DomainOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomainOrderByWithAggregationInput({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$max,
    this.$min,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? name;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.DomainCountOrderByAggregateInput? $count;

  final _i2.DomainMaxOrderByAggregateInput? $max;

  final _i2.DomainMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_max': $max,
    '_min': $min,
  };
}

class DomainScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomainScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
    _i2.DomainScalarWhereWithAggregatesInput,
    Iterable<_i2.DomainScalarWhereWithAggregatesInput>
  >?
  AND;

  final Iterable<_i2.DomainScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<
    _i2.DomainScalarWhereWithAggregatesInput,
    Iterable<_i2.DomainScalarWhereWithAggregatesInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? name;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class DomainCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomainCountAggregateOutputTypeSelect({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  final bool? id;

  final bool? name;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class DomainGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomainGroupByOutputTypeCountArgs({this.select});

  final _i2.DomainCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class DomainMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomainMinAggregateOutputTypeSelect({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? name;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class DomainGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomainGroupByOutputTypeMinArgs({this.select});

  final _i2.DomainMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class DomainMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomainMaxAggregateOutputTypeSelect({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? name;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class DomainGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomainGroupByOutputTypeMaxArgs({this.select});

  final _i2.DomainMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class DomainGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomainGroupByOutputTypeSelect({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? name;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.DomainGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.DomainGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.DomainGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class AggregateDomain {
  const AggregateDomain({this.$count, this.$min, this.$max});

  factory AggregateDomain.fromJson(Map json) => AggregateDomain(
    $count: json['_count'] is Map
        ? _i2.DomainCountAggregateOutputType.fromJson(json['_count'])
        : null,
    $min: json['_min'] is Map
        ? _i2.DomainMinAggregateOutputType.fromJson(json['_min'])
        : null,
    $max: json['_max'] is Map
        ? _i2.DomainMaxAggregateOutputType.fromJson(json['_max'])
        : null,
  );

  final _i2.DomainCountAggregateOutputType? $count;

  final _i2.DomainMinAggregateOutputType? $min;

  final _i2.DomainMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    '_count': $count?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class AggregateDomainCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateDomainCountArgs({this.select});

  final _i2.DomainCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateDomainMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateDomainMinArgs({this.select});

  final _i2.DomainMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateDomainMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateDomainMaxArgs({this.select});

  final _i2.DomainMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateDomainSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateDomainSelect({this.$count, this.$min, this.$max});

  final _i1.PrismaUnion<bool, _i2.AggregateDomainCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateDomainMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateDomainMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class SubDomainCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainCreateInput({
    this.id,
    required this.name,
    this.createdAt,
    this.updatedAt,
    required this.domain,
    this.consultantProfiles,
  });

  final String? id;

  final String name;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.DomainCreateNestedOneWithoutSubDomainsInput domain;

  final _i2.ConsultantProfileCreateNestedManyWithoutSubDomainsInput?
  consultantProfiles;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'domain': domain,
    'consultantProfiles': consultantProfiles,
  };
}

class SubDomainUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainUncheckedCreateInput({
    this.id,
    required this.name,
    required this.domainId,
    this.createdAt,
    this.updatedAt,
    this.consultantProfiles,
  });

  final String? id;

  final String name;

  final String domainId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ConsultantProfileUncheckedCreateNestedManyWithoutSubDomainsInput?
  consultantProfiles;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'domainId': domainId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultantProfiles': consultantProfiles,
  };
}

class SubDomainCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainCreateManyInput({
    this.id,
    required this.name,
    required this.domainId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final String name;

  final String domainId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'domainId': domainId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SubDomainUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainUpdateInput({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
    this.domain,
    this.consultantProfiles,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.DomainUpdateOneRequiredWithoutSubDomainsNestedInput? domain;

  final _i2.ConsultantProfileUpdateManyWithoutSubDomainsNestedInput?
  consultantProfiles;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'domain': domain,
    'consultantProfiles': consultantProfiles,
  };
}

class SubDomainUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainUncheckedUpdateInput({
    this.id,
    this.name,
    this.domainId,
    this.createdAt,
    this.updatedAt,
    this.consultantProfiles,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? domainId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.ConsultantProfileUncheckedUpdateManyWithoutSubDomainsNestedInput?
  consultantProfiles;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'domainId': domainId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultantProfiles': consultantProfiles,
  };
}

class SubDomainUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainUncheckedUpdateManyInput({
    this.id,
    this.name,
    this.domainId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? domainId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'domainId': domainId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SubDomainCountAggregateOutputType {
  const SubDomainCountAggregateOutputType({
    this.id,
    this.name,
    this.domainId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  factory SubDomainCountAggregateOutputType.fromJson(Map json) =>
      SubDomainCountAggregateOutputType(
        id: json['id'],
        name: json['name'],
        domainId: json['domainId'],
        createdAt: json['createdAt'],
        updatedAt: json['updatedAt'],
        $all: json['_all'],
      );

  final int? id;

  final int? name;

  final int? domainId;

  final int? createdAt;

  final int? updatedAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'domainId': domainId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class SubDomainMinAggregateOutputType {
  const SubDomainMinAggregateOutputType({
    this.id,
    this.name,
    this.domainId,
    this.createdAt,
    this.updatedAt,
  });

  factory SubDomainMinAggregateOutputType.fromJson(Map json) =>
      SubDomainMinAggregateOutputType(
        id: json['id'],
        name: json['name'],
        domainId: json['domainId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final String? name;

  final String? domainId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'domainId': domainId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class SubDomainMaxAggregateOutputType {
  const SubDomainMaxAggregateOutputType({
    this.id,
    this.name,
    this.domainId,
    this.createdAt,
    this.updatedAt,
  });

  factory SubDomainMaxAggregateOutputType.fromJson(Map json) =>
      SubDomainMaxAggregateOutputType(
        id: json['id'],
        name: json['name'],
        domainId: json['domainId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final String? name;

  final String? domainId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'domainId': domainId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class SubDomainGroupByOutputType {
  const SubDomainGroupByOutputType({
    this.id,
    this.name,
    this.domainId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$min,
    this.$max,
  });

  factory SubDomainGroupByOutputType.fromJson(Map json) =>
      SubDomainGroupByOutputType(
        id: json['id'],
        name: json['name'],
        domainId: json['domainId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
        $count: json['_count'] is Map
            ? _i2.SubDomainCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.SubDomainMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.SubDomainMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? id;

  final String? name;

  final String? domainId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.SubDomainCountAggregateOutputType? $count;

  final _i2.SubDomainMinAggregateOutputType? $min;

  final _i2.SubDomainMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'domainId': domainId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
    '_count': $count?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class SubDomainCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainCountOrderByAggregateInput({
    this.id,
    this.name,
    this.domainId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? name;

  final _i2.SortOrder? domainId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'domainId': domainId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SubDomainMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainMaxOrderByAggregateInput({
    this.id,
    this.name,
    this.domainId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? name;

  final _i2.SortOrder? domainId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'domainId': domainId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SubDomainMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainMinOrderByAggregateInput({
    this.id,
    this.name,
    this.domainId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? name;

  final _i2.SortOrder? domainId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'domainId': domainId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SubDomainOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainOrderByWithAggregationInput({
    this.id,
    this.name,
    this.domainId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$max,
    this.$min,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? name;

  final _i2.SortOrder? domainId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.SubDomainCountOrderByAggregateInput? $count;

  final _i2.SubDomainMaxOrderByAggregateInput? $max;

  final _i2.SubDomainMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'domainId': domainId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_max': $max,
    '_min': $min,
  };
}

class SubDomainScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.name,
    this.domainId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
    _i2.SubDomainScalarWhereWithAggregatesInput,
    Iterable<_i2.SubDomainScalarWhereWithAggregatesInput>
  >?
  AND;

  final Iterable<_i2.SubDomainScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<
    _i2.SubDomainScalarWhereWithAggregatesInput,
    Iterable<_i2.SubDomainScalarWhereWithAggregatesInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? name;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? domainId;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'name': name,
    'domainId': domainId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SubDomainCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainCountAggregateOutputTypeSelect({
    this.id,
    this.name,
    this.domainId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  final bool? id;

  final bool? name;

  final bool? domainId;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'domainId': domainId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class SubDomainGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainGroupByOutputTypeCountArgs({this.select});

  final _i2.SubDomainCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SubDomainMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainMinAggregateOutputTypeSelect({
    this.id,
    this.name,
    this.domainId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? name;

  final bool? domainId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'domainId': domainId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SubDomainGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainGroupByOutputTypeMinArgs({this.select});

  final _i2.SubDomainMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SubDomainMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainMaxAggregateOutputTypeSelect({
    this.id,
    this.name,
    this.domainId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? name;

  final bool? domainId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'domainId': domainId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SubDomainGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainGroupByOutputTypeMaxArgs({this.select});

  final _i2.SubDomainMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SubDomainGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubDomainGroupByOutputTypeSelect({
    this.id,
    this.name,
    this.domainId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? name;

  final bool? domainId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.SubDomainGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.SubDomainGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.SubDomainGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'domainId': domainId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class AggregateSubDomain {
  const AggregateSubDomain({this.$count, this.$min, this.$max});

  factory AggregateSubDomain.fromJson(Map json) => AggregateSubDomain(
    $count: json['_count'] is Map
        ? _i2.SubDomainCountAggregateOutputType.fromJson(json['_count'])
        : null,
    $min: json['_min'] is Map
        ? _i2.SubDomainMinAggregateOutputType.fromJson(json['_min'])
        : null,
    $max: json['_max'] is Map
        ? _i2.SubDomainMaxAggregateOutputType.fromJson(json['_max'])
        : null,
  );

  final _i2.SubDomainCountAggregateOutputType? $count;

  final _i2.SubDomainMinAggregateOutputType? $min;

  final _i2.SubDomainMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    '_count': $count?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class AggregateSubDomainCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSubDomainCountArgs({this.select});

  final _i2.SubDomainCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateSubDomainMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSubDomainMinArgs({this.select});

  final _i2.SubDomainMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateSubDomainMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSubDomainMaxArgs({this.select});

  final _i2.SubDomainMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateSubDomainSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSubDomainSelect({this.$count, this.$min, this.$max});

  final _i1.PrismaUnion<bool, _i2.AggregateSubDomainCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateSubDomainMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateSubDomainMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class TagCreateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagCreateInput({
    this.id,
    required this.name,
    this.createdAt,
    this.updatedAt,
    required this.domain,
    this.consultantProfiles,
  });

  final String? id;

  final String name;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.DomainCreateNestedOneWithoutTagsInput domain;

  final _i2.ConsultantProfileCreateNestedManyWithoutTagsInput?
  consultantProfiles;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'domain': domain,
    'consultantProfiles': consultantProfiles,
  };
}

class TagUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagUncheckedCreateInput({
    this.id,
    required this.name,
    required this.domainId,
    this.createdAt,
    this.updatedAt,
    this.consultantProfiles,
  });

  final String? id;

  final String name;

  final String domainId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ConsultantProfileUncheckedCreateNestedManyWithoutTagsInput?
  consultantProfiles;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'domainId': domainId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultantProfiles': consultantProfiles,
  };
}

class TagCreateManyInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagCreateManyInput({
    this.id,
    required this.name,
    required this.domainId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final String name;

  final String domainId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'domainId': domainId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class TagUpdateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagUpdateInput({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
    this.domain,
    this.consultantProfiles,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.DomainUpdateOneRequiredWithoutTagsNestedInput? domain;

  final _i2.ConsultantProfileUpdateManyWithoutTagsNestedInput?
  consultantProfiles;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'domain': domain,
    'consultantProfiles': consultantProfiles,
  };
}

class TagUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagUncheckedUpdateInput({
    this.id,
    this.name,
    this.domainId,
    this.createdAt,
    this.updatedAt,
    this.consultantProfiles,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? domainId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.ConsultantProfileUncheckedUpdateManyWithoutTagsNestedInput?
  consultantProfiles;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'domainId': domainId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultantProfiles': consultantProfiles,
  };
}

class TagUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagUncheckedUpdateManyInput({
    this.id,
    this.name,
    this.domainId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? domainId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'domainId': domainId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class TagCountAggregateOutputType {
  const TagCountAggregateOutputType({
    this.id,
    this.name,
    this.domainId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  factory TagCountAggregateOutputType.fromJson(Map json) =>
      TagCountAggregateOutputType(
        id: json['id'],
        name: json['name'],
        domainId: json['domainId'],
        createdAt: json['createdAt'],
        updatedAt: json['updatedAt'],
        $all: json['_all'],
      );

  final int? id;

  final int? name;

  final int? domainId;

  final int? createdAt;

  final int? updatedAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'domainId': domainId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class TagMinAggregateOutputType {
  const TagMinAggregateOutputType({
    this.id,
    this.name,
    this.domainId,
    this.createdAt,
    this.updatedAt,
  });

  factory TagMinAggregateOutputType.fromJson(Map json) =>
      TagMinAggregateOutputType(
        id: json['id'],
        name: json['name'],
        domainId: json['domainId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final String? name;

  final String? domainId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'domainId': domainId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class TagMaxAggregateOutputType {
  const TagMaxAggregateOutputType({
    this.id,
    this.name,
    this.domainId,
    this.createdAt,
    this.updatedAt,
  });

  factory TagMaxAggregateOutputType.fromJson(Map json) =>
      TagMaxAggregateOutputType(
        id: json['id'],
        name: json['name'],
        domainId: json['domainId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final String? name;

  final String? domainId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'domainId': domainId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class TagGroupByOutputType {
  const TagGroupByOutputType({
    this.id,
    this.name,
    this.domainId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$min,
    this.$max,
  });

  factory TagGroupByOutputType.fromJson(Map json) => TagGroupByOutputType(
    id: json['id'],
    name: json['name'],
    domainId: json['domainId'],
    createdAt: switch (json['createdAt']) {
      DateTime value => value,
      String value => DateTime.parse(value),
      _ => json['createdAt'],
    },
    updatedAt: switch (json['updatedAt']) {
      DateTime value => value,
      String value => DateTime.parse(value),
      _ => json['updatedAt'],
    },
    $count: json['_count'] is Map
        ? _i2.TagCountAggregateOutputType.fromJson(json['_count'])
        : null,
    $min: json['_min'] is Map
        ? _i2.TagMinAggregateOutputType.fromJson(json['_min'])
        : null,
    $max: json['_max'] is Map
        ? _i2.TagMaxAggregateOutputType.fromJson(json['_max'])
        : null,
  );

  final String? id;

  final String? name;

  final String? domainId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.TagCountAggregateOutputType? $count;

  final _i2.TagMinAggregateOutputType? $min;

  final _i2.TagMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'domainId': domainId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
    '_count': $count?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class TagCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagCountOrderByAggregateInput({
    this.id,
    this.name,
    this.domainId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? name;

  final _i2.SortOrder? domainId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'domainId': domainId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class TagMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagMaxOrderByAggregateInput({
    this.id,
    this.name,
    this.domainId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? name;

  final _i2.SortOrder? domainId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'domainId': domainId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class TagMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagMinOrderByAggregateInput({
    this.id,
    this.name,
    this.domainId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? name;

  final _i2.SortOrder? domainId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'domainId': domainId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class TagOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagOrderByWithAggregationInput({
    this.id,
    this.name,
    this.domainId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$max,
    this.$min,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? name;

  final _i2.SortOrder? domainId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.TagCountOrderByAggregateInput? $count;

  final _i2.TagMaxOrderByAggregateInput? $max;

  final _i2.TagMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'domainId': domainId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_max': $max,
    '_min': $min,
  };
}

class TagScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.name,
    this.domainId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
    _i2.TagScalarWhereWithAggregatesInput,
    Iterable<_i2.TagScalarWhereWithAggregatesInput>
  >?
  AND;

  final Iterable<_i2.TagScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<
    _i2.TagScalarWhereWithAggregatesInput,
    Iterable<_i2.TagScalarWhereWithAggregatesInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? name;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? domainId;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'name': name,
    'domainId': domainId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class TagCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagCountAggregateOutputTypeSelect({
    this.id,
    this.name,
    this.domainId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  final bool? id;

  final bool? name;

  final bool? domainId;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'domainId': domainId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class TagGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagGroupByOutputTypeCountArgs({this.select});

  final _i2.TagCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class TagMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagMinAggregateOutputTypeSelect({
    this.id,
    this.name,
    this.domainId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? name;

  final bool? domainId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'domainId': domainId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class TagGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagGroupByOutputTypeMinArgs({this.select});

  final _i2.TagMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class TagMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagMaxAggregateOutputTypeSelect({
    this.id,
    this.name,
    this.domainId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? name;

  final bool? domainId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'domainId': domainId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class TagGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagGroupByOutputTypeMaxArgs({this.select});

  final _i2.TagMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class TagGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TagGroupByOutputTypeSelect({
    this.id,
    this.name,
    this.domainId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? name;

  final bool? domainId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.TagGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.TagGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.TagGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'domainId': domainId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class AggregateTag {
  const AggregateTag({this.$count, this.$min, this.$max});

  factory AggregateTag.fromJson(Map json) => AggregateTag(
    $count: json['_count'] is Map
        ? _i2.TagCountAggregateOutputType.fromJson(json['_count'])
        : null,
    $min: json['_min'] is Map
        ? _i2.TagMinAggregateOutputType.fromJson(json['_min'])
        : null,
    $max: json['_max'] is Map
        ? _i2.TagMaxAggregateOutputType.fromJson(json['_max'])
        : null,
  );

  final _i2.TagCountAggregateOutputType? $count;

  final _i2.TagMinAggregateOutputType? $min;

  final _i2.TagMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    '_count': $count?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class AggregateTagCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateTagCountArgs({this.select});

  final _i2.TagCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateTagMinArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateTagMinArgs({this.select});

  final _i2.TagMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateTagMaxArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateTagMaxArgs({this.select});

  final _i2.TagMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateTagSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateTagSelect({this.$count, this.$min, this.$max});

  final _i1.PrismaUnion<bool, _i2.AggregateTagCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateTagMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateTagMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class ConsultantReviewCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewCreateInput({
    this.id,
    this.rating,
    this.reviewDescription,
    this.createdAt,
    this.updatedAt,
    required this.consultantProfile,
    required this.consulteeProfile,
  });

  final String? id;

  final int? rating;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? reviewDescription;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ConsultantProfileCreateNestedOneWithoutReviewsInput
  consultantProfile;

  final _i2.ConsulteeProfileCreateNestedOneWithoutConsultantReviewsInput
  consulteeProfile;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'rating': rating,
    'reviewDescription': reviewDescription,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
  };
}

class ConsultantReviewUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewUncheckedCreateInput({
    this.id,
    this.rating,
    this.reviewDescription,
    required this.consultantProfileId,
    required this.consulteeProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final int? rating;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? reviewDescription;

  final String consultantProfileId;

  final String consulteeProfileId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'rating': rating,
    'reviewDescription': reviewDescription,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultantReviewCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewCreateManyInput({
    this.id,
    this.rating,
    this.reviewDescription,
    required this.consultantProfileId,
    required this.consulteeProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final int? rating;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? reviewDescription;

  final String consultantProfileId;

  final String consulteeProfileId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'rating': rating,
    'reviewDescription': reviewDescription,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultantReviewUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewUpdateInput({
    this.id,
    this.rating,
    this.reviewDescription,
    this.createdAt,
    this.updatedAt,
    this.consultantProfile,
    this.consulteeProfile,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? rating;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  reviewDescription;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.ConsultantProfileUpdateOneRequiredWithoutReviewsNestedInput?
  consultantProfile;

  final _i2.ConsulteeProfileUpdateOneRequiredWithoutConsultantReviewsNestedInput?
  consulteeProfile;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'rating': rating,
    'reviewDescription': reviewDescription,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
  };
}

class ConsultantReviewUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewUncheckedUpdateInput({
    this.id,
    this.rating,
    this.reviewDescription,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? rating;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  reviewDescription;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  consultantProfileId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  consulteeProfileId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'rating': rating,
    'reviewDescription': reviewDescription,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultantReviewUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewUncheckedUpdateManyInput({
    this.id,
    this.rating,
    this.reviewDescription,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? rating;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  reviewDescription;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  consultantProfileId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  consulteeProfileId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'rating': rating,
    'reviewDescription': reviewDescription,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultantReviewCountAggregateOutputType {
  const ConsultantReviewCountAggregateOutputType({
    this.id,
    this.rating,
    this.reviewDescription,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  factory ConsultantReviewCountAggregateOutputType.fromJson(Map json) =>
      ConsultantReviewCountAggregateOutputType(
        id: json['id'],
        rating: json['rating'],
        reviewDescription: json['reviewDescription'],
        consultantProfileId: json['consultantProfileId'],
        consulteeProfileId: json['consulteeProfileId'],
        createdAt: json['createdAt'],
        updatedAt: json['updatedAt'],
        $all: json['_all'],
      );

  final int? id;

  final int? rating;

  final int? reviewDescription;

  final int? consultantProfileId;

  final int? consulteeProfileId;

  final int? createdAt;

  final int? updatedAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
    'id': id,
    'rating': rating,
    'reviewDescription': reviewDescription,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class ConsultantReviewAvgAggregateOutputType {
  const ConsultantReviewAvgAggregateOutputType({this.rating});

  factory ConsultantReviewAvgAggregateOutputType.fromJson(Map json) =>
      ConsultantReviewAvgAggregateOutputType(rating: json['rating']);

  final double? rating;

  Map<String, dynamic> toJson() => {'rating': rating};
}

class ConsultantReviewSumAggregateOutputType {
  const ConsultantReviewSumAggregateOutputType({this.rating});

  factory ConsultantReviewSumAggregateOutputType.fromJson(Map json) =>
      ConsultantReviewSumAggregateOutputType(rating: json['rating']);

  final int? rating;

  Map<String, dynamic> toJson() => {'rating': rating};
}

class ConsultantReviewMinAggregateOutputType {
  const ConsultantReviewMinAggregateOutputType({
    this.id,
    this.rating,
    this.reviewDescription,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.createdAt,
    this.updatedAt,
  });

  factory ConsultantReviewMinAggregateOutputType.fromJson(Map json) =>
      ConsultantReviewMinAggregateOutputType(
        id: json['id'],
        rating: json['rating'],
        reviewDescription: json['reviewDescription'],
        consultantProfileId: json['consultantProfileId'],
        consulteeProfileId: json['consulteeProfileId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final int? rating;

  final String? reviewDescription;

  final String? consultantProfileId;

  final String? consulteeProfileId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'rating': rating,
    'reviewDescription': reviewDescription,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class ConsultantReviewMaxAggregateOutputType {
  const ConsultantReviewMaxAggregateOutputType({
    this.id,
    this.rating,
    this.reviewDescription,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.createdAt,
    this.updatedAt,
  });

  factory ConsultantReviewMaxAggregateOutputType.fromJson(Map json) =>
      ConsultantReviewMaxAggregateOutputType(
        id: json['id'],
        rating: json['rating'],
        reviewDescription: json['reviewDescription'],
        consultantProfileId: json['consultantProfileId'],
        consulteeProfileId: json['consulteeProfileId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final int? rating;

  final String? reviewDescription;

  final String? consultantProfileId;

  final String? consulteeProfileId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'rating': rating,
    'reviewDescription': reviewDescription,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class ConsultantReviewGroupByOutputType {
  const ConsultantReviewGroupByOutputType({
    this.id,
    this.rating,
    this.reviewDescription,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory ConsultantReviewGroupByOutputType.fromJson(Map json) =>
      ConsultantReviewGroupByOutputType(
        id: json['id'],
        rating: json['rating'],
        reviewDescription: json['reviewDescription'],
        consultantProfileId: json['consultantProfileId'],
        consulteeProfileId: json['consulteeProfileId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
        $count: json['_count'] is Map
            ? _i2.ConsultantReviewCountAggregateOutputType.fromJson(
                json['_count'],
              )
            : null,
        $avg: json['_avg'] is Map
            ? _i2.ConsultantReviewAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.ConsultantReviewSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.ConsultantReviewMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.ConsultantReviewMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? id;

  final int? rating;

  final String? reviewDescription;

  final String? consultantProfileId;

  final String? consulteeProfileId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ConsultantReviewCountAggregateOutputType? $count;

  final _i2.ConsultantReviewAvgAggregateOutputType? $avg;

  final _i2.ConsultantReviewSumAggregateOutputType? $sum;

  final _i2.ConsultantReviewMinAggregateOutputType? $min;

  final _i2.ConsultantReviewMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    'id': id,
    'rating': rating,
    'reviewDescription': reviewDescription,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
    '_count': $count?.toJson(),
    '_avg': $avg?.toJson(),
    '_sum': $sum?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class ConsultantReviewCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewCountOrderByAggregateInput({
    this.id,
    this.rating,
    this.reviewDescription,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? rating;

  final _i2.SortOrder? reviewDescription;

  final _i2.SortOrder? consultantProfileId;

  final _i2.SortOrder? consulteeProfileId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'rating': rating,
    'reviewDescription': reviewDescription,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultantReviewAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewAvgOrderByAggregateInput({this.rating});

  final _i2.SortOrder? rating;

  @override
  Map<String, dynamic> toJson() => {'rating': rating};
}

class ConsultantReviewMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewMaxOrderByAggregateInput({
    this.id,
    this.rating,
    this.reviewDescription,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? rating;

  final _i2.SortOrder? reviewDescription;

  final _i2.SortOrder? consultantProfileId;

  final _i2.SortOrder? consulteeProfileId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'rating': rating,
    'reviewDescription': reviewDescription,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultantReviewMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewMinOrderByAggregateInput({
    this.id,
    this.rating,
    this.reviewDescription,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? rating;

  final _i2.SortOrder? reviewDescription;

  final _i2.SortOrder? consultantProfileId;

  final _i2.SortOrder? consulteeProfileId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'rating': rating,
    'reviewDescription': reviewDescription,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultantReviewSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewSumOrderByAggregateInput({this.rating});

  final _i2.SortOrder? rating;

  @override
  Map<String, dynamic> toJson() => {'rating': rating};
}

class ConsultantReviewOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewOrderByWithAggregationInput({
    this.id,
    this.rating,
    this.reviewDescription,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? rating;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? reviewDescription;

  final _i2.SortOrder? consultantProfileId;

  final _i2.SortOrder? consulteeProfileId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.ConsultantReviewCountOrderByAggregateInput? $count;

  final _i2.ConsultantReviewAvgOrderByAggregateInput? $avg;

  final _i2.ConsultantReviewMaxOrderByAggregateInput? $max;

  final _i2.ConsultantReviewMinOrderByAggregateInput? $min;

  final _i2.ConsultantReviewSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'rating': rating,
    'reviewDescription': reviewDescription,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_avg': $avg,
    '_max': $max,
    '_min': $min,
    '_sum': $sum,
  };
}

class NestedIntWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedIntWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final int? equals;

  final _i1.PrismaUnion<Iterable<int>, int>? $in;

  final _i1.PrismaUnion<Iterable<int>, int>? notIn;

  final int? lt;

  final int? lte;

  final int? gt;

  final int? gte;

  final _i1.PrismaUnion<int, _i2.NestedIntWithAggregatesFilter>? not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedFloatFilter? $avg;

  final _i2.NestedIntFilter? $sum;

  final _i2.NestedIntFilter? $min;

  final _i2.NestedIntFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'lt': lt,
    'lte': lte,
    'gt': gt,
    'gte': gte,
    'not': not,
    '_count': $count,
    '_avg': $avg,
    '_sum': $sum,
    '_min': $min,
    '_max': $max,
  };
}

class IntWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IntWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final int? equals;

  final _i1.PrismaUnion<Iterable<int>, int>? $in;

  final _i1.PrismaUnion<Iterable<int>, int>? notIn;

  final int? lt;

  final int? lte;

  final int? gt;

  final int? gte;

  final _i1.PrismaUnion<int, _i2.NestedIntWithAggregatesFilter>? not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedFloatFilter? $avg;

  final _i2.NestedIntFilter? $sum;

  final _i2.NestedIntFilter? $min;

  final _i2.NestedIntFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'lt': lt,
    'lte': lte,
    'gt': gt,
    'gte': gte,
    'not': not,
    '_count': $count,
    '_avg': $avg,
    '_sum': $sum,
    '_min': $min,
    '_max': $max,
  };
}

class ConsultantReviewScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.rating,
    this.reviewDescription,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
    _i2.ConsultantReviewScalarWhereWithAggregatesInput,
    Iterable<_i2.ConsultantReviewScalarWhereWithAggregatesInput>
  >?
  AND;

  final Iterable<_i2.ConsultantReviewScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<
    _i2.ConsultantReviewScalarWhereWithAggregatesInput,
    Iterable<_i2.ConsultantReviewScalarWhereWithAggregatesInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? id;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? rating;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  reviewDescription;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>?
  consultantProfileId;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>?
  consulteeProfileId;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'rating': rating,
    'reviewDescription': reviewDescription,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultantReviewCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewCountAggregateOutputTypeSelect({
    this.id,
    this.rating,
    this.reviewDescription,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  final bool? id;

  final bool? rating;

  final bool? reviewDescription;

  final bool? consultantProfileId;

  final bool? consulteeProfileId;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'rating': rating,
    'reviewDescription': reviewDescription,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class ConsultantReviewGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewGroupByOutputTypeCountArgs({this.select});

  final _i2.ConsultantReviewCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ConsultantReviewAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewAvgAggregateOutputTypeSelect({this.rating});

  final bool? rating;

  @override
  Map<String, dynamic> toJson() => {'rating': rating};
}

class ConsultantReviewGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewGroupByOutputTypeAvgArgs({this.select});

  final _i2.ConsultantReviewAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ConsultantReviewSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewSumAggregateOutputTypeSelect({this.rating});

  final bool? rating;

  @override
  Map<String, dynamic> toJson() => {'rating': rating};
}

class ConsultantReviewGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewGroupByOutputTypeSumArgs({this.select});

  final _i2.ConsultantReviewSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ConsultantReviewMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewMinAggregateOutputTypeSelect({
    this.id,
    this.rating,
    this.reviewDescription,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? rating;

  final bool? reviewDescription;

  final bool? consultantProfileId;

  final bool? consulteeProfileId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'rating': rating,
    'reviewDescription': reviewDescription,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultantReviewGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewGroupByOutputTypeMinArgs({this.select});

  final _i2.ConsultantReviewMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ConsultantReviewMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewMaxAggregateOutputTypeSelect({
    this.id,
    this.rating,
    this.reviewDescription,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? rating;

  final bool? reviewDescription;

  final bool? consultantProfileId;

  final bool? consulteeProfileId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'rating': rating,
    'reviewDescription': reviewDescription,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultantReviewGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewGroupByOutputTypeMaxArgs({this.select});

  final _i2.ConsultantReviewMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ConsultantReviewGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantReviewGroupByOutputTypeSelect({
    this.id,
    this.rating,
    this.reviewDescription,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? rating;

  final bool? reviewDescription;

  final bool? consultantProfileId;

  final bool? consulteeProfileId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.ConsultantReviewGroupByOutputTypeCountArgs>?
  $count;

  final _i1.PrismaUnion<bool, _i2.ConsultantReviewGroupByOutputTypeAvgArgs>?
  $avg;

  final _i1.PrismaUnion<bool, _i2.ConsultantReviewGroupByOutputTypeSumArgs>?
  $sum;

  final _i1.PrismaUnion<bool, _i2.ConsultantReviewGroupByOutputTypeMinArgs>?
  $min;

  final _i1.PrismaUnion<bool, _i2.ConsultantReviewGroupByOutputTypeMaxArgs>?
  $max;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'rating': rating,
    'reviewDescription': reviewDescription,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_avg': $avg,
    '_sum': $sum,
    '_min': $min,
    '_max': $max,
  };
}

class AggregateConsultantReview {
  const AggregateConsultantReview({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateConsultantReview.fromJson(Map json) =>
      AggregateConsultantReview(
        $count: json['_count'] is Map
            ? _i2.ConsultantReviewCountAggregateOutputType.fromJson(
                json['_count'],
              )
            : null,
        $avg: json['_avg'] is Map
            ? _i2.ConsultantReviewAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.ConsultantReviewSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.ConsultantReviewMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.ConsultantReviewMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.ConsultantReviewCountAggregateOutputType? $count;

  final _i2.ConsultantReviewAvgAggregateOutputType? $avg;

  final _i2.ConsultantReviewSumAggregateOutputType? $sum;

  final _i2.ConsultantReviewMinAggregateOutputType? $min;

  final _i2.ConsultantReviewMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    '_count': $count?.toJson(),
    '_avg': $avg?.toJson(),
    '_sum': $sum?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class AggregateConsultantReviewCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateConsultantReviewCountArgs({this.select});

  final _i2.ConsultantReviewCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateConsultantReviewAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateConsultantReviewAvgArgs({this.select});

  final _i2.ConsultantReviewAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateConsultantReviewSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateConsultantReviewSumArgs({this.select});

  final _i2.ConsultantReviewSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateConsultantReviewMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateConsultantReviewMinArgs({this.select});

  final _i2.ConsultantReviewMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateConsultantReviewMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateConsultantReviewMaxArgs({this.select});

  final _i2.ConsultantReviewMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateConsultantReviewSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateConsultantReviewSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateConsultantReviewCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateConsultantReviewAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateConsultantReviewSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateConsultantReviewMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateConsultantReviewMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    '_count': $count,
    '_avg': $avg,
    '_sum': $sum,
    '_min': $min,
    '_max': $max,
  };
}

enum ConsulteeProfileScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<String>('id', 'ConsulteeProfile'),
  education<String>('education', 'ConsulteeProfile'),
  occupation<String>('occupation', 'ConsulteeProfile'),
  aboutMe<String>('aboutMe', 'ConsulteeProfile'),
  preferredCommunicationMethod<_i3.ConsultationMode>(
    'preferredCommunicationMethod',
    'ConsulteeProfile',
  ),
  preferredLanguage<String>('preferredLanguage', 'ConsulteeProfile'),
  specialRequirements<String>('specialRequirements', 'ConsulteeProfile'),
  interests<String>('interests', 'ConsulteeProfile'),
  goals<String>('goals', 'ConsulteeProfile'),
  userId<String>('userId', 'ConsulteeProfile'),
  createdAt<DateTime>('createdAt', 'ConsulteeProfile'),
  updatedAt<DateTime>('updatedAt', 'ConsulteeProfile');

  const ConsulteeProfileScalar(this.name, this.model);

  @override
  final String name;

  @override
  final String model;
}

class ConsulteeProfileCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileCreateInput({
    this.id,
    this.education,
    this.occupation,
    this.aboutMe,
    this.preferredCommunicationMethod,
    this.preferredLanguage,
    this.specialRequirements,
    this.interests,
    this.goals,
    this.createdAt,
    this.updatedAt,
    this.consultationRequests,
    this.subscriptionRequests,
    this.consultantReviews,
    required this.user,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? education;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? occupation;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? aboutMe;

  final _i1.PrismaUnion<_i3.ConsultationMode, _i1.PrismaNull>?
  preferredCommunicationMethod;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? preferredLanguage;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? specialRequirements;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? interests;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? goals;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ConsultationCreateNestedManyWithoutRequestedByInput?
  consultationRequests;

  final _i2.SubscriptionCreateNestedManyWithoutRequestedByInput?
  subscriptionRequests;

  final _i2.ConsultantReviewCreateNestedManyWithoutConsulteeProfileInput?
  consultantReviews;

  final _i2.UserCreateNestedOneWithoutConsulteeProfileInput user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'education': education,
    'occupation': occupation,
    'aboutMe': aboutMe,
    'preferredCommunicationMethod': preferredCommunicationMethod,
    'preferredLanguage': preferredLanguage,
    'specialRequirements': specialRequirements,
    'interests': interests,
    'goals': goals,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultationRequests': consultationRequests,
    'subscriptionRequests': subscriptionRequests,
    'consultantReviews': consultantReviews,
    'user': user,
  };
}

class ConsulteeProfileUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileUncheckedCreateInput({
    this.id,
    this.education,
    this.occupation,
    this.aboutMe,
    this.preferredCommunicationMethod,
    this.preferredLanguage,
    this.specialRequirements,
    this.interests,
    this.goals,
    required this.userId,
    this.createdAt,
    this.updatedAt,
    this.consultationRequests,
    this.subscriptionRequests,
    this.consultantReviews,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? education;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? occupation;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? aboutMe;

  final _i1.PrismaUnion<_i3.ConsultationMode, _i1.PrismaNull>?
  preferredCommunicationMethod;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? preferredLanguage;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? specialRequirements;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? interests;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? goals;

  final String userId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ConsultationUncheckedCreateNestedManyWithoutRequestedByInput?
  consultationRequests;

  final _i2.SubscriptionUncheckedCreateNestedManyWithoutRequestedByInput?
  subscriptionRequests;

  final _i2.ConsultantReviewUncheckedCreateNestedManyWithoutConsulteeProfileInput?
  consultantReviews;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'education': education,
    'occupation': occupation,
    'aboutMe': aboutMe,
    'preferredCommunicationMethod': preferredCommunicationMethod,
    'preferredLanguage': preferredLanguage,
    'specialRequirements': specialRequirements,
    'interests': interests,
    'goals': goals,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultationRequests': consultationRequests,
    'subscriptionRequests': subscriptionRequests,
    'consultantReviews': consultantReviews,
  };
}

class ConsulteeProfileCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileCreateManyInput({
    this.id,
    this.education,
    this.occupation,
    this.aboutMe,
    this.preferredCommunicationMethod,
    this.preferredLanguage,
    this.specialRequirements,
    this.interests,
    this.goals,
    required this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? education;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? occupation;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? aboutMe;

  final _i1.PrismaUnion<_i3.ConsultationMode, _i1.PrismaNull>?
  preferredCommunicationMethod;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? preferredLanguage;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? specialRequirements;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? interests;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? goals;

  final String userId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'education': education,
    'occupation': occupation,
    'aboutMe': aboutMe,
    'preferredCommunicationMethod': preferredCommunicationMethod,
    'preferredLanguage': preferredLanguage,
    'specialRequirements': specialRequirements,
    'interests': interests,
    'goals': goals,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsulteeProfileUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileUpdateInput({
    this.id,
    this.education,
    this.occupation,
    this.aboutMe,
    this.preferredCommunicationMethod,
    this.preferredLanguage,
    this.specialRequirements,
    this.interests,
    this.goals,
    this.createdAt,
    this.updatedAt,
    this.consultationRequests,
    this.subscriptionRequests,
    this.consultantReviews,
    this.user,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  education;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  occupation;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  aboutMe;

  final _i1.PrismaUnion<
    _i3.ConsultationMode,
    _i1.PrismaUnion<
      _i2.NullableEnumConsultationModeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  preferredCommunicationMethod;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  preferredLanguage;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  specialRequirements;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  interests;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  goals;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.ConsultationUpdateManyWithoutRequestedByNestedInput?
  consultationRequests;

  final _i2.SubscriptionUpdateManyWithoutRequestedByNestedInput?
  subscriptionRequests;

  final _i2.ConsultantReviewUpdateManyWithoutConsulteeProfileNestedInput?
  consultantReviews;

  final _i2.UserUpdateOneRequiredWithoutConsulteeProfileNestedInput? user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'education': education,
    'occupation': occupation,
    'aboutMe': aboutMe,
    'preferredCommunicationMethod': preferredCommunicationMethod,
    'preferredLanguage': preferredLanguage,
    'specialRequirements': specialRequirements,
    'interests': interests,
    'goals': goals,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultationRequests': consultationRequests,
    'subscriptionRequests': subscriptionRequests,
    'consultantReviews': consultantReviews,
    'user': user,
  };
}

class ConsulteeProfileUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileUncheckedUpdateInput({
    this.id,
    this.education,
    this.occupation,
    this.aboutMe,
    this.preferredCommunicationMethod,
    this.preferredLanguage,
    this.specialRequirements,
    this.interests,
    this.goals,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.consultationRequests,
    this.subscriptionRequests,
    this.consultantReviews,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  education;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  occupation;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  aboutMe;

  final _i1.PrismaUnion<
    _i3.ConsultationMode,
    _i1.PrismaUnion<
      _i2.NullableEnumConsultationModeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  preferredCommunicationMethod;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  preferredLanguage;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  specialRequirements;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  interests;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  goals;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.ConsultationUncheckedUpdateManyWithoutRequestedByNestedInput?
  consultationRequests;

  final _i2.SubscriptionUncheckedUpdateManyWithoutRequestedByNestedInput?
  subscriptionRequests;

  final _i2.ConsultantReviewUncheckedUpdateManyWithoutConsulteeProfileNestedInput?
  consultantReviews;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'education': education,
    'occupation': occupation,
    'aboutMe': aboutMe,
    'preferredCommunicationMethod': preferredCommunicationMethod,
    'preferredLanguage': preferredLanguage,
    'specialRequirements': specialRequirements,
    'interests': interests,
    'goals': goals,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultationRequests': consultationRequests,
    'subscriptionRequests': subscriptionRequests,
    'consultantReviews': consultantReviews,
  };
}

class ConsulteeProfileUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileUpdateManyMutationInput({
    this.id,
    this.education,
    this.occupation,
    this.aboutMe,
    this.preferredCommunicationMethod,
    this.preferredLanguage,
    this.specialRequirements,
    this.interests,
    this.goals,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  education;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  occupation;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  aboutMe;

  final _i1.PrismaUnion<
    _i3.ConsultationMode,
    _i1.PrismaUnion<
      _i2.NullableEnumConsultationModeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  preferredCommunicationMethod;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  preferredLanguage;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  specialRequirements;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  interests;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  goals;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'education': education,
    'occupation': occupation,
    'aboutMe': aboutMe,
    'preferredCommunicationMethod': preferredCommunicationMethod,
    'preferredLanguage': preferredLanguage,
    'specialRequirements': specialRequirements,
    'interests': interests,
    'goals': goals,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsulteeProfileUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileUncheckedUpdateManyInput({
    this.id,
    this.education,
    this.occupation,
    this.aboutMe,
    this.preferredCommunicationMethod,
    this.preferredLanguage,
    this.specialRequirements,
    this.interests,
    this.goals,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  education;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  occupation;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  aboutMe;

  final _i1.PrismaUnion<
    _i3.ConsultationMode,
    _i1.PrismaUnion<
      _i2.NullableEnumConsultationModeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  preferredCommunicationMethod;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  preferredLanguage;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  specialRequirements;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  interests;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  goals;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'education': education,
    'occupation': occupation,
    'aboutMe': aboutMe,
    'preferredCommunicationMethod': preferredCommunicationMethod,
    'preferredLanguage': preferredLanguage,
    'specialRequirements': specialRequirements,
    'interests': interests,
    'goals': goals,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsulteeProfileCountAggregateOutputType {
  const ConsulteeProfileCountAggregateOutputType({
    this.id,
    this.education,
    this.occupation,
    this.aboutMe,
    this.preferredCommunicationMethod,
    this.preferredLanguage,
    this.specialRequirements,
    this.interests,
    this.goals,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  factory ConsulteeProfileCountAggregateOutputType.fromJson(Map json) =>
      ConsulteeProfileCountAggregateOutputType(
        id: json['id'],
        education: json['education'],
        occupation: json['occupation'],
        aboutMe: json['aboutMe'],
        preferredCommunicationMethod: json['preferredCommunicationMethod'],
        preferredLanguage: json['preferredLanguage'],
        specialRequirements: json['specialRequirements'],
        interests: json['interests'],
        goals: json['goals'],
        userId: json['userId'],
        createdAt: json['createdAt'],
        updatedAt: json['updatedAt'],
        $all: json['_all'],
      );

  final int? id;

  final int? education;

  final int? occupation;

  final int? aboutMe;

  final int? preferredCommunicationMethod;

  final int? preferredLanguage;

  final int? specialRequirements;

  final int? interests;

  final int? goals;

  final int? userId;

  final int? createdAt;

  final int? updatedAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
    'id': id,
    'education': education,
    'occupation': occupation,
    'aboutMe': aboutMe,
    'preferredCommunicationMethod': preferredCommunicationMethod,
    'preferredLanguage': preferredLanguage,
    'specialRequirements': specialRequirements,
    'interests': interests,
    'goals': goals,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class ConsulteeProfileMinAggregateOutputType {
  const ConsulteeProfileMinAggregateOutputType({
    this.id,
    this.education,
    this.occupation,
    this.aboutMe,
    this.preferredCommunicationMethod,
    this.preferredLanguage,
    this.specialRequirements,
    this.interests,
    this.goals,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  factory ConsulteeProfileMinAggregateOutputType.fromJson(Map json) =>
      ConsulteeProfileMinAggregateOutputType(
        id: json['id'],
        education: json['education'],
        occupation: json['occupation'],
        aboutMe: json['aboutMe'],
        preferredCommunicationMethod:
            json['preferredCommunicationMethod'] != null
            ? _i3.ConsultationMode.values.firstWhere(
                (e) => e.name == json['preferredCommunicationMethod'],
              )
            : null,
        preferredLanguage: json['preferredLanguage'],
        specialRequirements: json['specialRequirements'],
        interests: json['interests'],
        goals: json['goals'],
        userId: json['userId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final String? education;

  final String? occupation;

  final String? aboutMe;

  final _i3.ConsultationMode? preferredCommunicationMethod;

  final String? preferredLanguage;

  final String? specialRequirements;

  final String? interests;

  final String? goals;

  final String? userId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'education': education,
    'occupation': occupation,
    'aboutMe': aboutMe,
    'preferredCommunicationMethod': preferredCommunicationMethod?.name,
    'preferredLanguage': preferredLanguage,
    'specialRequirements': specialRequirements,
    'interests': interests,
    'goals': goals,
    'userId': userId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class ConsulteeProfileMaxAggregateOutputType {
  const ConsulteeProfileMaxAggregateOutputType({
    this.id,
    this.education,
    this.occupation,
    this.aboutMe,
    this.preferredCommunicationMethod,
    this.preferredLanguage,
    this.specialRequirements,
    this.interests,
    this.goals,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  factory ConsulteeProfileMaxAggregateOutputType.fromJson(Map json) =>
      ConsulteeProfileMaxAggregateOutputType(
        id: json['id'],
        education: json['education'],
        occupation: json['occupation'],
        aboutMe: json['aboutMe'],
        preferredCommunicationMethod:
            json['preferredCommunicationMethod'] != null
            ? _i3.ConsultationMode.values.firstWhere(
                (e) => e.name == json['preferredCommunicationMethod'],
              )
            : null,
        preferredLanguage: json['preferredLanguage'],
        specialRequirements: json['specialRequirements'],
        interests: json['interests'],
        goals: json['goals'],
        userId: json['userId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final String? education;

  final String? occupation;

  final String? aboutMe;

  final _i3.ConsultationMode? preferredCommunicationMethod;

  final String? preferredLanguage;

  final String? specialRequirements;

  final String? interests;

  final String? goals;

  final String? userId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'education': education,
    'occupation': occupation,
    'aboutMe': aboutMe,
    'preferredCommunicationMethod': preferredCommunicationMethod?.name,
    'preferredLanguage': preferredLanguage,
    'specialRequirements': specialRequirements,
    'interests': interests,
    'goals': goals,
    'userId': userId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class ConsulteeProfileGroupByOutputType {
  const ConsulteeProfileGroupByOutputType({
    this.id,
    this.education,
    this.occupation,
    this.aboutMe,
    this.preferredCommunicationMethod,
    this.preferredLanguage,
    this.specialRequirements,
    this.interests,
    this.goals,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$min,
    this.$max,
  });

  factory ConsulteeProfileGroupByOutputType.fromJson(
    Map json,
  ) => ConsulteeProfileGroupByOutputType(
    id: json['id'],
    education: json['education'],
    occupation: json['occupation'],
    aboutMe: json['aboutMe'],
    preferredCommunicationMethod: json['preferredCommunicationMethod'] != null
        ? _i3.ConsultationMode.values.firstWhere(
            (e) => e.name == json['preferredCommunicationMethod'],
          )
        : null,
    preferredLanguage: json['preferredLanguage'],
    specialRequirements: json['specialRequirements'],
    interests: json['interests'],
    goals: json['goals'],
    userId: json['userId'],
    createdAt: switch (json['createdAt']) {
      DateTime value => value,
      String value => DateTime.parse(value),
      _ => json['createdAt'],
    },
    updatedAt: switch (json['updatedAt']) {
      DateTime value => value,
      String value => DateTime.parse(value),
      _ => json['updatedAt'],
    },
    $count: json['_count'] is Map
        ? _i2.ConsulteeProfileCountAggregateOutputType.fromJson(json['_count'])
        : null,
    $min: json['_min'] is Map
        ? _i2.ConsulteeProfileMinAggregateOutputType.fromJson(json['_min'])
        : null,
    $max: json['_max'] is Map
        ? _i2.ConsulteeProfileMaxAggregateOutputType.fromJson(json['_max'])
        : null,
  );

  final String? id;

  final String? education;

  final String? occupation;

  final String? aboutMe;

  final _i3.ConsultationMode? preferredCommunicationMethod;

  final String? preferredLanguage;

  final String? specialRequirements;

  final String? interests;

  final String? goals;

  final String? userId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ConsulteeProfileCountAggregateOutputType? $count;

  final _i2.ConsulteeProfileMinAggregateOutputType? $min;

  final _i2.ConsulteeProfileMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    'id': id,
    'education': education,
    'occupation': occupation,
    'aboutMe': aboutMe,
    'preferredCommunicationMethod': preferredCommunicationMethod?.name,
    'preferredLanguage': preferredLanguage,
    'specialRequirements': specialRequirements,
    'interests': interests,
    'goals': goals,
    'userId': userId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
    '_count': $count?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class ConsulteeProfileCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileCountOrderByAggregateInput({
    this.id,
    this.education,
    this.occupation,
    this.aboutMe,
    this.preferredCommunicationMethod,
    this.preferredLanguage,
    this.specialRequirements,
    this.interests,
    this.goals,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? education;

  final _i2.SortOrder? occupation;

  final _i2.SortOrder? aboutMe;

  final _i2.SortOrder? preferredCommunicationMethod;

  final _i2.SortOrder? preferredLanguage;

  final _i2.SortOrder? specialRequirements;

  final _i2.SortOrder? interests;

  final _i2.SortOrder? goals;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'education': education,
    'occupation': occupation,
    'aboutMe': aboutMe,
    'preferredCommunicationMethod': preferredCommunicationMethod,
    'preferredLanguage': preferredLanguage,
    'specialRequirements': specialRequirements,
    'interests': interests,
    'goals': goals,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsulteeProfileMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileMaxOrderByAggregateInput({
    this.id,
    this.education,
    this.occupation,
    this.aboutMe,
    this.preferredCommunicationMethod,
    this.preferredLanguage,
    this.specialRequirements,
    this.interests,
    this.goals,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? education;

  final _i2.SortOrder? occupation;

  final _i2.SortOrder? aboutMe;

  final _i2.SortOrder? preferredCommunicationMethod;

  final _i2.SortOrder? preferredLanguage;

  final _i2.SortOrder? specialRequirements;

  final _i2.SortOrder? interests;

  final _i2.SortOrder? goals;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'education': education,
    'occupation': occupation,
    'aboutMe': aboutMe,
    'preferredCommunicationMethod': preferredCommunicationMethod,
    'preferredLanguage': preferredLanguage,
    'specialRequirements': specialRequirements,
    'interests': interests,
    'goals': goals,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsulteeProfileMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileMinOrderByAggregateInput({
    this.id,
    this.education,
    this.occupation,
    this.aboutMe,
    this.preferredCommunicationMethod,
    this.preferredLanguage,
    this.specialRequirements,
    this.interests,
    this.goals,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? education;

  final _i2.SortOrder? occupation;

  final _i2.SortOrder? aboutMe;

  final _i2.SortOrder? preferredCommunicationMethod;

  final _i2.SortOrder? preferredLanguage;

  final _i2.SortOrder? specialRequirements;

  final _i2.SortOrder? interests;

  final _i2.SortOrder? goals;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'education': education,
    'occupation': occupation,
    'aboutMe': aboutMe,
    'preferredCommunicationMethod': preferredCommunicationMethod,
    'preferredLanguage': preferredLanguage,
    'specialRequirements': specialRequirements,
    'interests': interests,
    'goals': goals,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsulteeProfileOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileOrderByWithAggregationInput({
    this.id,
    this.education,
    this.occupation,
    this.aboutMe,
    this.preferredCommunicationMethod,
    this.preferredLanguage,
    this.specialRequirements,
    this.interests,
    this.goals,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$max,
    this.$min,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? education;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? occupation;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? aboutMe;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>?
  preferredCommunicationMethod;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? preferredLanguage;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? specialRequirements;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? interests;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? goals;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.ConsulteeProfileCountOrderByAggregateInput? $count;

  final _i2.ConsulteeProfileMaxOrderByAggregateInput? $max;

  final _i2.ConsulteeProfileMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'education': education,
    'occupation': occupation,
    'aboutMe': aboutMe,
    'preferredCommunicationMethod': preferredCommunicationMethod,
    'preferredLanguage': preferredLanguage,
    'specialRequirements': specialRequirements,
    'interests': interests,
    'goals': goals,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_max': $max,
    '_min': $min,
  };
}

class NestedEnumConsultationModeNullableWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedEnumConsultationModeNullableWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<_i3.ConsultationMode, _i1.PrismaNull>? equals;

  final _i1.PrismaUnion<
    Iterable<_i3.ConsultationMode>,
    _i1.PrismaUnion<_i3.ConsultationMode, _i1.PrismaNull>
  >?
  $in;

  final _i1.PrismaUnion<
    Iterable<_i3.ConsultationMode>,
    _i1.PrismaUnion<_i3.ConsultationMode, _i1.PrismaNull>
  >?
  notIn;

  final _i1.PrismaUnion<
    _i3.ConsultationMode,
    _i1.PrismaUnion<
      _i2.NestedEnumConsultationModeNullableWithAggregatesFilter,
      _i1.PrismaNull
    >
  >?
  not;

  final _i2.NestedIntNullableFilter? $count;

  final _i2.NestedEnumConsultationModeNullableFilter? $min;

  final _i2.NestedEnumConsultationModeNullableFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class EnumConsultationModeNullableWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumConsultationModeNullableWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<_i3.ConsultationMode, _i1.PrismaNull>? equals;

  final _i1.PrismaUnion<
    Iterable<_i3.ConsultationMode>,
    _i1.PrismaUnion<_i3.ConsultationMode, _i1.PrismaNull>
  >?
  $in;

  final _i1.PrismaUnion<
    Iterable<_i3.ConsultationMode>,
    _i1.PrismaUnion<_i3.ConsultationMode, _i1.PrismaNull>
  >?
  notIn;

  final _i1.PrismaUnion<
    _i3.ConsultationMode,
    _i1.PrismaUnion<
      _i2.NestedEnumConsultationModeNullableWithAggregatesFilter,
      _i1.PrismaNull
    >
  >?
  not;

  final _i2.NestedIntNullableFilter? $count;

  final _i2.NestedEnumConsultationModeNullableFilter? $min;

  final _i2.NestedEnumConsultationModeNullableFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class ConsulteeProfileScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.education,
    this.occupation,
    this.aboutMe,
    this.preferredCommunicationMethod,
    this.preferredLanguage,
    this.specialRequirements,
    this.interests,
    this.goals,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
    _i2.ConsulteeProfileScalarWhereWithAggregatesInput,
    Iterable<_i2.ConsulteeProfileScalarWhereWithAggregatesInput>
  >?
  AND;

  final Iterable<_i2.ConsulteeProfileScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<
    _i2.ConsulteeProfileScalarWhereWithAggregatesInput,
    Iterable<_i2.ConsulteeProfileScalarWhereWithAggregatesInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? id;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  education;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  occupation;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  aboutMe;

  final _i1.PrismaUnion<
    _i2.EnumConsultationModeNullableWithAggregatesFilter,
    _i1.PrismaUnion<_i3.ConsultationMode, _i1.PrismaNull>
  >?
  preferredCommunicationMethod;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  preferredLanguage;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  specialRequirements;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  interests;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  goals;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? userId;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'education': education,
    'occupation': occupation,
    'aboutMe': aboutMe,
    'preferredCommunicationMethod': preferredCommunicationMethod,
    'preferredLanguage': preferredLanguage,
    'specialRequirements': specialRequirements,
    'interests': interests,
    'goals': goals,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsulteeProfileCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileCountAggregateOutputTypeSelect({
    this.id,
    this.education,
    this.occupation,
    this.aboutMe,
    this.preferredCommunicationMethod,
    this.preferredLanguage,
    this.specialRequirements,
    this.interests,
    this.goals,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  final bool? id;

  final bool? education;

  final bool? occupation;

  final bool? aboutMe;

  final bool? preferredCommunicationMethod;

  final bool? preferredLanguage;

  final bool? specialRequirements;

  final bool? interests;

  final bool? goals;

  final bool? userId;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'education': education,
    'occupation': occupation,
    'aboutMe': aboutMe,
    'preferredCommunicationMethod': preferredCommunicationMethod,
    'preferredLanguage': preferredLanguage,
    'specialRequirements': specialRequirements,
    'interests': interests,
    'goals': goals,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class ConsulteeProfileGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileGroupByOutputTypeCountArgs({this.select});

  final _i2.ConsulteeProfileCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ConsulteeProfileMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileMinAggregateOutputTypeSelect({
    this.id,
    this.education,
    this.occupation,
    this.aboutMe,
    this.preferredCommunicationMethod,
    this.preferredLanguage,
    this.specialRequirements,
    this.interests,
    this.goals,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? education;

  final bool? occupation;

  final bool? aboutMe;

  final bool? preferredCommunicationMethod;

  final bool? preferredLanguage;

  final bool? specialRequirements;

  final bool? interests;

  final bool? goals;

  final bool? userId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'education': education,
    'occupation': occupation,
    'aboutMe': aboutMe,
    'preferredCommunicationMethod': preferredCommunicationMethod,
    'preferredLanguage': preferredLanguage,
    'specialRequirements': specialRequirements,
    'interests': interests,
    'goals': goals,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsulteeProfileGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileGroupByOutputTypeMinArgs({this.select});

  final _i2.ConsulteeProfileMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ConsulteeProfileMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileMaxAggregateOutputTypeSelect({
    this.id,
    this.education,
    this.occupation,
    this.aboutMe,
    this.preferredCommunicationMethod,
    this.preferredLanguage,
    this.specialRequirements,
    this.interests,
    this.goals,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? education;

  final bool? occupation;

  final bool? aboutMe;

  final bool? preferredCommunicationMethod;

  final bool? preferredLanguage;

  final bool? specialRequirements;

  final bool? interests;

  final bool? goals;

  final bool? userId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'education': education,
    'occupation': occupation,
    'aboutMe': aboutMe,
    'preferredCommunicationMethod': preferredCommunicationMethod,
    'preferredLanguage': preferredLanguage,
    'specialRequirements': specialRequirements,
    'interests': interests,
    'goals': goals,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsulteeProfileGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileGroupByOutputTypeMaxArgs({this.select});

  final _i2.ConsulteeProfileMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ConsulteeProfileGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsulteeProfileGroupByOutputTypeSelect({
    this.id,
    this.education,
    this.occupation,
    this.aboutMe,
    this.preferredCommunicationMethod,
    this.preferredLanguage,
    this.specialRequirements,
    this.interests,
    this.goals,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? education;

  final bool? occupation;

  final bool? aboutMe;

  final bool? preferredCommunicationMethod;

  final bool? preferredLanguage;

  final bool? specialRequirements;

  final bool? interests;

  final bool? goals;

  final bool? userId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.ConsulteeProfileGroupByOutputTypeCountArgs>?
  $count;

  final _i1.PrismaUnion<bool, _i2.ConsulteeProfileGroupByOutputTypeMinArgs>?
  $min;

  final _i1.PrismaUnion<bool, _i2.ConsulteeProfileGroupByOutputTypeMaxArgs>?
  $max;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'education': education,
    'occupation': occupation,
    'aboutMe': aboutMe,
    'preferredCommunicationMethod': preferredCommunicationMethod,
    'preferredLanguage': preferredLanguage,
    'specialRequirements': specialRequirements,
    'interests': interests,
    'goals': goals,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class AggregateConsulteeProfile {
  const AggregateConsulteeProfile({this.$count, this.$min, this.$max});

  factory AggregateConsulteeProfile.fromJson(Map json) =>
      AggregateConsulteeProfile(
        $count: json['_count'] is Map
            ? _i2.ConsulteeProfileCountAggregateOutputType.fromJson(
                json['_count'],
              )
            : null,
        $min: json['_min'] is Map
            ? _i2.ConsulteeProfileMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.ConsulteeProfileMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.ConsulteeProfileCountAggregateOutputType? $count;

  final _i2.ConsulteeProfileMinAggregateOutputType? $min;

  final _i2.ConsulteeProfileMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    '_count': $count?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class AggregateConsulteeProfileCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateConsulteeProfileCountArgs({this.select});

  final _i2.ConsulteeProfileCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateConsulteeProfileMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateConsulteeProfileMinArgs({this.select});

  final _i2.ConsulteeProfileMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateConsulteeProfileMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateConsulteeProfileMaxArgs({this.select});

  final _i2.ConsulteeProfileMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateConsulteeProfileSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateConsulteeProfileSelect({this.$count, this.$min, this.$max});

  final _i1.PrismaUnion<bool, _i2.AggregateConsulteeProfileCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateConsulteeProfileMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateConsulteeProfileMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

enum StaffProfileScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<String>('id', 'StaffProfile'),
  department<String>('department', 'StaffProfile'),
  position<String>('position', 'StaffProfile'),
  permissions<_i1.PrismaJson>('permissions', 'StaffProfile'),
  responsibilities<_i1.PrismaJson>('responsibilities', 'StaffProfile'),
  userId<String>('userId', 'StaffProfile'),
  createdAt<DateTime>('createdAt', 'StaffProfile'),
  updatedAt<DateTime>('updatedAt', 'StaffProfile');

  const StaffProfileScalar(this.name, this.model);

  @override
  final String name;

  @override
  final String model;
}

class UserCreateWithoutStaffProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateWithoutStaffProfileInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.cookiePreferences,
    this.notificationPreferences,
    this.payment,
    this.consultantProfile,
    this.consulteeProfile,
    this.slotsOfAppointment,
    this.waitlist,
    this.feedbacks,
    this.supportTickets,
    this.supportResponses,
    this.accounts,
    this.sessions,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? email;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? emailVerified;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? image;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? address;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? password;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? passwordResetToken;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? passwordResetExpires;

  final bool? onlineStatus;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? currentTimezone;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? onboardingCompleted;

  final _i1.PrismaUnion<_i3.UserRole, _i1.PrismaNull>? role;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consultantProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consulteeProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? staffProfileId;

  final _i2.CookiePreferenceCreateNestedOneWithoutUserInput? cookiePreferences;

  final _i2.NotificationPreferenceCreateNestedOneWithoutUserInput?
  notificationPreferences;

  final _i2.PaymentCreateNestedManyWithoutUserInput? payment;

  final _i2.ConsultantProfileCreateNestedOneWithoutUserInput? consultantProfile;

  final _i2.ConsulteeProfileCreateNestedOneWithoutUserInput? consulteeProfile;

  final _i2.SlotOfAppointmentCreateNestedManyWithoutUserInput?
  slotsOfAppointment;

  final _i2.WaitlistCreateNestedManyWithoutUserInput? waitlist;

  final _i2.FeedbackCreateNestedManyWithoutUserInput? feedbacks;

  final _i2.SupportTicketCreateNestedManyWithoutUserInput? supportTickets;

  final _i2.SupportResponseCreateNestedManyWithoutUserInput? supportResponses;

  final _i2.AccountCreateNestedManyWithoutUserInput? accounts;

  final _i2.SessionCreateNestedManyWithoutUserInput? sessions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'cookiePreferences': cookiePreferences,
    'notificationPreferences': notificationPreferences,
    'Payment': payment,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
    'slotsOfAppointment': slotsOfAppointment,
    'Waitlist': waitlist,
    'feedbacks': feedbacks,
    'supportTickets': supportTickets,
    'supportResponses': supportResponses,
    'accounts': accounts,
    'sessions': sessions,
  };
}

class UserUncheckedCreateWithoutStaffProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUncheckedCreateWithoutStaffProfileInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.cookiePreferences,
    this.notificationPreferences,
    this.payment,
    this.consultantProfile,
    this.consulteeProfile,
    this.slotsOfAppointment,
    this.waitlist,
    this.feedbacks,
    this.supportTickets,
    this.supportResponses,
    this.accounts,
    this.sessions,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? email;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? emailVerified;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? image;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? address;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? password;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? passwordResetToken;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? passwordResetExpires;

  final bool? onlineStatus;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? currentTimezone;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? onboardingCompleted;

  final _i1.PrismaUnion<_i3.UserRole, _i1.PrismaNull>? role;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consultantProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consulteeProfileId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? staffProfileId;

  final _i2.CookiePreferenceUncheckedCreateNestedOneWithoutUserInput?
  cookiePreferences;

  final _i2.NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput?
  notificationPreferences;

  final _i2.PaymentUncheckedCreateNestedManyWithoutUserInput? payment;

  final _i2.ConsultantProfileUncheckedCreateNestedOneWithoutUserInput?
  consultantProfile;

  final _i2.ConsulteeProfileUncheckedCreateNestedOneWithoutUserInput?
  consulteeProfile;

  final _i2.SlotOfAppointmentUncheckedCreateNestedManyWithoutUserInput?
  slotsOfAppointment;

  final _i2.WaitlistUncheckedCreateNestedManyWithoutUserInput? waitlist;

  final _i2.FeedbackUncheckedCreateNestedManyWithoutUserInput? feedbacks;

  final _i2.SupportTicketUncheckedCreateNestedManyWithoutUserInput?
  supportTickets;

  final _i2.SupportResponseUncheckedCreateNestedManyWithoutUserInput?
  supportResponses;

  final _i2.AccountUncheckedCreateNestedManyWithoutUserInput? accounts;

  final _i2.SessionUncheckedCreateNestedManyWithoutUserInput? sessions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'cookiePreferences': cookiePreferences,
    'notificationPreferences': notificationPreferences,
    'Payment': payment,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
    'slotsOfAppointment': slotsOfAppointment,
    'Waitlist': waitlist,
    'feedbacks': feedbacks,
    'supportTickets': supportTickets,
    'supportResponses': supportResponses,
    'accounts': accounts,
    'sessions': sessions,
  };
}

class UserCreateOrConnectWithoutStaffProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateOrConnectWithoutStaffProfileInput({
    required this.where,
    required this.create,
  });

  final _i2.UserWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.UserCreateWithoutStaffProfileInput,
    _i2.UserUncheckedCreateWithoutStaffProfileInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class UserCreateNestedOneWithoutStaffProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateNestedOneWithoutStaffProfileInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.UserCreateWithoutStaffProfileInput,
    _i2.UserUncheckedCreateWithoutStaffProfileInput
  >?
  create;

  final _i2.UserCreateOrConnectWithoutStaffProfileInput? connectOrCreate;

  final _i2.UserWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class StaffProfileCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StaffProfileCreateInput({
    this.id,
    this.department,
    this.position,
    this.permissions,
    this.responsibilities,
    this.createdAt,
    this.updatedAt,
    required this.user,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? department;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? position;

  final _i1.PrismaUnion<_i2.NullableJsonNullValueInput, _i1.PrismaJson>?
  permissions;

  final _i1.PrismaUnion<_i2.NullableJsonNullValueInput, _i1.PrismaJson>?
  responsibilities;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.UserCreateNestedOneWithoutStaffProfileInput user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'department': department,
    'position': position,
    'permissions': permissions,
    'responsibilities': responsibilities,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'user': user,
  };
}

class StaffProfileUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StaffProfileUncheckedCreateInput({
    this.id,
    this.department,
    this.position,
    this.permissions,
    this.responsibilities,
    required this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? department;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? position;

  final _i1.PrismaUnion<_i2.NullableJsonNullValueInput, _i1.PrismaJson>?
  permissions;

  final _i1.PrismaUnion<_i2.NullableJsonNullValueInput, _i1.PrismaJson>?
  responsibilities;

  final String userId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'department': department,
    'position': position,
    'permissions': permissions,
    'responsibilities': responsibilities,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class StaffProfileCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StaffProfileCreateManyInput({
    this.id,
    this.department,
    this.position,
    this.permissions,
    this.responsibilities,
    required this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? department;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? position;

  final _i1.PrismaUnion<_i2.NullableJsonNullValueInput, _i1.PrismaJson>?
  permissions;

  final _i1.PrismaUnion<_i2.NullableJsonNullValueInput, _i1.PrismaJson>?
  responsibilities;

  final String userId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'department': department,
    'position': position,
    'permissions': permissions,
    'responsibilities': responsibilities,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class UserUpdateWithoutStaffProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpdateWithoutStaffProfileInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.cookiePreferences,
    this.notificationPreferences,
    this.payment,
    this.consultantProfile,
    this.consulteeProfile,
    this.slotsOfAppointment,
    this.waitlist,
    this.feedbacks,
    this.supportTickets,
    this.supportResponses,
    this.accounts,
    this.sessions,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  name;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  email;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  emailVerified;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  image;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  phone;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  address;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  password;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetToken;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetExpires;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? onlineStatus;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  currentTimezone;

  final _i1.PrismaUnion<
    bool,
    _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  onboardingCompleted;

  final _i1.PrismaUnion<
    _i3.UserRole,
    _i1.PrismaUnion<
      _i2.NullableEnumUserRoleFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  role;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consultantProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consulteeProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  staffProfileId;

  final _i2.CookiePreferenceUpdateOneWithoutUserNestedInput? cookiePreferences;

  final _i2.NotificationPreferenceUpdateOneWithoutUserNestedInput?
  notificationPreferences;

  final _i2.PaymentUpdateManyWithoutUserNestedInput? payment;

  final _i2.ConsultantProfileUpdateOneWithoutUserNestedInput? consultantProfile;

  final _i2.ConsulteeProfileUpdateOneWithoutUserNestedInput? consulteeProfile;

  final _i2.SlotOfAppointmentUpdateManyWithoutUserNestedInput?
  slotsOfAppointment;

  final _i2.WaitlistUpdateManyWithoutUserNestedInput? waitlist;

  final _i2.FeedbackUpdateManyWithoutUserNestedInput? feedbacks;

  final _i2.SupportTicketUpdateManyWithoutUserNestedInput? supportTickets;

  final _i2.SupportResponseUpdateManyWithoutUserNestedInput? supportResponses;

  final _i2.AccountUpdateManyWithoutUserNestedInput? accounts;

  final _i2.SessionUpdateManyWithoutUserNestedInput? sessions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'cookiePreferences': cookiePreferences,
    'notificationPreferences': notificationPreferences,
    'Payment': payment,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
    'slotsOfAppointment': slotsOfAppointment,
    'Waitlist': waitlist,
    'feedbacks': feedbacks,
    'supportTickets': supportTickets,
    'supportResponses': supportResponses,
    'accounts': accounts,
    'sessions': sessions,
  };
}

class UserUncheckedUpdateWithoutStaffProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUncheckedUpdateWithoutStaffProfileInput({
    this.id,
    this.name,
    this.email,
    this.emailVerified,
    this.image,
    this.phone,
    this.address,
    this.password,
    this.passwordResetToken,
    this.passwordResetExpires,
    this.onlineStatus,
    this.currentTimezone,
    this.onboardingCompleted,
    this.role,
    this.consultantProfileId,
    this.consulteeProfileId,
    this.staffProfileId,
    this.cookiePreferences,
    this.notificationPreferences,
    this.payment,
    this.consultantProfile,
    this.consulteeProfile,
    this.slotsOfAppointment,
    this.waitlist,
    this.feedbacks,
    this.supportTickets,
    this.supportResponses,
    this.accounts,
    this.sessions,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  name;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  email;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  emailVerified;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  image;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  phone;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  address;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  password;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetToken;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passwordResetExpires;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? onlineStatus;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  currentTimezone;

  final _i1.PrismaUnion<
    bool,
    _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  onboardingCompleted;

  final _i1.PrismaUnion<
    _i3.UserRole,
    _i1.PrismaUnion<
      _i2.NullableEnumUserRoleFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  role;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consultantProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consulteeProfileId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  staffProfileId;

  final _i2.CookiePreferenceUncheckedUpdateOneWithoutUserNestedInput?
  cookiePreferences;

  final _i2.NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput?
  notificationPreferences;

  final _i2.PaymentUncheckedUpdateManyWithoutUserNestedInput? payment;

  final _i2.ConsultantProfileUncheckedUpdateOneWithoutUserNestedInput?
  consultantProfile;

  final _i2.ConsulteeProfileUncheckedUpdateOneWithoutUserNestedInput?
  consulteeProfile;

  final _i2.SlotOfAppointmentUncheckedUpdateManyWithoutUserNestedInput?
  slotsOfAppointment;

  final _i2.WaitlistUncheckedUpdateManyWithoutUserNestedInput? waitlist;

  final _i2.FeedbackUncheckedUpdateManyWithoutUserNestedInput? feedbacks;

  final _i2.SupportTicketUncheckedUpdateManyWithoutUserNestedInput?
  supportTickets;

  final _i2.SupportResponseUncheckedUpdateManyWithoutUserNestedInput?
  supportResponses;

  final _i2.AccountUncheckedUpdateManyWithoutUserNestedInput? accounts;

  final _i2.SessionUncheckedUpdateManyWithoutUserNestedInput? sessions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
    'emailVerified': emailVerified,
    'image': image,
    'phone': phone,
    'address': address,
    'password': password,
    'passwordResetToken': passwordResetToken,
    'passwordResetExpires': passwordResetExpires,
    'onlineStatus': onlineStatus,
    'currentTimezone': currentTimezone,
    'onboardingCompleted': onboardingCompleted,
    'role': role,
    'consultantProfileId': consultantProfileId,
    'consulteeProfileId': consulteeProfileId,
    'staffProfileId': staffProfileId,
    'cookiePreferences': cookiePreferences,
    'notificationPreferences': notificationPreferences,
    'Payment': payment,
    'consultantProfile': consultantProfile,
    'consulteeProfile': consulteeProfile,
    'slotsOfAppointment': slotsOfAppointment,
    'Waitlist': waitlist,
    'feedbacks': feedbacks,
    'supportTickets': supportTickets,
    'supportResponses': supportResponses,
    'accounts': accounts,
    'sessions': sessions,
  };
}

class UserUpsertWithoutStaffProfileInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpsertWithoutStaffProfileInput({
    required this.update,
    required this.create,
  });

  final _i1.PrismaUnion<
    _i2.UserUpdateWithoutStaffProfileInput,
    _i2.UserUncheckedUpdateWithoutStaffProfileInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.UserCreateWithoutStaffProfileInput,
    _i2.UserUncheckedCreateWithoutStaffProfileInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'update': update, 'create': create};
}

class UserUpdateOneRequiredWithoutStaffProfileNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpdateOneRequiredWithoutStaffProfileNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.UserCreateWithoutStaffProfileInput,
    _i2.UserUncheckedCreateWithoutStaffProfileInput
  >?
  create;

  final _i2.UserCreateOrConnectWithoutStaffProfileInput? connectOrCreate;

  final _i2.UserUpsertWithoutStaffProfileInput? upsert;

  final _i2.UserWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.UserUpdateWithoutStaffProfileInput,
    _i2.UserUncheckedUpdateWithoutStaffProfileInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'connect': connect,
    'update': update,
  };
}

class StaffProfileUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StaffProfileUpdateInput({
    this.id,
    this.department,
    this.position,
    this.permissions,
    this.responsibilities,
    this.createdAt,
    this.updatedAt,
    this.user,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  department;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  position;

  final _i1.PrismaUnion<_i2.NullableJsonNullValueInput, _i1.PrismaJson>?
  permissions;

  final _i1.PrismaUnion<_i2.NullableJsonNullValueInput, _i1.PrismaJson>?
  responsibilities;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.UserUpdateOneRequiredWithoutStaffProfileNestedInput? user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'department': department,
    'position': position,
    'permissions': permissions,
    'responsibilities': responsibilities,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'user': user,
  };
}

class StaffProfileUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StaffProfileUncheckedUpdateInput({
    this.id,
    this.department,
    this.position,
    this.permissions,
    this.responsibilities,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  department;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  position;

  final _i1.PrismaUnion<_i2.NullableJsonNullValueInput, _i1.PrismaJson>?
  permissions;

  final _i1.PrismaUnion<_i2.NullableJsonNullValueInput, _i1.PrismaJson>?
  responsibilities;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'department': department,
    'position': position,
    'permissions': permissions,
    'responsibilities': responsibilities,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class StaffProfileUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StaffProfileUpdateManyMutationInput({
    this.id,
    this.department,
    this.position,
    this.permissions,
    this.responsibilities,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  department;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  position;

  final _i1.PrismaUnion<_i2.NullableJsonNullValueInput, _i1.PrismaJson>?
  permissions;

  final _i1.PrismaUnion<_i2.NullableJsonNullValueInput, _i1.PrismaJson>?
  responsibilities;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'department': department,
    'position': position,
    'permissions': permissions,
    'responsibilities': responsibilities,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class StaffProfileUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StaffProfileUncheckedUpdateManyInput({
    this.id,
    this.department,
    this.position,
    this.permissions,
    this.responsibilities,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  department;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  position;

  final _i1.PrismaUnion<_i2.NullableJsonNullValueInput, _i1.PrismaJson>?
  permissions;

  final _i1.PrismaUnion<_i2.NullableJsonNullValueInput, _i1.PrismaJson>?
  responsibilities;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'department': department,
    'position': position,
    'permissions': permissions,
    'responsibilities': responsibilities,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class StaffProfileCountAggregateOutputType {
  const StaffProfileCountAggregateOutputType({
    this.id,
    this.department,
    this.position,
    this.permissions,
    this.responsibilities,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  factory StaffProfileCountAggregateOutputType.fromJson(Map json) =>
      StaffProfileCountAggregateOutputType(
        id: json['id'],
        department: json['department'],
        position: json['position'],
        permissions: json['permissions'],
        responsibilities: json['responsibilities'],
        userId: json['userId'],
        createdAt: json['createdAt'],
        updatedAt: json['updatedAt'],
        $all: json['_all'],
      );

  final int? id;

  final int? department;

  final int? position;

  final int? permissions;

  final int? responsibilities;

  final int? userId;

  final int? createdAt;

  final int? updatedAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
    'id': id,
    'department': department,
    'position': position,
    'permissions': permissions,
    'responsibilities': responsibilities,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class StaffProfileMinAggregateOutputType {
  const StaffProfileMinAggregateOutputType({
    this.id,
    this.department,
    this.position,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  factory StaffProfileMinAggregateOutputType.fromJson(Map json) =>
      StaffProfileMinAggregateOutputType(
        id: json['id'],
        department: json['department'],
        position: json['position'],
        userId: json['userId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final String? department;

  final String? position;

  final String? userId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'department': department,
    'position': position,
    'userId': userId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class StaffProfileMaxAggregateOutputType {
  const StaffProfileMaxAggregateOutputType({
    this.id,
    this.department,
    this.position,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  factory StaffProfileMaxAggregateOutputType.fromJson(Map json) =>
      StaffProfileMaxAggregateOutputType(
        id: json['id'],
        department: json['department'],
        position: json['position'],
        userId: json['userId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final String? department;

  final String? position;

  final String? userId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'department': department,
    'position': position,
    'userId': userId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class StaffProfileGroupByOutputType {
  const StaffProfileGroupByOutputType({
    this.id,
    this.department,
    this.position,
    this.permissions,
    this.responsibilities,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$min,
    this.$max,
  });

  factory StaffProfileGroupByOutputType.fromJson(Map json) =>
      StaffProfileGroupByOutputType(
        id: json['id'],
        department: json['department'],
        position: json['position'],
        permissions: json['permissions'],
        responsibilities: json['responsibilities'],
        userId: json['userId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
        $count: json['_count'] is Map
            ? _i2.StaffProfileCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.StaffProfileMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.StaffProfileMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? id;

  final String? department;

  final String? position;

  final Object? permissions;

  final Object? responsibilities;

  final String? userId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.StaffProfileCountAggregateOutputType? $count;

  final _i2.StaffProfileMinAggregateOutputType? $min;

  final _i2.StaffProfileMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    'id': id,
    'department': department,
    'position': position,
    'permissions': permissions,
    'responsibilities': responsibilities,
    'userId': userId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
    '_count': $count?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class StaffProfileCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StaffProfileCountOrderByAggregateInput({
    this.id,
    this.department,
    this.position,
    this.permissions,
    this.responsibilities,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? department;

  final _i2.SortOrder? position;

  final _i2.SortOrder? permissions;

  final _i2.SortOrder? responsibilities;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'department': department,
    'position': position,
    'permissions': permissions,
    'responsibilities': responsibilities,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class StaffProfileMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StaffProfileMaxOrderByAggregateInput({
    this.id,
    this.department,
    this.position,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? department;

  final _i2.SortOrder? position;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'department': department,
    'position': position,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class StaffProfileMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StaffProfileMinOrderByAggregateInput({
    this.id,
    this.department,
    this.position,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? department;

  final _i2.SortOrder? position;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'department': department,
    'position': position,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class StaffProfileOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StaffProfileOrderByWithAggregationInput({
    this.id,
    this.department,
    this.position,
    this.permissions,
    this.responsibilities,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$max,
    this.$min,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? department;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? position;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? permissions;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? responsibilities;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.StaffProfileCountOrderByAggregateInput? $count;

  final _i2.StaffProfileMaxOrderByAggregateInput? $max;

  final _i2.StaffProfileMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'department': department,
    'position': position,
    'permissions': permissions,
    'responsibilities': responsibilities,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_max': $max,
    '_min': $min,
  };
}

class NestedJsonNullableFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedJsonNullableFilter({
    this.equals,
    this.path,
    this.stringContains,
    this.stringStartsWith,
    this.stringEndsWith,
    this.arrayContains,
    this.arrayStartsWith,
    this.arrayEndsWith,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final _i1.PrismaUnion<_i1.PrismaJson, _i2.JsonNullValueFilter>? equals;

  final Iterable<String>? path;

  final String? stringContains;

  final String? stringStartsWith;

  final String? stringEndsWith;

  final _i1.PrismaUnion<_i1.PrismaJson, _i1.PrismaNull>? arrayContains;

  final _i1.PrismaUnion<_i1.PrismaJson, _i1.PrismaNull>? arrayStartsWith;

  final _i1.PrismaUnion<_i1.PrismaJson, _i1.PrismaNull>? arrayEndsWith;

  final _i1.PrismaJson? lt;

  final _i1.PrismaJson? lte;

  final _i1.PrismaJson? gt;

  final _i1.PrismaJson? gte;

  final _i1.PrismaUnion<_i1.PrismaJson, _i2.JsonNullValueFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'path': path,
    'string_contains': stringContains,
    'string_starts_with': stringStartsWith,
    'string_ends_with': stringEndsWith,
    'array_contains': arrayContains,
    'array_starts_with': arrayStartsWith,
    'array_ends_with': arrayEndsWith,
    'lt': lt,
    'lte': lte,
    'gt': gt,
    'gte': gte,
    'not': not,
  };
}

class JsonNullableWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const JsonNullableWithAggregatesFilter({
    this.equals,
    this.path,
    this.stringContains,
    this.stringStartsWith,
    this.stringEndsWith,
    this.arrayContains,
    this.arrayStartsWith,
    this.arrayEndsWith,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<_i1.PrismaJson, _i2.JsonNullValueFilter>? equals;

  final Iterable<String>? path;

  final String? stringContains;

  final String? stringStartsWith;

  final String? stringEndsWith;

  final _i1.PrismaUnion<_i1.PrismaJson, _i1.PrismaNull>? arrayContains;

  final _i1.PrismaUnion<_i1.PrismaJson, _i1.PrismaNull>? arrayStartsWith;

  final _i1.PrismaUnion<_i1.PrismaJson, _i1.PrismaNull>? arrayEndsWith;

  final _i1.PrismaJson? lt;

  final _i1.PrismaJson? lte;

  final _i1.PrismaJson? gt;

  final _i1.PrismaJson? gte;

  final _i1.PrismaUnion<_i1.PrismaJson, _i2.JsonNullValueFilter>? not;

  final _i2.NestedIntNullableFilter? $count;

  final _i2.NestedJsonNullableFilter? $min;

  final _i2.NestedJsonNullableFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'path': path,
    'string_contains': stringContains,
    'string_starts_with': stringStartsWith,
    'string_ends_with': stringEndsWith,
    'array_contains': arrayContains,
    'array_starts_with': arrayStartsWith,
    'array_ends_with': arrayEndsWith,
    'lt': lt,
    'lte': lte,
    'gt': gt,
    'gte': gte,
    'not': not,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class StaffProfileScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StaffProfileScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.department,
    this.position,
    this.permissions,
    this.responsibilities,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
    _i2.StaffProfileScalarWhereWithAggregatesInput,
    Iterable<_i2.StaffProfileScalarWhereWithAggregatesInput>
  >?
  AND;

  final Iterable<_i2.StaffProfileScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<
    _i2.StaffProfileScalarWhereWithAggregatesInput,
    Iterable<_i2.StaffProfileScalarWhereWithAggregatesInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? id;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  department;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  position;

  final _i2.JsonNullableWithAggregatesFilter? permissions;

  final _i2.JsonNullableWithAggregatesFilter? responsibilities;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? userId;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'department': department,
    'position': position,
    'permissions': permissions,
    'responsibilities': responsibilities,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class StaffProfileCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StaffProfileCountAggregateOutputTypeSelect({
    this.id,
    this.department,
    this.position,
    this.permissions,
    this.responsibilities,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  final bool? id;

  final bool? department;

  final bool? position;

  final bool? permissions;

  final bool? responsibilities;

  final bool? userId;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'department': department,
    'position': position,
    'permissions': permissions,
    'responsibilities': responsibilities,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class StaffProfileGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StaffProfileGroupByOutputTypeCountArgs({this.select});

  final _i2.StaffProfileCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class StaffProfileMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StaffProfileMinAggregateOutputTypeSelect({
    this.id,
    this.department,
    this.position,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? department;

  final bool? position;

  final bool? userId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'department': department,
    'position': position,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class StaffProfileGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StaffProfileGroupByOutputTypeMinArgs({this.select});

  final _i2.StaffProfileMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class StaffProfileMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StaffProfileMaxAggregateOutputTypeSelect({
    this.id,
    this.department,
    this.position,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? department;

  final bool? position;

  final bool? userId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'department': department,
    'position': position,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class StaffProfileGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StaffProfileGroupByOutputTypeMaxArgs({this.select});

  final _i2.StaffProfileMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class StaffProfileGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StaffProfileGroupByOutputTypeSelect({
    this.id,
    this.department,
    this.position,
    this.permissions,
    this.responsibilities,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? department;

  final bool? position;

  final bool? permissions;

  final bool? responsibilities;

  final bool? userId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.StaffProfileGroupByOutputTypeCountArgs>?
  $count;

  final _i1.PrismaUnion<bool, _i2.StaffProfileGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.StaffProfileGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'department': department,
    'position': position,
    'permissions': permissions,
    'responsibilities': responsibilities,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class AggregateStaffProfile {
  const AggregateStaffProfile({this.$count, this.$min, this.$max});

  factory AggregateStaffProfile.fromJson(Map json) => AggregateStaffProfile(
    $count: json['_count'] is Map
        ? _i2.StaffProfileCountAggregateOutputType.fromJson(json['_count'])
        : null,
    $min: json['_min'] is Map
        ? _i2.StaffProfileMinAggregateOutputType.fromJson(json['_min'])
        : null,
    $max: json['_max'] is Map
        ? _i2.StaffProfileMaxAggregateOutputType.fromJson(json['_max'])
        : null,
  );

  final _i2.StaffProfileCountAggregateOutputType? $count;

  final _i2.StaffProfileMinAggregateOutputType? $min;

  final _i2.StaffProfileMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    '_count': $count?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class AggregateStaffProfileCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateStaffProfileCountArgs({this.select});

  final _i2.StaffProfileCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateStaffProfileMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateStaffProfileMinArgs({this.select});

  final _i2.StaffProfileMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateStaffProfileMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateStaffProfileMaxArgs({this.select});

  final _i2.StaffProfileMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateStaffProfileSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateStaffProfileSelect({this.$count, this.$min, this.$max});

  final _i1.PrismaUnion<bool, _i2.AggregateStaffProfileCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateStaffProfileMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateStaffProfileMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class ConsultantProfileCreateWithoutSlotsOfAvailabilityWeeklyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileCreateWithoutSlotsOfAvailabilityWeeklyInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    required this.scheduleType,
    this.createdAt,
    this.updatedAt,
    required this.domain,
    this.subDomains,
    this.tags,
    this.reviews,
    this.slotsOfAvailabilityCustom,
    this.consultationPlans,
    this.subscriptionPlans,
    this.webinarPlans,
    this.classPlans,
    required this.user,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? qualifications;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? specialization;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? experience;

  final double? rating;

  final _i3.ScheduleType scheduleType;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.DomainCreateNestedOneWithoutConsultantProfilesInput domain;

  final _i2.SubDomainCreateNestedManyWithoutConsultantProfilesInput? subDomains;

  final _i2.TagCreateNestedManyWithoutConsultantProfilesInput? tags;

  final _i2.ConsultantReviewCreateNestedManyWithoutConsultantProfileInput?
  reviews;

  final _i2.SlotOfAvailabilityCustomCreateNestedManyWithoutConsultantProfileInput?
  slotsOfAvailabilityCustom;

  final _i2.ConsultationPlanCreateNestedManyWithoutConsultantProfileInput?
  consultationPlans;

  final _i2.SubscriptionPlanCreateNestedManyWithoutConsultantProfileInput?
  subscriptionPlans;

  final _i2.WebinarPlanCreateNestedManyWithoutConsultantProfileInput?
  webinarPlans;

  final _i2.ClassPlanCreateNestedManyWithoutConsultantProfileInput? classPlans;

  final _i2.UserCreateNestedOneWithoutConsultantProfileInput user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'scheduleType': scheduleType,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'domain': domain,
    'subDomains': subDomains,
    'tags': tags,
    'reviews': reviews,
    'slotsOfAvailabilityCustom': slotsOfAvailabilityCustom,
    'consultationPlans': consultationPlans,
    'subscriptionPlans': subscriptionPlans,
    'webinarPlans': webinarPlans,
    'classPlans': classPlans,
    'user': user,
  };
}

class ConsultantProfileUncheckedCreateWithoutSlotsOfAvailabilityWeeklyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUncheckedCreateWithoutSlotsOfAvailabilityWeeklyInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    required this.domainId,
    required this.scheduleType,
    required this.userId,
    this.createdAt,
    this.updatedAt,
    this.subDomains,
    this.tags,
    this.reviews,
    this.slotsOfAvailabilityCustom,
    this.consultationPlans,
    this.subscriptionPlans,
    this.webinarPlans,
    this.classPlans,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? qualifications;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? specialization;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? experience;

  final double? rating;

  final String domainId;

  final _i3.ScheduleType scheduleType;

  final String userId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.SubDomainUncheckedCreateNestedManyWithoutConsultantProfilesInput?
  subDomains;

  final _i2.TagUncheckedCreateNestedManyWithoutConsultantProfilesInput? tags;

  final _i2.ConsultantReviewUncheckedCreateNestedManyWithoutConsultantProfileInput?
  reviews;

  final _i2.SlotOfAvailabilityCustomUncheckedCreateNestedManyWithoutConsultantProfileInput?
  slotsOfAvailabilityCustom;

  final _i2.ConsultationPlanUncheckedCreateNestedManyWithoutConsultantProfileInput?
  consultationPlans;

  final _i2.SubscriptionPlanUncheckedCreateNestedManyWithoutConsultantProfileInput?
  subscriptionPlans;

  final _i2.WebinarPlanUncheckedCreateNestedManyWithoutConsultantProfileInput?
  webinarPlans;

  final _i2.ClassPlanUncheckedCreateNestedManyWithoutConsultantProfileInput?
  classPlans;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'domainId': domainId,
    'scheduleType': scheduleType,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'subDomains': subDomains,
    'tags': tags,
    'reviews': reviews,
    'slotsOfAvailabilityCustom': slotsOfAvailabilityCustom,
    'consultationPlans': consultationPlans,
    'subscriptionPlans': subscriptionPlans,
    'webinarPlans': webinarPlans,
    'classPlans': classPlans,
  };
}

class ConsultantProfileCreateOrConnectWithoutSlotsOfAvailabilityWeeklyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileCreateOrConnectWithoutSlotsOfAvailabilityWeeklyInput({
    required this.where,
    required this.create,
  });

  final _i2.ConsultantProfileWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateWithoutSlotsOfAvailabilityWeeklyInput,
    _i2.ConsultantProfileUncheckedCreateWithoutSlotsOfAvailabilityWeeklyInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class ConsultantProfileCreateNestedOneWithoutSlotsOfAvailabilityWeeklyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileCreateNestedOneWithoutSlotsOfAvailabilityWeeklyInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateWithoutSlotsOfAvailabilityWeeklyInput,
    _i2.ConsultantProfileUncheckedCreateWithoutSlotsOfAvailabilityWeeklyInput
  >?
  create;

  final _i2.ConsultantProfileCreateOrConnectWithoutSlotsOfAvailabilityWeeklyInput?
  connectOrCreate;

  final _i2.ConsultantProfileWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class SlotOfAvailabilityWeeklyCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityWeeklyCreateInput({
    this.id,
    required this.dayOfWeekforStartTimeInUTC,
    required this.slotStartTimeInUTC,
    required this.dayOfWeekforEndTimeInUTC,
    required this.slotEndTimeInUTC,
    this.createdAt,
    this.updatedAt,
    required this.consultantProfile,
  });

  final String? id;

  final _i3.DayOfWeek dayOfWeekforStartTimeInUTC;

  final DateTime slotStartTimeInUTC;

  final _i3.DayOfWeek dayOfWeekforEndTimeInUTC;

  final DateTime slotEndTimeInUTC;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ConsultantProfileCreateNestedOneWithoutSlotsOfAvailabilityWeeklyInput
  consultantProfile;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'dayOfWeekforStartTimeInUTC': dayOfWeekforStartTimeInUTC,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'dayOfWeekforEndTimeInUTC': dayOfWeekforEndTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultantProfile': consultantProfile,
  };
}

class SlotOfAvailabilityWeeklyUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityWeeklyUncheckedCreateInput({
    this.id,
    required this.dayOfWeekforStartTimeInUTC,
    required this.slotStartTimeInUTC,
    required this.dayOfWeekforEndTimeInUTC,
    required this.slotEndTimeInUTC,
    required this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final _i3.DayOfWeek dayOfWeekforStartTimeInUTC;

  final DateTime slotStartTimeInUTC;

  final _i3.DayOfWeek dayOfWeekforEndTimeInUTC;

  final DateTime slotEndTimeInUTC;

  final String consultantProfileId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'dayOfWeekforStartTimeInUTC': dayOfWeekforStartTimeInUTC,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'dayOfWeekforEndTimeInUTC': dayOfWeekforEndTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SlotOfAvailabilityWeeklyCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityWeeklyCreateManyInput({
    this.id,
    required this.dayOfWeekforStartTimeInUTC,
    required this.slotStartTimeInUTC,
    required this.dayOfWeekforEndTimeInUTC,
    required this.slotEndTimeInUTC,
    required this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final _i3.DayOfWeek dayOfWeekforStartTimeInUTC;

  final DateTime slotStartTimeInUTC;

  final _i3.DayOfWeek dayOfWeekforEndTimeInUTC;

  final DateTime slotEndTimeInUTC;

  final String consultantProfileId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'dayOfWeekforStartTimeInUTC': dayOfWeekforStartTimeInUTC,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'dayOfWeekforEndTimeInUTC': dayOfWeekforEndTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultantProfileUpdateWithoutSlotsOfAvailabilityWeeklyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUpdateWithoutSlotsOfAvailabilityWeeklyInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    this.scheduleType,
    this.createdAt,
    this.updatedAt,
    this.domain,
    this.subDomains,
    this.tags,
    this.reviews,
    this.slotsOfAvailabilityCustom,
    this.consultationPlans,
    this.subscriptionPlans,
    this.webinarPlans,
    this.classPlans,
    this.user,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  qualifications;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  specialization;

  final _i1.PrismaUnion<
    double,
    _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  experience;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? rating;

  final _i1.PrismaUnion<
    _i3.ScheduleType,
    _i2.EnumScheduleTypeFieldUpdateOperationsInput
  >?
  scheduleType;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.DomainUpdateOneRequiredWithoutConsultantProfilesNestedInput? domain;

  final _i2.SubDomainUpdateManyWithoutConsultantProfilesNestedInput? subDomains;

  final _i2.TagUpdateManyWithoutConsultantProfilesNestedInput? tags;

  final _i2.ConsultantReviewUpdateManyWithoutConsultantProfileNestedInput?
  reviews;

  final _i2.SlotOfAvailabilityCustomUpdateManyWithoutConsultantProfileNestedInput?
  slotsOfAvailabilityCustom;

  final _i2.ConsultationPlanUpdateManyWithoutConsultantProfileNestedInput?
  consultationPlans;

  final _i2.SubscriptionPlanUpdateManyWithoutConsultantProfileNestedInput?
  subscriptionPlans;

  final _i2.WebinarPlanUpdateManyWithoutConsultantProfileNestedInput?
  webinarPlans;

  final _i2.ClassPlanUpdateManyWithoutConsultantProfileNestedInput? classPlans;

  final _i2.UserUpdateOneRequiredWithoutConsultantProfileNestedInput? user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'scheduleType': scheduleType,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'domain': domain,
    'subDomains': subDomains,
    'tags': tags,
    'reviews': reviews,
    'slotsOfAvailabilityCustom': slotsOfAvailabilityCustom,
    'consultationPlans': consultationPlans,
    'subscriptionPlans': subscriptionPlans,
    'webinarPlans': webinarPlans,
    'classPlans': classPlans,
    'user': user,
  };
}

class ConsultantProfileUncheckedUpdateWithoutSlotsOfAvailabilityWeeklyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUncheckedUpdateWithoutSlotsOfAvailabilityWeeklyInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    this.domainId,
    this.scheduleType,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.subDomains,
    this.tags,
    this.reviews,
    this.slotsOfAvailabilityCustom,
    this.consultationPlans,
    this.subscriptionPlans,
    this.webinarPlans,
    this.classPlans,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  qualifications;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  specialization;

  final _i1.PrismaUnion<
    double,
    _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  experience;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? rating;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? domainId;

  final _i1.PrismaUnion<
    _i3.ScheduleType,
    _i2.EnumScheduleTypeFieldUpdateOperationsInput
  >?
  scheduleType;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.SubDomainUncheckedUpdateManyWithoutConsultantProfilesNestedInput?
  subDomains;

  final _i2.TagUncheckedUpdateManyWithoutConsultantProfilesNestedInput? tags;

  final _i2.ConsultantReviewUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  reviews;

  final _i2.SlotOfAvailabilityCustomUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  slotsOfAvailabilityCustom;

  final _i2.ConsultationPlanUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  consultationPlans;

  final _i2.SubscriptionPlanUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  subscriptionPlans;

  final _i2.WebinarPlanUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  webinarPlans;

  final _i2.ClassPlanUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  classPlans;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'domainId': domainId,
    'scheduleType': scheduleType,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'subDomains': subDomains,
    'tags': tags,
    'reviews': reviews,
    'slotsOfAvailabilityCustom': slotsOfAvailabilityCustom,
    'consultationPlans': consultationPlans,
    'subscriptionPlans': subscriptionPlans,
    'webinarPlans': webinarPlans,
    'classPlans': classPlans,
  };
}

class ConsultantProfileUpsertWithoutSlotsOfAvailabilityWeeklyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUpsertWithoutSlotsOfAvailabilityWeeklyInput({
    required this.update,
    required this.create,
  });

  final _i1.PrismaUnion<
    _i2.ConsultantProfileUpdateWithoutSlotsOfAvailabilityWeeklyInput,
    _i2.ConsultantProfileUncheckedUpdateWithoutSlotsOfAvailabilityWeeklyInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateWithoutSlotsOfAvailabilityWeeklyInput,
    _i2.ConsultantProfileUncheckedCreateWithoutSlotsOfAvailabilityWeeklyInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'update': update, 'create': create};
}

class ConsultantProfileUpdateOneRequiredWithoutSlotsOfAvailabilityWeeklyNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUpdateOneRequiredWithoutSlotsOfAvailabilityWeeklyNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateWithoutSlotsOfAvailabilityWeeklyInput,
    _i2.ConsultantProfileUncheckedCreateWithoutSlotsOfAvailabilityWeeklyInput
  >?
  create;

  final _i2.ConsultantProfileCreateOrConnectWithoutSlotsOfAvailabilityWeeklyInput?
  connectOrCreate;

  final _i2.ConsultantProfileUpsertWithoutSlotsOfAvailabilityWeeklyInput?
  upsert;

  final _i2.ConsultantProfileWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileUpdateWithoutSlotsOfAvailabilityWeeklyInput,
    _i2.ConsultantProfileUncheckedUpdateWithoutSlotsOfAvailabilityWeeklyInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'connect': connect,
    'update': update,
  };
}

class SlotOfAvailabilityWeeklyUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityWeeklyUpdateInput({
    this.id,
    this.dayOfWeekforStartTimeInUTC,
    this.slotStartTimeInUTC,
    this.dayOfWeekforEndTimeInUTC,
    this.slotEndTimeInUTC,
    this.createdAt,
    this.updatedAt,
    this.consultantProfile,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    _i3.DayOfWeek,
    _i2.EnumDayOfWeekFieldUpdateOperationsInput
  >?
  dayOfWeekforStartTimeInUTC;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  slotStartTimeInUTC;

  final _i1.PrismaUnion<
    _i3.DayOfWeek,
    _i2.EnumDayOfWeekFieldUpdateOperationsInput
  >?
  dayOfWeekforEndTimeInUTC;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  slotEndTimeInUTC;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.ConsultantProfileUpdateOneRequiredWithoutSlotsOfAvailabilityWeeklyNestedInput?
  consultantProfile;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'dayOfWeekforStartTimeInUTC': dayOfWeekforStartTimeInUTC,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'dayOfWeekforEndTimeInUTC': dayOfWeekforEndTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultantProfile': consultantProfile,
  };
}

class SlotOfAvailabilityWeeklyUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityWeeklyUncheckedUpdateInput({
    this.id,
    this.dayOfWeekforStartTimeInUTC,
    this.slotStartTimeInUTC,
    this.dayOfWeekforEndTimeInUTC,
    this.slotEndTimeInUTC,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    _i3.DayOfWeek,
    _i2.EnumDayOfWeekFieldUpdateOperationsInput
  >?
  dayOfWeekforStartTimeInUTC;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  slotStartTimeInUTC;

  final _i1.PrismaUnion<
    _i3.DayOfWeek,
    _i2.EnumDayOfWeekFieldUpdateOperationsInput
  >?
  dayOfWeekforEndTimeInUTC;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  slotEndTimeInUTC;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  consultantProfileId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'dayOfWeekforStartTimeInUTC': dayOfWeekforStartTimeInUTC,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'dayOfWeekforEndTimeInUTC': dayOfWeekforEndTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SlotOfAvailabilityWeeklyUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityWeeklyUncheckedUpdateManyInput({
    this.id,
    this.dayOfWeekforStartTimeInUTC,
    this.slotStartTimeInUTC,
    this.dayOfWeekforEndTimeInUTC,
    this.slotEndTimeInUTC,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    _i3.DayOfWeek,
    _i2.EnumDayOfWeekFieldUpdateOperationsInput
  >?
  dayOfWeekforStartTimeInUTC;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  slotStartTimeInUTC;

  final _i1.PrismaUnion<
    _i3.DayOfWeek,
    _i2.EnumDayOfWeekFieldUpdateOperationsInput
  >?
  dayOfWeekforEndTimeInUTC;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  slotEndTimeInUTC;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  consultantProfileId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'dayOfWeekforStartTimeInUTC': dayOfWeekforStartTimeInUTC,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'dayOfWeekforEndTimeInUTC': dayOfWeekforEndTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SlotOfAvailabilityWeeklyCountAggregateOutputType {
  const SlotOfAvailabilityWeeklyCountAggregateOutputType({
    this.id,
    this.dayOfWeekforStartTimeInUTC,
    this.slotStartTimeInUTC,
    this.dayOfWeekforEndTimeInUTC,
    this.slotEndTimeInUTC,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  factory SlotOfAvailabilityWeeklyCountAggregateOutputType.fromJson(Map json) =>
      SlotOfAvailabilityWeeklyCountAggregateOutputType(
        id: json['id'],
        dayOfWeekforStartTimeInUTC: json['dayOfWeekforStartTimeInUTC'],
        slotStartTimeInUTC: json['slotStartTimeInUTC'],
        dayOfWeekforEndTimeInUTC: json['dayOfWeekforEndTimeInUTC'],
        slotEndTimeInUTC: json['slotEndTimeInUTC'],
        consultantProfileId: json['consultantProfileId'],
        createdAt: json['createdAt'],
        updatedAt: json['updatedAt'],
        $all: json['_all'],
      );

  final int? id;

  final int? dayOfWeekforStartTimeInUTC;

  final int? slotStartTimeInUTC;

  final int? dayOfWeekforEndTimeInUTC;

  final int? slotEndTimeInUTC;

  final int? consultantProfileId;

  final int? createdAt;

  final int? updatedAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
    'id': id,
    'dayOfWeekforStartTimeInUTC': dayOfWeekforStartTimeInUTC,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'dayOfWeekforEndTimeInUTC': dayOfWeekforEndTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class SlotOfAvailabilityWeeklyMinAggregateOutputType {
  const SlotOfAvailabilityWeeklyMinAggregateOutputType({
    this.id,
    this.dayOfWeekforStartTimeInUTC,
    this.slotStartTimeInUTC,
    this.dayOfWeekforEndTimeInUTC,
    this.slotEndTimeInUTC,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  factory SlotOfAvailabilityWeeklyMinAggregateOutputType.fromJson(Map json) =>
      SlotOfAvailabilityWeeklyMinAggregateOutputType(
        id: json['id'],
        dayOfWeekforStartTimeInUTC: json['dayOfWeekforStartTimeInUTC'] != null
            ? _i3.DayOfWeek.values.firstWhere(
                (e) => e.name == json['dayOfWeekforStartTimeInUTC'],
              )
            : null,
        slotStartTimeInUTC: switch (json['slotStartTimeInUTC']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['slotStartTimeInUTC'],
        },
        dayOfWeekforEndTimeInUTC: json['dayOfWeekforEndTimeInUTC'] != null
            ? _i3.DayOfWeek.values.firstWhere(
                (e) => e.name == json['dayOfWeekforEndTimeInUTC'],
              )
            : null,
        slotEndTimeInUTC: switch (json['slotEndTimeInUTC']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['slotEndTimeInUTC'],
        },
        consultantProfileId: json['consultantProfileId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final _i3.DayOfWeek? dayOfWeekforStartTimeInUTC;

  final DateTime? slotStartTimeInUTC;

  final _i3.DayOfWeek? dayOfWeekforEndTimeInUTC;

  final DateTime? slotEndTimeInUTC;

  final String? consultantProfileId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'dayOfWeekforStartTimeInUTC': dayOfWeekforStartTimeInUTC?.name,
    'slotStartTimeInUTC': slotStartTimeInUTC?.toIso8601String(),
    'dayOfWeekforEndTimeInUTC': dayOfWeekforEndTimeInUTC?.name,
    'slotEndTimeInUTC': slotEndTimeInUTC?.toIso8601String(),
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class SlotOfAvailabilityWeeklyMaxAggregateOutputType {
  const SlotOfAvailabilityWeeklyMaxAggregateOutputType({
    this.id,
    this.dayOfWeekforStartTimeInUTC,
    this.slotStartTimeInUTC,
    this.dayOfWeekforEndTimeInUTC,
    this.slotEndTimeInUTC,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  factory SlotOfAvailabilityWeeklyMaxAggregateOutputType.fromJson(Map json) =>
      SlotOfAvailabilityWeeklyMaxAggregateOutputType(
        id: json['id'],
        dayOfWeekforStartTimeInUTC: json['dayOfWeekforStartTimeInUTC'] != null
            ? _i3.DayOfWeek.values.firstWhere(
                (e) => e.name == json['dayOfWeekforStartTimeInUTC'],
              )
            : null,
        slotStartTimeInUTC: switch (json['slotStartTimeInUTC']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['slotStartTimeInUTC'],
        },
        dayOfWeekforEndTimeInUTC: json['dayOfWeekforEndTimeInUTC'] != null
            ? _i3.DayOfWeek.values.firstWhere(
                (e) => e.name == json['dayOfWeekforEndTimeInUTC'],
              )
            : null,
        slotEndTimeInUTC: switch (json['slotEndTimeInUTC']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['slotEndTimeInUTC'],
        },
        consultantProfileId: json['consultantProfileId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final _i3.DayOfWeek? dayOfWeekforStartTimeInUTC;

  final DateTime? slotStartTimeInUTC;

  final _i3.DayOfWeek? dayOfWeekforEndTimeInUTC;

  final DateTime? slotEndTimeInUTC;

  final String? consultantProfileId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'dayOfWeekforStartTimeInUTC': dayOfWeekforStartTimeInUTC?.name,
    'slotStartTimeInUTC': slotStartTimeInUTC?.toIso8601String(),
    'dayOfWeekforEndTimeInUTC': dayOfWeekforEndTimeInUTC?.name,
    'slotEndTimeInUTC': slotEndTimeInUTC?.toIso8601String(),
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class SlotOfAvailabilityWeeklyGroupByOutputType {
  const SlotOfAvailabilityWeeklyGroupByOutputType({
    this.id,
    this.dayOfWeekforStartTimeInUTC,
    this.slotStartTimeInUTC,
    this.dayOfWeekforEndTimeInUTC,
    this.slotEndTimeInUTC,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$min,
    this.$max,
  });

  factory SlotOfAvailabilityWeeklyGroupByOutputType.fromJson(Map json) =>
      SlotOfAvailabilityWeeklyGroupByOutputType(
        id: json['id'],
        dayOfWeekforStartTimeInUTC: json['dayOfWeekforStartTimeInUTC'] != null
            ? _i3.DayOfWeek.values.firstWhere(
                (e) => e.name == json['dayOfWeekforStartTimeInUTC'],
              )
            : null,
        slotStartTimeInUTC: switch (json['slotStartTimeInUTC']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['slotStartTimeInUTC'],
        },
        dayOfWeekforEndTimeInUTC: json['dayOfWeekforEndTimeInUTC'] != null
            ? _i3.DayOfWeek.values.firstWhere(
                (e) => e.name == json['dayOfWeekforEndTimeInUTC'],
              )
            : null,
        slotEndTimeInUTC: switch (json['slotEndTimeInUTC']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['slotEndTimeInUTC'],
        },
        consultantProfileId: json['consultantProfileId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
        $count: json['_count'] is Map
            ? _i2.SlotOfAvailabilityWeeklyCountAggregateOutputType.fromJson(
                json['_count'],
              )
            : null,
        $min: json['_min'] is Map
            ? _i2.SlotOfAvailabilityWeeklyMinAggregateOutputType.fromJson(
                json['_min'],
              )
            : null,
        $max: json['_max'] is Map
            ? _i2.SlotOfAvailabilityWeeklyMaxAggregateOutputType.fromJson(
                json['_max'],
              )
            : null,
      );

  final String? id;

  final _i3.DayOfWeek? dayOfWeekforStartTimeInUTC;

  final DateTime? slotStartTimeInUTC;

  final _i3.DayOfWeek? dayOfWeekforEndTimeInUTC;

  final DateTime? slotEndTimeInUTC;

  final String? consultantProfileId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.SlotOfAvailabilityWeeklyCountAggregateOutputType? $count;

  final _i2.SlotOfAvailabilityWeeklyMinAggregateOutputType? $min;

  final _i2.SlotOfAvailabilityWeeklyMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    'id': id,
    'dayOfWeekforStartTimeInUTC': dayOfWeekforStartTimeInUTC?.name,
    'slotStartTimeInUTC': slotStartTimeInUTC?.toIso8601String(),
    'dayOfWeekforEndTimeInUTC': dayOfWeekforEndTimeInUTC?.name,
    'slotEndTimeInUTC': slotEndTimeInUTC?.toIso8601String(),
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
    '_count': $count?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class SlotOfAvailabilityWeeklyCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityWeeklyCountOrderByAggregateInput({
    this.id,
    this.dayOfWeekforStartTimeInUTC,
    this.slotStartTimeInUTC,
    this.dayOfWeekforEndTimeInUTC,
    this.slotEndTimeInUTC,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? dayOfWeekforStartTimeInUTC;

  final _i2.SortOrder? slotStartTimeInUTC;

  final _i2.SortOrder? dayOfWeekforEndTimeInUTC;

  final _i2.SortOrder? slotEndTimeInUTC;

  final _i2.SortOrder? consultantProfileId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'dayOfWeekforStartTimeInUTC': dayOfWeekforStartTimeInUTC,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'dayOfWeekforEndTimeInUTC': dayOfWeekforEndTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SlotOfAvailabilityWeeklyMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityWeeklyMaxOrderByAggregateInput({
    this.id,
    this.dayOfWeekforStartTimeInUTC,
    this.slotStartTimeInUTC,
    this.dayOfWeekforEndTimeInUTC,
    this.slotEndTimeInUTC,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? dayOfWeekforStartTimeInUTC;

  final _i2.SortOrder? slotStartTimeInUTC;

  final _i2.SortOrder? dayOfWeekforEndTimeInUTC;

  final _i2.SortOrder? slotEndTimeInUTC;

  final _i2.SortOrder? consultantProfileId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'dayOfWeekforStartTimeInUTC': dayOfWeekforStartTimeInUTC,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'dayOfWeekforEndTimeInUTC': dayOfWeekforEndTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SlotOfAvailabilityWeeklyMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityWeeklyMinOrderByAggregateInput({
    this.id,
    this.dayOfWeekforStartTimeInUTC,
    this.slotStartTimeInUTC,
    this.dayOfWeekforEndTimeInUTC,
    this.slotEndTimeInUTC,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? dayOfWeekforStartTimeInUTC;

  final _i2.SortOrder? slotStartTimeInUTC;

  final _i2.SortOrder? dayOfWeekforEndTimeInUTC;

  final _i2.SortOrder? slotEndTimeInUTC;

  final _i2.SortOrder? consultantProfileId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'dayOfWeekforStartTimeInUTC': dayOfWeekforStartTimeInUTC,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'dayOfWeekforEndTimeInUTC': dayOfWeekforEndTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SlotOfAvailabilityWeeklyOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityWeeklyOrderByWithAggregationInput({
    this.id,
    this.dayOfWeekforStartTimeInUTC,
    this.slotStartTimeInUTC,
    this.dayOfWeekforEndTimeInUTC,
    this.slotEndTimeInUTC,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$max,
    this.$min,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? dayOfWeekforStartTimeInUTC;

  final _i2.SortOrder? slotStartTimeInUTC;

  final _i2.SortOrder? dayOfWeekforEndTimeInUTC;

  final _i2.SortOrder? slotEndTimeInUTC;

  final _i2.SortOrder? consultantProfileId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.SlotOfAvailabilityWeeklyCountOrderByAggregateInput? $count;

  final _i2.SlotOfAvailabilityWeeklyMaxOrderByAggregateInput? $max;

  final _i2.SlotOfAvailabilityWeeklyMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'dayOfWeekforStartTimeInUTC': dayOfWeekforStartTimeInUTC,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'dayOfWeekforEndTimeInUTC': dayOfWeekforEndTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_max': $max,
    '_min': $min,
  };
}

class NestedEnumDayOfWeekWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedEnumDayOfWeekWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i3.DayOfWeek? equals;

  final _i1.PrismaUnion<Iterable<_i3.DayOfWeek>, _i3.DayOfWeek>? $in;

  final _i1.PrismaUnion<Iterable<_i3.DayOfWeek>, _i3.DayOfWeek>? notIn;

  final _i1.PrismaUnion<
    _i3.DayOfWeek,
    _i2.NestedEnumDayOfWeekWithAggregatesFilter
  >?
  not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedEnumDayOfWeekFilter? $min;

  final _i2.NestedEnumDayOfWeekFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class EnumDayOfWeekWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumDayOfWeekWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i3.DayOfWeek? equals;

  final _i1.PrismaUnion<Iterable<_i3.DayOfWeek>, _i3.DayOfWeek>? $in;

  final _i1.PrismaUnion<Iterable<_i3.DayOfWeek>, _i3.DayOfWeek>? notIn;

  final _i1.PrismaUnion<
    _i3.DayOfWeek,
    _i2.NestedEnumDayOfWeekWithAggregatesFilter
  >?
  not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedEnumDayOfWeekFilter? $min;

  final _i2.NestedEnumDayOfWeekFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class SlotOfAvailabilityWeeklyScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityWeeklyScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.dayOfWeekforStartTimeInUTC,
    this.slotStartTimeInUTC,
    this.dayOfWeekforEndTimeInUTC,
    this.slotEndTimeInUTC,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityWeeklyScalarWhereWithAggregatesInput,
    Iterable<_i2.SlotOfAvailabilityWeeklyScalarWhereWithAggregatesInput>
  >?
  AND;

  final Iterable<_i2.SlotOfAvailabilityWeeklyScalarWhereWithAggregatesInput>?
  OR;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityWeeklyScalarWhereWithAggregatesInput,
    Iterable<_i2.SlotOfAvailabilityWeeklyScalarWhereWithAggregatesInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? id;

  final _i1.PrismaUnion<_i2.EnumDayOfWeekWithAggregatesFilter, _i3.DayOfWeek>?
  dayOfWeekforStartTimeInUTC;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>?
  slotStartTimeInUTC;

  final _i1.PrismaUnion<_i2.EnumDayOfWeekWithAggregatesFilter, _i3.DayOfWeek>?
  dayOfWeekforEndTimeInUTC;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>?
  slotEndTimeInUTC;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>?
  consultantProfileId;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'dayOfWeekforStartTimeInUTC': dayOfWeekforStartTimeInUTC,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'dayOfWeekforEndTimeInUTC': dayOfWeekforEndTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SlotOfAvailabilityWeeklyCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityWeeklyCountAggregateOutputTypeSelect({
    this.id,
    this.dayOfWeekforStartTimeInUTC,
    this.slotStartTimeInUTC,
    this.dayOfWeekforEndTimeInUTC,
    this.slotEndTimeInUTC,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  final bool? id;

  final bool? dayOfWeekforStartTimeInUTC;

  final bool? slotStartTimeInUTC;

  final bool? dayOfWeekforEndTimeInUTC;

  final bool? slotEndTimeInUTC;

  final bool? consultantProfileId;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'dayOfWeekforStartTimeInUTC': dayOfWeekforStartTimeInUTC,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'dayOfWeekforEndTimeInUTC': dayOfWeekforEndTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class SlotOfAvailabilityWeeklyGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityWeeklyGroupByOutputTypeCountArgs({this.select});

  final _i2.SlotOfAvailabilityWeeklyCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SlotOfAvailabilityWeeklyMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityWeeklyMinAggregateOutputTypeSelect({
    this.id,
    this.dayOfWeekforStartTimeInUTC,
    this.slotStartTimeInUTC,
    this.dayOfWeekforEndTimeInUTC,
    this.slotEndTimeInUTC,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? dayOfWeekforStartTimeInUTC;

  final bool? slotStartTimeInUTC;

  final bool? dayOfWeekforEndTimeInUTC;

  final bool? slotEndTimeInUTC;

  final bool? consultantProfileId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'dayOfWeekforStartTimeInUTC': dayOfWeekforStartTimeInUTC,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'dayOfWeekforEndTimeInUTC': dayOfWeekforEndTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SlotOfAvailabilityWeeklyGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityWeeklyGroupByOutputTypeMinArgs({this.select});

  final _i2.SlotOfAvailabilityWeeklyMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SlotOfAvailabilityWeeklyMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityWeeklyMaxAggregateOutputTypeSelect({
    this.id,
    this.dayOfWeekforStartTimeInUTC,
    this.slotStartTimeInUTC,
    this.dayOfWeekforEndTimeInUTC,
    this.slotEndTimeInUTC,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? dayOfWeekforStartTimeInUTC;

  final bool? slotStartTimeInUTC;

  final bool? dayOfWeekforEndTimeInUTC;

  final bool? slotEndTimeInUTC;

  final bool? consultantProfileId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'dayOfWeekforStartTimeInUTC': dayOfWeekforStartTimeInUTC,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'dayOfWeekforEndTimeInUTC': dayOfWeekforEndTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SlotOfAvailabilityWeeklyGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityWeeklyGroupByOutputTypeMaxArgs({this.select});

  final _i2.SlotOfAvailabilityWeeklyMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SlotOfAvailabilityWeeklyGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityWeeklyGroupByOutputTypeSelect({
    this.id,
    this.dayOfWeekforStartTimeInUTC,
    this.slotStartTimeInUTC,
    this.dayOfWeekforEndTimeInUTC,
    this.slotEndTimeInUTC,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? dayOfWeekforStartTimeInUTC;

  final bool? slotStartTimeInUTC;

  final bool? dayOfWeekforEndTimeInUTC;

  final bool? slotEndTimeInUTC;

  final bool? consultantProfileId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<
    bool,
    _i2.SlotOfAvailabilityWeeklyGroupByOutputTypeCountArgs
  >?
  $count;

  final _i1.PrismaUnion<
    bool,
    _i2.SlotOfAvailabilityWeeklyGroupByOutputTypeMinArgs
  >?
  $min;

  final _i1.PrismaUnion<
    bool,
    _i2.SlotOfAvailabilityWeeklyGroupByOutputTypeMaxArgs
  >?
  $max;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'dayOfWeekforStartTimeInUTC': dayOfWeekforStartTimeInUTC,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'dayOfWeekforEndTimeInUTC': dayOfWeekforEndTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class AggregateSlotOfAvailabilityWeekly {
  const AggregateSlotOfAvailabilityWeekly({this.$count, this.$min, this.$max});

  factory AggregateSlotOfAvailabilityWeekly.fromJson(Map json) =>
      AggregateSlotOfAvailabilityWeekly(
        $count: json['_count'] is Map
            ? _i2.SlotOfAvailabilityWeeklyCountAggregateOutputType.fromJson(
                json['_count'],
              )
            : null,
        $min: json['_min'] is Map
            ? _i2.SlotOfAvailabilityWeeklyMinAggregateOutputType.fromJson(
                json['_min'],
              )
            : null,
        $max: json['_max'] is Map
            ? _i2.SlotOfAvailabilityWeeklyMaxAggregateOutputType.fromJson(
                json['_max'],
              )
            : null,
      );

  final _i2.SlotOfAvailabilityWeeklyCountAggregateOutputType? $count;

  final _i2.SlotOfAvailabilityWeeklyMinAggregateOutputType? $min;

  final _i2.SlotOfAvailabilityWeeklyMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    '_count': $count?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class AggregateSlotOfAvailabilityWeeklyCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSlotOfAvailabilityWeeklyCountArgs({this.select});

  final _i2.SlotOfAvailabilityWeeklyCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateSlotOfAvailabilityWeeklyMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSlotOfAvailabilityWeeklyMinArgs({this.select});

  final _i2.SlotOfAvailabilityWeeklyMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateSlotOfAvailabilityWeeklyMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSlotOfAvailabilityWeeklyMaxArgs({this.select});

  final _i2.SlotOfAvailabilityWeeklyMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateSlotOfAvailabilityWeeklySelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSlotOfAvailabilityWeeklySelect({
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateSlotOfAvailabilityWeeklyCountArgs>?
  $count;

  final _i1.PrismaUnion<bool, _i2.AggregateSlotOfAvailabilityWeeklyMinArgs>?
  $min;

  final _i1.PrismaUnion<bool, _i2.AggregateSlotOfAvailabilityWeeklyMaxArgs>?
  $max;

  @override
  Map<String, dynamic> toJson() => {
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class ConsultantProfileCreateWithoutSlotsOfAvailabilityCustomInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileCreateWithoutSlotsOfAvailabilityCustomInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    required this.scheduleType,
    this.createdAt,
    this.updatedAt,
    required this.domain,
    this.subDomains,
    this.tags,
    this.reviews,
    this.slotsOfAvailabilityWeekly,
    this.consultationPlans,
    this.subscriptionPlans,
    this.webinarPlans,
    this.classPlans,
    required this.user,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? qualifications;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? specialization;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? experience;

  final double? rating;

  final _i3.ScheduleType scheduleType;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.DomainCreateNestedOneWithoutConsultantProfilesInput domain;

  final _i2.SubDomainCreateNestedManyWithoutConsultantProfilesInput? subDomains;

  final _i2.TagCreateNestedManyWithoutConsultantProfilesInput? tags;

  final _i2.ConsultantReviewCreateNestedManyWithoutConsultantProfileInput?
  reviews;

  final _i2.SlotOfAvailabilityWeeklyCreateNestedManyWithoutConsultantProfileInput?
  slotsOfAvailabilityWeekly;

  final _i2.ConsultationPlanCreateNestedManyWithoutConsultantProfileInput?
  consultationPlans;

  final _i2.SubscriptionPlanCreateNestedManyWithoutConsultantProfileInput?
  subscriptionPlans;

  final _i2.WebinarPlanCreateNestedManyWithoutConsultantProfileInput?
  webinarPlans;

  final _i2.ClassPlanCreateNestedManyWithoutConsultantProfileInput? classPlans;

  final _i2.UserCreateNestedOneWithoutConsultantProfileInput user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'scheduleType': scheduleType,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'domain': domain,
    'subDomains': subDomains,
    'tags': tags,
    'reviews': reviews,
    'slotsOfAvailabilityWeekly': slotsOfAvailabilityWeekly,
    'consultationPlans': consultationPlans,
    'subscriptionPlans': subscriptionPlans,
    'webinarPlans': webinarPlans,
    'classPlans': classPlans,
    'user': user,
  };
}

class ConsultantProfileUncheckedCreateWithoutSlotsOfAvailabilityCustomInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUncheckedCreateWithoutSlotsOfAvailabilityCustomInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    required this.domainId,
    required this.scheduleType,
    required this.userId,
    this.createdAt,
    this.updatedAt,
    this.subDomains,
    this.tags,
    this.reviews,
    this.slotsOfAvailabilityWeekly,
    this.consultationPlans,
    this.subscriptionPlans,
    this.webinarPlans,
    this.classPlans,
  });

  final String? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? qualifications;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? specialization;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? experience;

  final double? rating;

  final String domainId;

  final _i3.ScheduleType scheduleType;

  final String userId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.SubDomainUncheckedCreateNestedManyWithoutConsultantProfilesInput?
  subDomains;

  final _i2.TagUncheckedCreateNestedManyWithoutConsultantProfilesInput? tags;

  final _i2.ConsultantReviewUncheckedCreateNestedManyWithoutConsultantProfileInput?
  reviews;

  final _i2.SlotOfAvailabilityWeeklyUncheckedCreateNestedManyWithoutConsultantProfileInput?
  slotsOfAvailabilityWeekly;

  final _i2.ConsultationPlanUncheckedCreateNestedManyWithoutConsultantProfileInput?
  consultationPlans;

  final _i2.SubscriptionPlanUncheckedCreateNestedManyWithoutConsultantProfileInput?
  subscriptionPlans;

  final _i2.WebinarPlanUncheckedCreateNestedManyWithoutConsultantProfileInput?
  webinarPlans;

  final _i2.ClassPlanUncheckedCreateNestedManyWithoutConsultantProfileInput?
  classPlans;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'domainId': domainId,
    'scheduleType': scheduleType,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'subDomains': subDomains,
    'tags': tags,
    'reviews': reviews,
    'slotsOfAvailabilityWeekly': slotsOfAvailabilityWeekly,
    'consultationPlans': consultationPlans,
    'subscriptionPlans': subscriptionPlans,
    'webinarPlans': webinarPlans,
    'classPlans': classPlans,
  };
}

class ConsultantProfileCreateOrConnectWithoutSlotsOfAvailabilityCustomInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileCreateOrConnectWithoutSlotsOfAvailabilityCustomInput({
    required this.where,
    required this.create,
  });

  final _i2.ConsultantProfileWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateWithoutSlotsOfAvailabilityCustomInput,
    _i2.ConsultantProfileUncheckedCreateWithoutSlotsOfAvailabilityCustomInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class ConsultantProfileCreateNestedOneWithoutSlotsOfAvailabilityCustomInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileCreateNestedOneWithoutSlotsOfAvailabilityCustomInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateWithoutSlotsOfAvailabilityCustomInput,
    _i2.ConsultantProfileUncheckedCreateWithoutSlotsOfAvailabilityCustomInput
  >?
  create;

  final _i2.ConsultantProfileCreateOrConnectWithoutSlotsOfAvailabilityCustomInput?
  connectOrCreate;

  final _i2.ConsultantProfileWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class SlotOfAvailabilityCustomCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityCustomCreateInput({
    this.id,
    required this.slotStartTimeInUTC,
    required this.slotEndTimeInUTC,
    this.createdAt,
    this.updatedAt,
    required this.consultantProfile,
  });

  final String? id;

  final DateTime slotStartTimeInUTC;

  final DateTime slotEndTimeInUTC;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ConsultantProfileCreateNestedOneWithoutSlotsOfAvailabilityCustomInput
  consultantProfile;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultantProfile': consultantProfile,
  };
}

class SlotOfAvailabilityCustomUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityCustomUncheckedCreateInput({
    this.id,
    required this.slotStartTimeInUTC,
    required this.slotEndTimeInUTC,
    required this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final DateTime slotStartTimeInUTC;

  final DateTime slotEndTimeInUTC;

  final String consultantProfileId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SlotOfAvailabilityCustomCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityCustomCreateManyInput({
    this.id,
    required this.slotStartTimeInUTC,
    required this.slotEndTimeInUTC,
    required this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final DateTime slotStartTimeInUTC;

  final DateTime slotEndTimeInUTC;

  final String consultantProfileId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultantProfileUpdateWithoutSlotsOfAvailabilityCustomInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUpdateWithoutSlotsOfAvailabilityCustomInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    this.scheduleType,
    this.createdAt,
    this.updatedAt,
    this.domain,
    this.subDomains,
    this.tags,
    this.reviews,
    this.slotsOfAvailabilityWeekly,
    this.consultationPlans,
    this.subscriptionPlans,
    this.webinarPlans,
    this.classPlans,
    this.user,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  qualifications;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  specialization;

  final _i1.PrismaUnion<
    double,
    _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  experience;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? rating;

  final _i1.PrismaUnion<
    _i3.ScheduleType,
    _i2.EnumScheduleTypeFieldUpdateOperationsInput
  >?
  scheduleType;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.DomainUpdateOneRequiredWithoutConsultantProfilesNestedInput? domain;

  final _i2.SubDomainUpdateManyWithoutConsultantProfilesNestedInput? subDomains;

  final _i2.TagUpdateManyWithoutConsultantProfilesNestedInput? tags;

  final _i2.ConsultantReviewUpdateManyWithoutConsultantProfileNestedInput?
  reviews;

  final _i2.SlotOfAvailabilityWeeklyUpdateManyWithoutConsultantProfileNestedInput?
  slotsOfAvailabilityWeekly;

  final _i2.ConsultationPlanUpdateManyWithoutConsultantProfileNestedInput?
  consultationPlans;

  final _i2.SubscriptionPlanUpdateManyWithoutConsultantProfileNestedInput?
  subscriptionPlans;

  final _i2.WebinarPlanUpdateManyWithoutConsultantProfileNestedInput?
  webinarPlans;

  final _i2.ClassPlanUpdateManyWithoutConsultantProfileNestedInput? classPlans;

  final _i2.UserUpdateOneRequiredWithoutConsultantProfileNestedInput? user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'scheduleType': scheduleType,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'domain': domain,
    'subDomains': subDomains,
    'tags': tags,
    'reviews': reviews,
    'slotsOfAvailabilityWeekly': slotsOfAvailabilityWeekly,
    'consultationPlans': consultationPlans,
    'subscriptionPlans': subscriptionPlans,
    'webinarPlans': webinarPlans,
    'classPlans': classPlans,
    'user': user,
  };
}

class ConsultantProfileUncheckedUpdateWithoutSlotsOfAvailabilityCustomInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUncheckedUpdateWithoutSlotsOfAvailabilityCustomInput({
    this.id,
    this.description,
    this.qualifications,
    this.specialization,
    this.experience,
    this.rating,
    this.domainId,
    this.scheduleType,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.subDomains,
    this.tags,
    this.reviews,
    this.slotsOfAvailabilityWeekly,
    this.consultationPlans,
    this.subscriptionPlans,
    this.webinarPlans,
    this.classPlans,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  qualifications;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  specialization;

  final _i1.PrismaUnion<
    double,
    _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  experience;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? rating;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? domainId;

  final _i1.PrismaUnion<
    _i3.ScheduleType,
    _i2.EnumScheduleTypeFieldUpdateOperationsInput
  >?
  scheduleType;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.SubDomainUncheckedUpdateManyWithoutConsultantProfilesNestedInput?
  subDomains;

  final _i2.TagUncheckedUpdateManyWithoutConsultantProfilesNestedInput? tags;

  final _i2.ConsultantReviewUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  reviews;

  final _i2.SlotOfAvailabilityWeeklyUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  slotsOfAvailabilityWeekly;

  final _i2.ConsultationPlanUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  consultationPlans;

  final _i2.SubscriptionPlanUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  subscriptionPlans;

  final _i2.WebinarPlanUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  webinarPlans;

  final _i2.ClassPlanUncheckedUpdateManyWithoutConsultantProfileNestedInput?
  classPlans;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'description': description,
    'qualifications': qualifications,
    'specialization': specialization,
    'experience': experience,
    'rating': rating,
    'domainId': domainId,
    'scheduleType': scheduleType,
    'userId': userId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'subDomains': subDomains,
    'tags': tags,
    'reviews': reviews,
    'slotsOfAvailabilityWeekly': slotsOfAvailabilityWeekly,
    'consultationPlans': consultationPlans,
    'subscriptionPlans': subscriptionPlans,
    'webinarPlans': webinarPlans,
    'classPlans': classPlans,
  };
}

class ConsultantProfileUpsertWithoutSlotsOfAvailabilityCustomInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUpsertWithoutSlotsOfAvailabilityCustomInput({
    required this.update,
    required this.create,
  });

  final _i1.PrismaUnion<
    _i2.ConsultantProfileUpdateWithoutSlotsOfAvailabilityCustomInput,
    _i2.ConsultantProfileUncheckedUpdateWithoutSlotsOfAvailabilityCustomInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateWithoutSlotsOfAvailabilityCustomInput,
    _i2.ConsultantProfileUncheckedCreateWithoutSlotsOfAvailabilityCustomInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'update': update, 'create': create};
}

class ConsultantProfileUpdateOneRequiredWithoutSlotsOfAvailabilityCustomNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultantProfileUpdateOneRequiredWithoutSlotsOfAvailabilityCustomNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.ConsultantProfileCreateWithoutSlotsOfAvailabilityCustomInput,
    _i2.ConsultantProfileUncheckedCreateWithoutSlotsOfAvailabilityCustomInput
  >?
  create;

  final _i2.ConsultantProfileCreateOrConnectWithoutSlotsOfAvailabilityCustomInput?
  connectOrCreate;

  final _i2.ConsultantProfileUpsertWithoutSlotsOfAvailabilityCustomInput?
  upsert;

  final _i2.ConsultantProfileWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.ConsultantProfileUpdateWithoutSlotsOfAvailabilityCustomInput,
    _i2.ConsultantProfileUncheckedUpdateWithoutSlotsOfAvailabilityCustomInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'connect': connect,
    'update': update,
  };
}

class SlotOfAvailabilityCustomUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityCustomUpdateInput({
    this.id,
    this.slotStartTimeInUTC,
    this.slotEndTimeInUTC,
    this.createdAt,
    this.updatedAt,
    this.consultantProfile,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  slotStartTimeInUTC;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  slotEndTimeInUTC;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.ConsultantProfileUpdateOneRequiredWithoutSlotsOfAvailabilityCustomNestedInput?
  consultantProfile;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultantProfile': consultantProfile,
  };
}

class SlotOfAvailabilityCustomUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityCustomUncheckedUpdateInput({
    this.id,
    this.slotStartTimeInUTC,
    this.slotEndTimeInUTC,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  slotStartTimeInUTC;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  slotEndTimeInUTC;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  consultantProfileId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SlotOfAvailabilityCustomUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityCustomUncheckedUpdateManyInput({
    this.id,
    this.slotStartTimeInUTC,
    this.slotEndTimeInUTC,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  slotStartTimeInUTC;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  slotEndTimeInUTC;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  consultantProfileId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SlotOfAvailabilityCustomCountAggregateOutputType {
  const SlotOfAvailabilityCustomCountAggregateOutputType({
    this.id,
    this.slotStartTimeInUTC,
    this.slotEndTimeInUTC,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  factory SlotOfAvailabilityCustomCountAggregateOutputType.fromJson(Map json) =>
      SlotOfAvailabilityCustomCountAggregateOutputType(
        id: json['id'],
        slotStartTimeInUTC: json['slotStartTimeInUTC'],
        slotEndTimeInUTC: json['slotEndTimeInUTC'],
        consultantProfileId: json['consultantProfileId'],
        createdAt: json['createdAt'],
        updatedAt: json['updatedAt'],
        $all: json['_all'],
      );

  final int? id;

  final int? slotStartTimeInUTC;

  final int? slotEndTimeInUTC;

  final int? consultantProfileId;

  final int? createdAt;

  final int? updatedAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class SlotOfAvailabilityCustomMinAggregateOutputType {
  const SlotOfAvailabilityCustomMinAggregateOutputType({
    this.id,
    this.slotStartTimeInUTC,
    this.slotEndTimeInUTC,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  factory SlotOfAvailabilityCustomMinAggregateOutputType.fromJson(Map json) =>
      SlotOfAvailabilityCustomMinAggregateOutputType(
        id: json['id'],
        slotStartTimeInUTC: switch (json['slotStartTimeInUTC']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['slotStartTimeInUTC'],
        },
        slotEndTimeInUTC: switch (json['slotEndTimeInUTC']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['slotEndTimeInUTC'],
        },
        consultantProfileId: json['consultantProfileId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final DateTime? slotStartTimeInUTC;

  final DateTime? slotEndTimeInUTC;

  final String? consultantProfileId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC?.toIso8601String(),
    'slotEndTimeInUTC': slotEndTimeInUTC?.toIso8601String(),
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class SlotOfAvailabilityCustomMaxAggregateOutputType {
  const SlotOfAvailabilityCustomMaxAggregateOutputType({
    this.id,
    this.slotStartTimeInUTC,
    this.slotEndTimeInUTC,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  factory SlotOfAvailabilityCustomMaxAggregateOutputType.fromJson(Map json) =>
      SlotOfAvailabilityCustomMaxAggregateOutputType(
        id: json['id'],
        slotStartTimeInUTC: switch (json['slotStartTimeInUTC']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['slotStartTimeInUTC'],
        },
        slotEndTimeInUTC: switch (json['slotEndTimeInUTC']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['slotEndTimeInUTC'],
        },
        consultantProfileId: json['consultantProfileId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final DateTime? slotStartTimeInUTC;

  final DateTime? slotEndTimeInUTC;

  final String? consultantProfileId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC?.toIso8601String(),
    'slotEndTimeInUTC': slotEndTimeInUTC?.toIso8601String(),
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class SlotOfAvailabilityCustomGroupByOutputType {
  const SlotOfAvailabilityCustomGroupByOutputType({
    this.id,
    this.slotStartTimeInUTC,
    this.slotEndTimeInUTC,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$min,
    this.$max,
  });

  factory SlotOfAvailabilityCustomGroupByOutputType.fromJson(Map json) =>
      SlotOfAvailabilityCustomGroupByOutputType(
        id: json['id'],
        slotStartTimeInUTC: switch (json['slotStartTimeInUTC']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['slotStartTimeInUTC'],
        },
        slotEndTimeInUTC: switch (json['slotEndTimeInUTC']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['slotEndTimeInUTC'],
        },
        consultantProfileId: json['consultantProfileId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
        $count: json['_count'] is Map
            ? _i2.SlotOfAvailabilityCustomCountAggregateOutputType.fromJson(
                json['_count'],
              )
            : null,
        $min: json['_min'] is Map
            ? _i2.SlotOfAvailabilityCustomMinAggregateOutputType.fromJson(
                json['_min'],
              )
            : null,
        $max: json['_max'] is Map
            ? _i2.SlotOfAvailabilityCustomMaxAggregateOutputType.fromJson(
                json['_max'],
              )
            : null,
      );

  final String? id;

  final DateTime? slotStartTimeInUTC;

  final DateTime? slotEndTimeInUTC;

  final String? consultantProfileId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.SlotOfAvailabilityCustomCountAggregateOutputType? $count;

  final _i2.SlotOfAvailabilityCustomMinAggregateOutputType? $min;

  final _i2.SlotOfAvailabilityCustomMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC?.toIso8601String(),
    'slotEndTimeInUTC': slotEndTimeInUTC?.toIso8601String(),
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
    '_count': $count?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class SlotOfAvailabilityCustomCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityCustomCountOrderByAggregateInput({
    this.id,
    this.slotStartTimeInUTC,
    this.slotEndTimeInUTC,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? slotStartTimeInUTC;

  final _i2.SortOrder? slotEndTimeInUTC;

  final _i2.SortOrder? consultantProfileId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SlotOfAvailabilityCustomMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityCustomMaxOrderByAggregateInput({
    this.id,
    this.slotStartTimeInUTC,
    this.slotEndTimeInUTC,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? slotStartTimeInUTC;

  final _i2.SortOrder? slotEndTimeInUTC;

  final _i2.SortOrder? consultantProfileId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SlotOfAvailabilityCustomMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityCustomMinOrderByAggregateInput({
    this.id,
    this.slotStartTimeInUTC,
    this.slotEndTimeInUTC,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? slotStartTimeInUTC;

  final _i2.SortOrder? slotEndTimeInUTC;

  final _i2.SortOrder? consultantProfileId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SlotOfAvailabilityCustomOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityCustomOrderByWithAggregationInput({
    this.id,
    this.slotStartTimeInUTC,
    this.slotEndTimeInUTC,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$max,
    this.$min,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? slotStartTimeInUTC;

  final _i2.SortOrder? slotEndTimeInUTC;

  final _i2.SortOrder? consultantProfileId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.SlotOfAvailabilityCustomCountOrderByAggregateInput? $count;

  final _i2.SlotOfAvailabilityCustomMaxOrderByAggregateInput? $max;

  final _i2.SlotOfAvailabilityCustomMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_max': $max,
    '_min': $min,
  };
}

class SlotOfAvailabilityCustomScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityCustomScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.slotStartTimeInUTC,
    this.slotEndTimeInUTC,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityCustomScalarWhereWithAggregatesInput,
    Iterable<_i2.SlotOfAvailabilityCustomScalarWhereWithAggregatesInput>
  >?
  AND;

  final Iterable<_i2.SlotOfAvailabilityCustomScalarWhereWithAggregatesInput>?
  OR;

  final _i1.PrismaUnion<
    _i2.SlotOfAvailabilityCustomScalarWhereWithAggregatesInput,
    Iterable<_i2.SlotOfAvailabilityCustomScalarWhereWithAggregatesInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? id;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>?
  slotStartTimeInUTC;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>?
  slotEndTimeInUTC;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>?
  consultantProfileId;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SlotOfAvailabilityCustomCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityCustomCountAggregateOutputTypeSelect({
    this.id,
    this.slotStartTimeInUTC,
    this.slotEndTimeInUTC,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  final bool? id;

  final bool? slotStartTimeInUTC;

  final bool? slotEndTimeInUTC;

  final bool? consultantProfileId;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class SlotOfAvailabilityCustomGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityCustomGroupByOutputTypeCountArgs({this.select});

  final _i2.SlotOfAvailabilityCustomCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SlotOfAvailabilityCustomMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityCustomMinAggregateOutputTypeSelect({
    this.id,
    this.slotStartTimeInUTC,
    this.slotEndTimeInUTC,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? slotStartTimeInUTC;

  final bool? slotEndTimeInUTC;

  final bool? consultantProfileId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SlotOfAvailabilityCustomGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityCustomGroupByOutputTypeMinArgs({this.select});

  final _i2.SlotOfAvailabilityCustomMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SlotOfAvailabilityCustomMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityCustomMaxAggregateOutputTypeSelect({
    this.id,
    this.slotStartTimeInUTC,
    this.slotEndTimeInUTC,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? slotStartTimeInUTC;

  final bool? slotEndTimeInUTC;

  final bool? consultantProfileId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SlotOfAvailabilityCustomGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityCustomGroupByOutputTypeMaxArgs({this.select});

  final _i2.SlotOfAvailabilityCustomMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SlotOfAvailabilityCustomGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAvailabilityCustomGroupByOutputTypeSelect({
    this.id,
    this.slotStartTimeInUTC,
    this.slotEndTimeInUTC,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? slotStartTimeInUTC;

  final bool? slotEndTimeInUTC;

  final bool? consultantProfileId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<
    bool,
    _i2.SlotOfAvailabilityCustomGroupByOutputTypeCountArgs
  >?
  $count;

  final _i1.PrismaUnion<
    bool,
    _i2.SlotOfAvailabilityCustomGroupByOutputTypeMinArgs
  >?
  $min;

  final _i1.PrismaUnion<
    bool,
    _i2.SlotOfAvailabilityCustomGroupByOutputTypeMaxArgs
  >?
  $max;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class AggregateSlotOfAvailabilityCustom {
  const AggregateSlotOfAvailabilityCustom({this.$count, this.$min, this.$max});

  factory AggregateSlotOfAvailabilityCustom.fromJson(Map json) =>
      AggregateSlotOfAvailabilityCustom(
        $count: json['_count'] is Map
            ? _i2.SlotOfAvailabilityCustomCountAggregateOutputType.fromJson(
                json['_count'],
              )
            : null,
        $min: json['_min'] is Map
            ? _i2.SlotOfAvailabilityCustomMinAggregateOutputType.fromJson(
                json['_min'],
              )
            : null,
        $max: json['_max'] is Map
            ? _i2.SlotOfAvailabilityCustomMaxAggregateOutputType.fromJson(
                json['_max'],
              )
            : null,
      );

  final _i2.SlotOfAvailabilityCustomCountAggregateOutputType? $count;

  final _i2.SlotOfAvailabilityCustomMinAggregateOutputType? $min;

  final _i2.SlotOfAvailabilityCustomMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    '_count': $count?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class AggregateSlotOfAvailabilityCustomCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSlotOfAvailabilityCustomCountArgs({this.select});

  final _i2.SlotOfAvailabilityCustomCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateSlotOfAvailabilityCustomMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSlotOfAvailabilityCustomMinArgs({this.select});

  final _i2.SlotOfAvailabilityCustomMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateSlotOfAvailabilityCustomMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSlotOfAvailabilityCustomMaxArgs({this.select});

  final _i2.SlotOfAvailabilityCustomMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateSlotOfAvailabilityCustomSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSlotOfAvailabilityCustomSelect({
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateSlotOfAvailabilityCustomCountArgs>?
  $count;

  final _i1.PrismaUnion<bool, _i2.AggregateSlotOfAvailabilityCustomMinArgs>?
  $min;

  final _i1.PrismaUnion<bool, _i2.AggregateSlotOfAvailabilityCustomMaxArgs>?
  $max;

  @override
  Map<String, dynamic> toJson() => {
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class SlotOfAppointmentCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentCreateInput({
    this.id,
    required this.slotStartTimeInUTC,
    required this.slotEndTimeInUTC,
    this.isTentative,
    this.createdAt,
    this.updatedAt,
    this.user,
    required this.appointment,
    this.meetingSession,
  });

  final String? id;

  final DateTime slotStartTimeInUTC;

  final DateTime slotEndTimeInUTC;

  final bool? isTentative;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.UserCreateNestedManyWithoutSlotsOfAppointmentInput? user;

  final _i2.AppointmentCreateNestedOneWithoutSlotsOfAppointmentInput
  appointment;

  final _i2.MeetingSessionCreateNestedOneWithoutSlotOfAppointmentInput?
  meetingSession;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'isTentative': isTentative,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'user': user,
    'appointment': appointment,
    'meetingSession': meetingSession,
  };
}

class SlotOfAppointmentUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentUncheckedCreateInput({
    this.id,
    required this.slotStartTimeInUTC,
    required this.slotEndTimeInUTC,
    this.isTentative,
    required this.appointmentId,
    this.createdAt,
    this.updatedAt,
    this.user,
    this.meetingSession,
  });

  final String? id;

  final DateTime slotStartTimeInUTC;

  final DateTime slotEndTimeInUTC;

  final bool? isTentative;

  final String appointmentId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.UserUncheckedCreateNestedManyWithoutSlotsOfAppointmentInput? user;

  final _i2.MeetingSessionUncheckedCreateNestedOneWithoutSlotOfAppointmentInput?
  meetingSession;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'isTentative': isTentative,
    'appointmentId': appointmentId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'user': user,
    'meetingSession': meetingSession,
  };
}

class SlotOfAppointmentCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentCreateManyInput({
    this.id,
    required this.slotStartTimeInUTC,
    required this.slotEndTimeInUTC,
    this.isTentative,
    required this.appointmentId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final DateTime slotStartTimeInUTC;

  final DateTime slotEndTimeInUTC;

  final bool? isTentative;

  final String appointmentId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'isTentative': isTentative,
    'appointmentId': appointmentId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SlotOfAppointmentUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentUpdateInput({
    this.id,
    this.slotStartTimeInUTC,
    this.slotEndTimeInUTC,
    this.isTentative,
    this.createdAt,
    this.updatedAt,
    this.user,
    this.appointment,
    this.meetingSession,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  slotStartTimeInUTC;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  slotEndTimeInUTC;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? isTentative;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.UserUpdateManyWithoutSlotsOfAppointmentNestedInput? user;

  final _i2.AppointmentUpdateOneRequiredWithoutSlotsOfAppointmentNestedInput?
  appointment;

  final _i2.MeetingSessionUpdateOneWithoutSlotOfAppointmentNestedInput?
  meetingSession;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'isTentative': isTentative,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'user': user,
    'appointment': appointment,
    'meetingSession': meetingSession,
  };
}

class SlotOfAppointmentUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentUncheckedUpdateInput({
    this.id,
    this.slotStartTimeInUTC,
    this.slotEndTimeInUTC,
    this.isTentative,
    this.appointmentId,
    this.createdAt,
    this.updatedAt,
    this.user,
    this.meetingSession,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  slotStartTimeInUTC;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  slotEndTimeInUTC;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? isTentative;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  appointmentId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.UserUncheckedUpdateManyWithoutSlotsOfAppointmentNestedInput? user;

  final _i2.MeetingSessionUncheckedUpdateOneWithoutSlotOfAppointmentNestedInput?
  meetingSession;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'isTentative': isTentative,
    'appointmentId': appointmentId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'user': user,
    'meetingSession': meetingSession,
  };
}

class SlotOfAppointmentUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentUncheckedUpdateManyInput({
    this.id,
    this.slotStartTimeInUTC,
    this.slotEndTimeInUTC,
    this.isTentative,
    this.appointmentId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  slotStartTimeInUTC;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  slotEndTimeInUTC;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? isTentative;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  appointmentId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'isTentative': isTentative,
    'appointmentId': appointmentId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SlotOfAppointmentCountAggregateOutputType {
  const SlotOfAppointmentCountAggregateOutputType({
    this.id,
    this.slotStartTimeInUTC,
    this.slotEndTimeInUTC,
    this.isTentative,
    this.appointmentId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  factory SlotOfAppointmentCountAggregateOutputType.fromJson(Map json) =>
      SlotOfAppointmentCountAggregateOutputType(
        id: json['id'],
        slotStartTimeInUTC: json['slotStartTimeInUTC'],
        slotEndTimeInUTC: json['slotEndTimeInUTC'],
        isTentative: json['isTentative'],
        appointmentId: json['appointmentId'],
        createdAt: json['createdAt'],
        updatedAt: json['updatedAt'],
        $all: json['_all'],
      );

  final int? id;

  final int? slotStartTimeInUTC;

  final int? slotEndTimeInUTC;

  final int? isTentative;

  final int? appointmentId;

  final int? createdAt;

  final int? updatedAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'isTentative': isTentative,
    'appointmentId': appointmentId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class SlotOfAppointmentMinAggregateOutputType {
  const SlotOfAppointmentMinAggregateOutputType({
    this.id,
    this.slotStartTimeInUTC,
    this.slotEndTimeInUTC,
    this.isTentative,
    this.appointmentId,
    this.createdAt,
    this.updatedAt,
  });

  factory SlotOfAppointmentMinAggregateOutputType.fromJson(Map json) =>
      SlotOfAppointmentMinAggregateOutputType(
        id: json['id'],
        slotStartTimeInUTC: switch (json['slotStartTimeInUTC']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['slotStartTimeInUTC'],
        },
        slotEndTimeInUTC: switch (json['slotEndTimeInUTC']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['slotEndTimeInUTC'],
        },
        isTentative: json['isTentative'],
        appointmentId: json['appointmentId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final DateTime? slotStartTimeInUTC;

  final DateTime? slotEndTimeInUTC;

  final bool? isTentative;

  final String? appointmentId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC?.toIso8601String(),
    'slotEndTimeInUTC': slotEndTimeInUTC?.toIso8601String(),
    'isTentative': isTentative,
    'appointmentId': appointmentId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class SlotOfAppointmentMaxAggregateOutputType {
  const SlotOfAppointmentMaxAggregateOutputType({
    this.id,
    this.slotStartTimeInUTC,
    this.slotEndTimeInUTC,
    this.isTentative,
    this.appointmentId,
    this.createdAt,
    this.updatedAt,
  });

  factory SlotOfAppointmentMaxAggregateOutputType.fromJson(Map json) =>
      SlotOfAppointmentMaxAggregateOutputType(
        id: json['id'],
        slotStartTimeInUTC: switch (json['slotStartTimeInUTC']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['slotStartTimeInUTC'],
        },
        slotEndTimeInUTC: switch (json['slotEndTimeInUTC']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['slotEndTimeInUTC'],
        },
        isTentative: json['isTentative'],
        appointmentId: json['appointmentId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final DateTime? slotStartTimeInUTC;

  final DateTime? slotEndTimeInUTC;

  final bool? isTentative;

  final String? appointmentId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC?.toIso8601String(),
    'slotEndTimeInUTC': slotEndTimeInUTC?.toIso8601String(),
    'isTentative': isTentative,
    'appointmentId': appointmentId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class SlotOfAppointmentGroupByOutputType {
  const SlotOfAppointmentGroupByOutputType({
    this.id,
    this.slotStartTimeInUTC,
    this.slotEndTimeInUTC,
    this.isTentative,
    this.appointmentId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$min,
    this.$max,
  });

  factory SlotOfAppointmentGroupByOutputType.fromJson(Map json) =>
      SlotOfAppointmentGroupByOutputType(
        id: json['id'],
        slotStartTimeInUTC: switch (json['slotStartTimeInUTC']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['slotStartTimeInUTC'],
        },
        slotEndTimeInUTC: switch (json['slotEndTimeInUTC']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['slotEndTimeInUTC'],
        },
        isTentative: json['isTentative'],
        appointmentId: json['appointmentId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
        $count: json['_count'] is Map
            ? _i2.SlotOfAppointmentCountAggregateOutputType.fromJson(
                json['_count'],
              )
            : null,
        $min: json['_min'] is Map
            ? _i2.SlotOfAppointmentMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.SlotOfAppointmentMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? id;

  final DateTime? slotStartTimeInUTC;

  final DateTime? slotEndTimeInUTC;

  final bool? isTentative;

  final String? appointmentId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.SlotOfAppointmentCountAggregateOutputType? $count;

  final _i2.SlotOfAppointmentMinAggregateOutputType? $min;

  final _i2.SlotOfAppointmentMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC?.toIso8601String(),
    'slotEndTimeInUTC': slotEndTimeInUTC?.toIso8601String(),
    'isTentative': isTentative,
    'appointmentId': appointmentId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
    '_count': $count?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class SlotOfAppointmentCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentCountOrderByAggregateInput({
    this.id,
    this.slotStartTimeInUTC,
    this.slotEndTimeInUTC,
    this.isTentative,
    this.appointmentId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? slotStartTimeInUTC;

  final _i2.SortOrder? slotEndTimeInUTC;

  final _i2.SortOrder? isTentative;

  final _i2.SortOrder? appointmentId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'isTentative': isTentative,
    'appointmentId': appointmentId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SlotOfAppointmentMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentMaxOrderByAggregateInput({
    this.id,
    this.slotStartTimeInUTC,
    this.slotEndTimeInUTC,
    this.isTentative,
    this.appointmentId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? slotStartTimeInUTC;

  final _i2.SortOrder? slotEndTimeInUTC;

  final _i2.SortOrder? isTentative;

  final _i2.SortOrder? appointmentId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'isTentative': isTentative,
    'appointmentId': appointmentId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SlotOfAppointmentMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentMinOrderByAggregateInput({
    this.id,
    this.slotStartTimeInUTC,
    this.slotEndTimeInUTC,
    this.isTentative,
    this.appointmentId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? slotStartTimeInUTC;

  final _i2.SortOrder? slotEndTimeInUTC;

  final _i2.SortOrder? isTentative;

  final _i2.SortOrder? appointmentId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'isTentative': isTentative,
    'appointmentId': appointmentId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SlotOfAppointmentOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentOrderByWithAggregationInput({
    this.id,
    this.slotStartTimeInUTC,
    this.slotEndTimeInUTC,
    this.isTentative,
    this.appointmentId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$max,
    this.$min,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? slotStartTimeInUTC;

  final _i2.SortOrder? slotEndTimeInUTC;

  final _i2.SortOrder? isTentative;

  final _i2.SortOrder? appointmentId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.SlotOfAppointmentCountOrderByAggregateInput? $count;

  final _i2.SlotOfAppointmentMaxOrderByAggregateInput? $max;

  final _i2.SlotOfAppointmentMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'isTentative': isTentative,
    'appointmentId': appointmentId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_max': $max,
    '_min': $min,
  };
}

class SlotOfAppointmentScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.slotStartTimeInUTC,
    this.slotEndTimeInUTC,
    this.isTentative,
    this.appointmentId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentScalarWhereWithAggregatesInput,
    Iterable<_i2.SlotOfAppointmentScalarWhereWithAggregatesInput>
  >?
  AND;

  final Iterable<_i2.SlotOfAppointmentScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentScalarWhereWithAggregatesInput,
    Iterable<_i2.SlotOfAppointmentScalarWhereWithAggregatesInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? id;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>?
  slotStartTimeInUTC;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>?
  slotEndTimeInUTC;

  final _i1.PrismaUnion<_i2.BoolWithAggregatesFilter, bool>? isTentative;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? appointmentId;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'isTentative': isTentative,
    'appointmentId': appointmentId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SlotOfAppointmentCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentCountAggregateOutputTypeSelect({
    this.id,
    this.slotStartTimeInUTC,
    this.slotEndTimeInUTC,
    this.isTentative,
    this.appointmentId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  final bool? id;

  final bool? slotStartTimeInUTC;

  final bool? slotEndTimeInUTC;

  final bool? isTentative;

  final bool? appointmentId;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'isTentative': isTentative,
    'appointmentId': appointmentId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class SlotOfAppointmentGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentGroupByOutputTypeCountArgs({this.select});

  final _i2.SlotOfAppointmentCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SlotOfAppointmentMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentMinAggregateOutputTypeSelect({
    this.id,
    this.slotStartTimeInUTC,
    this.slotEndTimeInUTC,
    this.isTentative,
    this.appointmentId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? slotStartTimeInUTC;

  final bool? slotEndTimeInUTC;

  final bool? isTentative;

  final bool? appointmentId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'isTentative': isTentative,
    'appointmentId': appointmentId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SlotOfAppointmentGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentGroupByOutputTypeMinArgs({this.select});

  final _i2.SlotOfAppointmentMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SlotOfAppointmentMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentMaxAggregateOutputTypeSelect({
    this.id,
    this.slotStartTimeInUTC,
    this.slotEndTimeInUTC,
    this.isTentative,
    this.appointmentId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? slotStartTimeInUTC;

  final bool? slotEndTimeInUTC;

  final bool? isTentative;

  final bool? appointmentId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'isTentative': isTentative,
    'appointmentId': appointmentId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SlotOfAppointmentGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentGroupByOutputTypeMaxArgs({this.select});

  final _i2.SlotOfAppointmentMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SlotOfAppointmentGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentGroupByOutputTypeSelect({
    this.id,
    this.slotStartTimeInUTC,
    this.slotEndTimeInUTC,
    this.isTentative,
    this.appointmentId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? slotStartTimeInUTC;

  final bool? slotEndTimeInUTC;

  final bool? isTentative;

  final bool? appointmentId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.SlotOfAppointmentGroupByOutputTypeCountArgs>?
  $count;

  final _i1.PrismaUnion<bool, _i2.SlotOfAppointmentGroupByOutputTypeMinArgs>?
  $min;

  final _i1.PrismaUnion<bool, _i2.SlotOfAppointmentGroupByOutputTypeMaxArgs>?
  $max;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'isTentative': isTentative,
    'appointmentId': appointmentId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class AggregateSlotOfAppointment {
  const AggregateSlotOfAppointment({this.$count, this.$min, this.$max});

  factory AggregateSlotOfAppointment.fromJson(Map json) =>
      AggregateSlotOfAppointment(
        $count: json['_count'] is Map
            ? _i2.SlotOfAppointmentCountAggregateOutputType.fromJson(
                json['_count'],
              )
            : null,
        $min: json['_min'] is Map
            ? _i2.SlotOfAppointmentMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.SlotOfAppointmentMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.SlotOfAppointmentCountAggregateOutputType? $count;

  final _i2.SlotOfAppointmentMinAggregateOutputType? $min;

  final _i2.SlotOfAppointmentMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    '_count': $count?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class AggregateSlotOfAppointmentCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSlotOfAppointmentCountArgs({this.select});

  final _i2.SlotOfAppointmentCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateSlotOfAppointmentMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSlotOfAppointmentMinArgs({this.select});

  final _i2.SlotOfAppointmentMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateSlotOfAppointmentMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSlotOfAppointmentMaxArgs({this.select});

  final _i2.SlotOfAppointmentMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateSlotOfAppointmentSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSlotOfAppointmentSelect({this.$count, this.$min, this.$max});

  final _i1.PrismaUnion<bool, _i2.AggregateSlotOfAppointmentCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateSlotOfAppointmentMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateSlotOfAppointmentMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class ConsultationPlanCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanCreateInput({
    this.id,
    required this.title,
    this.description,
    this.durationInHours,
    required this.price,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.createdAt,
    this.updatedAt,
    required this.consultantProfile,
    this.consultations,
  });

  final String? id;

  final String title;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final double? durationInHours;

  final int price;

  final String? language;

  final String? level;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? prerequisites;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? materialProvided;

  final _i1.PrismaUnion<
    _i2.ConsultationPlanCreatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ConsultantProfileCreateNestedOneWithoutConsultationPlansInput
  consultantProfile;

  final _i2.ConsultationCreateNestedManyWithoutConsultationPlanInput?
  consultations;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInHours': durationInHours,
    'price': price,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultantProfile': consultantProfile,
    'consultations': consultations,
  };
}

class ConsultationPlanUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanUncheckedCreateInput({
    this.id,
    required this.title,
    this.description,
    this.durationInHours,
    required this.price,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    required this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.consultations,
  });

  final String? id;

  final String title;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final double? durationInHours;

  final int price;

  final String? language;

  final String? level;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? prerequisites;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? materialProvided;

  final _i1.PrismaUnion<
    _i2.ConsultationPlanCreatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final String consultantProfileId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ConsultationUncheckedCreateNestedManyWithoutConsultationPlanInput?
  consultations;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInHours': durationInHours,
    'price': price,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultations': consultations,
  };
}

class ConsultationPlanCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanCreateManyInput({
    this.id,
    required this.title,
    this.description,
    this.durationInHours,
    required this.price,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    required this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final String title;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final double? durationInHours;

  final int price;

  final String? language;

  final String? level;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? prerequisites;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? materialProvided;

  final _i1.PrismaUnion<
    _i2.ConsultationPlanCreatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final String consultantProfileId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInHours': durationInHours,
    'price': price,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultationPlanUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanUpdateInput({
    this.id,
    this.title,
    this.description,
    this.durationInHours,
    this.price,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.createdAt,
    this.updatedAt,
    this.consultantProfile,
    this.consultations,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
  durationInHours;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? price;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? language;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? level;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  prerequisites;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  materialProvided;

  final _i1.PrismaUnion<
    _i2.ConsultationPlanUpdatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.ConsultantProfileUpdateOneRequiredWithoutConsultationPlansNestedInput?
  consultantProfile;

  final _i2.ConsultationUpdateManyWithoutConsultationPlanNestedInput?
  consultations;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInHours': durationInHours,
    'price': price,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultantProfile': consultantProfile,
    'consultations': consultations,
  };
}

class ConsultationPlanUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanUncheckedUpdateInput({
    this.id,
    this.title,
    this.description,
    this.durationInHours,
    this.price,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.consultations,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
  durationInHours;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? price;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? language;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? level;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  prerequisites;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  materialProvided;

  final _i1.PrismaUnion<
    _i2.ConsultationPlanUpdatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  consultantProfileId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.ConsultationUncheckedUpdateManyWithoutConsultationPlanNestedInput?
  consultations;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInHours': durationInHours,
    'price': price,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultations': consultations,
  };
}

class ConsultationPlanUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanUncheckedUpdateManyInput({
    this.id,
    this.title,
    this.description,
    this.durationInHours,
    this.price,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
  durationInHours;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? price;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? language;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? level;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  prerequisites;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  materialProvided;

  final _i1.PrismaUnion<
    _i2.ConsultationPlanUpdatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  consultantProfileId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInHours': durationInHours,
    'price': price,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultationPlanCountAggregateOutputType {
  const ConsultationPlanCountAggregateOutputType({
    this.id,
    this.title,
    this.description,
    this.durationInHours,
    this.price,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  factory ConsultationPlanCountAggregateOutputType.fromJson(Map json) =>
      ConsultationPlanCountAggregateOutputType(
        id: json['id'],
        title: json['title'],
        description: json['description'],
        durationInHours: json['durationInHours'],
        price: json['price'],
        language: json['language'],
        level: json['level'],
        prerequisites: json['prerequisites'],
        materialProvided: json['materialProvided'],
        learningOutcomes: json['learningOutcomes'],
        consultantProfileId: json['consultantProfileId'],
        createdAt: json['createdAt'],
        updatedAt: json['updatedAt'],
        $all: json['_all'],
      );

  final int? id;

  final int? title;

  final int? description;

  final int? durationInHours;

  final int? price;

  final int? language;

  final int? level;

  final int? prerequisites;

  final int? materialProvided;

  final int? learningOutcomes;

  final int? consultantProfileId;

  final int? createdAt;

  final int? updatedAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInHours': durationInHours,
    'price': price,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class ConsultationPlanAvgAggregateOutputType {
  const ConsultationPlanAvgAggregateOutputType({
    this.durationInHours,
    this.price,
  });

  factory ConsultationPlanAvgAggregateOutputType.fromJson(Map json) =>
      ConsultationPlanAvgAggregateOutputType(
        durationInHours: json['durationInHours'],
        price: json['price'],
      );

  final double? durationInHours;

  final double? price;

  Map<String, dynamic> toJson() => {
    'durationInHours': durationInHours,
    'price': price,
  };
}

class ConsultationPlanSumAggregateOutputType {
  const ConsultationPlanSumAggregateOutputType({
    this.durationInHours,
    this.price,
  });

  factory ConsultationPlanSumAggregateOutputType.fromJson(Map json) =>
      ConsultationPlanSumAggregateOutputType(
        durationInHours: json['durationInHours'],
        price: json['price'],
      );

  final double? durationInHours;

  final int? price;

  Map<String, dynamic> toJson() => {
    'durationInHours': durationInHours,
    'price': price,
  };
}

class ConsultationPlanMinAggregateOutputType {
  const ConsultationPlanMinAggregateOutputType({
    this.id,
    this.title,
    this.description,
    this.durationInHours,
    this.price,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  factory ConsultationPlanMinAggregateOutputType.fromJson(Map json) =>
      ConsultationPlanMinAggregateOutputType(
        id: json['id'],
        title: json['title'],
        description: json['description'],
        durationInHours: json['durationInHours'],
        price: json['price'],
        language: json['language'],
        level: json['level'],
        prerequisites: json['prerequisites'],
        materialProvided: json['materialProvided'],
        consultantProfileId: json['consultantProfileId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final String? title;

  final String? description;

  final double? durationInHours;

  final int? price;

  final String? language;

  final String? level;

  final String? prerequisites;

  final String? materialProvided;

  final String? consultantProfileId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInHours': durationInHours,
    'price': price,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class ConsultationPlanMaxAggregateOutputType {
  const ConsultationPlanMaxAggregateOutputType({
    this.id,
    this.title,
    this.description,
    this.durationInHours,
    this.price,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  factory ConsultationPlanMaxAggregateOutputType.fromJson(Map json) =>
      ConsultationPlanMaxAggregateOutputType(
        id: json['id'],
        title: json['title'],
        description: json['description'],
        durationInHours: json['durationInHours'],
        price: json['price'],
        language: json['language'],
        level: json['level'],
        prerequisites: json['prerequisites'],
        materialProvided: json['materialProvided'],
        consultantProfileId: json['consultantProfileId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final String? title;

  final String? description;

  final double? durationInHours;

  final int? price;

  final String? language;

  final String? level;

  final String? prerequisites;

  final String? materialProvided;

  final String? consultantProfileId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInHours': durationInHours,
    'price': price,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class ConsultationPlanGroupByOutputType {
  const ConsultationPlanGroupByOutputType({
    this.id,
    this.title,
    this.description,
    this.durationInHours,
    this.price,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory ConsultationPlanGroupByOutputType.fromJson(Map json) =>
      ConsultationPlanGroupByOutputType(
        id: json['id'],
        title: json['title'],
        description: json['description'],
        durationInHours: json['durationInHours'],
        price: json['price'],
        language: json['language'],
        level: json['level'],
        prerequisites: json['prerequisites'],
        materialProvided: json['materialProvided'],
        learningOutcomes: json['learningOutcomes'] is Iterable
            ? (json['learningOutcomes'] as Iterable).whereType<String>()
            : null,
        consultantProfileId: json['consultantProfileId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
        $count: json['_count'] is Map
            ? _i2.ConsultationPlanCountAggregateOutputType.fromJson(
                json['_count'],
              )
            : null,
        $avg: json['_avg'] is Map
            ? _i2.ConsultationPlanAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.ConsultationPlanSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.ConsultationPlanMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.ConsultationPlanMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? id;

  final String? title;

  final String? description;

  final double? durationInHours;

  final int? price;

  final String? language;

  final String? level;

  final String? prerequisites;

  final String? materialProvided;

  final Iterable<String>? learningOutcomes;

  final String? consultantProfileId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ConsultationPlanCountAggregateOutputType? $count;

  final _i2.ConsultationPlanAvgAggregateOutputType? $avg;

  final _i2.ConsultationPlanSumAggregateOutputType? $sum;

  final _i2.ConsultationPlanMinAggregateOutputType? $min;

  final _i2.ConsultationPlanMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInHours': durationInHours,
    'price': price,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes?.map((e) => e),
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
    '_count': $count?.toJson(),
    '_avg': $avg?.toJson(),
    '_sum': $sum?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class ConsultationPlanCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanCountOrderByAggregateInput({
    this.id,
    this.title,
    this.description,
    this.durationInHours,
    this.price,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? title;

  final _i2.SortOrder? description;

  final _i2.SortOrder? durationInHours;

  final _i2.SortOrder? price;

  final _i2.SortOrder? language;

  final _i2.SortOrder? level;

  final _i2.SortOrder? prerequisites;

  final _i2.SortOrder? materialProvided;

  final _i2.SortOrder? learningOutcomes;

  final _i2.SortOrder? consultantProfileId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInHours': durationInHours,
    'price': price,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultationPlanAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanAvgOrderByAggregateInput({
    this.durationInHours,
    this.price,
  });

  final _i2.SortOrder? durationInHours;

  final _i2.SortOrder? price;

  @override
  Map<String, dynamic> toJson() => {
    'durationInHours': durationInHours,
    'price': price,
  };
}

class ConsultationPlanMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanMaxOrderByAggregateInput({
    this.id,
    this.title,
    this.description,
    this.durationInHours,
    this.price,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? title;

  final _i2.SortOrder? description;

  final _i2.SortOrder? durationInHours;

  final _i2.SortOrder? price;

  final _i2.SortOrder? language;

  final _i2.SortOrder? level;

  final _i2.SortOrder? prerequisites;

  final _i2.SortOrder? materialProvided;

  final _i2.SortOrder? consultantProfileId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInHours': durationInHours,
    'price': price,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultationPlanMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanMinOrderByAggregateInput({
    this.id,
    this.title,
    this.description,
    this.durationInHours,
    this.price,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? title;

  final _i2.SortOrder? description;

  final _i2.SortOrder? durationInHours;

  final _i2.SortOrder? price;

  final _i2.SortOrder? language;

  final _i2.SortOrder? level;

  final _i2.SortOrder? prerequisites;

  final _i2.SortOrder? materialProvided;

  final _i2.SortOrder? consultantProfileId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInHours': durationInHours,
    'price': price,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultationPlanSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanSumOrderByAggregateInput({
    this.durationInHours,
    this.price,
  });

  final _i2.SortOrder? durationInHours;

  final _i2.SortOrder? price;

  @override
  Map<String, dynamic> toJson() => {
    'durationInHours': durationInHours,
    'price': price,
  };
}

class ConsultationPlanOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanOrderByWithAggregationInput({
    this.id,
    this.title,
    this.description,
    this.durationInHours,
    this.price,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? title;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? description;

  final _i2.SortOrder? durationInHours;

  final _i2.SortOrder? price;

  final _i2.SortOrder? language;

  final _i2.SortOrder? level;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? prerequisites;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? materialProvided;

  final _i2.SortOrder? learningOutcomes;

  final _i2.SortOrder? consultantProfileId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.ConsultationPlanCountOrderByAggregateInput? $count;

  final _i2.ConsultationPlanAvgOrderByAggregateInput? $avg;

  final _i2.ConsultationPlanMaxOrderByAggregateInput? $max;

  final _i2.ConsultationPlanMinOrderByAggregateInput? $min;

  final _i2.ConsultationPlanSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInHours': durationInHours,
    'price': price,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_avg': $avg,
    '_max': $max,
    '_min': $min,
    '_sum': $sum,
  };
}

class ConsultationPlanScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.title,
    this.description,
    this.durationInHours,
    this.price,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
    _i2.ConsultationPlanScalarWhereWithAggregatesInput,
    Iterable<_i2.ConsultationPlanScalarWhereWithAggregatesInput>
  >?
  AND;

  final Iterable<_i2.ConsultationPlanScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<
    _i2.ConsultationPlanScalarWhereWithAggregatesInput,
    Iterable<_i2.ConsultationPlanScalarWhereWithAggregatesInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? title;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  description;

  final _i1.PrismaUnion<_i2.FloatWithAggregatesFilter, double>? durationInHours;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? price;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? language;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? level;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  prerequisites;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  materialProvided;

  final _i2.StringNullableListFilter? learningOutcomes;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>?
  consultantProfileId;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'title': title,
    'description': description,
    'durationInHours': durationInHours,
    'price': price,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultationPlanCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanCountAggregateOutputTypeSelect({
    this.id,
    this.title,
    this.description,
    this.durationInHours,
    this.price,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  final bool? id;

  final bool? title;

  final bool? description;

  final bool? durationInHours;

  final bool? price;

  final bool? language;

  final bool? level;

  final bool? prerequisites;

  final bool? materialProvided;

  final bool? learningOutcomes;

  final bool? consultantProfileId;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInHours': durationInHours,
    'price': price,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class ConsultationPlanGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanGroupByOutputTypeCountArgs({this.select});

  final _i2.ConsultationPlanCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ConsultationPlanAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanAvgAggregateOutputTypeSelect({
    this.durationInHours,
    this.price,
  });

  final bool? durationInHours;

  final bool? price;

  @override
  Map<String, dynamic> toJson() => {
    'durationInHours': durationInHours,
    'price': price,
  };
}

class ConsultationPlanGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanGroupByOutputTypeAvgArgs({this.select});

  final _i2.ConsultationPlanAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ConsultationPlanSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanSumAggregateOutputTypeSelect({
    this.durationInHours,
    this.price,
  });

  final bool? durationInHours;

  final bool? price;

  @override
  Map<String, dynamic> toJson() => {
    'durationInHours': durationInHours,
    'price': price,
  };
}

class ConsultationPlanGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanGroupByOutputTypeSumArgs({this.select});

  final _i2.ConsultationPlanSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ConsultationPlanMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanMinAggregateOutputTypeSelect({
    this.id,
    this.title,
    this.description,
    this.durationInHours,
    this.price,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? title;

  final bool? description;

  final bool? durationInHours;

  final bool? price;

  final bool? language;

  final bool? level;

  final bool? prerequisites;

  final bool? materialProvided;

  final bool? consultantProfileId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInHours': durationInHours,
    'price': price,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultationPlanGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanGroupByOutputTypeMinArgs({this.select});

  final _i2.ConsultationPlanMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ConsultationPlanMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanMaxAggregateOutputTypeSelect({
    this.id,
    this.title,
    this.description,
    this.durationInHours,
    this.price,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? title;

  final bool? description;

  final bool? durationInHours;

  final bool? price;

  final bool? language;

  final bool? level;

  final bool? prerequisites;

  final bool? materialProvided;

  final bool? consultantProfileId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInHours': durationInHours,
    'price': price,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultationPlanGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanGroupByOutputTypeMaxArgs({this.select});

  final _i2.ConsultationPlanMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ConsultationPlanGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationPlanGroupByOutputTypeSelect({
    this.id,
    this.title,
    this.description,
    this.durationInHours,
    this.price,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? title;

  final bool? description;

  final bool? durationInHours;

  final bool? price;

  final bool? language;

  final bool? level;

  final bool? prerequisites;

  final bool? materialProvided;

  final bool? learningOutcomes;

  final bool? consultantProfileId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.ConsultationPlanGroupByOutputTypeCountArgs>?
  $count;

  final _i1.PrismaUnion<bool, _i2.ConsultationPlanGroupByOutputTypeAvgArgs>?
  $avg;

  final _i1.PrismaUnion<bool, _i2.ConsultationPlanGroupByOutputTypeSumArgs>?
  $sum;

  final _i1.PrismaUnion<bool, _i2.ConsultationPlanGroupByOutputTypeMinArgs>?
  $min;

  final _i1.PrismaUnion<bool, _i2.ConsultationPlanGroupByOutputTypeMaxArgs>?
  $max;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInHours': durationInHours,
    'price': price,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_avg': $avg,
    '_sum': $sum,
    '_min': $min,
    '_max': $max,
  };
}

class AggregateConsultationPlan {
  const AggregateConsultationPlan({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateConsultationPlan.fromJson(Map json) =>
      AggregateConsultationPlan(
        $count: json['_count'] is Map
            ? _i2.ConsultationPlanCountAggregateOutputType.fromJson(
                json['_count'],
              )
            : null,
        $avg: json['_avg'] is Map
            ? _i2.ConsultationPlanAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.ConsultationPlanSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.ConsultationPlanMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.ConsultationPlanMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.ConsultationPlanCountAggregateOutputType? $count;

  final _i2.ConsultationPlanAvgAggregateOutputType? $avg;

  final _i2.ConsultationPlanSumAggregateOutputType? $sum;

  final _i2.ConsultationPlanMinAggregateOutputType? $min;

  final _i2.ConsultationPlanMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    '_count': $count?.toJson(),
    '_avg': $avg?.toJson(),
    '_sum': $sum?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class AggregateConsultationPlanCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateConsultationPlanCountArgs({this.select});

  final _i2.ConsultationPlanCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateConsultationPlanAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateConsultationPlanAvgArgs({this.select});

  final _i2.ConsultationPlanAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateConsultationPlanSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateConsultationPlanSumArgs({this.select});

  final _i2.ConsultationPlanSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateConsultationPlanMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateConsultationPlanMinArgs({this.select});

  final _i2.ConsultationPlanMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateConsultationPlanMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateConsultationPlanMaxArgs({this.select});

  final _i2.ConsultationPlanMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateConsultationPlanSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateConsultationPlanSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateConsultationPlanCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateConsultationPlanAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateConsultationPlanSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateConsultationPlanMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateConsultationPlanMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    '_count': $count,
    '_avg': $avg,
    '_sum': $sum,
    '_min': $min,
    '_max': $max,
  };
}

class ConsultationCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationCreateInput({
    this.id,
    this.requestStatus,
    this.requestedAt,
    this.requestNotes,
    this.directlyBooked,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.createdAt,
    this.updatedAt,
    required this.consultationPlan,
    required this.requestedBy,
    this.appointment,
  });

  final String? id;

  final _i3.RequestStatus? requestStatus;

  final DateTime? requestedAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? requestNotes;

  final bool? directlyBooked;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackFromConsultee;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackFromConsultant;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? rating;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ConsultationPlanCreateNestedOneWithoutConsultationsInput
  consultationPlan;

  final _i2.ConsulteeProfileCreateNestedOneWithoutConsultationRequestsInput
  requestedBy;

  final _i2.AppointmentCreateNestedOneWithoutConsultationInput? appointment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'requestStatus': requestStatus,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'directlyBooked': directlyBooked,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultationPlan': consultationPlan,
    'requestedBy': requestedBy,
    'appointment': appointment,
  };
}

class ConsultationUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationUncheckedCreateInput({
    this.id,
    required this.consultationPlanId,
    this.requestStatus,
    required this.requestedById,
    this.requestedAt,
    this.requestNotes,
    this.directlyBooked,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.createdAt,
    this.updatedAt,
    this.appointment,
  });

  final String? id;

  final String consultationPlanId;

  final _i3.RequestStatus? requestStatus;

  final String requestedById;

  final DateTime? requestedAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? requestNotes;

  final bool? directlyBooked;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackFromConsultee;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackFromConsultant;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? rating;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.AppointmentUncheckedCreateNestedOneWithoutConsultationInput?
  appointment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'consultationPlanId': consultationPlanId,
    'requestStatus': requestStatus,
    'requestedById': requestedById,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'directlyBooked': directlyBooked,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'appointment': appointment,
  };
}

class ConsultationCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationCreateManyInput({
    this.id,
    required this.consultationPlanId,
    this.requestStatus,
    required this.requestedById,
    this.requestedAt,
    this.requestNotes,
    this.directlyBooked,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final String consultationPlanId;

  final _i3.RequestStatus? requestStatus;

  final String requestedById;

  final DateTime? requestedAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? requestNotes;

  final bool? directlyBooked;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackFromConsultee;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackFromConsultant;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? rating;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'consultationPlanId': consultationPlanId,
    'requestStatus': requestStatus,
    'requestedById': requestedById,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'directlyBooked': directlyBooked,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultationUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationUpdateInput({
    this.id,
    this.requestStatus,
    this.requestedAt,
    this.requestNotes,
    this.directlyBooked,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.createdAt,
    this.updatedAt,
    this.consultationPlan,
    this.requestedBy,
    this.appointment,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    _i3.RequestStatus,
    _i2.EnumRequestStatusFieldUpdateOperationsInput
  >?
  requestStatus;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  requestedAt;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  requestNotes;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
  directlyBooked;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackFromConsultee;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackFromConsultant;

  final _i1.PrismaUnion<
    double,
    _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  rating;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.ConsultationPlanUpdateOneRequiredWithoutConsultationsNestedInput?
  consultationPlan;

  final _i2.ConsulteeProfileUpdateOneRequiredWithoutConsultationRequestsNestedInput?
  requestedBy;

  final _i2.AppointmentUpdateOneWithoutConsultationNestedInput? appointment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'requestStatus': requestStatus,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'directlyBooked': directlyBooked,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultationPlan': consultationPlan,
    'requestedBy': requestedBy,
    'appointment': appointment,
  };
}

class ConsultationUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationUncheckedUpdateInput({
    this.id,
    this.consultationPlanId,
    this.requestStatus,
    this.requestedById,
    this.requestedAt,
    this.requestNotes,
    this.directlyBooked,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.createdAt,
    this.updatedAt,
    this.appointment,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  consultationPlanId;

  final _i1.PrismaUnion<
    _i3.RequestStatus,
    _i2.EnumRequestStatusFieldUpdateOperationsInput
  >?
  requestStatus;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  requestedById;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  requestedAt;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  requestNotes;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
  directlyBooked;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackFromConsultee;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackFromConsultant;

  final _i1.PrismaUnion<
    double,
    _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  rating;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.AppointmentUncheckedUpdateOneWithoutConsultationNestedInput?
  appointment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'consultationPlanId': consultationPlanId,
    'requestStatus': requestStatus,
    'requestedById': requestedById,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'directlyBooked': directlyBooked,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'appointment': appointment,
  };
}

class ConsultationUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationUncheckedUpdateManyInput({
    this.id,
    this.consultationPlanId,
    this.requestStatus,
    this.requestedById,
    this.requestedAt,
    this.requestNotes,
    this.directlyBooked,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  consultationPlanId;

  final _i1.PrismaUnion<
    _i3.RequestStatus,
    _i2.EnumRequestStatusFieldUpdateOperationsInput
  >?
  requestStatus;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  requestedById;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  requestedAt;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  requestNotes;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
  directlyBooked;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackFromConsultee;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackFromConsultant;

  final _i1.PrismaUnion<
    double,
    _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  rating;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'consultationPlanId': consultationPlanId,
    'requestStatus': requestStatus,
    'requestedById': requestedById,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'directlyBooked': directlyBooked,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultationCountAggregateOutputType {
  const ConsultationCountAggregateOutputType({
    this.id,
    this.consultationPlanId,
    this.requestStatus,
    this.requestedById,
    this.requestedAt,
    this.requestNotes,
    this.directlyBooked,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  factory ConsultationCountAggregateOutputType.fromJson(Map json) =>
      ConsultationCountAggregateOutputType(
        id: json['id'],
        consultationPlanId: json['consultationPlanId'],
        requestStatus: json['requestStatus'],
        requestedById: json['requestedById'],
        requestedAt: json['requestedAt'],
        requestNotes: json['requestNotes'],
        directlyBooked: json['directlyBooked'],
        feedbackFromConsultee: json['feedbackFromConsultee'],
        feedbackFromConsultant: json['feedbackFromConsultant'],
        rating: json['rating'],
        createdAt: json['createdAt'],
        updatedAt: json['updatedAt'],
        $all: json['_all'],
      );

  final int? id;

  final int? consultationPlanId;

  final int? requestStatus;

  final int? requestedById;

  final int? requestedAt;

  final int? requestNotes;

  final int? directlyBooked;

  final int? feedbackFromConsultee;

  final int? feedbackFromConsultant;

  final int? rating;

  final int? createdAt;

  final int? updatedAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
    'id': id,
    'consultationPlanId': consultationPlanId,
    'requestStatus': requestStatus,
    'requestedById': requestedById,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'directlyBooked': directlyBooked,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class ConsultationAvgAggregateOutputType {
  const ConsultationAvgAggregateOutputType({this.rating});

  factory ConsultationAvgAggregateOutputType.fromJson(Map json) =>
      ConsultationAvgAggregateOutputType(rating: json['rating']);

  final double? rating;

  Map<String, dynamic> toJson() => {'rating': rating};
}

class ConsultationSumAggregateOutputType {
  const ConsultationSumAggregateOutputType({this.rating});

  factory ConsultationSumAggregateOutputType.fromJson(Map json) =>
      ConsultationSumAggregateOutputType(rating: json['rating']);

  final double? rating;

  Map<String, dynamic> toJson() => {'rating': rating};
}

class ConsultationMinAggregateOutputType {
  const ConsultationMinAggregateOutputType({
    this.id,
    this.consultationPlanId,
    this.requestStatus,
    this.requestedById,
    this.requestedAt,
    this.requestNotes,
    this.directlyBooked,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.createdAt,
    this.updatedAt,
  });

  factory ConsultationMinAggregateOutputType.fromJson(Map json) =>
      ConsultationMinAggregateOutputType(
        id: json['id'],
        consultationPlanId: json['consultationPlanId'],
        requestStatus: json['requestStatus'] != null
            ? _i3.RequestStatus.values.firstWhere(
                (e) => e.name == json['requestStatus'],
              )
            : null,
        requestedById: json['requestedById'],
        requestedAt: switch (json['requestedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['requestedAt'],
        },
        requestNotes: json['requestNotes'],
        directlyBooked: json['directlyBooked'],
        feedbackFromConsultee: json['feedbackFromConsultee'],
        feedbackFromConsultant: json['feedbackFromConsultant'],
        rating: json['rating'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final String? consultationPlanId;

  final _i3.RequestStatus? requestStatus;

  final String? requestedById;

  final DateTime? requestedAt;

  final String? requestNotes;

  final bool? directlyBooked;

  final String? feedbackFromConsultee;

  final String? feedbackFromConsultant;

  final double? rating;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'consultationPlanId': consultationPlanId,
    'requestStatus': requestStatus?.name,
    'requestedById': requestedById,
    'requestedAt': requestedAt?.toIso8601String(),
    'requestNotes': requestNotes,
    'directlyBooked': directlyBooked,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class ConsultationMaxAggregateOutputType {
  const ConsultationMaxAggregateOutputType({
    this.id,
    this.consultationPlanId,
    this.requestStatus,
    this.requestedById,
    this.requestedAt,
    this.requestNotes,
    this.directlyBooked,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.createdAt,
    this.updatedAt,
  });

  factory ConsultationMaxAggregateOutputType.fromJson(Map json) =>
      ConsultationMaxAggregateOutputType(
        id: json['id'],
        consultationPlanId: json['consultationPlanId'],
        requestStatus: json['requestStatus'] != null
            ? _i3.RequestStatus.values.firstWhere(
                (e) => e.name == json['requestStatus'],
              )
            : null,
        requestedById: json['requestedById'],
        requestedAt: switch (json['requestedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['requestedAt'],
        },
        requestNotes: json['requestNotes'],
        directlyBooked: json['directlyBooked'],
        feedbackFromConsultee: json['feedbackFromConsultee'],
        feedbackFromConsultant: json['feedbackFromConsultant'],
        rating: json['rating'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final String? consultationPlanId;

  final _i3.RequestStatus? requestStatus;

  final String? requestedById;

  final DateTime? requestedAt;

  final String? requestNotes;

  final bool? directlyBooked;

  final String? feedbackFromConsultee;

  final String? feedbackFromConsultant;

  final double? rating;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'consultationPlanId': consultationPlanId,
    'requestStatus': requestStatus?.name,
    'requestedById': requestedById,
    'requestedAt': requestedAt?.toIso8601String(),
    'requestNotes': requestNotes,
    'directlyBooked': directlyBooked,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class ConsultationGroupByOutputType {
  const ConsultationGroupByOutputType({
    this.id,
    this.consultationPlanId,
    this.requestStatus,
    this.requestedById,
    this.requestedAt,
    this.requestNotes,
    this.directlyBooked,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory ConsultationGroupByOutputType.fromJson(Map json) =>
      ConsultationGroupByOutputType(
        id: json['id'],
        consultationPlanId: json['consultationPlanId'],
        requestStatus: json['requestStatus'] != null
            ? _i3.RequestStatus.values.firstWhere(
                (e) => e.name == json['requestStatus'],
              )
            : null,
        requestedById: json['requestedById'],
        requestedAt: switch (json['requestedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['requestedAt'],
        },
        requestNotes: json['requestNotes'],
        directlyBooked: json['directlyBooked'],
        feedbackFromConsultee: json['feedbackFromConsultee'],
        feedbackFromConsultant: json['feedbackFromConsultant'],
        rating: json['rating'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
        $count: json['_count'] is Map
            ? _i2.ConsultationCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.ConsultationAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.ConsultationSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.ConsultationMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.ConsultationMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? id;

  final String? consultationPlanId;

  final _i3.RequestStatus? requestStatus;

  final String? requestedById;

  final DateTime? requestedAt;

  final String? requestNotes;

  final bool? directlyBooked;

  final String? feedbackFromConsultee;

  final String? feedbackFromConsultant;

  final double? rating;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ConsultationCountAggregateOutputType? $count;

  final _i2.ConsultationAvgAggregateOutputType? $avg;

  final _i2.ConsultationSumAggregateOutputType? $sum;

  final _i2.ConsultationMinAggregateOutputType? $min;

  final _i2.ConsultationMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    'id': id,
    'consultationPlanId': consultationPlanId,
    'requestStatus': requestStatus?.name,
    'requestedById': requestedById,
    'requestedAt': requestedAt?.toIso8601String(),
    'requestNotes': requestNotes,
    'directlyBooked': directlyBooked,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
    '_count': $count?.toJson(),
    '_avg': $avg?.toJson(),
    '_sum': $sum?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class ConsultationCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationCountOrderByAggregateInput({
    this.id,
    this.consultationPlanId,
    this.requestStatus,
    this.requestedById,
    this.requestedAt,
    this.requestNotes,
    this.directlyBooked,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? consultationPlanId;

  final _i2.SortOrder? requestStatus;

  final _i2.SortOrder? requestedById;

  final _i2.SortOrder? requestedAt;

  final _i2.SortOrder? requestNotes;

  final _i2.SortOrder? directlyBooked;

  final _i2.SortOrder? feedbackFromConsultee;

  final _i2.SortOrder? feedbackFromConsultant;

  final _i2.SortOrder? rating;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'consultationPlanId': consultationPlanId,
    'requestStatus': requestStatus,
    'requestedById': requestedById,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'directlyBooked': directlyBooked,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultationAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationAvgOrderByAggregateInput({this.rating});

  final _i2.SortOrder? rating;

  @override
  Map<String, dynamic> toJson() => {'rating': rating};
}

class ConsultationMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationMaxOrderByAggregateInput({
    this.id,
    this.consultationPlanId,
    this.requestStatus,
    this.requestedById,
    this.requestedAt,
    this.requestNotes,
    this.directlyBooked,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? consultationPlanId;

  final _i2.SortOrder? requestStatus;

  final _i2.SortOrder? requestedById;

  final _i2.SortOrder? requestedAt;

  final _i2.SortOrder? requestNotes;

  final _i2.SortOrder? directlyBooked;

  final _i2.SortOrder? feedbackFromConsultee;

  final _i2.SortOrder? feedbackFromConsultant;

  final _i2.SortOrder? rating;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'consultationPlanId': consultationPlanId,
    'requestStatus': requestStatus,
    'requestedById': requestedById,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'directlyBooked': directlyBooked,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultationMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationMinOrderByAggregateInput({
    this.id,
    this.consultationPlanId,
    this.requestStatus,
    this.requestedById,
    this.requestedAt,
    this.requestNotes,
    this.directlyBooked,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? consultationPlanId;

  final _i2.SortOrder? requestStatus;

  final _i2.SortOrder? requestedById;

  final _i2.SortOrder? requestedAt;

  final _i2.SortOrder? requestNotes;

  final _i2.SortOrder? directlyBooked;

  final _i2.SortOrder? feedbackFromConsultee;

  final _i2.SortOrder? feedbackFromConsultant;

  final _i2.SortOrder? rating;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'consultationPlanId': consultationPlanId,
    'requestStatus': requestStatus,
    'requestedById': requestedById,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'directlyBooked': directlyBooked,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultationSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationSumOrderByAggregateInput({this.rating});

  final _i2.SortOrder? rating;

  @override
  Map<String, dynamic> toJson() => {'rating': rating};
}

class ConsultationOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationOrderByWithAggregationInput({
    this.id,
    this.consultationPlanId,
    this.requestStatus,
    this.requestedById,
    this.requestedAt,
    this.requestNotes,
    this.directlyBooked,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? consultationPlanId;

  final _i2.SortOrder? requestStatus;

  final _i2.SortOrder? requestedById;

  final _i2.SortOrder? requestedAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? requestNotes;

  final _i2.SortOrder? directlyBooked;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>?
  feedbackFromConsultee;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>?
  feedbackFromConsultant;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? rating;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.ConsultationCountOrderByAggregateInput? $count;

  final _i2.ConsultationAvgOrderByAggregateInput? $avg;

  final _i2.ConsultationMaxOrderByAggregateInput? $max;

  final _i2.ConsultationMinOrderByAggregateInput? $min;

  final _i2.ConsultationSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'consultationPlanId': consultationPlanId,
    'requestStatus': requestStatus,
    'requestedById': requestedById,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'directlyBooked': directlyBooked,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_avg': $avg,
    '_max': $max,
    '_min': $min,
    '_sum': $sum,
  };
}

class NestedEnumRequestStatusWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedEnumRequestStatusWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i3.RequestStatus? equals;

  final _i1.PrismaUnion<Iterable<_i3.RequestStatus>, _i3.RequestStatus>? $in;

  final _i1.PrismaUnion<Iterable<_i3.RequestStatus>, _i3.RequestStatus>? notIn;

  final _i1.PrismaUnion<
    _i3.RequestStatus,
    _i2.NestedEnumRequestStatusWithAggregatesFilter
  >?
  not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedEnumRequestStatusFilter? $min;

  final _i2.NestedEnumRequestStatusFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class EnumRequestStatusWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumRequestStatusWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i3.RequestStatus? equals;

  final _i1.PrismaUnion<Iterable<_i3.RequestStatus>, _i3.RequestStatus>? $in;

  final _i1.PrismaUnion<Iterable<_i3.RequestStatus>, _i3.RequestStatus>? notIn;

  final _i1.PrismaUnion<
    _i3.RequestStatus,
    _i2.NestedEnumRequestStatusWithAggregatesFilter
  >?
  not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedEnumRequestStatusFilter? $min;

  final _i2.NestedEnumRequestStatusFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class ConsultationScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.consultationPlanId,
    this.requestStatus,
    this.requestedById,
    this.requestedAt,
    this.requestNotes,
    this.directlyBooked,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
    _i2.ConsultationScalarWhereWithAggregatesInput,
    Iterable<_i2.ConsultationScalarWhereWithAggregatesInput>
  >?
  AND;

  final Iterable<_i2.ConsultationScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<
    _i2.ConsultationScalarWhereWithAggregatesInput,
    Iterable<_i2.ConsultationScalarWhereWithAggregatesInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>?
  consultationPlanId;

  final _i1.PrismaUnion<
    _i2.EnumRequestStatusWithAggregatesFilter,
    _i3.RequestStatus
  >?
  requestStatus;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? requestedById;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>?
  requestedAt;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  requestNotes;

  final _i1.PrismaUnion<_i2.BoolWithAggregatesFilter, bool>? directlyBooked;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  feedbackFromConsultee;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  feedbackFromConsultant;

  final _i1.PrismaUnion<
    _i2.FloatNullableWithAggregatesFilter,
    _i1.PrismaUnion<double, _i1.PrismaNull>
  >?
  rating;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'consultationPlanId': consultationPlanId,
    'requestStatus': requestStatus,
    'requestedById': requestedById,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'directlyBooked': directlyBooked,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultationCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationCountAggregateOutputTypeSelect({
    this.id,
    this.consultationPlanId,
    this.requestStatus,
    this.requestedById,
    this.requestedAt,
    this.requestNotes,
    this.directlyBooked,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  final bool? id;

  final bool? consultationPlanId;

  final bool? requestStatus;

  final bool? requestedById;

  final bool? requestedAt;

  final bool? requestNotes;

  final bool? directlyBooked;

  final bool? feedbackFromConsultee;

  final bool? feedbackFromConsultant;

  final bool? rating;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'consultationPlanId': consultationPlanId,
    'requestStatus': requestStatus,
    'requestedById': requestedById,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'directlyBooked': directlyBooked,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class ConsultationGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationGroupByOutputTypeCountArgs({this.select});

  final _i2.ConsultationCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ConsultationAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationAvgAggregateOutputTypeSelect({this.rating});

  final bool? rating;

  @override
  Map<String, dynamic> toJson() => {'rating': rating};
}

class ConsultationGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationGroupByOutputTypeAvgArgs({this.select});

  final _i2.ConsultationAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ConsultationSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationSumAggregateOutputTypeSelect({this.rating});

  final bool? rating;

  @override
  Map<String, dynamic> toJson() => {'rating': rating};
}

class ConsultationGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationGroupByOutputTypeSumArgs({this.select});

  final _i2.ConsultationSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ConsultationMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationMinAggregateOutputTypeSelect({
    this.id,
    this.consultationPlanId,
    this.requestStatus,
    this.requestedById,
    this.requestedAt,
    this.requestNotes,
    this.directlyBooked,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? consultationPlanId;

  final bool? requestStatus;

  final bool? requestedById;

  final bool? requestedAt;

  final bool? requestNotes;

  final bool? directlyBooked;

  final bool? feedbackFromConsultee;

  final bool? feedbackFromConsultant;

  final bool? rating;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'consultationPlanId': consultationPlanId,
    'requestStatus': requestStatus,
    'requestedById': requestedById,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'directlyBooked': directlyBooked,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultationGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationGroupByOutputTypeMinArgs({this.select});

  final _i2.ConsultationMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ConsultationMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationMaxAggregateOutputTypeSelect({
    this.id,
    this.consultationPlanId,
    this.requestStatus,
    this.requestedById,
    this.requestedAt,
    this.requestNotes,
    this.directlyBooked,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? consultationPlanId;

  final bool? requestStatus;

  final bool? requestedById;

  final bool? requestedAt;

  final bool? requestNotes;

  final bool? directlyBooked;

  final bool? feedbackFromConsultee;

  final bool? feedbackFromConsultant;

  final bool? rating;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'consultationPlanId': consultationPlanId,
    'requestStatus': requestStatus,
    'requestedById': requestedById,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'directlyBooked': directlyBooked,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ConsultationGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationGroupByOutputTypeMaxArgs({this.select});

  final _i2.ConsultationMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ConsultationGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsultationGroupByOutputTypeSelect({
    this.id,
    this.consultationPlanId,
    this.requestStatus,
    this.requestedById,
    this.requestedAt,
    this.requestNotes,
    this.directlyBooked,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? consultationPlanId;

  final bool? requestStatus;

  final bool? requestedById;

  final bool? requestedAt;

  final bool? requestNotes;

  final bool? directlyBooked;

  final bool? feedbackFromConsultee;

  final bool? feedbackFromConsultant;

  final bool? rating;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.ConsultationGroupByOutputTypeCountArgs>?
  $count;

  final _i1.PrismaUnion<bool, _i2.ConsultationGroupByOutputTypeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.ConsultationGroupByOutputTypeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.ConsultationGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.ConsultationGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'consultationPlanId': consultationPlanId,
    'requestStatus': requestStatus,
    'requestedById': requestedById,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'directlyBooked': directlyBooked,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_avg': $avg,
    '_sum': $sum,
    '_min': $min,
    '_max': $max,
  };
}

class AggregateConsultation {
  const AggregateConsultation({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateConsultation.fromJson(Map json) => AggregateConsultation(
    $count: json['_count'] is Map
        ? _i2.ConsultationCountAggregateOutputType.fromJson(json['_count'])
        : null,
    $avg: json['_avg'] is Map
        ? _i2.ConsultationAvgAggregateOutputType.fromJson(json['_avg'])
        : null,
    $sum: json['_sum'] is Map
        ? _i2.ConsultationSumAggregateOutputType.fromJson(json['_sum'])
        : null,
    $min: json['_min'] is Map
        ? _i2.ConsultationMinAggregateOutputType.fromJson(json['_min'])
        : null,
    $max: json['_max'] is Map
        ? _i2.ConsultationMaxAggregateOutputType.fromJson(json['_max'])
        : null,
  );

  final _i2.ConsultationCountAggregateOutputType? $count;

  final _i2.ConsultationAvgAggregateOutputType? $avg;

  final _i2.ConsultationSumAggregateOutputType? $sum;

  final _i2.ConsultationMinAggregateOutputType? $min;

  final _i2.ConsultationMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    '_count': $count?.toJson(),
    '_avg': $avg?.toJson(),
    '_sum': $sum?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class AggregateConsultationCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateConsultationCountArgs({this.select});

  final _i2.ConsultationCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateConsultationAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateConsultationAvgArgs({this.select});

  final _i2.ConsultationAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateConsultationSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateConsultationSumArgs({this.select});

  final _i2.ConsultationSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateConsultationMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateConsultationMinArgs({this.select});

  final _i2.ConsultationMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateConsultationMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateConsultationMaxArgs({this.select});

  final _i2.ConsultationMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateConsultationSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateConsultationSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateConsultationCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateConsultationAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateConsultationSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateConsultationMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateConsultationMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    '_count': $count,
    '_avg': $avg,
    '_sum': $sum,
    '_min': $min,
    '_max': $max,
  };
}

class SubscriptionPlanCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanCreateInput({
    this.id,
    required this.title,
    this.description,
    this.durationInMonths,
    required this.price,
    this.callsPerWeek,
    this.sessionDurationInHours,
    this.videoMeetings,
    this.emailSupport,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.createdAt,
    this.updatedAt,
    required this.consultantProfile,
    this.subscriptions,
  });

  final String? id;

  final String title;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final int? durationInMonths;

  final int price;

  final int? callsPerWeek;

  final double? sessionDurationInHours;

  final int? videoMeetings;

  final _i3.PlanEmailSupport? emailSupport;

  final String? language;

  final String? level;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? prerequisites;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? materialProvided;

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanCreatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ConsultantProfileCreateNestedOneWithoutSubscriptionPlansInput
  consultantProfile;

  final _i2.SubscriptionCreateNestedManyWithoutSubscriptionPlanInput?
  subscriptions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInMonths': durationInMonths,
    'price': price,
    'callsPerWeek': callsPerWeek,
    'sessionDurationInHours': sessionDurationInHours,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultantProfile': consultantProfile,
    'subscriptions': subscriptions,
  };
}

class SubscriptionPlanUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanUncheckedCreateInput({
    this.id,
    required this.title,
    this.description,
    this.durationInMonths,
    required this.price,
    this.callsPerWeek,
    this.sessionDurationInHours,
    this.videoMeetings,
    this.emailSupport,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    required this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.subscriptions,
  });

  final String? id;

  final String title;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final int? durationInMonths;

  final int price;

  final int? callsPerWeek;

  final double? sessionDurationInHours;

  final int? videoMeetings;

  final _i3.PlanEmailSupport? emailSupport;

  final String? language;

  final String? level;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? prerequisites;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? materialProvided;

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanCreatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final String consultantProfileId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.SubscriptionUncheckedCreateNestedManyWithoutSubscriptionPlanInput?
  subscriptions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInMonths': durationInMonths,
    'price': price,
    'callsPerWeek': callsPerWeek,
    'sessionDurationInHours': sessionDurationInHours,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'subscriptions': subscriptions,
  };
}

class SubscriptionPlanCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanCreateManyInput({
    this.id,
    required this.title,
    this.description,
    this.durationInMonths,
    required this.price,
    this.callsPerWeek,
    this.sessionDurationInHours,
    this.videoMeetings,
    this.emailSupport,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    required this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final String title;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final int? durationInMonths;

  final int price;

  final int? callsPerWeek;

  final double? sessionDurationInHours;

  final int? videoMeetings;

  final _i3.PlanEmailSupport? emailSupport;

  final String? language;

  final String? level;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? prerequisites;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? materialProvided;

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanCreatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final String consultantProfileId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInMonths': durationInMonths,
    'price': price,
    'callsPerWeek': callsPerWeek,
    'sessionDurationInHours': sessionDurationInHours,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SubscriptionPlanUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanUpdateInput({
    this.id,
    this.title,
    this.description,
    this.durationInMonths,
    this.price,
    this.callsPerWeek,
    this.sessionDurationInHours,
    this.videoMeetings,
    this.emailSupport,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.createdAt,
    this.updatedAt,
    this.consultantProfile,
    this.subscriptions,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
  durationInMonths;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? price;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? callsPerWeek;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
  sessionDurationInHours;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? videoMeetings;

  final _i1.PrismaUnion<
    _i3.PlanEmailSupport,
    _i2.EnumPlanEmailSupportFieldUpdateOperationsInput
  >?
  emailSupport;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? language;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? level;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  prerequisites;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  materialProvided;

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanUpdatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.ConsultantProfileUpdateOneRequiredWithoutSubscriptionPlansNestedInput?
  consultantProfile;

  final _i2.SubscriptionUpdateManyWithoutSubscriptionPlanNestedInput?
  subscriptions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInMonths': durationInMonths,
    'price': price,
    'callsPerWeek': callsPerWeek,
    'sessionDurationInHours': sessionDurationInHours,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'consultantProfile': consultantProfile,
    'subscriptions': subscriptions,
  };
}

class SubscriptionPlanUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanUncheckedUpdateInput({
    this.id,
    this.title,
    this.description,
    this.durationInMonths,
    this.price,
    this.callsPerWeek,
    this.sessionDurationInHours,
    this.videoMeetings,
    this.emailSupport,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.subscriptions,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
  durationInMonths;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? price;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? callsPerWeek;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
  sessionDurationInHours;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? videoMeetings;

  final _i1.PrismaUnion<
    _i3.PlanEmailSupport,
    _i2.EnumPlanEmailSupportFieldUpdateOperationsInput
  >?
  emailSupport;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? language;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? level;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  prerequisites;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  materialProvided;

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanUpdatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  consultantProfileId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.SubscriptionUncheckedUpdateManyWithoutSubscriptionPlanNestedInput?
  subscriptions;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInMonths': durationInMonths,
    'price': price,
    'callsPerWeek': callsPerWeek,
    'sessionDurationInHours': sessionDurationInHours,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'subscriptions': subscriptions,
  };
}

class SubscriptionPlanUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanUncheckedUpdateManyInput({
    this.id,
    this.title,
    this.description,
    this.durationInMonths,
    this.price,
    this.callsPerWeek,
    this.sessionDurationInHours,
    this.videoMeetings,
    this.emailSupport,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
  durationInMonths;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? price;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? callsPerWeek;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
  sessionDurationInHours;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? videoMeetings;

  final _i1.PrismaUnion<
    _i3.PlanEmailSupport,
    _i2.EnumPlanEmailSupportFieldUpdateOperationsInput
  >?
  emailSupport;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? language;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? level;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  prerequisites;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  materialProvided;

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanUpdatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  consultantProfileId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInMonths': durationInMonths,
    'price': price,
    'callsPerWeek': callsPerWeek,
    'sessionDurationInHours': sessionDurationInHours,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SubscriptionPlanCountAggregateOutputType {
  const SubscriptionPlanCountAggregateOutputType({
    this.id,
    this.title,
    this.description,
    this.durationInMonths,
    this.price,
    this.callsPerWeek,
    this.sessionDurationInHours,
    this.videoMeetings,
    this.emailSupport,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  factory SubscriptionPlanCountAggregateOutputType.fromJson(Map json) =>
      SubscriptionPlanCountAggregateOutputType(
        id: json['id'],
        title: json['title'],
        description: json['description'],
        durationInMonths: json['durationInMonths'],
        price: json['price'],
        callsPerWeek: json['callsPerWeek'],
        sessionDurationInHours: json['sessionDurationInHours'],
        videoMeetings: json['videoMeetings'],
        emailSupport: json['emailSupport'],
        language: json['language'],
        level: json['level'],
        prerequisites: json['prerequisites'],
        materialProvided: json['materialProvided'],
        learningOutcomes: json['learningOutcomes'],
        consultantProfileId: json['consultantProfileId'],
        createdAt: json['createdAt'],
        updatedAt: json['updatedAt'],
        $all: json['_all'],
      );

  final int? id;

  final int? title;

  final int? description;

  final int? durationInMonths;

  final int? price;

  final int? callsPerWeek;

  final int? sessionDurationInHours;

  final int? videoMeetings;

  final int? emailSupport;

  final int? language;

  final int? level;

  final int? prerequisites;

  final int? materialProvided;

  final int? learningOutcomes;

  final int? consultantProfileId;

  final int? createdAt;

  final int? updatedAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInMonths': durationInMonths,
    'price': price,
    'callsPerWeek': callsPerWeek,
    'sessionDurationInHours': sessionDurationInHours,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class SubscriptionPlanAvgAggregateOutputType {
  const SubscriptionPlanAvgAggregateOutputType({
    this.durationInMonths,
    this.price,
    this.callsPerWeek,
    this.sessionDurationInHours,
    this.videoMeetings,
  });

  factory SubscriptionPlanAvgAggregateOutputType.fromJson(Map json) =>
      SubscriptionPlanAvgAggregateOutputType(
        durationInMonths: json['durationInMonths'],
        price: json['price'],
        callsPerWeek: json['callsPerWeek'],
        sessionDurationInHours: json['sessionDurationInHours'],
        videoMeetings: json['videoMeetings'],
      );

  final double? durationInMonths;

  final double? price;

  final double? callsPerWeek;

  final double? sessionDurationInHours;

  final double? videoMeetings;

  Map<String, dynamic> toJson() => {
    'durationInMonths': durationInMonths,
    'price': price,
    'callsPerWeek': callsPerWeek,
    'sessionDurationInHours': sessionDurationInHours,
    'videoMeetings': videoMeetings,
  };
}

class SubscriptionPlanSumAggregateOutputType {
  const SubscriptionPlanSumAggregateOutputType({
    this.durationInMonths,
    this.price,
    this.callsPerWeek,
    this.sessionDurationInHours,
    this.videoMeetings,
  });

  factory SubscriptionPlanSumAggregateOutputType.fromJson(Map json) =>
      SubscriptionPlanSumAggregateOutputType(
        durationInMonths: json['durationInMonths'],
        price: json['price'],
        callsPerWeek: json['callsPerWeek'],
        sessionDurationInHours: json['sessionDurationInHours'],
        videoMeetings: json['videoMeetings'],
      );

  final int? durationInMonths;

  final int? price;

  final int? callsPerWeek;

  final double? sessionDurationInHours;

  final int? videoMeetings;

  Map<String, dynamic> toJson() => {
    'durationInMonths': durationInMonths,
    'price': price,
    'callsPerWeek': callsPerWeek,
    'sessionDurationInHours': sessionDurationInHours,
    'videoMeetings': videoMeetings,
  };
}

class SubscriptionPlanMinAggregateOutputType {
  const SubscriptionPlanMinAggregateOutputType({
    this.id,
    this.title,
    this.description,
    this.durationInMonths,
    this.price,
    this.callsPerWeek,
    this.sessionDurationInHours,
    this.videoMeetings,
    this.emailSupport,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  factory SubscriptionPlanMinAggregateOutputType.fromJson(Map json) =>
      SubscriptionPlanMinAggregateOutputType(
        id: json['id'],
        title: json['title'],
        description: json['description'],
        durationInMonths: json['durationInMonths'],
        price: json['price'],
        callsPerWeek: json['callsPerWeek'],
        sessionDurationInHours: json['sessionDurationInHours'],
        videoMeetings: json['videoMeetings'],
        emailSupport: json['emailSupport'] != null
            ? _i3.PlanEmailSupport.values.firstWhere(
                (e) => e.name == json['emailSupport'],
              )
            : null,
        language: json['language'],
        level: json['level'],
        prerequisites: json['prerequisites'],
        materialProvided: json['materialProvided'],
        consultantProfileId: json['consultantProfileId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final String? title;

  final String? description;

  final int? durationInMonths;

  final int? price;

  final int? callsPerWeek;

  final double? sessionDurationInHours;

  final int? videoMeetings;

  final _i3.PlanEmailSupport? emailSupport;

  final String? language;

  final String? level;

  final String? prerequisites;

  final String? materialProvided;

  final String? consultantProfileId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInMonths': durationInMonths,
    'price': price,
    'callsPerWeek': callsPerWeek,
    'sessionDurationInHours': sessionDurationInHours,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport?.name,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class SubscriptionPlanMaxAggregateOutputType {
  const SubscriptionPlanMaxAggregateOutputType({
    this.id,
    this.title,
    this.description,
    this.durationInMonths,
    this.price,
    this.callsPerWeek,
    this.sessionDurationInHours,
    this.videoMeetings,
    this.emailSupport,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  factory SubscriptionPlanMaxAggregateOutputType.fromJson(Map json) =>
      SubscriptionPlanMaxAggregateOutputType(
        id: json['id'],
        title: json['title'],
        description: json['description'],
        durationInMonths: json['durationInMonths'],
        price: json['price'],
        callsPerWeek: json['callsPerWeek'],
        sessionDurationInHours: json['sessionDurationInHours'],
        videoMeetings: json['videoMeetings'],
        emailSupport: json['emailSupport'] != null
            ? _i3.PlanEmailSupport.values.firstWhere(
                (e) => e.name == json['emailSupport'],
              )
            : null,
        language: json['language'],
        level: json['level'],
        prerequisites: json['prerequisites'],
        materialProvided: json['materialProvided'],
        consultantProfileId: json['consultantProfileId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final String? title;

  final String? description;

  final int? durationInMonths;

  final int? price;

  final int? callsPerWeek;

  final double? sessionDurationInHours;

  final int? videoMeetings;

  final _i3.PlanEmailSupport? emailSupport;

  final String? language;

  final String? level;

  final String? prerequisites;

  final String? materialProvided;

  final String? consultantProfileId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInMonths': durationInMonths,
    'price': price,
    'callsPerWeek': callsPerWeek,
    'sessionDurationInHours': sessionDurationInHours,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport?.name,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class SubscriptionPlanGroupByOutputType {
  const SubscriptionPlanGroupByOutputType({
    this.id,
    this.title,
    this.description,
    this.durationInMonths,
    this.price,
    this.callsPerWeek,
    this.sessionDurationInHours,
    this.videoMeetings,
    this.emailSupport,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory SubscriptionPlanGroupByOutputType.fromJson(Map json) =>
      SubscriptionPlanGroupByOutputType(
        id: json['id'],
        title: json['title'],
        description: json['description'],
        durationInMonths: json['durationInMonths'],
        price: json['price'],
        callsPerWeek: json['callsPerWeek'],
        sessionDurationInHours: json['sessionDurationInHours'],
        videoMeetings: json['videoMeetings'],
        emailSupport: json['emailSupport'] != null
            ? _i3.PlanEmailSupport.values.firstWhere(
                (e) => e.name == json['emailSupport'],
              )
            : null,
        language: json['language'],
        level: json['level'],
        prerequisites: json['prerequisites'],
        materialProvided: json['materialProvided'],
        learningOutcomes: json['learningOutcomes'] is Iterable
            ? (json['learningOutcomes'] as Iterable).whereType<String>()
            : null,
        consultantProfileId: json['consultantProfileId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
        $count: json['_count'] is Map
            ? _i2.SubscriptionPlanCountAggregateOutputType.fromJson(
                json['_count'],
              )
            : null,
        $avg: json['_avg'] is Map
            ? _i2.SubscriptionPlanAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.SubscriptionPlanSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.SubscriptionPlanMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.SubscriptionPlanMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? id;

  final String? title;

  final String? description;

  final int? durationInMonths;

  final int? price;

  final int? callsPerWeek;

  final double? sessionDurationInHours;

  final int? videoMeetings;

  final _i3.PlanEmailSupport? emailSupport;

  final String? language;

  final String? level;

  final String? prerequisites;

  final String? materialProvided;

  final Iterable<String>? learningOutcomes;

  final String? consultantProfileId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.SubscriptionPlanCountAggregateOutputType? $count;

  final _i2.SubscriptionPlanAvgAggregateOutputType? $avg;

  final _i2.SubscriptionPlanSumAggregateOutputType? $sum;

  final _i2.SubscriptionPlanMinAggregateOutputType? $min;

  final _i2.SubscriptionPlanMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInMonths': durationInMonths,
    'price': price,
    'callsPerWeek': callsPerWeek,
    'sessionDurationInHours': sessionDurationInHours,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport?.name,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes?.map((e) => e),
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
    '_count': $count?.toJson(),
    '_avg': $avg?.toJson(),
    '_sum': $sum?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class SubscriptionPlanCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanCountOrderByAggregateInput({
    this.id,
    this.title,
    this.description,
    this.durationInMonths,
    this.price,
    this.callsPerWeek,
    this.sessionDurationInHours,
    this.videoMeetings,
    this.emailSupport,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? title;

  final _i2.SortOrder? description;

  final _i2.SortOrder? durationInMonths;

  final _i2.SortOrder? price;

  final _i2.SortOrder? callsPerWeek;

  final _i2.SortOrder? sessionDurationInHours;

  final _i2.SortOrder? videoMeetings;

  final _i2.SortOrder? emailSupport;

  final _i2.SortOrder? language;

  final _i2.SortOrder? level;

  final _i2.SortOrder? prerequisites;

  final _i2.SortOrder? materialProvided;

  final _i2.SortOrder? learningOutcomes;

  final _i2.SortOrder? consultantProfileId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInMonths': durationInMonths,
    'price': price,
    'callsPerWeek': callsPerWeek,
    'sessionDurationInHours': sessionDurationInHours,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SubscriptionPlanAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanAvgOrderByAggregateInput({
    this.durationInMonths,
    this.price,
    this.callsPerWeek,
    this.sessionDurationInHours,
    this.videoMeetings,
  });

  final _i2.SortOrder? durationInMonths;

  final _i2.SortOrder? price;

  final _i2.SortOrder? callsPerWeek;

  final _i2.SortOrder? sessionDurationInHours;

  final _i2.SortOrder? videoMeetings;

  @override
  Map<String, dynamic> toJson() => {
    'durationInMonths': durationInMonths,
    'price': price,
    'callsPerWeek': callsPerWeek,
    'sessionDurationInHours': sessionDurationInHours,
    'videoMeetings': videoMeetings,
  };
}

class SubscriptionPlanMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanMaxOrderByAggregateInput({
    this.id,
    this.title,
    this.description,
    this.durationInMonths,
    this.price,
    this.callsPerWeek,
    this.sessionDurationInHours,
    this.videoMeetings,
    this.emailSupport,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? title;

  final _i2.SortOrder? description;

  final _i2.SortOrder? durationInMonths;

  final _i2.SortOrder? price;

  final _i2.SortOrder? callsPerWeek;

  final _i2.SortOrder? sessionDurationInHours;

  final _i2.SortOrder? videoMeetings;

  final _i2.SortOrder? emailSupport;

  final _i2.SortOrder? language;

  final _i2.SortOrder? level;

  final _i2.SortOrder? prerequisites;

  final _i2.SortOrder? materialProvided;

  final _i2.SortOrder? consultantProfileId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInMonths': durationInMonths,
    'price': price,
    'callsPerWeek': callsPerWeek,
    'sessionDurationInHours': sessionDurationInHours,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SubscriptionPlanMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanMinOrderByAggregateInput({
    this.id,
    this.title,
    this.description,
    this.durationInMonths,
    this.price,
    this.callsPerWeek,
    this.sessionDurationInHours,
    this.videoMeetings,
    this.emailSupport,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? title;

  final _i2.SortOrder? description;

  final _i2.SortOrder? durationInMonths;

  final _i2.SortOrder? price;

  final _i2.SortOrder? callsPerWeek;

  final _i2.SortOrder? sessionDurationInHours;

  final _i2.SortOrder? videoMeetings;

  final _i2.SortOrder? emailSupport;

  final _i2.SortOrder? language;

  final _i2.SortOrder? level;

  final _i2.SortOrder? prerequisites;

  final _i2.SortOrder? materialProvided;

  final _i2.SortOrder? consultantProfileId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInMonths': durationInMonths,
    'price': price,
    'callsPerWeek': callsPerWeek,
    'sessionDurationInHours': sessionDurationInHours,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SubscriptionPlanSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanSumOrderByAggregateInput({
    this.durationInMonths,
    this.price,
    this.callsPerWeek,
    this.sessionDurationInHours,
    this.videoMeetings,
  });

  final _i2.SortOrder? durationInMonths;

  final _i2.SortOrder? price;

  final _i2.SortOrder? callsPerWeek;

  final _i2.SortOrder? sessionDurationInHours;

  final _i2.SortOrder? videoMeetings;

  @override
  Map<String, dynamic> toJson() => {
    'durationInMonths': durationInMonths,
    'price': price,
    'callsPerWeek': callsPerWeek,
    'sessionDurationInHours': sessionDurationInHours,
    'videoMeetings': videoMeetings,
  };
}

class SubscriptionPlanOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanOrderByWithAggregationInput({
    this.id,
    this.title,
    this.description,
    this.durationInMonths,
    this.price,
    this.callsPerWeek,
    this.sessionDurationInHours,
    this.videoMeetings,
    this.emailSupport,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? title;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? description;

  final _i2.SortOrder? durationInMonths;

  final _i2.SortOrder? price;

  final _i2.SortOrder? callsPerWeek;

  final _i2.SortOrder? sessionDurationInHours;

  final _i2.SortOrder? videoMeetings;

  final _i2.SortOrder? emailSupport;

  final _i2.SortOrder? language;

  final _i2.SortOrder? level;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? prerequisites;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? materialProvided;

  final _i2.SortOrder? learningOutcomes;

  final _i2.SortOrder? consultantProfileId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.SubscriptionPlanCountOrderByAggregateInput? $count;

  final _i2.SubscriptionPlanAvgOrderByAggregateInput? $avg;

  final _i2.SubscriptionPlanMaxOrderByAggregateInput? $max;

  final _i2.SubscriptionPlanMinOrderByAggregateInput? $min;

  final _i2.SubscriptionPlanSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInMonths': durationInMonths,
    'price': price,
    'callsPerWeek': callsPerWeek,
    'sessionDurationInHours': sessionDurationInHours,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_avg': $avg,
    '_max': $max,
    '_min': $min,
    '_sum': $sum,
  };
}

class NestedEnumPlanEmailSupportWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedEnumPlanEmailSupportWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i3.PlanEmailSupport? equals;

  final _i1.PrismaUnion<Iterable<_i3.PlanEmailSupport>, _i3.PlanEmailSupport>?
  $in;

  final _i1.PrismaUnion<Iterable<_i3.PlanEmailSupport>, _i3.PlanEmailSupport>?
  notIn;

  final _i1.PrismaUnion<
    _i3.PlanEmailSupport,
    _i2.NestedEnumPlanEmailSupportWithAggregatesFilter
  >?
  not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedEnumPlanEmailSupportFilter? $min;

  final _i2.NestedEnumPlanEmailSupportFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class EnumPlanEmailSupportWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumPlanEmailSupportWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i3.PlanEmailSupport? equals;

  final _i1.PrismaUnion<Iterable<_i3.PlanEmailSupport>, _i3.PlanEmailSupport>?
  $in;

  final _i1.PrismaUnion<Iterable<_i3.PlanEmailSupport>, _i3.PlanEmailSupport>?
  notIn;

  final _i1.PrismaUnion<
    _i3.PlanEmailSupport,
    _i2.NestedEnumPlanEmailSupportWithAggregatesFilter
  >?
  not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedEnumPlanEmailSupportFilter? $min;

  final _i2.NestedEnumPlanEmailSupportFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class SubscriptionPlanScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.title,
    this.description,
    this.durationInMonths,
    this.price,
    this.callsPerWeek,
    this.sessionDurationInHours,
    this.videoMeetings,
    this.emailSupport,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanScalarWhereWithAggregatesInput,
    Iterable<_i2.SubscriptionPlanScalarWhereWithAggregatesInput>
  >?
  AND;

  final Iterable<_i2.SubscriptionPlanScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<
    _i2.SubscriptionPlanScalarWhereWithAggregatesInput,
    Iterable<_i2.SubscriptionPlanScalarWhereWithAggregatesInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? title;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  description;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? durationInMonths;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? price;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? callsPerWeek;

  final _i1.PrismaUnion<_i2.FloatWithAggregatesFilter, double>?
  sessionDurationInHours;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? videoMeetings;

  final _i1.PrismaUnion<
    _i2.EnumPlanEmailSupportWithAggregatesFilter,
    _i3.PlanEmailSupport
  >?
  emailSupport;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? language;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? level;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  prerequisites;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  materialProvided;

  final _i2.StringNullableListFilter? learningOutcomes;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>?
  consultantProfileId;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'title': title,
    'description': description,
    'durationInMonths': durationInMonths,
    'price': price,
    'callsPerWeek': callsPerWeek,
    'sessionDurationInHours': sessionDurationInHours,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SubscriptionPlanCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanCountAggregateOutputTypeSelect({
    this.id,
    this.title,
    this.description,
    this.durationInMonths,
    this.price,
    this.callsPerWeek,
    this.sessionDurationInHours,
    this.videoMeetings,
    this.emailSupport,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  final bool? id;

  final bool? title;

  final bool? description;

  final bool? durationInMonths;

  final bool? price;

  final bool? callsPerWeek;

  final bool? sessionDurationInHours;

  final bool? videoMeetings;

  final bool? emailSupport;

  final bool? language;

  final bool? level;

  final bool? prerequisites;

  final bool? materialProvided;

  final bool? learningOutcomes;

  final bool? consultantProfileId;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInMonths': durationInMonths,
    'price': price,
    'callsPerWeek': callsPerWeek,
    'sessionDurationInHours': sessionDurationInHours,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class SubscriptionPlanGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanGroupByOutputTypeCountArgs({this.select});

  final _i2.SubscriptionPlanCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SubscriptionPlanAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanAvgAggregateOutputTypeSelect({
    this.durationInMonths,
    this.price,
    this.callsPerWeek,
    this.sessionDurationInHours,
    this.videoMeetings,
  });

  final bool? durationInMonths;

  final bool? price;

  final bool? callsPerWeek;

  final bool? sessionDurationInHours;

  final bool? videoMeetings;

  @override
  Map<String, dynamic> toJson() => {
    'durationInMonths': durationInMonths,
    'price': price,
    'callsPerWeek': callsPerWeek,
    'sessionDurationInHours': sessionDurationInHours,
    'videoMeetings': videoMeetings,
  };
}

class SubscriptionPlanGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanGroupByOutputTypeAvgArgs({this.select});

  final _i2.SubscriptionPlanAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SubscriptionPlanSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanSumAggregateOutputTypeSelect({
    this.durationInMonths,
    this.price,
    this.callsPerWeek,
    this.sessionDurationInHours,
    this.videoMeetings,
  });

  final bool? durationInMonths;

  final bool? price;

  final bool? callsPerWeek;

  final bool? sessionDurationInHours;

  final bool? videoMeetings;

  @override
  Map<String, dynamic> toJson() => {
    'durationInMonths': durationInMonths,
    'price': price,
    'callsPerWeek': callsPerWeek,
    'sessionDurationInHours': sessionDurationInHours,
    'videoMeetings': videoMeetings,
  };
}

class SubscriptionPlanGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanGroupByOutputTypeSumArgs({this.select});

  final _i2.SubscriptionPlanSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SubscriptionPlanMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanMinAggregateOutputTypeSelect({
    this.id,
    this.title,
    this.description,
    this.durationInMonths,
    this.price,
    this.callsPerWeek,
    this.sessionDurationInHours,
    this.videoMeetings,
    this.emailSupport,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? title;

  final bool? description;

  final bool? durationInMonths;

  final bool? price;

  final bool? callsPerWeek;

  final bool? sessionDurationInHours;

  final bool? videoMeetings;

  final bool? emailSupport;

  final bool? language;

  final bool? level;

  final bool? prerequisites;

  final bool? materialProvided;

  final bool? consultantProfileId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInMonths': durationInMonths,
    'price': price,
    'callsPerWeek': callsPerWeek,
    'sessionDurationInHours': sessionDurationInHours,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SubscriptionPlanGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanGroupByOutputTypeMinArgs({this.select});

  final _i2.SubscriptionPlanMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SubscriptionPlanMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanMaxAggregateOutputTypeSelect({
    this.id,
    this.title,
    this.description,
    this.durationInMonths,
    this.price,
    this.callsPerWeek,
    this.sessionDurationInHours,
    this.videoMeetings,
    this.emailSupport,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? title;

  final bool? description;

  final bool? durationInMonths;

  final bool? price;

  final bool? callsPerWeek;

  final bool? sessionDurationInHours;

  final bool? videoMeetings;

  final bool? emailSupport;

  final bool? language;

  final bool? level;

  final bool? prerequisites;

  final bool? materialProvided;

  final bool? consultantProfileId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInMonths': durationInMonths,
    'price': price,
    'callsPerWeek': callsPerWeek,
    'sessionDurationInHours': sessionDurationInHours,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SubscriptionPlanGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanGroupByOutputTypeMaxArgs({this.select});

  final _i2.SubscriptionPlanMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SubscriptionPlanGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionPlanGroupByOutputTypeSelect({
    this.id,
    this.title,
    this.description,
    this.durationInMonths,
    this.price,
    this.callsPerWeek,
    this.sessionDurationInHours,
    this.videoMeetings,
    this.emailSupport,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? title;

  final bool? description;

  final bool? durationInMonths;

  final bool? price;

  final bool? callsPerWeek;

  final bool? sessionDurationInHours;

  final bool? videoMeetings;

  final bool? emailSupport;

  final bool? language;

  final bool? level;

  final bool? prerequisites;

  final bool? materialProvided;

  final bool? learningOutcomes;

  final bool? consultantProfileId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.SubscriptionPlanGroupByOutputTypeCountArgs>?
  $count;

  final _i1.PrismaUnion<bool, _i2.SubscriptionPlanGroupByOutputTypeAvgArgs>?
  $avg;

  final _i1.PrismaUnion<bool, _i2.SubscriptionPlanGroupByOutputTypeSumArgs>?
  $sum;

  final _i1.PrismaUnion<bool, _i2.SubscriptionPlanGroupByOutputTypeMinArgs>?
  $min;

  final _i1.PrismaUnion<bool, _i2.SubscriptionPlanGroupByOutputTypeMaxArgs>?
  $max;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'durationInMonths': durationInMonths,
    'price': price,
    'callsPerWeek': callsPerWeek,
    'sessionDurationInHours': sessionDurationInHours,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_avg': $avg,
    '_sum': $sum,
    '_min': $min,
    '_max': $max,
  };
}

class AggregateSubscriptionPlan {
  const AggregateSubscriptionPlan({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateSubscriptionPlan.fromJson(Map json) =>
      AggregateSubscriptionPlan(
        $count: json['_count'] is Map
            ? _i2.SubscriptionPlanCountAggregateOutputType.fromJson(
                json['_count'],
              )
            : null,
        $avg: json['_avg'] is Map
            ? _i2.SubscriptionPlanAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.SubscriptionPlanSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.SubscriptionPlanMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.SubscriptionPlanMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.SubscriptionPlanCountAggregateOutputType? $count;

  final _i2.SubscriptionPlanAvgAggregateOutputType? $avg;

  final _i2.SubscriptionPlanSumAggregateOutputType? $sum;

  final _i2.SubscriptionPlanMinAggregateOutputType? $min;

  final _i2.SubscriptionPlanMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    '_count': $count?.toJson(),
    '_avg': $avg?.toJson(),
    '_sum': $sum?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class AggregateSubscriptionPlanCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSubscriptionPlanCountArgs({this.select});

  final _i2.SubscriptionPlanCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateSubscriptionPlanAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSubscriptionPlanAvgArgs({this.select});

  final _i2.SubscriptionPlanAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateSubscriptionPlanSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSubscriptionPlanSumArgs({this.select});

  final _i2.SubscriptionPlanSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateSubscriptionPlanMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSubscriptionPlanMinArgs({this.select});

  final _i2.SubscriptionPlanMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateSubscriptionPlanMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSubscriptionPlanMaxArgs({this.select});

  final _i2.SubscriptionPlanMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateSubscriptionPlanSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSubscriptionPlanSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateSubscriptionPlanCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateSubscriptionPlanAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateSubscriptionPlanSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateSubscriptionPlanMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateSubscriptionPlanMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    '_count': $count,
    '_avg': $avg,
    '_sum': $sum,
    '_min': $min,
    '_max': $max,
  };
}

class SubscriptionCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionCreateInput({
    this.id,
    this.startDate,
    required this.endDate,
    this.requestStatus,
    this.requestedAt,
    this.requestNotes,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.createdAt,
    this.updatedAt,
    required this.requestedBy,
    required this.subscriptionPlan,
    this.appointments,
  });

  final String? id;

  final DateTime? startDate;

  final DateTime endDate;

  final _i3.RequestStatus? requestStatus;

  final DateTime? requestedAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? requestNotes;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackFromConsultee;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackFromConsultant;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? rating;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ConsulteeProfileCreateNestedOneWithoutSubscriptionRequestsInput
  requestedBy;

  final _i2.SubscriptionPlanCreateNestedOneWithoutSubscriptionsInput
  subscriptionPlan;

  final _i2.AppointmentCreateNestedManyWithoutSubscriptionInput? appointments;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'requestStatus': requestStatus,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'requestedBy': requestedBy,
    'subscriptionPlan': subscriptionPlan,
    'appointments': appointments,
  };
}

class SubscriptionUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionUncheckedCreateInput({
    this.id,
    this.startDate,
    required this.endDate,
    this.requestStatus,
    required this.requestedById,
    this.requestedAt,
    this.requestNotes,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    required this.subscriptionPlanId,
    this.createdAt,
    this.updatedAt,
    this.appointments,
  });

  final String? id;

  final DateTime? startDate;

  final DateTime endDate;

  final _i3.RequestStatus? requestStatus;

  final String requestedById;

  final DateTime? requestedAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? requestNotes;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackFromConsultee;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackFromConsultant;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? rating;

  final String subscriptionPlanId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.AppointmentUncheckedCreateNestedManyWithoutSubscriptionInput?
  appointments;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'requestStatus': requestStatus,
    'requestedById': requestedById,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'subscriptionPlanId': subscriptionPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'appointments': appointments,
  };
}

class SubscriptionCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionCreateManyInput({
    this.id,
    this.startDate,
    required this.endDate,
    this.requestStatus,
    required this.requestedById,
    this.requestedAt,
    this.requestNotes,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    required this.subscriptionPlanId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final DateTime? startDate;

  final DateTime endDate;

  final _i3.RequestStatus? requestStatus;

  final String requestedById;

  final DateTime? requestedAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? requestNotes;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackFromConsultee;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackFromConsultant;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? rating;

  final String subscriptionPlanId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'requestStatus': requestStatus,
    'requestedById': requestedById,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'subscriptionPlanId': subscriptionPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SubscriptionUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionUpdateInput({
    this.id,
    this.startDate,
    this.endDate,
    this.requestStatus,
    this.requestedAt,
    this.requestNotes,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.createdAt,
    this.updatedAt,
    this.requestedBy,
    this.subscriptionPlan,
    this.appointments,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  startDate;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  endDate;

  final _i1.PrismaUnion<
    _i3.RequestStatus,
    _i2.EnumRequestStatusFieldUpdateOperationsInput
  >?
  requestStatus;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  requestedAt;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  requestNotes;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackFromConsultee;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackFromConsultant;

  final _i1.PrismaUnion<
    double,
    _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  rating;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.ConsulteeProfileUpdateOneRequiredWithoutSubscriptionRequestsNestedInput?
  requestedBy;

  final _i2.SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInput?
  subscriptionPlan;

  final _i2.AppointmentUpdateManyWithoutSubscriptionNestedInput? appointments;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'requestStatus': requestStatus,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'requestedBy': requestedBy,
    'subscriptionPlan': subscriptionPlan,
    'appointments': appointments,
  };
}

class SubscriptionUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionUncheckedUpdateInput({
    this.id,
    this.startDate,
    this.endDate,
    this.requestStatus,
    this.requestedById,
    this.requestedAt,
    this.requestNotes,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.subscriptionPlanId,
    this.createdAt,
    this.updatedAt,
    this.appointments,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  startDate;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  endDate;

  final _i1.PrismaUnion<
    _i3.RequestStatus,
    _i2.EnumRequestStatusFieldUpdateOperationsInput
  >?
  requestStatus;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  requestedById;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  requestedAt;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  requestNotes;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackFromConsultee;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackFromConsultant;

  final _i1.PrismaUnion<
    double,
    _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  rating;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  subscriptionPlanId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.AppointmentUncheckedUpdateManyWithoutSubscriptionNestedInput?
  appointments;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'requestStatus': requestStatus,
    'requestedById': requestedById,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'subscriptionPlanId': subscriptionPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'appointments': appointments,
  };
}

class SubscriptionUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionUncheckedUpdateManyInput({
    this.id,
    this.startDate,
    this.endDate,
    this.requestStatus,
    this.requestedById,
    this.requestedAt,
    this.requestNotes,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.subscriptionPlanId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  startDate;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  endDate;

  final _i1.PrismaUnion<
    _i3.RequestStatus,
    _i2.EnumRequestStatusFieldUpdateOperationsInput
  >?
  requestStatus;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  requestedById;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  requestedAt;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  requestNotes;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackFromConsultee;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackFromConsultant;

  final _i1.PrismaUnion<
    double,
    _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput, _i1.PrismaNull>
  >?
  rating;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  subscriptionPlanId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'requestStatus': requestStatus,
    'requestedById': requestedById,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'subscriptionPlanId': subscriptionPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SubscriptionCountAggregateOutputType {
  const SubscriptionCountAggregateOutputType({
    this.id,
    this.startDate,
    this.endDate,
    this.requestStatus,
    this.requestedById,
    this.requestedAt,
    this.requestNotes,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.subscriptionPlanId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  factory SubscriptionCountAggregateOutputType.fromJson(Map json) =>
      SubscriptionCountAggregateOutputType(
        id: json['id'],
        startDate: json['startDate'],
        endDate: json['endDate'],
        requestStatus: json['requestStatus'],
        requestedById: json['requestedById'],
        requestedAt: json['requestedAt'],
        requestNotes: json['requestNotes'],
        feedbackFromConsultee: json['feedbackFromConsultee'],
        feedbackFromConsultant: json['feedbackFromConsultant'],
        rating: json['rating'],
        subscriptionPlanId: json['subscriptionPlanId'],
        createdAt: json['createdAt'],
        updatedAt: json['updatedAt'],
        $all: json['_all'],
      );

  final int? id;

  final int? startDate;

  final int? endDate;

  final int? requestStatus;

  final int? requestedById;

  final int? requestedAt;

  final int? requestNotes;

  final int? feedbackFromConsultee;

  final int? feedbackFromConsultant;

  final int? rating;

  final int? subscriptionPlanId;

  final int? createdAt;

  final int? updatedAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'requestStatus': requestStatus,
    'requestedById': requestedById,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'subscriptionPlanId': subscriptionPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class SubscriptionAvgAggregateOutputType {
  const SubscriptionAvgAggregateOutputType({this.rating});

  factory SubscriptionAvgAggregateOutputType.fromJson(Map json) =>
      SubscriptionAvgAggregateOutputType(rating: json['rating']);

  final double? rating;

  Map<String, dynamic> toJson() => {'rating': rating};
}

class SubscriptionSumAggregateOutputType {
  const SubscriptionSumAggregateOutputType({this.rating});

  factory SubscriptionSumAggregateOutputType.fromJson(Map json) =>
      SubscriptionSumAggregateOutputType(rating: json['rating']);

  final double? rating;

  Map<String, dynamic> toJson() => {'rating': rating};
}

class SubscriptionMinAggregateOutputType {
  const SubscriptionMinAggregateOutputType({
    this.id,
    this.startDate,
    this.endDate,
    this.requestStatus,
    this.requestedById,
    this.requestedAt,
    this.requestNotes,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.subscriptionPlanId,
    this.createdAt,
    this.updatedAt,
  });

  factory SubscriptionMinAggregateOutputType.fromJson(Map json) =>
      SubscriptionMinAggregateOutputType(
        id: json['id'],
        startDate: switch (json['startDate']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['startDate'],
        },
        endDate: switch (json['endDate']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['endDate'],
        },
        requestStatus: json['requestStatus'] != null
            ? _i3.RequestStatus.values.firstWhere(
                (e) => e.name == json['requestStatus'],
              )
            : null,
        requestedById: json['requestedById'],
        requestedAt: switch (json['requestedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['requestedAt'],
        },
        requestNotes: json['requestNotes'],
        feedbackFromConsultee: json['feedbackFromConsultee'],
        feedbackFromConsultant: json['feedbackFromConsultant'],
        rating: json['rating'],
        subscriptionPlanId: json['subscriptionPlanId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final DateTime? startDate;

  final DateTime? endDate;

  final _i3.RequestStatus? requestStatus;

  final String? requestedById;

  final DateTime? requestedAt;

  final String? requestNotes;

  final String? feedbackFromConsultee;

  final String? feedbackFromConsultant;

  final double? rating;

  final String? subscriptionPlanId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate?.toIso8601String(),
    'endDate': endDate?.toIso8601String(),
    'requestStatus': requestStatus?.name,
    'requestedById': requestedById,
    'requestedAt': requestedAt?.toIso8601String(),
    'requestNotes': requestNotes,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'subscriptionPlanId': subscriptionPlanId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class SubscriptionMaxAggregateOutputType {
  const SubscriptionMaxAggregateOutputType({
    this.id,
    this.startDate,
    this.endDate,
    this.requestStatus,
    this.requestedById,
    this.requestedAt,
    this.requestNotes,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.subscriptionPlanId,
    this.createdAt,
    this.updatedAt,
  });

  factory SubscriptionMaxAggregateOutputType.fromJson(Map json) =>
      SubscriptionMaxAggregateOutputType(
        id: json['id'],
        startDate: switch (json['startDate']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['startDate'],
        },
        endDate: switch (json['endDate']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['endDate'],
        },
        requestStatus: json['requestStatus'] != null
            ? _i3.RequestStatus.values.firstWhere(
                (e) => e.name == json['requestStatus'],
              )
            : null,
        requestedById: json['requestedById'],
        requestedAt: switch (json['requestedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['requestedAt'],
        },
        requestNotes: json['requestNotes'],
        feedbackFromConsultee: json['feedbackFromConsultee'],
        feedbackFromConsultant: json['feedbackFromConsultant'],
        rating: json['rating'],
        subscriptionPlanId: json['subscriptionPlanId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final DateTime? startDate;

  final DateTime? endDate;

  final _i3.RequestStatus? requestStatus;

  final String? requestedById;

  final DateTime? requestedAt;

  final String? requestNotes;

  final String? feedbackFromConsultee;

  final String? feedbackFromConsultant;

  final double? rating;

  final String? subscriptionPlanId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate?.toIso8601String(),
    'endDate': endDate?.toIso8601String(),
    'requestStatus': requestStatus?.name,
    'requestedById': requestedById,
    'requestedAt': requestedAt?.toIso8601String(),
    'requestNotes': requestNotes,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'subscriptionPlanId': subscriptionPlanId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class SubscriptionGroupByOutputType {
  const SubscriptionGroupByOutputType({
    this.id,
    this.startDate,
    this.endDate,
    this.requestStatus,
    this.requestedById,
    this.requestedAt,
    this.requestNotes,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.subscriptionPlanId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory SubscriptionGroupByOutputType.fromJson(Map json) =>
      SubscriptionGroupByOutputType(
        id: json['id'],
        startDate: switch (json['startDate']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['startDate'],
        },
        endDate: switch (json['endDate']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['endDate'],
        },
        requestStatus: json['requestStatus'] != null
            ? _i3.RequestStatus.values.firstWhere(
                (e) => e.name == json['requestStatus'],
              )
            : null,
        requestedById: json['requestedById'],
        requestedAt: switch (json['requestedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['requestedAt'],
        },
        requestNotes: json['requestNotes'],
        feedbackFromConsultee: json['feedbackFromConsultee'],
        feedbackFromConsultant: json['feedbackFromConsultant'],
        rating: json['rating'],
        subscriptionPlanId: json['subscriptionPlanId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
        $count: json['_count'] is Map
            ? _i2.SubscriptionCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.SubscriptionAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.SubscriptionSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.SubscriptionMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.SubscriptionMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? id;

  final DateTime? startDate;

  final DateTime? endDate;

  final _i3.RequestStatus? requestStatus;

  final String? requestedById;

  final DateTime? requestedAt;

  final String? requestNotes;

  final String? feedbackFromConsultee;

  final String? feedbackFromConsultant;

  final double? rating;

  final String? subscriptionPlanId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.SubscriptionCountAggregateOutputType? $count;

  final _i2.SubscriptionAvgAggregateOutputType? $avg;

  final _i2.SubscriptionSumAggregateOutputType? $sum;

  final _i2.SubscriptionMinAggregateOutputType? $min;

  final _i2.SubscriptionMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate?.toIso8601String(),
    'endDate': endDate?.toIso8601String(),
    'requestStatus': requestStatus?.name,
    'requestedById': requestedById,
    'requestedAt': requestedAt?.toIso8601String(),
    'requestNotes': requestNotes,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'subscriptionPlanId': subscriptionPlanId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
    '_count': $count?.toJson(),
    '_avg': $avg?.toJson(),
    '_sum': $sum?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class SubscriptionCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionCountOrderByAggregateInput({
    this.id,
    this.startDate,
    this.endDate,
    this.requestStatus,
    this.requestedById,
    this.requestedAt,
    this.requestNotes,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.subscriptionPlanId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? startDate;

  final _i2.SortOrder? endDate;

  final _i2.SortOrder? requestStatus;

  final _i2.SortOrder? requestedById;

  final _i2.SortOrder? requestedAt;

  final _i2.SortOrder? requestNotes;

  final _i2.SortOrder? feedbackFromConsultee;

  final _i2.SortOrder? feedbackFromConsultant;

  final _i2.SortOrder? rating;

  final _i2.SortOrder? subscriptionPlanId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'requestStatus': requestStatus,
    'requestedById': requestedById,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'subscriptionPlanId': subscriptionPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SubscriptionAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionAvgOrderByAggregateInput({this.rating});

  final _i2.SortOrder? rating;

  @override
  Map<String, dynamic> toJson() => {'rating': rating};
}

class SubscriptionMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionMaxOrderByAggregateInput({
    this.id,
    this.startDate,
    this.endDate,
    this.requestStatus,
    this.requestedById,
    this.requestedAt,
    this.requestNotes,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.subscriptionPlanId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? startDate;

  final _i2.SortOrder? endDate;

  final _i2.SortOrder? requestStatus;

  final _i2.SortOrder? requestedById;

  final _i2.SortOrder? requestedAt;

  final _i2.SortOrder? requestNotes;

  final _i2.SortOrder? feedbackFromConsultee;

  final _i2.SortOrder? feedbackFromConsultant;

  final _i2.SortOrder? rating;

  final _i2.SortOrder? subscriptionPlanId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'requestStatus': requestStatus,
    'requestedById': requestedById,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'subscriptionPlanId': subscriptionPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SubscriptionMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionMinOrderByAggregateInput({
    this.id,
    this.startDate,
    this.endDate,
    this.requestStatus,
    this.requestedById,
    this.requestedAt,
    this.requestNotes,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.subscriptionPlanId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? startDate;

  final _i2.SortOrder? endDate;

  final _i2.SortOrder? requestStatus;

  final _i2.SortOrder? requestedById;

  final _i2.SortOrder? requestedAt;

  final _i2.SortOrder? requestNotes;

  final _i2.SortOrder? feedbackFromConsultee;

  final _i2.SortOrder? feedbackFromConsultant;

  final _i2.SortOrder? rating;

  final _i2.SortOrder? subscriptionPlanId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'requestStatus': requestStatus,
    'requestedById': requestedById,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'subscriptionPlanId': subscriptionPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SubscriptionSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionSumOrderByAggregateInput({this.rating});

  final _i2.SortOrder? rating;

  @override
  Map<String, dynamic> toJson() => {'rating': rating};
}

class SubscriptionOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionOrderByWithAggregationInput({
    this.id,
    this.startDate,
    this.endDate,
    this.requestStatus,
    this.requestedById,
    this.requestedAt,
    this.requestNotes,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.subscriptionPlanId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? startDate;

  final _i2.SortOrder? endDate;

  final _i2.SortOrder? requestStatus;

  final _i2.SortOrder? requestedById;

  final _i2.SortOrder? requestedAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? requestNotes;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>?
  feedbackFromConsultee;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>?
  feedbackFromConsultant;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? rating;

  final _i2.SortOrder? subscriptionPlanId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.SubscriptionCountOrderByAggregateInput? $count;

  final _i2.SubscriptionAvgOrderByAggregateInput? $avg;

  final _i2.SubscriptionMaxOrderByAggregateInput? $max;

  final _i2.SubscriptionMinOrderByAggregateInput? $min;

  final _i2.SubscriptionSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'requestStatus': requestStatus,
    'requestedById': requestedById,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'subscriptionPlanId': subscriptionPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_avg': $avg,
    '_max': $max,
    '_min': $min,
    '_sum': $sum,
  };
}

class SubscriptionScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.startDate,
    this.endDate,
    this.requestStatus,
    this.requestedById,
    this.requestedAt,
    this.requestNotes,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.subscriptionPlanId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
    _i2.SubscriptionScalarWhereWithAggregatesInput,
    Iterable<_i2.SubscriptionScalarWhereWithAggregatesInput>
  >?
  AND;

  final Iterable<_i2.SubscriptionScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<
    _i2.SubscriptionScalarWhereWithAggregatesInput,
    Iterable<_i2.SubscriptionScalarWhereWithAggregatesInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? id;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? startDate;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? endDate;

  final _i1.PrismaUnion<
    _i2.EnumRequestStatusWithAggregatesFilter,
    _i3.RequestStatus
  >?
  requestStatus;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? requestedById;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>?
  requestedAt;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  requestNotes;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  feedbackFromConsultee;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  feedbackFromConsultant;

  final _i1.PrismaUnion<
    _i2.FloatNullableWithAggregatesFilter,
    _i1.PrismaUnion<double, _i1.PrismaNull>
  >?
  rating;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>?
  subscriptionPlanId;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'requestStatus': requestStatus,
    'requestedById': requestedById,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'subscriptionPlanId': subscriptionPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SubscriptionCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionCountAggregateOutputTypeSelect({
    this.id,
    this.startDate,
    this.endDate,
    this.requestStatus,
    this.requestedById,
    this.requestedAt,
    this.requestNotes,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.subscriptionPlanId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  final bool? id;

  final bool? startDate;

  final bool? endDate;

  final bool? requestStatus;

  final bool? requestedById;

  final bool? requestedAt;

  final bool? requestNotes;

  final bool? feedbackFromConsultee;

  final bool? feedbackFromConsultant;

  final bool? rating;

  final bool? subscriptionPlanId;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'requestStatus': requestStatus,
    'requestedById': requestedById,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'subscriptionPlanId': subscriptionPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class SubscriptionGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionGroupByOutputTypeCountArgs({this.select});

  final _i2.SubscriptionCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SubscriptionAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionAvgAggregateOutputTypeSelect({this.rating});

  final bool? rating;

  @override
  Map<String, dynamic> toJson() => {'rating': rating};
}

class SubscriptionGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionGroupByOutputTypeAvgArgs({this.select});

  final _i2.SubscriptionAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SubscriptionSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionSumAggregateOutputTypeSelect({this.rating});

  final bool? rating;

  @override
  Map<String, dynamic> toJson() => {'rating': rating};
}

class SubscriptionGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionGroupByOutputTypeSumArgs({this.select});

  final _i2.SubscriptionSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SubscriptionMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionMinAggregateOutputTypeSelect({
    this.id,
    this.startDate,
    this.endDate,
    this.requestStatus,
    this.requestedById,
    this.requestedAt,
    this.requestNotes,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.subscriptionPlanId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? startDate;

  final bool? endDate;

  final bool? requestStatus;

  final bool? requestedById;

  final bool? requestedAt;

  final bool? requestNotes;

  final bool? feedbackFromConsultee;

  final bool? feedbackFromConsultant;

  final bool? rating;

  final bool? subscriptionPlanId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'requestStatus': requestStatus,
    'requestedById': requestedById,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'subscriptionPlanId': subscriptionPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SubscriptionGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionGroupByOutputTypeMinArgs({this.select});

  final _i2.SubscriptionMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SubscriptionMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionMaxAggregateOutputTypeSelect({
    this.id,
    this.startDate,
    this.endDate,
    this.requestStatus,
    this.requestedById,
    this.requestedAt,
    this.requestNotes,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.subscriptionPlanId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? startDate;

  final bool? endDate;

  final bool? requestStatus;

  final bool? requestedById;

  final bool? requestedAt;

  final bool? requestNotes;

  final bool? feedbackFromConsultee;

  final bool? feedbackFromConsultant;

  final bool? rating;

  final bool? subscriptionPlanId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'requestStatus': requestStatus,
    'requestedById': requestedById,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'subscriptionPlanId': subscriptionPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SubscriptionGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionGroupByOutputTypeMaxArgs({this.select});

  final _i2.SubscriptionMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SubscriptionGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubscriptionGroupByOutputTypeSelect({
    this.id,
    this.startDate,
    this.endDate,
    this.requestStatus,
    this.requestedById,
    this.requestedAt,
    this.requestNotes,
    this.feedbackFromConsultee,
    this.feedbackFromConsultant,
    this.rating,
    this.subscriptionPlanId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? startDate;

  final bool? endDate;

  final bool? requestStatus;

  final bool? requestedById;

  final bool? requestedAt;

  final bool? requestNotes;

  final bool? feedbackFromConsultee;

  final bool? feedbackFromConsultant;

  final bool? rating;

  final bool? subscriptionPlanId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.SubscriptionGroupByOutputTypeCountArgs>?
  $count;

  final _i1.PrismaUnion<bool, _i2.SubscriptionGroupByOutputTypeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.SubscriptionGroupByOutputTypeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.SubscriptionGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.SubscriptionGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'requestStatus': requestStatus,
    'requestedById': requestedById,
    'requestedAt': requestedAt,
    'requestNotes': requestNotes,
    'feedbackFromConsultee': feedbackFromConsultee,
    'feedbackFromConsultant': feedbackFromConsultant,
    'rating': rating,
    'subscriptionPlanId': subscriptionPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_avg': $avg,
    '_sum': $sum,
    '_min': $min,
    '_max': $max,
  };
}

class AggregateSubscription {
  const AggregateSubscription({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateSubscription.fromJson(Map json) => AggregateSubscription(
    $count: json['_count'] is Map
        ? _i2.SubscriptionCountAggregateOutputType.fromJson(json['_count'])
        : null,
    $avg: json['_avg'] is Map
        ? _i2.SubscriptionAvgAggregateOutputType.fromJson(json['_avg'])
        : null,
    $sum: json['_sum'] is Map
        ? _i2.SubscriptionSumAggregateOutputType.fromJson(json['_sum'])
        : null,
    $min: json['_min'] is Map
        ? _i2.SubscriptionMinAggregateOutputType.fromJson(json['_min'])
        : null,
    $max: json['_max'] is Map
        ? _i2.SubscriptionMaxAggregateOutputType.fromJson(json['_max'])
        : null,
  );

  final _i2.SubscriptionCountAggregateOutputType? $count;

  final _i2.SubscriptionAvgAggregateOutputType? $avg;

  final _i2.SubscriptionSumAggregateOutputType? $sum;

  final _i2.SubscriptionMinAggregateOutputType? $min;

  final _i2.SubscriptionMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    '_count': $count?.toJson(),
    '_avg': $avg?.toJson(),
    '_sum': $sum?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class AggregateSubscriptionCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSubscriptionCountArgs({this.select});

  final _i2.SubscriptionCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateSubscriptionAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSubscriptionAvgArgs({this.select});

  final _i2.SubscriptionAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateSubscriptionSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSubscriptionSumArgs({this.select});

  final _i2.SubscriptionSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateSubscriptionMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSubscriptionMinArgs({this.select});

  final _i2.SubscriptionMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateSubscriptionMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSubscriptionMaxArgs({this.select});

  final _i2.SubscriptionMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateSubscriptionSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSubscriptionSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateSubscriptionCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateSubscriptionAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateSubscriptionSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateSubscriptionMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateSubscriptionMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    '_count': $count,
    '_avg': $avg,
    '_sum': $sum,
    '_min': $min,
    '_max': $max,
  };
}

class WebinarPlanCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanCreateInput({
    this.id,
    required this.title,
    this.description,
    required this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInHours,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.createdAt,
    this.updatedAt,
    this.topics,
    this.consultantProfile,
    this.webinars,
  });

  final String? id;

  final String title;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final int price;

  final String? priceCurrency;

  final bool? certificateProvided;

  final double? durationInHours;

  final int? maxParticipants;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? language;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? level;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? prerequisites;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? materialProvided;

  final _i1.PrismaUnion<
    _i2.WebinarPlanCreatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.TopicCreateNestedManyWithoutWebinarPlansInput? topics;

  final _i2.ConsultantProfileCreateNestedOneWithoutWebinarPlansInput?
  consultantProfile;

  final _i2.WebinarCreateNestedManyWithoutWebinarPlanInput? webinars;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInHours': durationInHours,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'topics': topics,
    'consultantProfile': consultantProfile,
    'webinars': webinars,
  };
}

class WebinarPlanUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanUncheckedCreateInput({
    this.id,
    required this.title,
    this.description,
    required this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInHours,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.topics,
    this.webinars,
  });

  final String? id;

  final String title;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final int price;

  final String? priceCurrency;

  final bool? certificateProvided;

  final double? durationInHours;

  final int? maxParticipants;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? language;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? level;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? prerequisites;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? materialProvided;

  final _i1.PrismaUnion<
    _i2.WebinarPlanCreatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consultantProfileId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.TopicUncheckedCreateNestedManyWithoutWebinarPlansInput? topics;

  final _i2.WebinarUncheckedCreateNestedManyWithoutWebinarPlanInput? webinars;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInHours': durationInHours,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'topics': topics,
    'webinars': webinars,
  };
}

class WebinarPlanCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanCreateManyInput({
    this.id,
    required this.title,
    this.description,
    required this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInHours,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final String title;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final int price;

  final String? priceCurrency;

  final bool? certificateProvided;

  final double? durationInHours;

  final int? maxParticipants;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? language;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? level;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? prerequisites;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? materialProvided;

  final _i1.PrismaUnion<
    _i2.WebinarPlanCreatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consultantProfileId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInHours': durationInHours,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class WebinarPlanUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanUpdateInput({
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInHours,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.createdAt,
    this.updatedAt,
    this.topics,
    this.consultantProfile,
    this.webinars,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? price;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  priceCurrency;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
  certificateProvided;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
  durationInHours;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
  maxParticipants;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  language;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  level;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  prerequisites;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  materialProvided;

  final _i1.PrismaUnion<
    _i2.WebinarPlanUpdatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.TopicUpdateManyWithoutWebinarPlansNestedInput? topics;

  final _i2.ConsultantProfileUpdateOneWithoutWebinarPlansNestedInput?
  consultantProfile;

  final _i2.WebinarUpdateManyWithoutWebinarPlanNestedInput? webinars;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInHours': durationInHours,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'topics': topics,
    'consultantProfile': consultantProfile,
    'webinars': webinars,
  };
}

class WebinarPlanUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanUncheckedUpdateInput({
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInHours,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.topics,
    this.webinars,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? price;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  priceCurrency;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
  certificateProvided;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
  durationInHours;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
  maxParticipants;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  language;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  level;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  prerequisites;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  materialProvided;

  final _i1.PrismaUnion<
    _i2.WebinarPlanUpdatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consultantProfileId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.TopicUncheckedUpdateManyWithoutWebinarPlansNestedInput? topics;

  final _i2.WebinarUncheckedUpdateManyWithoutWebinarPlanNestedInput? webinars;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInHours': durationInHours,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'topics': topics,
    'webinars': webinars,
  };
}

class WebinarPlanUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanUncheckedUpdateManyInput({
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInHours,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? price;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  priceCurrency;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
  certificateProvided;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
  durationInHours;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
  maxParticipants;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  language;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  level;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  prerequisites;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  materialProvided;

  final _i1.PrismaUnion<
    _i2.WebinarPlanUpdatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consultantProfileId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInHours': durationInHours,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class WebinarPlanCountAggregateOutputType {
  const WebinarPlanCountAggregateOutputType({
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInHours,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  factory WebinarPlanCountAggregateOutputType.fromJson(Map json) =>
      WebinarPlanCountAggregateOutputType(
        id: json['id'],
        title: json['title'],
        description: json['description'],
        price: json['price'],
        priceCurrency: json['priceCurrency'],
        certificateProvided: json['certificateProvided'],
        durationInHours: json['durationInHours'],
        maxParticipants: json['maxParticipants'],
        language: json['language'],
        level: json['level'],
        prerequisites: json['prerequisites'],
        materialProvided: json['materialProvided'],
        learningOutcomes: json['learningOutcomes'],
        consultantProfileId: json['consultantProfileId'],
        createdAt: json['createdAt'],
        updatedAt: json['updatedAt'],
        $all: json['_all'],
      );

  final int? id;

  final int? title;

  final int? description;

  final int? price;

  final int? priceCurrency;

  final int? certificateProvided;

  final int? durationInHours;

  final int? maxParticipants;

  final int? language;

  final int? level;

  final int? prerequisites;

  final int? materialProvided;

  final int? learningOutcomes;

  final int? consultantProfileId;

  final int? createdAt;

  final int? updatedAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInHours': durationInHours,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class WebinarPlanAvgAggregateOutputType {
  const WebinarPlanAvgAggregateOutputType({
    this.price,
    this.durationInHours,
    this.maxParticipants,
  });

  factory WebinarPlanAvgAggregateOutputType.fromJson(Map json) =>
      WebinarPlanAvgAggregateOutputType(
        price: json['price'],
        durationInHours: json['durationInHours'],
        maxParticipants: json['maxParticipants'],
      );

  final double? price;

  final double? durationInHours;

  final double? maxParticipants;

  Map<String, dynamic> toJson() => {
    'price': price,
    'durationInHours': durationInHours,
    'maxParticipants': maxParticipants,
  };
}

class WebinarPlanSumAggregateOutputType {
  const WebinarPlanSumAggregateOutputType({
    this.price,
    this.durationInHours,
    this.maxParticipants,
  });

  factory WebinarPlanSumAggregateOutputType.fromJson(Map json) =>
      WebinarPlanSumAggregateOutputType(
        price: json['price'],
        durationInHours: json['durationInHours'],
        maxParticipants: json['maxParticipants'],
      );

  final int? price;

  final double? durationInHours;

  final int? maxParticipants;

  Map<String, dynamic> toJson() => {
    'price': price,
    'durationInHours': durationInHours,
    'maxParticipants': maxParticipants,
  };
}

class WebinarPlanMinAggregateOutputType {
  const WebinarPlanMinAggregateOutputType({
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInHours,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  factory WebinarPlanMinAggregateOutputType.fromJson(Map json) =>
      WebinarPlanMinAggregateOutputType(
        id: json['id'],
        title: json['title'],
        description: json['description'],
        price: json['price'],
        priceCurrency: json['priceCurrency'],
        certificateProvided: json['certificateProvided'],
        durationInHours: json['durationInHours'],
        maxParticipants: json['maxParticipants'],
        language: json['language'],
        level: json['level'],
        prerequisites: json['prerequisites'],
        materialProvided: json['materialProvided'],
        consultantProfileId: json['consultantProfileId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final String? title;

  final String? description;

  final int? price;

  final String? priceCurrency;

  final bool? certificateProvided;

  final double? durationInHours;

  final int? maxParticipants;

  final String? language;

  final String? level;

  final String? prerequisites;

  final String? materialProvided;

  final String? consultantProfileId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInHours': durationInHours,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class WebinarPlanMaxAggregateOutputType {
  const WebinarPlanMaxAggregateOutputType({
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInHours,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  factory WebinarPlanMaxAggregateOutputType.fromJson(Map json) =>
      WebinarPlanMaxAggregateOutputType(
        id: json['id'],
        title: json['title'],
        description: json['description'],
        price: json['price'],
        priceCurrency: json['priceCurrency'],
        certificateProvided: json['certificateProvided'],
        durationInHours: json['durationInHours'],
        maxParticipants: json['maxParticipants'],
        language: json['language'],
        level: json['level'],
        prerequisites: json['prerequisites'],
        materialProvided: json['materialProvided'],
        consultantProfileId: json['consultantProfileId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final String? title;

  final String? description;

  final int? price;

  final String? priceCurrency;

  final bool? certificateProvided;

  final double? durationInHours;

  final int? maxParticipants;

  final String? language;

  final String? level;

  final String? prerequisites;

  final String? materialProvided;

  final String? consultantProfileId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInHours': durationInHours,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class WebinarPlanGroupByOutputType {
  const WebinarPlanGroupByOutputType({
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInHours,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory WebinarPlanGroupByOutputType.fromJson(Map json) =>
      WebinarPlanGroupByOutputType(
        id: json['id'],
        title: json['title'],
        description: json['description'],
        price: json['price'],
        priceCurrency: json['priceCurrency'],
        certificateProvided: json['certificateProvided'],
        durationInHours: json['durationInHours'],
        maxParticipants: json['maxParticipants'],
        language: json['language'],
        level: json['level'],
        prerequisites: json['prerequisites'],
        materialProvided: json['materialProvided'],
        learningOutcomes: json['learningOutcomes'] is Iterable
            ? (json['learningOutcomes'] as Iterable).whereType<String>()
            : null,
        consultantProfileId: json['consultantProfileId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
        $count: json['_count'] is Map
            ? _i2.WebinarPlanCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.WebinarPlanAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.WebinarPlanSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.WebinarPlanMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.WebinarPlanMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? id;

  final String? title;

  final String? description;

  final int? price;

  final String? priceCurrency;

  final bool? certificateProvided;

  final double? durationInHours;

  final int? maxParticipants;

  final String? language;

  final String? level;

  final String? prerequisites;

  final String? materialProvided;

  final Iterable<String>? learningOutcomes;

  final String? consultantProfileId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.WebinarPlanCountAggregateOutputType? $count;

  final _i2.WebinarPlanAvgAggregateOutputType? $avg;

  final _i2.WebinarPlanSumAggregateOutputType? $sum;

  final _i2.WebinarPlanMinAggregateOutputType? $min;

  final _i2.WebinarPlanMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInHours': durationInHours,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes?.map((e) => e),
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
    '_count': $count?.toJson(),
    '_avg': $avg?.toJson(),
    '_sum': $sum?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class WebinarPlanCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanCountOrderByAggregateInput({
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInHours,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? title;

  final _i2.SortOrder? description;

  final _i2.SortOrder? price;

  final _i2.SortOrder? priceCurrency;

  final _i2.SortOrder? certificateProvided;

  final _i2.SortOrder? durationInHours;

  final _i2.SortOrder? maxParticipants;

  final _i2.SortOrder? language;

  final _i2.SortOrder? level;

  final _i2.SortOrder? prerequisites;

  final _i2.SortOrder? materialProvided;

  final _i2.SortOrder? learningOutcomes;

  final _i2.SortOrder? consultantProfileId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInHours': durationInHours,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class WebinarPlanAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanAvgOrderByAggregateInput({
    this.price,
    this.durationInHours,
    this.maxParticipants,
  });

  final _i2.SortOrder? price;

  final _i2.SortOrder? durationInHours;

  final _i2.SortOrder? maxParticipants;

  @override
  Map<String, dynamic> toJson() => {
    'price': price,
    'durationInHours': durationInHours,
    'maxParticipants': maxParticipants,
  };
}

class WebinarPlanMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanMaxOrderByAggregateInput({
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInHours,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? title;

  final _i2.SortOrder? description;

  final _i2.SortOrder? price;

  final _i2.SortOrder? priceCurrency;

  final _i2.SortOrder? certificateProvided;

  final _i2.SortOrder? durationInHours;

  final _i2.SortOrder? maxParticipants;

  final _i2.SortOrder? language;

  final _i2.SortOrder? level;

  final _i2.SortOrder? prerequisites;

  final _i2.SortOrder? materialProvided;

  final _i2.SortOrder? consultantProfileId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInHours': durationInHours,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class WebinarPlanMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanMinOrderByAggregateInput({
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInHours,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? title;

  final _i2.SortOrder? description;

  final _i2.SortOrder? price;

  final _i2.SortOrder? priceCurrency;

  final _i2.SortOrder? certificateProvided;

  final _i2.SortOrder? durationInHours;

  final _i2.SortOrder? maxParticipants;

  final _i2.SortOrder? language;

  final _i2.SortOrder? level;

  final _i2.SortOrder? prerequisites;

  final _i2.SortOrder? materialProvided;

  final _i2.SortOrder? consultantProfileId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInHours': durationInHours,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class WebinarPlanSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanSumOrderByAggregateInput({
    this.price,
    this.durationInHours,
    this.maxParticipants,
  });

  final _i2.SortOrder? price;

  final _i2.SortOrder? durationInHours;

  final _i2.SortOrder? maxParticipants;

  @override
  Map<String, dynamic> toJson() => {
    'price': price,
    'durationInHours': durationInHours,
    'maxParticipants': maxParticipants,
  };
}

class WebinarPlanOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanOrderByWithAggregationInput({
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInHours,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? title;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? description;

  final _i2.SortOrder? price;

  final _i2.SortOrder? priceCurrency;

  final _i2.SortOrder? certificateProvided;

  final _i2.SortOrder? durationInHours;

  final _i2.SortOrder? maxParticipants;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? language;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? level;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? prerequisites;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? materialProvided;

  final _i2.SortOrder? learningOutcomes;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? consultantProfileId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.WebinarPlanCountOrderByAggregateInput? $count;

  final _i2.WebinarPlanAvgOrderByAggregateInput? $avg;

  final _i2.WebinarPlanMaxOrderByAggregateInput? $max;

  final _i2.WebinarPlanMinOrderByAggregateInput? $min;

  final _i2.WebinarPlanSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInHours': durationInHours,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_avg': $avg,
    '_max': $max,
    '_min': $min,
    '_sum': $sum,
  };
}

class WebinarPlanScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInHours,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
    _i2.WebinarPlanScalarWhereWithAggregatesInput,
    Iterable<_i2.WebinarPlanScalarWhereWithAggregatesInput>
  >?
  AND;

  final Iterable<_i2.WebinarPlanScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<
    _i2.WebinarPlanScalarWhereWithAggregatesInput,
    Iterable<_i2.WebinarPlanScalarWhereWithAggregatesInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? title;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  description;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? price;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? priceCurrency;

  final _i1.PrismaUnion<_i2.BoolWithAggregatesFilter, bool>?
  certificateProvided;

  final _i1.PrismaUnion<_i2.FloatWithAggregatesFilter, double>? durationInHours;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? maxParticipants;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  language;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  level;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  prerequisites;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  materialProvided;

  final _i2.StringNullableListFilter? learningOutcomes;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  consultantProfileId;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInHours': durationInHours,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class WebinarPlanCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanCountAggregateOutputTypeSelect({
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInHours,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  final bool? id;

  final bool? title;

  final bool? description;

  final bool? price;

  final bool? priceCurrency;

  final bool? certificateProvided;

  final bool? durationInHours;

  final bool? maxParticipants;

  final bool? language;

  final bool? level;

  final bool? prerequisites;

  final bool? materialProvided;

  final bool? learningOutcomes;

  final bool? consultantProfileId;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInHours': durationInHours,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class WebinarPlanGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanGroupByOutputTypeCountArgs({this.select});

  final _i2.WebinarPlanCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class WebinarPlanAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanAvgAggregateOutputTypeSelect({
    this.price,
    this.durationInHours,
    this.maxParticipants,
  });

  final bool? price;

  final bool? durationInHours;

  final bool? maxParticipants;

  @override
  Map<String, dynamic> toJson() => {
    'price': price,
    'durationInHours': durationInHours,
    'maxParticipants': maxParticipants,
  };
}

class WebinarPlanGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanGroupByOutputTypeAvgArgs({this.select});

  final _i2.WebinarPlanAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class WebinarPlanSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanSumAggregateOutputTypeSelect({
    this.price,
    this.durationInHours,
    this.maxParticipants,
  });

  final bool? price;

  final bool? durationInHours;

  final bool? maxParticipants;

  @override
  Map<String, dynamic> toJson() => {
    'price': price,
    'durationInHours': durationInHours,
    'maxParticipants': maxParticipants,
  };
}

class WebinarPlanGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanGroupByOutputTypeSumArgs({this.select});

  final _i2.WebinarPlanSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class WebinarPlanMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanMinAggregateOutputTypeSelect({
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInHours,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? title;

  final bool? description;

  final bool? price;

  final bool? priceCurrency;

  final bool? certificateProvided;

  final bool? durationInHours;

  final bool? maxParticipants;

  final bool? language;

  final bool? level;

  final bool? prerequisites;

  final bool? materialProvided;

  final bool? consultantProfileId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInHours': durationInHours,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class WebinarPlanGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanGroupByOutputTypeMinArgs({this.select});

  final _i2.WebinarPlanMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class WebinarPlanMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanMaxAggregateOutputTypeSelect({
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInHours,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? title;

  final bool? description;

  final bool? price;

  final bool? priceCurrency;

  final bool? certificateProvided;

  final bool? durationInHours;

  final bool? maxParticipants;

  final bool? language;

  final bool? level;

  final bool? prerequisites;

  final bool? materialProvided;

  final bool? consultantProfileId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInHours': durationInHours,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class WebinarPlanGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanGroupByOutputTypeMaxArgs({this.select});

  final _i2.WebinarPlanMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class WebinarPlanGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarPlanGroupByOutputTypeSelect({
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInHours,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? title;

  final bool? description;

  final bool? price;

  final bool? priceCurrency;

  final bool? certificateProvided;

  final bool? durationInHours;

  final bool? maxParticipants;

  final bool? language;

  final bool? level;

  final bool? prerequisites;

  final bool? materialProvided;

  final bool? learningOutcomes;

  final bool? consultantProfileId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.WebinarPlanGroupByOutputTypeCountArgs>?
  $count;

  final _i1.PrismaUnion<bool, _i2.WebinarPlanGroupByOutputTypeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.WebinarPlanGroupByOutputTypeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.WebinarPlanGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.WebinarPlanGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInHours': durationInHours,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_avg': $avg,
    '_sum': $sum,
    '_min': $min,
    '_max': $max,
  };
}

class AggregateWebinarPlan {
  const AggregateWebinarPlan({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateWebinarPlan.fromJson(Map json) => AggregateWebinarPlan(
    $count: json['_count'] is Map
        ? _i2.WebinarPlanCountAggregateOutputType.fromJson(json['_count'])
        : null,
    $avg: json['_avg'] is Map
        ? _i2.WebinarPlanAvgAggregateOutputType.fromJson(json['_avg'])
        : null,
    $sum: json['_sum'] is Map
        ? _i2.WebinarPlanSumAggregateOutputType.fromJson(json['_sum'])
        : null,
    $min: json['_min'] is Map
        ? _i2.WebinarPlanMinAggregateOutputType.fromJson(json['_min'])
        : null,
    $max: json['_max'] is Map
        ? _i2.WebinarPlanMaxAggregateOutputType.fromJson(json['_max'])
        : null,
  );

  final _i2.WebinarPlanCountAggregateOutputType? $count;

  final _i2.WebinarPlanAvgAggregateOutputType? $avg;

  final _i2.WebinarPlanSumAggregateOutputType? $sum;

  final _i2.WebinarPlanMinAggregateOutputType? $min;

  final _i2.WebinarPlanMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    '_count': $count?.toJson(),
    '_avg': $avg?.toJson(),
    '_sum': $sum?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class AggregateWebinarPlanCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateWebinarPlanCountArgs({this.select});

  final _i2.WebinarPlanCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateWebinarPlanAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateWebinarPlanAvgArgs({this.select});

  final _i2.WebinarPlanAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateWebinarPlanSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateWebinarPlanSumArgs({this.select});

  final _i2.WebinarPlanSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateWebinarPlanMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateWebinarPlanMinArgs({this.select});

  final _i2.WebinarPlanMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateWebinarPlanMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateWebinarPlanMaxArgs({this.select});

  final _i2.WebinarPlanMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateWebinarPlanSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateWebinarPlanSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateWebinarPlanCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateWebinarPlanAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateWebinarPlanSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateWebinarPlanMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateWebinarPlanMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    '_count': $count,
    '_avg': $avg,
    '_sum': $sum,
    '_min': $min,
    '_max': $max,
  };
}

class WebinarCreateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarCreateInput({
    this.id,
    this.status,
    this.feedbackSummary,
    this.createdAt,
    this.updatedAt,
    this.waitlist,
    required this.webinarPlan,
    this.appointment,
  });

  final String? id;

  final _i3.WebinarStatus? status;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackSummary;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.WaitlistCreateNestedManyWithoutWebinarInput? waitlist;

  final _i2.WebinarPlanCreateNestedOneWithoutWebinarsInput webinarPlan;

  final _i2.AppointmentCreateNestedOneWithoutWebinarInput? appointment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'status': status,
    'feedbackSummary': feedbackSummary,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'waitlist': waitlist,
    'webinarPlan': webinarPlan,
    'appointment': appointment,
  };
}

class WebinarUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarUncheckedCreateInput({
    this.id,
    this.status,
    this.feedbackSummary,
    required this.webinarPlanId,
    this.createdAt,
    this.updatedAt,
    this.waitlist,
    this.appointment,
  });

  final String? id;

  final _i3.WebinarStatus? status;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackSummary;

  final String webinarPlanId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.WaitlistUncheckedCreateNestedManyWithoutWebinarInput? waitlist;

  final _i2.AppointmentUncheckedCreateNestedOneWithoutWebinarInput? appointment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'status': status,
    'feedbackSummary': feedbackSummary,
    'webinarPlanId': webinarPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'waitlist': waitlist,
    'appointment': appointment,
  };
}

class WebinarCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarCreateManyInput({
    this.id,
    this.status,
    this.feedbackSummary,
    required this.webinarPlanId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final _i3.WebinarStatus? status;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackSummary;

  final String webinarPlanId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'status': status,
    'feedbackSummary': feedbackSummary,
    'webinarPlanId': webinarPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class WebinarUpdateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarUpdateInput({
    this.id,
    this.status,
    this.feedbackSummary,
    this.createdAt,
    this.updatedAt,
    this.waitlist,
    this.webinarPlan,
    this.appointment,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    _i3.WebinarStatus,
    _i2.EnumWebinarStatusFieldUpdateOperationsInput
  >?
  status;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackSummary;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.WaitlistUpdateManyWithoutWebinarNestedInput? waitlist;

  final _i2.WebinarPlanUpdateOneRequiredWithoutWebinarsNestedInput? webinarPlan;

  final _i2.AppointmentUpdateOneWithoutWebinarNestedInput? appointment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'status': status,
    'feedbackSummary': feedbackSummary,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'waitlist': waitlist,
    'webinarPlan': webinarPlan,
    'appointment': appointment,
  };
}

class WebinarUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarUncheckedUpdateInput({
    this.id,
    this.status,
    this.feedbackSummary,
    this.webinarPlanId,
    this.createdAt,
    this.updatedAt,
    this.waitlist,
    this.appointment,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    _i3.WebinarStatus,
    _i2.EnumWebinarStatusFieldUpdateOperationsInput
  >?
  status;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackSummary;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  webinarPlanId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.WaitlistUncheckedUpdateManyWithoutWebinarNestedInput? waitlist;

  final _i2.AppointmentUncheckedUpdateOneWithoutWebinarNestedInput? appointment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'status': status,
    'feedbackSummary': feedbackSummary,
    'webinarPlanId': webinarPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'waitlist': waitlist,
    'appointment': appointment,
  };
}

class WebinarUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarUncheckedUpdateManyInput({
    this.id,
    this.status,
    this.feedbackSummary,
    this.webinarPlanId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    _i3.WebinarStatus,
    _i2.EnumWebinarStatusFieldUpdateOperationsInput
  >?
  status;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackSummary;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  webinarPlanId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'status': status,
    'feedbackSummary': feedbackSummary,
    'webinarPlanId': webinarPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class WebinarCountAggregateOutputType {
  const WebinarCountAggregateOutputType({
    this.id,
    this.status,
    this.feedbackSummary,
    this.webinarPlanId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  factory WebinarCountAggregateOutputType.fromJson(Map json) =>
      WebinarCountAggregateOutputType(
        id: json['id'],
        status: json['status'],
        feedbackSummary: json['feedbackSummary'],
        webinarPlanId: json['webinarPlanId'],
        createdAt: json['createdAt'],
        updatedAt: json['updatedAt'],
        $all: json['_all'],
      );

  final int? id;

  final int? status;

  final int? feedbackSummary;

  final int? webinarPlanId;

  final int? createdAt;

  final int? updatedAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
    'id': id,
    'status': status,
    'feedbackSummary': feedbackSummary,
    'webinarPlanId': webinarPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class WebinarMinAggregateOutputType {
  const WebinarMinAggregateOutputType({
    this.id,
    this.status,
    this.feedbackSummary,
    this.webinarPlanId,
    this.createdAt,
    this.updatedAt,
  });

  factory WebinarMinAggregateOutputType.fromJson(Map json) =>
      WebinarMinAggregateOutputType(
        id: json['id'],
        status: json['status'] != null
            ? _i3.WebinarStatus.values.firstWhere(
                (e) => e.name == json['status'],
              )
            : null,
        feedbackSummary: json['feedbackSummary'],
        webinarPlanId: json['webinarPlanId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final _i3.WebinarStatus? status;

  final String? feedbackSummary;

  final String? webinarPlanId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'status': status?.name,
    'feedbackSummary': feedbackSummary,
    'webinarPlanId': webinarPlanId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class WebinarMaxAggregateOutputType {
  const WebinarMaxAggregateOutputType({
    this.id,
    this.status,
    this.feedbackSummary,
    this.webinarPlanId,
    this.createdAt,
    this.updatedAt,
  });

  factory WebinarMaxAggregateOutputType.fromJson(Map json) =>
      WebinarMaxAggregateOutputType(
        id: json['id'],
        status: json['status'] != null
            ? _i3.WebinarStatus.values.firstWhere(
                (e) => e.name == json['status'],
              )
            : null,
        feedbackSummary: json['feedbackSummary'],
        webinarPlanId: json['webinarPlanId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final _i3.WebinarStatus? status;

  final String? feedbackSummary;

  final String? webinarPlanId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'status': status?.name,
    'feedbackSummary': feedbackSummary,
    'webinarPlanId': webinarPlanId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class WebinarGroupByOutputType {
  const WebinarGroupByOutputType({
    this.id,
    this.status,
    this.feedbackSummary,
    this.webinarPlanId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$min,
    this.$max,
  });

  factory WebinarGroupByOutputType.fromJson(Map json) =>
      WebinarGroupByOutputType(
        id: json['id'],
        status: json['status'] != null
            ? _i3.WebinarStatus.values.firstWhere(
                (e) => e.name == json['status'],
              )
            : null,
        feedbackSummary: json['feedbackSummary'],
        webinarPlanId: json['webinarPlanId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
        $count: json['_count'] is Map
            ? _i2.WebinarCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.WebinarMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.WebinarMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? id;

  final _i3.WebinarStatus? status;

  final String? feedbackSummary;

  final String? webinarPlanId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.WebinarCountAggregateOutputType? $count;

  final _i2.WebinarMinAggregateOutputType? $min;

  final _i2.WebinarMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    'id': id,
    'status': status?.name,
    'feedbackSummary': feedbackSummary,
    'webinarPlanId': webinarPlanId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
    '_count': $count?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class WebinarCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarCountOrderByAggregateInput({
    this.id,
    this.status,
    this.feedbackSummary,
    this.webinarPlanId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? status;

  final _i2.SortOrder? feedbackSummary;

  final _i2.SortOrder? webinarPlanId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'status': status,
    'feedbackSummary': feedbackSummary,
    'webinarPlanId': webinarPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class WebinarMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarMaxOrderByAggregateInput({
    this.id,
    this.status,
    this.feedbackSummary,
    this.webinarPlanId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? status;

  final _i2.SortOrder? feedbackSummary;

  final _i2.SortOrder? webinarPlanId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'status': status,
    'feedbackSummary': feedbackSummary,
    'webinarPlanId': webinarPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class WebinarMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarMinOrderByAggregateInput({
    this.id,
    this.status,
    this.feedbackSummary,
    this.webinarPlanId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? status;

  final _i2.SortOrder? feedbackSummary;

  final _i2.SortOrder? webinarPlanId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'status': status,
    'feedbackSummary': feedbackSummary,
    'webinarPlanId': webinarPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class WebinarOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarOrderByWithAggregationInput({
    this.id,
    this.status,
    this.feedbackSummary,
    this.webinarPlanId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$max,
    this.$min,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? status;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? feedbackSummary;

  final _i2.SortOrder? webinarPlanId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.WebinarCountOrderByAggregateInput? $count;

  final _i2.WebinarMaxOrderByAggregateInput? $max;

  final _i2.WebinarMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'status': status,
    'feedbackSummary': feedbackSummary,
    'webinarPlanId': webinarPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_max': $max,
    '_min': $min,
  };
}

class NestedEnumWebinarStatusWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedEnumWebinarStatusWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i3.WebinarStatus? equals;

  final _i1.PrismaUnion<Iterable<_i3.WebinarStatus>, _i3.WebinarStatus>? $in;

  final _i1.PrismaUnion<Iterable<_i3.WebinarStatus>, _i3.WebinarStatus>? notIn;

  final _i1.PrismaUnion<
    _i3.WebinarStatus,
    _i2.NestedEnumWebinarStatusWithAggregatesFilter
  >?
  not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedEnumWebinarStatusFilter? $min;

  final _i2.NestedEnumWebinarStatusFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class EnumWebinarStatusWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumWebinarStatusWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i3.WebinarStatus? equals;

  final _i1.PrismaUnion<Iterable<_i3.WebinarStatus>, _i3.WebinarStatus>? $in;

  final _i1.PrismaUnion<Iterable<_i3.WebinarStatus>, _i3.WebinarStatus>? notIn;

  final _i1.PrismaUnion<
    _i3.WebinarStatus,
    _i2.NestedEnumWebinarStatusWithAggregatesFilter
  >?
  not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedEnumWebinarStatusFilter? $min;

  final _i2.NestedEnumWebinarStatusFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class WebinarScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.status,
    this.feedbackSummary,
    this.webinarPlanId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
    _i2.WebinarScalarWhereWithAggregatesInput,
    Iterable<_i2.WebinarScalarWhereWithAggregatesInput>
  >?
  AND;

  final Iterable<_i2.WebinarScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<
    _i2.WebinarScalarWhereWithAggregatesInput,
    Iterable<_i2.WebinarScalarWhereWithAggregatesInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? id;

  final _i1.PrismaUnion<
    _i2.EnumWebinarStatusWithAggregatesFilter,
    _i3.WebinarStatus
  >?
  status;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  feedbackSummary;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? webinarPlanId;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'status': status,
    'feedbackSummary': feedbackSummary,
    'webinarPlanId': webinarPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class WebinarCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarCountAggregateOutputTypeSelect({
    this.id,
    this.status,
    this.feedbackSummary,
    this.webinarPlanId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  final bool? id;

  final bool? status;

  final bool? feedbackSummary;

  final bool? webinarPlanId;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'status': status,
    'feedbackSummary': feedbackSummary,
    'webinarPlanId': webinarPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class WebinarGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarGroupByOutputTypeCountArgs({this.select});

  final _i2.WebinarCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class WebinarMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarMinAggregateOutputTypeSelect({
    this.id,
    this.status,
    this.feedbackSummary,
    this.webinarPlanId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? status;

  final bool? feedbackSummary;

  final bool? webinarPlanId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'status': status,
    'feedbackSummary': feedbackSummary,
    'webinarPlanId': webinarPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class WebinarGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarGroupByOutputTypeMinArgs({this.select});

  final _i2.WebinarMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class WebinarMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarMaxAggregateOutputTypeSelect({
    this.id,
    this.status,
    this.feedbackSummary,
    this.webinarPlanId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? status;

  final bool? feedbackSummary;

  final bool? webinarPlanId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'status': status,
    'feedbackSummary': feedbackSummary,
    'webinarPlanId': webinarPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class WebinarGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarGroupByOutputTypeMaxArgs({this.select});

  final _i2.WebinarMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class WebinarGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WebinarGroupByOutputTypeSelect({
    this.id,
    this.status,
    this.feedbackSummary,
    this.webinarPlanId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? status;

  final bool? feedbackSummary;

  final bool? webinarPlanId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.WebinarGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.WebinarGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.WebinarGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'status': status,
    'feedbackSummary': feedbackSummary,
    'webinarPlanId': webinarPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class AggregateWebinar {
  const AggregateWebinar({this.$count, this.$min, this.$max});

  factory AggregateWebinar.fromJson(Map json) => AggregateWebinar(
    $count: json['_count'] is Map
        ? _i2.WebinarCountAggregateOutputType.fromJson(json['_count'])
        : null,
    $min: json['_min'] is Map
        ? _i2.WebinarMinAggregateOutputType.fromJson(json['_min'])
        : null,
    $max: json['_max'] is Map
        ? _i2.WebinarMaxAggregateOutputType.fromJson(json['_max'])
        : null,
  );

  final _i2.WebinarCountAggregateOutputType? $count;

  final _i2.WebinarMinAggregateOutputType? $min;

  final _i2.WebinarMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    '_count': $count?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class AggregateWebinarCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateWebinarCountArgs({this.select});

  final _i2.WebinarCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateWebinarMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateWebinarMinArgs({this.select});

  final _i2.WebinarMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateWebinarMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateWebinarMaxArgs({this.select});

  final _i2.WebinarMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateWebinarSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateWebinarSelect({this.$count, this.$min, this.$max});

  final _i1.PrismaUnion<bool, _i2.AggregateWebinarCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateWebinarMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateWebinarMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class ClassPlanCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanCreateInput({
    this.id,
    required this.title,
    required this.description,
    required this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInMonths,
    this.callsPerWeek,
    this.videoMeetings,
    this.emailSupport,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.createdAt,
    this.updatedAt,
    this.topics,
    this.classContents,
    this.consultantProfile,
    this.classes,
  });

  final String? id;

  final String title;

  final String description;

  final int price;

  final String? priceCurrency;

  final bool? certificateProvided;

  final int? durationInMonths;

  final int? callsPerWeek;

  final int? videoMeetings;

  final _i3.PlanEmailSupport? emailSupport;

  final int? maxParticipants;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? language;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? level;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? prerequisites;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? materialProvided;

  final _i1.PrismaUnion<
    _i2.ClassPlanCreatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.TopicCreateNestedManyWithoutClassPlansInput? topics;

  final _i2.ClassContentCreateNestedManyWithoutClassPlanInput? classContents;

  final _i2.ConsultantProfileCreateNestedOneWithoutClassPlansInput?
  consultantProfile;

  final _i2.ClassCreateNestedManyWithoutClassPlanInput? classes;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInMonths': durationInMonths,
    'callsPerWeek': callsPerWeek,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'topics': topics,
    'classContents': classContents,
    'consultantProfile': consultantProfile,
    'classes': classes,
  };
}

class ClassPlanUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanUncheckedCreateInput({
    this.id,
    required this.title,
    required this.description,
    required this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInMonths,
    this.callsPerWeek,
    this.videoMeetings,
    this.emailSupport,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.topics,
    this.classContents,
    this.classes,
  });

  final String? id;

  final String title;

  final String description;

  final int price;

  final String? priceCurrency;

  final bool? certificateProvided;

  final int? durationInMonths;

  final int? callsPerWeek;

  final int? videoMeetings;

  final _i3.PlanEmailSupport? emailSupport;

  final int? maxParticipants;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? language;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? level;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? prerequisites;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? materialProvided;

  final _i1.PrismaUnion<
    _i2.ClassPlanCreatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consultantProfileId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.TopicUncheckedCreateNestedManyWithoutClassPlansInput? topics;

  final _i2.ClassContentUncheckedCreateNestedManyWithoutClassPlanInput?
  classContents;

  final _i2.ClassUncheckedCreateNestedManyWithoutClassPlanInput? classes;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInMonths': durationInMonths,
    'callsPerWeek': callsPerWeek,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'topics': topics,
    'classContents': classContents,
    'classes': classes,
  };
}

class ClassPlanCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanCreateManyInput({
    this.id,
    required this.title,
    required this.description,
    required this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInMonths,
    this.callsPerWeek,
    this.videoMeetings,
    this.emailSupport,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final String title;

  final String description;

  final int price;

  final String? priceCurrency;

  final bool? certificateProvided;

  final int? durationInMonths;

  final int? callsPerWeek;

  final int? videoMeetings;

  final _i3.PlanEmailSupport? emailSupport;

  final int? maxParticipants;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? language;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? level;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? prerequisites;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? materialProvided;

  final _i1.PrismaUnion<
    _i2.ClassPlanCreatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consultantProfileId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInMonths': durationInMonths,
    'callsPerWeek': callsPerWeek,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ClassPlanUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanUpdateInput({
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInMonths,
    this.callsPerWeek,
    this.videoMeetings,
    this.emailSupport,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.createdAt,
    this.updatedAt,
    this.topics,
    this.classContents,
    this.consultantProfile,
    this.classes,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  description;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? price;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  priceCurrency;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
  certificateProvided;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
  durationInMonths;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? callsPerWeek;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? videoMeetings;

  final _i1.PrismaUnion<
    _i3.PlanEmailSupport,
    _i2.EnumPlanEmailSupportFieldUpdateOperationsInput
  >?
  emailSupport;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
  maxParticipants;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  language;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  level;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  prerequisites;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  materialProvided;

  final _i1.PrismaUnion<
    _i2.ClassPlanUpdatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.TopicUpdateManyWithoutClassPlansNestedInput? topics;

  final _i2.ClassContentUpdateManyWithoutClassPlanNestedInput? classContents;

  final _i2.ConsultantProfileUpdateOneWithoutClassPlansNestedInput?
  consultantProfile;

  final _i2.ClassUpdateManyWithoutClassPlanNestedInput? classes;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInMonths': durationInMonths,
    'callsPerWeek': callsPerWeek,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'topics': topics,
    'classContents': classContents,
    'consultantProfile': consultantProfile,
    'classes': classes,
  };
}

class ClassPlanUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanUncheckedUpdateInput({
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInMonths,
    this.callsPerWeek,
    this.videoMeetings,
    this.emailSupport,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.topics,
    this.classContents,
    this.classes,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  description;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? price;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  priceCurrency;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
  certificateProvided;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
  durationInMonths;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? callsPerWeek;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? videoMeetings;

  final _i1.PrismaUnion<
    _i3.PlanEmailSupport,
    _i2.EnumPlanEmailSupportFieldUpdateOperationsInput
  >?
  emailSupport;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
  maxParticipants;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  language;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  level;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  prerequisites;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  materialProvided;

  final _i1.PrismaUnion<
    _i2.ClassPlanUpdatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consultantProfileId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.TopicUncheckedUpdateManyWithoutClassPlansNestedInput? topics;

  final _i2.ClassContentUncheckedUpdateManyWithoutClassPlanNestedInput?
  classContents;

  final _i2.ClassUncheckedUpdateManyWithoutClassPlanNestedInput? classes;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInMonths': durationInMonths,
    'callsPerWeek': callsPerWeek,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'topics': topics,
    'classContents': classContents,
    'classes': classes,
  };
}

class ClassPlanUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanUncheckedUpdateManyInput({
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInMonths,
    this.callsPerWeek,
    this.videoMeetings,
    this.emailSupport,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  description;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? price;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  priceCurrency;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
  certificateProvided;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
  durationInMonths;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? callsPerWeek;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? videoMeetings;

  final _i1.PrismaUnion<
    _i3.PlanEmailSupport,
    _i2.EnumPlanEmailSupportFieldUpdateOperationsInput
  >?
  emailSupport;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
  maxParticipants;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  language;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  level;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  prerequisites;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  materialProvided;

  final _i1.PrismaUnion<
    _i2.ClassPlanUpdatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consultantProfileId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInMonths': durationInMonths,
    'callsPerWeek': callsPerWeek,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ClassPlanCountAggregateOutputType {
  const ClassPlanCountAggregateOutputType({
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInMonths,
    this.callsPerWeek,
    this.videoMeetings,
    this.emailSupport,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  factory ClassPlanCountAggregateOutputType.fromJson(Map json) =>
      ClassPlanCountAggregateOutputType(
        id: json['id'],
        title: json['title'],
        description: json['description'],
        price: json['price'],
        priceCurrency: json['priceCurrency'],
        certificateProvided: json['certificateProvided'],
        durationInMonths: json['durationInMonths'],
        callsPerWeek: json['callsPerWeek'],
        videoMeetings: json['videoMeetings'],
        emailSupport: json['emailSupport'],
        maxParticipants: json['maxParticipants'],
        language: json['language'],
        level: json['level'],
        prerequisites: json['prerequisites'],
        materialProvided: json['materialProvided'],
        learningOutcomes: json['learningOutcomes'],
        consultantProfileId: json['consultantProfileId'],
        createdAt: json['createdAt'],
        updatedAt: json['updatedAt'],
        $all: json['_all'],
      );

  final int? id;

  final int? title;

  final int? description;

  final int? price;

  final int? priceCurrency;

  final int? certificateProvided;

  final int? durationInMonths;

  final int? callsPerWeek;

  final int? videoMeetings;

  final int? emailSupport;

  final int? maxParticipants;

  final int? language;

  final int? level;

  final int? prerequisites;

  final int? materialProvided;

  final int? learningOutcomes;

  final int? consultantProfileId;

  final int? createdAt;

  final int? updatedAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInMonths': durationInMonths,
    'callsPerWeek': callsPerWeek,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class ClassPlanAvgAggregateOutputType {
  const ClassPlanAvgAggregateOutputType({
    this.price,
    this.durationInMonths,
    this.callsPerWeek,
    this.videoMeetings,
    this.maxParticipants,
  });

  factory ClassPlanAvgAggregateOutputType.fromJson(Map json) =>
      ClassPlanAvgAggregateOutputType(
        price: json['price'],
        durationInMonths: json['durationInMonths'],
        callsPerWeek: json['callsPerWeek'],
        videoMeetings: json['videoMeetings'],
        maxParticipants: json['maxParticipants'],
      );

  final double? price;

  final double? durationInMonths;

  final double? callsPerWeek;

  final double? videoMeetings;

  final double? maxParticipants;

  Map<String, dynamic> toJson() => {
    'price': price,
    'durationInMonths': durationInMonths,
    'callsPerWeek': callsPerWeek,
    'videoMeetings': videoMeetings,
    'maxParticipants': maxParticipants,
  };
}

class ClassPlanSumAggregateOutputType {
  const ClassPlanSumAggregateOutputType({
    this.price,
    this.durationInMonths,
    this.callsPerWeek,
    this.videoMeetings,
    this.maxParticipants,
  });

  factory ClassPlanSumAggregateOutputType.fromJson(Map json) =>
      ClassPlanSumAggregateOutputType(
        price: json['price'],
        durationInMonths: json['durationInMonths'],
        callsPerWeek: json['callsPerWeek'],
        videoMeetings: json['videoMeetings'],
        maxParticipants: json['maxParticipants'],
      );

  final int? price;

  final int? durationInMonths;

  final int? callsPerWeek;

  final int? videoMeetings;

  final int? maxParticipants;

  Map<String, dynamic> toJson() => {
    'price': price,
    'durationInMonths': durationInMonths,
    'callsPerWeek': callsPerWeek,
    'videoMeetings': videoMeetings,
    'maxParticipants': maxParticipants,
  };
}

class ClassPlanMinAggregateOutputType {
  const ClassPlanMinAggregateOutputType({
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInMonths,
    this.callsPerWeek,
    this.videoMeetings,
    this.emailSupport,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  factory ClassPlanMinAggregateOutputType.fromJson(Map json) =>
      ClassPlanMinAggregateOutputType(
        id: json['id'],
        title: json['title'],
        description: json['description'],
        price: json['price'],
        priceCurrency: json['priceCurrency'],
        certificateProvided: json['certificateProvided'],
        durationInMonths: json['durationInMonths'],
        callsPerWeek: json['callsPerWeek'],
        videoMeetings: json['videoMeetings'],
        emailSupport: json['emailSupport'] != null
            ? _i3.PlanEmailSupport.values.firstWhere(
                (e) => e.name == json['emailSupport'],
              )
            : null,
        maxParticipants: json['maxParticipants'],
        language: json['language'],
        level: json['level'],
        prerequisites: json['prerequisites'],
        materialProvided: json['materialProvided'],
        consultantProfileId: json['consultantProfileId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final String? title;

  final String? description;

  final int? price;

  final String? priceCurrency;

  final bool? certificateProvided;

  final int? durationInMonths;

  final int? callsPerWeek;

  final int? videoMeetings;

  final _i3.PlanEmailSupport? emailSupport;

  final int? maxParticipants;

  final String? language;

  final String? level;

  final String? prerequisites;

  final String? materialProvided;

  final String? consultantProfileId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInMonths': durationInMonths,
    'callsPerWeek': callsPerWeek,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport?.name,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class ClassPlanMaxAggregateOutputType {
  const ClassPlanMaxAggregateOutputType({
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInMonths,
    this.callsPerWeek,
    this.videoMeetings,
    this.emailSupport,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  factory ClassPlanMaxAggregateOutputType.fromJson(Map json) =>
      ClassPlanMaxAggregateOutputType(
        id: json['id'],
        title: json['title'],
        description: json['description'],
        price: json['price'],
        priceCurrency: json['priceCurrency'],
        certificateProvided: json['certificateProvided'],
        durationInMonths: json['durationInMonths'],
        callsPerWeek: json['callsPerWeek'],
        videoMeetings: json['videoMeetings'],
        emailSupport: json['emailSupport'] != null
            ? _i3.PlanEmailSupport.values.firstWhere(
                (e) => e.name == json['emailSupport'],
              )
            : null,
        maxParticipants: json['maxParticipants'],
        language: json['language'],
        level: json['level'],
        prerequisites: json['prerequisites'],
        materialProvided: json['materialProvided'],
        consultantProfileId: json['consultantProfileId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final String? title;

  final String? description;

  final int? price;

  final String? priceCurrency;

  final bool? certificateProvided;

  final int? durationInMonths;

  final int? callsPerWeek;

  final int? videoMeetings;

  final _i3.PlanEmailSupport? emailSupport;

  final int? maxParticipants;

  final String? language;

  final String? level;

  final String? prerequisites;

  final String? materialProvided;

  final String? consultantProfileId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInMonths': durationInMonths,
    'callsPerWeek': callsPerWeek,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport?.name,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class ClassPlanGroupByOutputType {
  const ClassPlanGroupByOutputType({
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInMonths,
    this.callsPerWeek,
    this.videoMeetings,
    this.emailSupport,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory ClassPlanGroupByOutputType.fromJson(Map json) =>
      ClassPlanGroupByOutputType(
        id: json['id'],
        title: json['title'],
        description: json['description'],
        price: json['price'],
        priceCurrency: json['priceCurrency'],
        certificateProvided: json['certificateProvided'],
        durationInMonths: json['durationInMonths'],
        callsPerWeek: json['callsPerWeek'],
        videoMeetings: json['videoMeetings'],
        emailSupport: json['emailSupport'] != null
            ? _i3.PlanEmailSupport.values.firstWhere(
                (e) => e.name == json['emailSupport'],
              )
            : null,
        maxParticipants: json['maxParticipants'],
        language: json['language'],
        level: json['level'],
        prerequisites: json['prerequisites'],
        materialProvided: json['materialProvided'],
        learningOutcomes: json['learningOutcomes'] is Iterable
            ? (json['learningOutcomes'] as Iterable).whereType<String>()
            : null,
        consultantProfileId: json['consultantProfileId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
        $count: json['_count'] is Map
            ? _i2.ClassPlanCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.ClassPlanAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.ClassPlanSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.ClassPlanMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.ClassPlanMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? id;

  final String? title;

  final String? description;

  final int? price;

  final String? priceCurrency;

  final bool? certificateProvided;

  final int? durationInMonths;

  final int? callsPerWeek;

  final int? videoMeetings;

  final _i3.PlanEmailSupport? emailSupport;

  final int? maxParticipants;

  final String? language;

  final String? level;

  final String? prerequisites;

  final String? materialProvided;

  final Iterable<String>? learningOutcomes;

  final String? consultantProfileId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ClassPlanCountAggregateOutputType? $count;

  final _i2.ClassPlanAvgAggregateOutputType? $avg;

  final _i2.ClassPlanSumAggregateOutputType? $sum;

  final _i2.ClassPlanMinAggregateOutputType? $min;

  final _i2.ClassPlanMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInMonths': durationInMonths,
    'callsPerWeek': callsPerWeek,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport?.name,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes?.map((e) => e),
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
    '_count': $count?.toJson(),
    '_avg': $avg?.toJson(),
    '_sum': $sum?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class ClassPlanCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanCountOrderByAggregateInput({
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInMonths,
    this.callsPerWeek,
    this.videoMeetings,
    this.emailSupport,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? title;

  final _i2.SortOrder? description;

  final _i2.SortOrder? price;

  final _i2.SortOrder? priceCurrency;

  final _i2.SortOrder? certificateProvided;

  final _i2.SortOrder? durationInMonths;

  final _i2.SortOrder? callsPerWeek;

  final _i2.SortOrder? videoMeetings;

  final _i2.SortOrder? emailSupport;

  final _i2.SortOrder? maxParticipants;

  final _i2.SortOrder? language;

  final _i2.SortOrder? level;

  final _i2.SortOrder? prerequisites;

  final _i2.SortOrder? materialProvided;

  final _i2.SortOrder? learningOutcomes;

  final _i2.SortOrder? consultantProfileId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInMonths': durationInMonths,
    'callsPerWeek': callsPerWeek,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ClassPlanAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanAvgOrderByAggregateInput({
    this.price,
    this.durationInMonths,
    this.callsPerWeek,
    this.videoMeetings,
    this.maxParticipants,
  });

  final _i2.SortOrder? price;

  final _i2.SortOrder? durationInMonths;

  final _i2.SortOrder? callsPerWeek;

  final _i2.SortOrder? videoMeetings;

  final _i2.SortOrder? maxParticipants;

  @override
  Map<String, dynamic> toJson() => {
    'price': price,
    'durationInMonths': durationInMonths,
    'callsPerWeek': callsPerWeek,
    'videoMeetings': videoMeetings,
    'maxParticipants': maxParticipants,
  };
}

class ClassPlanMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanMaxOrderByAggregateInput({
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInMonths,
    this.callsPerWeek,
    this.videoMeetings,
    this.emailSupport,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? title;

  final _i2.SortOrder? description;

  final _i2.SortOrder? price;

  final _i2.SortOrder? priceCurrency;

  final _i2.SortOrder? certificateProvided;

  final _i2.SortOrder? durationInMonths;

  final _i2.SortOrder? callsPerWeek;

  final _i2.SortOrder? videoMeetings;

  final _i2.SortOrder? emailSupport;

  final _i2.SortOrder? maxParticipants;

  final _i2.SortOrder? language;

  final _i2.SortOrder? level;

  final _i2.SortOrder? prerequisites;

  final _i2.SortOrder? materialProvided;

  final _i2.SortOrder? consultantProfileId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInMonths': durationInMonths,
    'callsPerWeek': callsPerWeek,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ClassPlanMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanMinOrderByAggregateInput({
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInMonths,
    this.callsPerWeek,
    this.videoMeetings,
    this.emailSupport,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? title;

  final _i2.SortOrder? description;

  final _i2.SortOrder? price;

  final _i2.SortOrder? priceCurrency;

  final _i2.SortOrder? certificateProvided;

  final _i2.SortOrder? durationInMonths;

  final _i2.SortOrder? callsPerWeek;

  final _i2.SortOrder? videoMeetings;

  final _i2.SortOrder? emailSupport;

  final _i2.SortOrder? maxParticipants;

  final _i2.SortOrder? language;

  final _i2.SortOrder? level;

  final _i2.SortOrder? prerequisites;

  final _i2.SortOrder? materialProvided;

  final _i2.SortOrder? consultantProfileId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInMonths': durationInMonths,
    'callsPerWeek': callsPerWeek,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ClassPlanSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanSumOrderByAggregateInput({
    this.price,
    this.durationInMonths,
    this.callsPerWeek,
    this.videoMeetings,
    this.maxParticipants,
  });

  final _i2.SortOrder? price;

  final _i2.SortOrder? durationInMonths;

  final _i2.SortOrder? callsPerWeek;

  final _i2.SortOrder? videoMeetings;

  final _i2.SortOrder? maxParticipants;

  @override
  Map<String, dynamic> toJson() => {
    'price': price,
    'durationInMonths': durationInMonths,
    'callsPerWeek': callsPerWeek,
    'videoMeetings': videoMeetings,
    'maxParticipants': maxParticipants,
  };
}

class ClassPlanOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanOrderByWithAggregationInput({
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInMonths,
    this.callsPerWeek,
    this.videoMeetings,
    this.emailSupport,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? title;

  final _i2.SortOrder? description;

  final _i2.SortOrder? price;

  final _i2.SortOrder? priceCurrency;

  final _i2.SortOrder? certificateProvided;

  final _i2.SortOrder? durationInMonths;

  final _i2.SortOrder? callsPerWeek;

  final _i2.SortOrder? videoMeetings;

  final _i2.SortOrder? emailSupport;

  final _i2.SortOrder? maxParticipants;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? language;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? level;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? prerequisites;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? materialProvided;

  final _i2.SortOrder? learningOutcomes;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? consultantProfileId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.ClassPlanCountOrderByAggregateInput? $count;

  final _i2.ClassPlanAvgOrderByAggregateInput? $avg;

  final _i2.ClassPlanMaxOrderByAggregateInput? $max;

  final _i2.ClassPlanMinOrderByAggregateInput? $min;

  final _i2.ClassPlanSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInMonths': durationInMonths,
    'callsPerWeek': callsPerWeek,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_avg': $avg,
    '_max': $max,
    '_min': $min,
    '_sum': $sum,
  };
}

class ClassPlanScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInMonths,
    this.callsPerWeek,
    this.videoMeetings,
    this.emailSupport,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
    _i2.ClassPlanScalarWhereWithAggregatesInput,
    Iterable<_i2.ClassPlanScalarWhereWithAggregatesInput>
  >?
  AND;

  final Iterable<_i2.ClassPlanScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<
    _i2.ClassPlanScalarWhereWithAggregatesInput,
    Iterable<_i2.ClassPlanScalarWhereWithAggregatesInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? title;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? description;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? price;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? priceCurrency;

  final _i1.PrismaUnion<_i2.BoolWithAggregatesFilter, bool>?
  certificateProvided;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? durationInMonths;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? callsPerWeek;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? videoMeetings;

  final _i1.PrismaUnion<
    _i2.EnumPlanEmailSupportWithAggregatesFilter,
    _i3.PlanEmailSupport
  >?
  emailSupport;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? maxParticipants;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  language;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  level;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  prerequisites;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  materialProvided;

  final _i2.StringNullableListFilter? learningOutcomes;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  consultantProfileId;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInMonths': durationInMonths,
    'callsPerWeek': callsPerWeek,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ClassPlanCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanCountAggregateOutputTypeSelect({
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInMonths,
    this.callsPerWeek,
    this.videoMeetings,
    this.emailSupport,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  final bool? id;

  final bool? title;

  final bool? description;

  final bool? price;

  final bool? priceCurrency;

  final bool? certificateProvided;

  final bool? durationInMonths;

  final bool? callsPerWeek;

  final bool? videoMeetings;

  final bool? emailSupport;

  final bool? maxParticipants;

  final bool? language;

  final bool? level;

  final bool? prerequisites;

  final bool? materialProvided;

  final bool? learningOutcomes;

  final bool? consultantProfileId;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInMonths': durationInMonths,
    'callsPerWeek': callsPerWeek,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class ClassPlanGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanGroupByOutputTypeCountArgs({this.select});

  final _i2.ClassPlanCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ClassPlanAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanAvgAggregateOutputTypeSelect({
    this.price,
    this.durationInMonths,
    this.callsPerWeek,
    this.videoMeetings,
    this.maxParticipants,
  });

  final bool? price;

  final bool? durationInMonths;

  final bool? callsPerWeek;

  final bool? videoMeetings;

  final bool? maxParticipants;

  @override
  Map<String, dynamic> toJson() => {
    'price': price,
    'durationInMonths': durationInMonths,
    'callsPerWeek': callsPerWeek,
    'videoMeetings': videoMeetings,
    'maxParticipants': maxParticipants,
  };
}

class ClassPlanGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanGroupByOutputTypeAvgArgs({this.select});

  final _i2.ClassPlanAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ClassPlanSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanSumAggregateOutputTypeSelect({
    this.price,
    this.durationInMonths,
    this.callsPerWeek,
    this.videoMeetings,
    this.maxParticipants,
  });

  final bool? price;

  final bool? durationInMonths;

  final bool? callsPerWeek;

  final bool? videoMeetings;

  final bool? maxParticipants;

  @override
  Map<String, dynamic> toJson() => {
    'price': price,
    'durationInMonths': durationInMonths,
    'callsPerWeek': callsPerWeek,
    'videoMeetings': videoMeetings,
    'maxParticipants': maxParticipants,
  };
}

class ClassPlanGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanGroupByOutputTypeSumArgs({this.select});

  final _i2.ClassPlanSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ClassPlanMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanMinAggregateOutputTypeSelect({
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInMonths,
    this.callsPerWeek,
    this.videoMeetings,
    this.emailSupport,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? title;

  final bool? description;

  final bool? price;

  final bool? priceCurrency;

  final bool? certificateProvided;

  final bool? durationInMonths;

  final bool? callsPerWeek;

  final bool? videoMeetings;

  final bool? emailSupport;

  final bool? maxParticipants;

  final bool? language;

  final bool? level;

  final bool? prerequisites;

  final bool? materialProvided;

  final bool? consultantProfileId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInMonths': durationInMonths,
    'callsPerWeek': callsPerWeek,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ClassPlanGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanGroupByOutputTypeMinArgs({this.select});

  final _i2.ClassPlanMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ClassPlanMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanMaxAggregateOutputTypeSelect({
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInMonths,
    this.callsPerWeek,
    this.videoMeetings,
    this.emailSupport,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? title;

  final bool? description;

  final bool? price;

  final bool? priceCurrency;

  final bool? certificateProvided;

  final bool? durationInMonths;

  final bool? callsPerWeek;

  final bool? videoMeetings;

  final bool? emailSupport;

  final bool? maxParticipants;

  final bool? language;

  final bool? level;

  final bool? prerequisites;

  final bool? materialProvided;

  final bool? consultantProfileId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInMonths': durationInMonths,
    'callsPerWeek': callsPerWeek,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ClassPlanGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanGroupByOutputTypeMaxArgs({this.select});

  final _i2.ClassPlanMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ClassPlanGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanGroupByOutputTypeSelect({
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInMonths,
    this.callsPerWeek,
    this.videoMeetings,
    this.emailSupport,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? title;

  final bool? description;

  final bool? price;

  final bool? priceCurrency;

  final bool? certificateProvided;

  final bool? durationInMonths;

  final bool? callsPerWeek;

  final bool? videoMeetings;

  final bool? emailSupport;

  final bool? maxParticipants;

  final bool? language;

  final bool? level;

  final bool? prerequisites;

  final bool? materialProvided;

  final bool? learningOutcomes;

  final bool? consultantProfileId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.ClassPlanGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.ClassPlanGroupByOutputTypeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.ClassPlanGroupByOutputTypeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.ClassPlanGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.ClassPlanGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInMonths': durationInMonths,
    'callsPerWeek': callsPerWeek,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_avg': $avg,
    '_sum': $sum,
    '_min': $min,
    '_max': $max,
  };
}

class AggregateClassPlan {
  const AggregateClassPlan({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateClassPlan.fromJson(Map json) => AggregateClassPlan(
    $count: json['_count'] is Map
        ? _i2.ClassPlanCountAggregateOutputType.fromJson(json['_count'])
        : null,
    $avg: json['_avg'] is Map
        ? _i2.ClassPlanAvgAggregateOutputType.fromJson(json['_avg'])
        : null,
    $sum: json['_sum'] is Map
        ? _i2.ClassPlanSumAggregateOutputType.fromJson(json['_sum'])
        : null,
    $min: json['_min'] is Map
        ? _i2.ClassPlanMinAggregateOutputType.fromJson(json['_min'])
        : null,
    $max: json['_max'] is Map
        ? _i2.ClassPlanMaxAggregateOutputType.fromJson(json['_max'])
        : null,
  );

  final _i2.ClassPlanCountAggregateOutputType? $count;

  final _i2.ClassPlanAvgAggregateOutputType? $avg;

  final _i2.ClassPlanSumAggregateOutputType? $sum;

  final _i2.ClassPlanMinAggregateOutputType? $min;

  final _i2.ClassPlanMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    '_count': $count?.toJson(),
    '_avg': $avg?.toJson(),
    '_sum': $sum?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class AggregateClassPlanCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateClassPlanCountArgs({this.select});

  final _i2.ClassPlanCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateClassPlanAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateClassPlanAvgArgs({this.select});

  final _i2.ClassPlanAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateClassPlanSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateClassPlanSumArgs({this.select});

  final _i2.ClassPlanSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateClassPlanMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateClassPlanMinArgs({this.select});

  final _i2.ClassPlanMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateClassPlanMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateClassPlanMaxArgs({this.select});

  final _i2.ClassPlanMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateClassPlanSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateClassPlanSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateClassPlanCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateClassPlanAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateClassPlanSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateClassPlanMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateClassPlanMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    '_count': $count,
    '_avg': $avg,
    '_sum': $sum,
    '_min': $min,
    '_max': $max,
  };
}

class ClassCreateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassCreateInput({
    this.id,
    this.startDate,
    this.endDate,
    this.status,
    this.recordingUrls,
    this.feedbackSummary,
    this.createdAt,
    this.updatedAt,
    this.waitlist,
    required this.classPlan,
    this.appointments,
  });

  final String? id;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? startDate;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? endDate;

  final _i3.ClassStatus? status;

  final _i1.PrismaUnion<_i2.ClassCreaterecordingUrlsInput, Iterable<String>>?
  recordingUrls;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackSummary;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.WaitlistCreateNestedManyWithoutClassInput? waitlist;

  final _i2.ClassPlanCreateNestedOneWithoutClassesInput classPlan;

  final _i2.AppointmentCreateNestedManyWithoutClassInput? appointments;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'status': status,
    'recordingUrls': recordingUrls,
    'feedbackSummary': feedbackSummary,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'waitlist': waitlist,
    'classPlan': classPlan,
    'appointments': appointments,
  };
}

class ClassUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassUncheckedCreateInput({
    this.id,
    this.startDate,
    this.endDate,
    this.status,
    this.recordingUrls,
    this.feedbackSummary,
    required this.classPlanId,
    this.createdAt,
    this.updatedAt,
    this.waitlist,
    this.appointments,
  });

  final String? id;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? startDate;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? endDate;

  final _i3.ClassStatus? status;

  final _i1.PrismaUnion<_i2.ClassCreaterecordingUrlsInput, Iterable<String>>?
  recordingUrls;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackSummary;

  final String classPlanId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.WaitlistUncheckedCreateNestedManyWithoutClassInput? waitlist;

  final _i2.AppointmentUncheckedCreateNestedManyWithoutClassInput? appointments;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'status': status,
    'recordingUrls': recordingUrls,
    'feedbackSummary': feedbackSummary,
    'classPlanId': classPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'waitlist': waitlist,
    'appointments': appointments,
  };
}

class ClassCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassCreateManyInput({
    this.id,
    this.startDate,
    this.endDate,
    this.status,
    this.recordingUrls,
    this.feedbackSummary,
    required this.classPlanId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? startDate;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? endDate;

  final _i3.ClassStatus? status;

  final _i1.PrismaUnion<_i2.ClassCreaterecordingUrlsInput, Iterable<String>>?
  recordingUrls;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? feedbackSummary;

  final String classPlanId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'status': status,
    'recordingUrls': recordingUrls,
    'feedbackSummary': feedbackSummary,
    'classPlanId': classPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ClassUpdateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassUpdateInput({
    this.id,
    this.startDate,
    this.endDate,
    this.status,
    this.recordingUrls,
    this.feedbackSummary,
    this.createdAt,
    this.updatedAt,
    this.waitlist,
    this.classPlan,
    this.appointments,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  startDate;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  endDate;

  final _i1.PrismaUnion<
    _i3.ClassStatus,
    _i2.EnumClassStatusFieldUpdateOperationsInput
  >?
  status;

  final _i1.PrismaUnion<_i2.ClassUpdaterecordingUrlsInput, Iterable<String>>?
  recordingUrls;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackSummary;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.WaitlistUpdateManyWithoutClassNestedInput? waitlist;

  final _i2.ClassPlanUpdateOneRequiredWithoutClassesNestedInput? classPlan;

  final _i2.AppointmentUpdateManyWithoutClassNestedInput? appointments;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'status': status,
    'recordingUrls': recordingUrls,
    'feedbackSummary': feedbackSummary,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'waitlist': waitlist,
    'classPlan': classPlan,
    'appointments': appointments,
  };
}

class ClassUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassUncheckedUpdateInput({
    this.id,
    this.startDate,
    this.endDate,
    this.status,
    this.recordingUrls,
    this.feedbackSummary,
    this.classPlanId,
    this.createdAt,
    this.updatedAt,
    this.waitlist,
    this.appointments,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  startDate;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  endDate;

  final _i1.PrismaUnion<
    _i3.ClassStatus,
    _i2.EnumClassStatusFieldUpdateOperationsInput
  >?
  status;

  final _i1.PrismaUnion<_i2.ClassUpdaterecordingUrlsInput, Iterable<String>>?
  recordingUrls;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackSummary;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  classPlanId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.WaitlistUncheckedUpdateManyWithoutClassNestedInput? waitlist;

  final _i2.AppointmentUncheckedUpdateManyWithoutClassNestedInput? appointments;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'status': status,
    'recordingUrls': recordingUrls,
    'feedbackSummary': feedbackSummary,
    'classPlanId': classPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'waitlist': waitlist,
    'appointments': appointments,
  };
}

class ClassUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassUncheckedUpdateManyInput({
    this.id,
    this.startDate,
    this.endDate,
    this.status,
    this.recordingUrls,
    this.feedbackSummary,
    this.classPlanId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  startDate;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  endDate;

  final _i1.PrismaUnion<
    _i3.ClassStatus,
    _i2.EnumClassStatusFieldUpdateOperationsInput
  >?
  status;

  final _i1.PrismaUnion<_i2.ClassUpdaterecordingUrlsInput, Iterable<String>>?
  recordingUrls;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  feedbackSummary;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  classPlanId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'status': status,
    'recordingUrls': recordingUrls,
    'feedbackSummary': feedbackSummary,
    'classPlanId': classPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ClassCountAggregateOutputType {
  const ClassCountAggregateOutputType({
    this.id,
    this.startDate,
    this.endDate,
    this.status,
    this.recordingUrls,
    this.feedbackSummary,
    this.classPlanId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  factory ClassCountAggregateOutputType.fromJson(Map json) =>
      ClassCountAggregateOutputType(
        id: json['id'],
        startDate: json['startDate'],
        endDate: json['endDate'],
        status: json['status'],
        recordingUrls: json['recordingUrls'],
        feedbackSummary: json['feedbackSummary'],
        classPlanId: json['classPlanId'],
        createdAt: json['createdAt'],
        updatedAt: json['updatedAt'],
        $all: json['_all'],
      );

  final int? id;

  final int? startDate;

  final int? endDate;

  final int? status;

  final int? recordingUrls;

  final int? feedbackSummary;

  final int? classPlanId;

  final int? createdAt;

  final int? updatedAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'status': status,
    'recordingUrls': recordingUrls,
    'feedbackSummary': feedbackSummary,
    'classPlanId': classPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class ClassMinAggregateOutputType {
  const ClassMinAggregateOutputType({
    this.id,
    this.startDate,
    this.endDate,
    this.status,
    this.feedbackSummary,
    this.classPlanId,
    this.createdAt,
    this.updatedAt,
  });

  factory ClassMinAggregateOutputType.fromJson(Map json) =>
      ClassMinAggregateOutputType(
        id: json['id'],
        startDate: switch (json['startDate']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['startDate'],
        },
        endDate: switch (json['endDate']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['endDate'],
        },
        status: json['status'] != null
            ? _i3.ClassStatus.values.firstWhere((e) => e.name == json['status'])
            : null,
        feedbackSummary: json['feedbackSummary'],
        classPlanId: json['classPlanId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final DateTime? startDate;

  final DateTime? endDate;

  final _i3.ClassStatus? status;

  final String? feedbackSummary;

  final String? classPlanId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate?.toIso8601String(),
    'endDate': endDate?.toIso8601String(),
    'status': status?.name,
    'feedbackSummary': feedbackSummary,
    'classPlanId': classPlanId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class ClassMaxAggregateOutputType {
  const ClassMaxAggregateOutputType({
    this.id,
    this.startDate,
    this.endDate,
    this.status,
    this.feedbackSummary,
    this.classPlanId,
    this.createdAt,
    this.updatedAt,
  });

  factory ClassMaxAggregateOutputType.fromJson(Map json) =>
      ClassMaxAggregateOutputType(
        id: json['id'],
        startDate: switch (json['startDate']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['startDate'],
        },
        endDate: switch (json['endDate']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['endDate'],
        },
        status: json['status'] != null
            ? _i3.ClassStatus.values.firstWhere((e) => e.name == json['status'])
            : null,
        feedbackSummary: json['feedbackSummary'],
        classPlanId: json['classPlanId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final DateTime? startDate;

  final DateTime? endDate;

  final _i3.ClassStatus? status;

  final String? feedbackSummary;

  final String? classPlanId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate?.toIso8601String(),
    'endDate': endDate?.toIso8601String(),
    'status': status?.name,
    'feedbackSummary': feedbackSummary,
    'classPlanId': classPlanId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class ClassGroupByOutputType {
  const ClassGroupByOutputType({
    this.id,
    this.startDate,
    this.endDate,
    this.status,
    this.recordingUrls,
    this.feedbackSummary,
    this.classPlanId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$min,
    this.$max,
  });

  factory ClassGroupByOutputType.fromJson(Map json) => ClassGroupByOutputType(
    id: json['id'],
    startDate: switch (json['startDate']) {
      DateTime value => value,
      String value => DateTime.parse(value),
      _ => json['startDate'],
    },
    endDate: switch (json['endDate']) {
      DateTime value => value,
      String value => DateTime.parse(value),
      _ => json['endDate'],
    },
    status: json['status'] != null
        ? _i3.ClassStatus.values.firstWhere((e) => e.name == json['status'])
        : null,
    recordingUrls: json['recordingUrls'] is Iterable
        ? (json['recordingUrls'] as Iterable).whereType<String>()
        : null,
    feedbackSummary: json['feedbackSummary'],
    classPlanId: json['classPlanId'],
    createdAt: switch (json['createdAt']) {
      DateTime value => value,
      String value => DateTime.parse(value),
      _ => json['createdAt'],
    },
    updatedAt: switch (json['updatedAt']) {
      DateTime value => value,
      String value => DateTime.parse(value),
      _ => json['updatedAt'],
    },
    $count: json['_count'] is Map
        ? _i2.ClassCountAggregateOutputType.fromJson(json['_count'])
        : null,
    $min: json['_min'] is Map
        ? _i2.ClassMinAggregateOutputType.fromJson(json['_min'])
        : null,
    $max: json['_max'] is Map
        ? _i2.ClassMaxAggregateOutputType.fromJson(json['_max'])
        : null,
  );

  final String? id;

  final DateTime? startDate;

  final DateTime? endDate;

  final _i3.ClassStatus? status;

  final Iterable<String>? recordingUrls;

  final String? feedbackSummary;

  final String? classPlanId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ClassCountAggregateOutputType? $count;

  final _i2.ClassMinAggregateOutputType? $min;

  final _i2.ClassMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate?.toIso8601String(),
    'endDate': endDate?.toIso8601String(),
    'status': status?.name,
    'recordingUrls': recordingUrls?.map((e) => e),
    'feedbackSummary': feedbackSummary,
    'classPlanId': classPlanId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
    '_count': $count?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class ClassCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassCountOrderByAggregateInput({
    this.id,
    this.startDate,
    this.endDate,
    this.status,
    this.recordingUrls,
    this.feedbackSummary,
    this.classPlanId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? startDate;

  final _i2.SortOrder? endDate;

  final _i2.SortOrder? status;

  final _i2.SortOrder? recordingUrls;

  final _i2.SortOrder? feedbackSummary;

  final _i2.SortOrder? classPlanId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'status': status,
    'recordingUrls': recordingUrls,
    'feedbackSummary': feedbackSummary,
    'classPlanId': classPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ClassMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassMaxOrderByAggregateInput({
    this.id,
    this.startDate,
    this.endDate,
    this.status,
    this.feedbackSummary,
    this.classPlanId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? startDate;

  final _i2.SortOrder? endDate;

  final _i2.SortOrder? status;

  final _i2.SortOrder? feedbackSummary;

  final _i2.SortOrder? classPlanId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'status': status,
    'feedbackSummary': feedbackSummary,
    'classPlanId': classPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ClassMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassMinOrderByAggregateInput({
    this.id,
    this.startDate,
    this.endDate,
    this.status,
    this.feedbackSummary,
    this.classPlanId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? startDate;

  final _i2.SortOrder? endDate;

  final _i2.SortOrder? status;

  final _i2.SortOrder? feedbackSummary;

  final _i2.SortOrder? classPlanId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'status': status,
    'feedbackSummary': feedbackSummary,
    'classPlanId': classPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ClassOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassOrderByWithAggregationInput({
    this.id,
    this.startDate,
    this.endDate,
    this.status,
    this.recordingUrls,
    this.feedbackSummary,
    this.classPlanId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$max,
    this.$min,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? startDate;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? endDate;

  final _i2.SortOrder? status;

  final _i2.SortOrder? recordingUrls;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? feedbackSummary;

  final _i2.SortOrder? classPlanId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.ClassCountOrderByAggregateInput? $count;

  final _i2.ClassMaxOrderByAggregateInput? $max;

  final _i2.ClassMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'status': status,
    'recordingUrls': recordingUrls,
    'feedbackSummary': feedbackSummary,
    'classPlanId': classPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_max': $max,
    '_min': $min,
  };
}

class NestedEnumClassStatusWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedEnumClassStatusWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i3.ClassStatus? equals;

  final _i1.PrismaUnion<Iterable<_i3.ClassStatus>, _i3.ClassStatus>? $in;

  final _i1.PrismaUnion<Iterable<_i3.ClassStatus>, _i3.ClassStatus>? notIn;

  final _i1.PrismaUnion<
    _i3.ClassStatus,
    _i2.NestedEnumClassStatusWithAggregatesFilter
  >?
  not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedEnumClassStatusFilter? $min;

  final _i2.NestedEnumClassStatusFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class EnumClassStatusWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumClassStatusWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i3.ClassStatus? equals;

  final _i1.PrismaUnion<Iterable<_i3.ClassStatus>, _i3.ClassStatus>? $in;

  final _i1.PrismaUnion<Iterable<_i3.ClassStatus>, _i3.ClassStatus>? notIn;

  final _i1.PrismaUnion<
    _i3.ClassStatus,
    _i2.NestedEnumClassStatusWithAggregatesFilter
  >?
  not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedEnumClassStatusFilter? $min;

  final _i2.NestedEnumClassStatusFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class ClassScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.startDate,
    this.endDate,
    this.status,
    this.recordingUrls,
    this.feedbackSummary,
    this.classPlanId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
    _i2.ClassScalarWhereWithAggregatesInput,
    Iterable<_i2.ClassScalarWhereWithAggregatesInput>
  >?
  AND;

  final Iterable<_i2.ClassScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<
    _i2.ClassScalarWhereWithAggregatesInput,
    Iterable<_i2.ClassScalarWhereWithAggregatesInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? id;

  final _i1.PrismaUnion<
    _i2.DateTimeNullableWithAggregatesFilter,
    _i1.PrismaUnion<DateTime, _i1.PrismaNull>
  >?
  startDate;

  final _i1.PrismaUnion<
    _i2.DateTimeNullableWithAggregatesFilter,
    _i1.PrismaUnion<DateTime, _i1.PrismaNull>
  >?
  endDate;

  final _i1.PrismaUnion<
    _i2.EnumClassStatusWithAggregatesFilter,
    _i3.ClassStatus
  >?
  status;

  final _i2.StringNullableListFilter? recordingUrls;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  feedbackSummary;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? classPlanId;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'status': status,
    'recordingUrls': recordingUrls,
    'feedbackSummary': feedbackSummary,
    'classPlanId': classPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ClassCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassCountAggregateOutputTypeSelect({
    this.id,
    this.startDate,
    this.endDate,
    this.status,
    this.recordingUrls,
    this.feedbackSummary,
    this.classPlanId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  final bool? id;

  final bool? startDate;

  final bool? endDate;

  final bool? status;

  final bool? recordingUrls;

  final bool? feedbackSummary;

  final bool? classPlanId;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'status': status,
    'recordingUrls': recordingUrls,
    'feedbackSummary': feedbackSummary,
    'classPlanId': classPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class ClassGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassGroupByOutputTypeCountArgs({this.select});

  final _i2.ClassCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ClassMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassMinAggregateOutputTypeSelect({
    this.id,
    this.startDate,
    this.endDate,
    this.status,
    this.feedbackSummary,
    this.classPlanId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? startDate;

  final bool? endDate;

  final bool? status;

  final bool? feedbackSummary;

  final bool? classPlanId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'status': status,
    'feedbackSummary': feedbackSummary,
    'classPlanId': classPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ClassGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassGroupByOutputTypeMinArgs({this.select});

  final _i2.ClassMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ClassMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassMaxAggregateOutputTypeSelect({
    this.id,
    this.startDate,
    this.endDate,
    this.status,
    this.feedbackSummary,
    this.classPlanId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? startDate;

  final bool? endDate;

  final bool? status;

  final bool? feedbackSummary;

  final bool? classPlanId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'status': status,
    'feedbackSummary': feedbackSummary,
    'classPlanId': classPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ClassGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassGroupByOutputTypeMaxArgs({this.select});

  final _i2.ClassMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ClassGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassGroupByOutputTypeSelect({
    this.id,
    this.startDate,
    this.endDate,
    this.status,
    this.recordingUrls,
    this.feedbackSummary,
    this.classPlanId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? startDate;

  final bool? endDate;

  final bool? status;

  final bool? recordingUrls;

  final bool? feedbackSummary;

  final bool? classPlanId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.ClassGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.ClassGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.ClassGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'startDate': startDate,
    'endDate': endDate,
    'status': status,
    'recordingUrls': recordingUrls,
    'feedbackSummary': feedbackSummary,
    'classPlanId': classPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class AggregateClass {
  const AggregateClass({this.$count, this.$min, this.$max});

  factory AggregateClass.fromJson(Map json) => AggregateClass(
    $count: json['_count'] is Map
        ? _i2.ClassCountAggregateOutputType.fromJson(json['_count'])
        : null,
    $min: json['_min'] is Map
        ? _i2.ClassMinAggregateOutputType.fromJson(json['_min'])
        : null,
    $max: json['_max'] is Map
        ? _i2.ClassMaxAggregateOutputType.fromJson(json['_max'])
        : null,
  );

  final _i2.ClassCountAggregateOutputType? $count;

  final _i2.ClassMinAggregateOutputType? $min;

  final _i2.ClassMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    '_count': $count?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class AggregateClassCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateClassCountArgs({this.select});

  final _i2.ClassCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateClassMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateClassMinArgs({this.select});

  final _i2.ClassMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateClassMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateClassMaxArgs({this.select});

  final _i2.ClassMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateClassSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateClassSelect({this.$count, this.$min, this.$max});

  final _i1.PrismaUnion<bool, _i2.AggregateClassCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateClassMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateClassMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class ClassPlanCreateWithoutClassContentsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanCreateWithoutClassContentsInput({
    this.id,
    required this.title,
    required this.description,
    required this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInMonths,
    this.callsPerWeek,
    this.videoMeetings,
    this.emailSupport,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.createdAt,
    this.updatedAt,
    this.topics,
    this.consultantProfile,
    this.classes,
  });

  final String? id;

  final String title;

  final String description;

  final int price;

  final String? priceCurrency;

  final bool? certificateProvided;

  final int? durationInMonths;

  final int? callsPerWeek;

  final int? videoMeetings;

  final _i3.PlanEmailSupport? emailSupport;

  final int? maxParticipants;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? language;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? level;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? prerequisites;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? materialProvided;

  final _i1.PrismaUnion<
    _i2.ClassPlanCreatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.TopicCreateNestedManyWithoutClassPlansInput? topics;

  final _i2.ConsultantProfileCreateNestedOneWithoutClassPlansInput?
  consultantProfile;

  final _i2.ClassCreateNestedManyWithoutClassPlanInput? classes;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInMonths': durationInMonths,
    'callsPerWeek': callsPerWeek,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'topics': topics,
    'consultantProfile': consultantProfile,
    'classes': classes,
  };
}

class ClassPlanUncheckedCreateWithoutClassContentsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanUncheckedCreateWithoutClassContentsInput({
    this.id,
    required this.title,
    required this.description,
    required this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInMonths,
    this.callsPerWeek,
    this.videoMeetings,
    this.emailSupport,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.topics,
    this.classes,
  });

  final String? id;

  final String title;

  final String description;

  final int price;

  final String? priceCurrency;

  final bool? certificateProvided;

  final int? durationInMonths;

  final int? callsPerWeek;

  final int? videoMeetings;

  final _i3.PlanEmailSupport? emailSupport;

  final int? maxParticipants;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? language;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? level;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? prerequisites;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? materialProvided;

  final _i1.PrismaUnion<
    _i2.ClassPlanCreatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consultantProfileId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.TopicUncheckedCreateNestedManyWithoutClassPlansInput? topics;

  final _i2.ClassUncheckedCreateNestedManyWithoutClassPlanInput? classes;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInMonths': durationInMonths,
    'callsPerWeek': callsPerWeek,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'topics': topics,
    'classes': classes,
  };
}

class ClassPlanCreateOrConnectWithoutClassContentsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanCreateOrConnectWithoutClassContentsInput({
    required this.where,
    required this.create,
  });

  final _i2.ClassPlanWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.ClassPlanCreateWithoutClassContentsInput,
    _i2.ClassPlanUncheckedCreateWithoutClassContentsInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class ClassPlanCreateNestedOneWithoutClassContentsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanCreateNestedOneWithoutClassContentsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.ClassPlanCreateWithoutClassContentsInput,
    _i2.ClassPlanUncheckedCreateWithoutClassContentsInput
  >?
  create;

  final _i2.ClassPlanCreateOrConnectWithoutClassContentsInput? connectOrCreate;

  final _i2.ClassPlanWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class ClassContentCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassContentCreateInput({
    this.id,
    required this.title,
    required this.description,
    this.contentType,
    this.contentUrl,
    required this.order,
    required this.hoursAllotted,
    this.createdAt,
    this.updatedAt,
    required this.classPlan,
  });

  final String? id;

  final String title;

  final String description;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? contentType;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? contentUrl;

  final int order;

  final double hoursAllotted;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ClassPlanCreateNestedOneWithoutClassContentsInput classPlan;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'contentType': contentType,
    'contentUrl': contentUrl,
    'order': order,
    'hoursAllotted': hoursAllotted,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'classPlan': classPlan,
  };
}

class ClassContentUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassContentUncheckedCreateInput({
    this.id,
    required this.title,
    required this.description,
    this.contentType,
    this.contentUrl,
    required this.order,
    required this.hoursAllotted,
    required this.classPlanId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final String title;

  final String description;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? contentType;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? contentUrl;

  final int order;

  final double hoursAllotted;

  final String classPlanId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'contentType': contentType,
    'contentUrl': contentUrl,
    'order': order,
    'hoursAllotted': hoursAllotted,
    'classPlanId': classPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ClassContentCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassContentCreateManyInput({
    this.id,
    required this.title,
    required this.description,
    this.contentType,
    this.contentUrl,
    required this.order,
    required this.hoursAllotted,
    required this.classPlanId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final String title;

  final String description;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? contentType;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? contentUrl;

  final int order;

  final double hoursAllotted;

  final String classPlanId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'contentType': contentType,
    'contentUrl': contentUrl,
    'order': order,
    'hoursAllotted': hoursAllotted,
    'classPlanId': classPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ClassPlanUpdateWithoutClassContentsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanUpdateWithoutClassContentsInput({
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInMonths,
    this.callsPerWeek,
    this.videoMeetings,
    this.emailSupport,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.createdAt,
    this.updatedAt,
    this.topics,
    this.consultantProfile,
    this.classes,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  description;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? price;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  priceCurrency;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
  certificateProvided;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
  durationInMonths;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? callsPerWeek;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? videoMeetings;

  final _i1.PrismaUnion<
    _i3.PlanEmailSupport,
    _i2.EnumPlanEmailSupportFieldUpdateOperationsInput
  >?
  emailSupport;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
  maxParticipants;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  language;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  level;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  prerequisites;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  materialProvided;

  final _i1.PrismaUnion<
    _i2.ClassPlanUpdatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.TopicUpdateManyWithoutClassPlansNestedInput? topics;

  final _i2.ConsultantProfileUpdateOneWithoutClassPlansNestedInput?
  consultantProfile;

  final _i2.ClassUpdateManyWithoutClassPlanNestedInput? classes;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInMonths': durationInMonths,
    'callsPerWeek': callsPerWeek,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'topics': topics,
    'consultantProfile': consultantProfile,
    'classes': classes,
  };
}

class ClassPlanUncheckedUpdateWithoutClassContentsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanUncheckedUpdateWithoutClassContentsInput({
    this.id,
    this.title,
    this.description,
    this.price,
    this.priceCurrency,
    this.certificateProvided,
    this.durationInMonths,
    this.callsPerWeek,
    this.videoMeetings,
    this.emailSupport,
    this.maxParticipants,
    this.language,
    this.level,
    this.prerequisites,
    this.materialProvided,
    this.learningOutcomes,
    this.consultantProfileId,
    this.createdAt,
    this.updatedAt,
    this.topics,
    this.classes,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  description;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? price;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  priceCurrency;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
  certificateProvided;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
  durationInMonths;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? callsPerWeek;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? videoMeetings;

  final _i1.PrismaUnion<
    _i3.PlanEmailSupport,
    _i2.EnumPlanEmailSupportFieldUpdateOperationsInput
  >?
  emailSupport;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
  maxParticipants;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  language;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  level;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  prerequisites;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  materialProvided;

  final _i1.PrismaUnion<
    _i2.ClassPlanUpdatelearningOutcomesInput,
    Iterable<String>
  >?
  learningOutcomes;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consultantProfileId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.TopicUncheckedUpdateManyWithoutClassPlansNestedInput? topics;

  final _i2.ClassUncheckedUpdateManyWithoutClassPlanNestedInput? classes;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'price': price,
    'priceCurrency': priceCurrency,
    'certificateProvided': certificateProvided,
    'durationInMonths': durationInMonths,
    'callsPerWeek': callsPerWeek,
    'videoMeetings': videoMeetings,
    'emailSupport': emailSupport,
    'maxParticipants': maxParticipants,
    'language': language,
    'level': level,
    'prerequisites': prerequisites,
    'materialProvided': materialProvided,
    'learningOutcomes': learningOutcomes,
    'consultantProfileId': consultantProfileId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'topics': topics,
    'classes': classes,
  };
}

class ClassPlanUpsertWithoutClassContentsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanUpsertWithoutClassContentsInput({
    required this.update,
    required this.create,
  });

  final _i1.PrismaUnion<
    _i2.ClassPlanUpdateWithoutClassContentsInput,
    _i2.ClassPlanUncheckedUpdateWithoutClassContentsInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.ClassPlanCreateWithoutClassContentsInput,
    _i2.ClassPlanUncheckedCreateWithoutClassContentsInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'update': update, 'create': create};
}

class ClassPlanUpdateOneRequiredWithoutClassContentsNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassPlanUpdateOneRequiredWithoutClassContentsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.ClassPlanCreateWithoutClassContentsInput,
    _i2.ClassPlanUncheckedCreateWithoutClassContentsInput
  >?
  create;

  final _i2.ClassPlanCreateOrConnectWithoutClassContentsInput? connectOrCreate;

  final _i2.ClassPlanUpsertWithoutClassContentsInput? upsert;

  final _i2.ClassPlanWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.ClassPlanUpdateWithoutClassContentsInput,
    _i2.ClassPlanUncheckedUpdateWithoutClassContentsInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'connect': connect,
    'update': update,
  };
}

class ClassContentUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassContentUpdateInput({
    this.id,
    this.title,
    this.description,
    this.contentType,
    this.contentUrl,
    this.order,
    this.hoursAllotted,
    this.createdAt,
    this.updatedAt,
    this.classPlan,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  description;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  contentType;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  contentUrl;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? order;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
  hoursAllotted;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.ClassPlanUpdateOneRequiredWithoutClassContentsNestedInput?
  classPlan;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'contentType': contentType,
    'contentUrl': contentUrl,
    'order': order,
    'hoursAllotted': hoursAllotted,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'classPlan': classPlan,
  };
}

class ClassContentUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassContentUncheckedUpdateInput({
    this.id,
    this.title,
    this.description,
    this.contentType,
    this.contentUrl,
    this.order,
    this.hoursAllotted,
    this.classPlanId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  description;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  contentType;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  contentUrl;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? order;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
  hoursAllotted;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  classPlanId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'contentType': contentType,
    'contentUrl': contentUrl,
    'order': order,
    'hoursAllotted': hoursAllotted,
    'classPlanId': classPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ClassContentUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassContentUncheckedUpdateManyInput({
    this.id,
    this.title,
    this.description,
    this.contentType,
    this.contentUrl,
    this.order,
    this.hoursAllotted,
    this.classPlanId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  description;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  contentType;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  contentUrl;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? order;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
  hoursAllotted;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  classPlanId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'contentType': contentType,
    'contentUrl': contentUrl,
    'order': order,
    'hoursAllotted': hoursAllotted,
    'classPlanId': classPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ClassContentCountAggregateOutputType {
  const ClassContentCountAggregateOutputType({
    this.id,
    this.title,
    this.description,
    this.contentType,
    this.contentUrl,
    this.order,
    this.hoursAllotted,
    this.classPlanId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  factory ClassContentCountAggregateOutputType.fromJson(Map json) =>
      ClassContentCountAggregateOutputType(
        id: json['id'],
        title: json['title'],
        description: json['description'],
        contentType: json['contentType'],
        contentUrl: json['contentUrl'],
        order: json['order'],
        hoursAllotted: json['hoursAllotted'],
        classPlanId: json['classPlanId'],
        createdAt: json['createdAt'],
        updatedAt: json['updatedAt'],
        $all: json['_all'],
      );

  final int? id;

  final int? title;

  final int? description;

  final int? contentType;

  final int? contentUrl;

  final int? order;

  final int? hoursAllotted;

  final int? classPlanId;

  final int? createdAt;

  final int? updatedAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'contentType': contentType,
    'contentUrl': contentUrl,
    'order': order,
    'hoursAllotted': hoursAllotted,
    'classPlanId': classPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class ClassContentAvgAggregateOutputType {
  const ClassContentAvgAggregateOutputType({this.order, this.hoursAllotted});

  factory ClassContentAvgAggregateOutputType.fromJson(Map json) =>
      ClassContentAvgAggregateOutputType(
        order: json['order'],
        hoursAllotted: json['hoursAllotted'],
      );

  final double? order;

  final double? hoursAllotted;

  Map<String, dynamic> toJson() => {
    'order': order,
    'hoursAllotted': hoursAllotted,
  };
}

class ClassContentSumAggregateOutputType {
  const ClassContentSumAggregateOutputType({this.order, this.hoursAllotted});

  factory ClassContentSumAggregateOutputType.fromJson(Map json) =>
      ClassContentSumAggregateOutputType(
        order: json['order'],
        hoursAllotted: json['hoursAllotted'],
      );

  final int? order;

  final double? hoursAllotted;

  Map<String, dynamic> toJson() => {
    'order': order,
    'hoursAllotted': hoursAllotted,
  };
}

class ClassContentMinAggregateOutputType {
  const ClassContentMinAggregateOutputType({
    this.id,
    this.title,
    this.description,
    this.contentType,
    this.contentUrl,
    this.order,
    this.hoursAllotted,
    this.classPlanId,
    this.createdAt,
    this.updatedAt,
  });

  factory ClassContentMinAggregateOutputType.fromJson(Map json) =>
      ClassContentMinAggregateOutputType(
        id: json['id'],
        title: json['title'],
        description: json['description'],
        contentType: json['contentType'],
        contentUrl: json['contentUrl'],
        order: json['order'],
        hoursAllotted: json['hoursAllotted'],
        classPlanId: json['classPlanId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final String? title;

  final String? description;

  final String? contentType;

  final String? contentUrl;

  final int? order;

  final double? hoursAllotted;

  final String? classPlanId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'contentType': contentType,
    'contentUrl': contentUrl,
    'order': order,
    'hoursAllotted': hoursAllotted,
    'classPlanId': classPlanId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class ClassContentMaxAggregateOutputType {
  const ClassContentMaxAggregateOutputType({
    this.id,
    this.title,
    this.description,
    this.contentType,
    this.contentUrl,
    this.order,
    this.hoursAllotted,
    this.classPlanId,
    this.createdAt,
    this.updatedAt,
  });

  factory ClassContentMaxAggregateOutputType.fromJson(Map json) =>
      ClassContentMaxAggregateOutputType(
        id: json['id'],
        title: json['title'],
        description: json['description'],
        contentType: json['contentType'],
        contentUrl: json['contentUrl'],
        order: json['order'],
        hoursAllotted: json['hoursAllotted'],
        classPlanId: json['classPlanId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final String? title;

  final String? description;

  final String? contentType;

  final String? contentUrl;

  final int? order;

  final double? hoursAllotted;

  final String? classPlanId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'contentType': contentType,
    'contentUrl': contentUrl,
    'order': order,
    'hoursAllotted': hoursAllotted,
    'classPlanId': classPlanId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class ClassContentGroupByOutputType {
  const ClassContentGroupByOutputType({
    this.id,
    this.title,
    this.description,
    this.contentType,
    this.contentUrl,
    this.order,
    this.hoursAllotted,
    this.classPlanId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory ClassContentGroupByOutputType.fromJson(Map json) =>
      ClassContentGroupByOutputType(
        id: json['id'],
        title: json['title'],
        description: json['description'],
        contentType: json['contentType'],
        contentUrl: json['contentUrl'],
        order: json['order'],
        hoursAllotted: json['hoursAllotted'],
        classPlanId: json['classPlanId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
        $count: json['_count'] is Map
            ? _i2.ClassContentCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.ClassContentAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.ClassContentSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.ClassContentMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.ClassContentMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? id;

  final String? title;

  final String? description;

  final String? contentType;

  final String? contentUrl;

  final int? order;

  final double? hoursAllotted;

  final String? classPlanId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ClassContentCountAggregateOutputType? $count;

  final _i2.ClassContentAvgAggregateOutputType? $avg;

  final _i2.ClassContentSumAggregateOutputType? $sum;

  final _i2.ClassContentMinAggregateOutputType? $min;

  final _i2.ClassContentMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'contentType': contentType,
    'contentUrl': contentUrl,
    'order': order,
    'hoursAllotted': hoursAllotted,
    'classPlanId': classPlanId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
    '_count': $count?.toJson(),
    '_avg': $avg?.toJson(),
    '_sum': $sum?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class ClassContentCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassContentCountOrderByAggregateInput({
    this.id,
    this.title,
    this.description,
    this.contentType,
    this.contentUrl,
    this.order,
    this.hoursAllotted,
    this.classPlanId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? title;

  final _i2.SortOrder? description;

  final _i2.SortOrder? contentType;

  final _i2.SortOrder? contentUrl;

  final _i2.SortOrder? order;

  final _i2.SortOrder? hoursAllotted;

  final _i2.SortOrder? classPlanId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'contentType': contentType,
    'contentUrl': contentUrl,
    'order': order,
    'hoursAllotted': hoursAllotted,
    'classPlanId': classPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ClassContentAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassContentAvgOrderByAggregateInput({this.order, this.hoursAllotted});

  final _i2.SortOrder? order;

  final _i2.SortOrder? hoursAllotted;

  @override
  Map<String, dynamic> toJson() => {
    'order': order,
    'hoursAllotted': hoursAllotted,
  };
}

class ClassContentMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassContentMaxOrderByAggregateInput({
    this.id,
    this.title,
    this.description,
    this.contentType,
    this.contentUrl,
    this.order,
    this.hoursAllotted,
    this.classPlanId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? title;

  final _i2.SortOrder? description;

  final _i2.SortOrder? contentType;

  final _i2.SortOrder? contentUrl;

  final _i2.SortOrder? order;

  final _i2.SortOrder? hoursAllotted;

  final _i2.SortOrder? classPlanId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'contentType': contentType,
    'contentUrl': contentUrl,
    'order': order,
    'hoursAllotted': hoursAllotted,
    'classPlanId': classPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ClassContentMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassContentMinOrderByAggregateInput({
    this.id,
    this.title,
    this.description,
    this.contentType,
    this.contentUrl,
    this.order,
    this.hoursAllotted,
    this.classPlanId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? title;

  final _i2.SortOrder? description;

  final _i2.SortOrder? contentType;

  final _i2.SortOrder? contentUrl;

  final _i2.SortOrder? order;

  final _i2.SortOrder? hoursAllotted;

  final _i2.SortOrder? classPlanId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'contentType': contentType,
    'contentUrl': contentUrl,
    'order': order,
    'hoursAllotted': hoursAllotted,
    'classPlanId': classPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ClassContentSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassContentSumOrderByAggregateInput({this.order, this.hoursAllotted});

  final _i2.SortOrder? order;

  final _i2.SortOrder? hoursAllotted;

  @override
  Map<String, dynamic> toJson() => {
    'order': order,
    'hoursAllotted': hoursAllotted,
  };
}

class ClassContentOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassContentOrderByWithAggregationInput({
    this.id,
    this.title,
    this.description,
    this.contentType,
    this.contentUrl,
    this.order,
    this.hoursAllotted,
    this.classPlanId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? title;

  final _i2.SortOrder? description;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? contentType;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? contentUrl;

  final _i2.SortOrder? order;

  final _i2.SortOrder? hoursAllotted;

  final _i2.SortOrder? classPlanId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.ClassContentCountOrderByAggregateInput? $count;

  final _i2.ClassContentAvgOrderByAggregateInput? $avg;

  final _i2.ClassContentMaxOrderByAggregateInput? $max;

  final _i2.ClassContentMinOrderByAggregateInput? $min;

  final _i2.ClassContentSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'contentType': contentType,
    'contentUrl': contentUrl,
    'order': order,
    'hoursAllotted': hoursAllotted,
    'classPlanId': classPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_avg': $avg,
    '_max': $max,
    '_min': $min,
    '_sum': $sum,
  };
}

class ClassContentScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassContentScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.title,
    this.description,
    this.contentType,
    this.contentUrl,
    this.order,
    this.hoursAllotted,
    this.classPlanId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
    _i2.ClassContentScalarWhereWithAggregatesInput,
    Iterable<_i2.ClassContentScalarWhereWithAggregatesInput>
  >?
  AND;

  final Iterable<_i2.ClassContentScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<
    _i2.ClassContentScalarWhereWithAggregatesInput,
    Iterable<_i2.ClassContentScalarWhereWithAggregatesInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? title;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? description;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  contentType;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  contentUrl;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? order;

  final _i1.PrismaUnion<_i2.FloatWithAggregatesFilter, double>? hoursAllotted;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? classPlanId;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'title': title,
    'description': description,
    'contentType': contentType,
    'contentUrl': contentUrl,
    'order': order,
    'hoursAllotted': hoursAllotted,
    'classPlanId': classPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ClassContentCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassContentCountAggregateOutputTypeSelect({
    this.id,
    this.title,
    this.description,
    this.contentType,
    this.contentUrl,
    this.order,
    this.hoursAllotted,
    this.classPlanId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  final bool? id;

  final bool? title;

  final bool? description;

  final bool? contentType;

  final bool? contentUrl;

  final bool? order;

  final bool? hoursAllotted;

  final bool? classPlanId;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'contentType': contentType,
    'contentUrl': contentUrl,
    'order': order,
    'hoursAllotted': hoursAllotted,
    'classPlanId': classPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class ClassContentGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassContentGroupByOutputTypeCountArgs({this.select});

  final _i2.ClassContentCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ClassContentAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassContentAvgAggregateOutputTypeSelect({
    this.order,
    this.hoursAllotted,
  });

  final bool? order;

  final bool? hoursAllotted;

  @override
  Map<String, dynamic> toJson() => {
    'order': order,
    'hoursAllotted': hoursAllotted,
  };
}

class ClassContentGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassContentGroupByOutputTypeAvgArgs({this.select});

  final _i2.ClassContentAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ClassContentSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassContentSumAggregateOutputTypeSelect({
    this.order,
    this.hoursAllotted,
  });

  final bool? order;

  final bool? hoursAllotted;

  @override
  Map<String, dynamic> toJson() => {
    'order': order,
    'hoursAllotted': hoursAllotted,
  };
}

class ClassContentGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassContentGroupByOutputTypeSumArgs({this.select});

  final _i2.ClassContentSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ClassContentMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassContentMinAggregateOutputTypeSelect({
    this.id,
    this.title,
    this.description,
    this.contentType,
    this.contentUrl,
    this.order,
    this.hoursAllotted,
    this.classPlanId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? title;

  final bool? description;

  final bool? contentType;

  final bool? contentUrl;

  final bool? order;

  final bool? hoursAllotted;

  final bool? classPlanId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'contentType': contentType,
    'contentUrl': contentUrl,
    'order': order,
    'hoursAllotted': hoursAllotted,
    'classPlanId': classPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ClassContentGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassContentGroupByOutputTypeMinArgs({this.select});

  final _i2.ClassContentMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ClassContentMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassContentMaxAggregateOutputTypeSelect({
    this.id,
    this.title,
    this.description,
    this.contentType,
    this.contentUrl,
    this.order,
    this.hoursAllotted,
    this.classPlanId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? title;

  final bool? description;

  final bool? contentType;

  final bool? contentUrl;

  final bool? order;

  final bool? hoursAllotted;

  final bool? classPlanId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'contentType': contentType,
    'contentUrl': contentUrl,
    'order': order,
    'hoursAllotted': hoursAllotted,
    'classPlanId': classPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class ClassContentGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassContentGroupByOutputTypeMaxArgs({this.select});

  final _i2.ClassContentMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ClassContentGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClassContentGroupByOutputTypeSelect({
    this.id,
    this.title,
    this.description,
    this.contentType,
    this.contentUrl,
    this.order,
    this.hoursAllotted,
    this.classPlanId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? title;

  final bool? description;

  final bool? contentType;

  final bool? contentUrl;

  final bool? order;

  final bool? hoursAllotted;

  final bool? classPlanId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.ClassContentGroupByOutputTypeCountArgs>?
  $count;

  final _i1.PrismaUnion<bool, _i2.ClassContentGroupByOutputTypeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.ClassContentGroupByOutputTypeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.ClassContentGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.ClassContentGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'contentType': contentType,
    'contentUrl': contentUrl,
    'order': order,
    'hoursAllotted': hoursAllotted,
    'classPlanId': classPlanId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_avg': $avg,
    '_sum': $sum,
    '_min': $min,
    '_max': $max,
  };
}

class AggregateClassContent {
  const AggregateClassContent({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateClassContent.fromJson(Map json) => AggregateClassContent(
    $count: json['_count'] is Map
        ? _i2.ClassContentCountAggregateOutputType.fromJson(json['_count'])
        : null,
    $avg: json['_avg'] is Map
        ? _i2.ClassContentAvgAggregateOutputType.fromJson(json['_avg'])
        : null,
    $sum: json['_sum'] is Map
        ? _i2.ClassContentSumAggregateOutputType.fromJson(json['_sum'])
        : null,
    $min: json['_min'] is Map
        ? _i2.ClassContentMinAggregateOutputType.fromJson(json['_min'])
        : null,
    $max: json['_max'] is Map
        ? _i2.ClassContentMaxAggregateOutputType.fromJson(json['_max'])
        : null,
  );

  final _i2.ClassContentCountAggregateOutputType? $count;

  final _i2.ClassContentAvgAggregateOutputType? $avg;

  final _i2.ClassContentSumAggregateOutputType? $sum;

  final _i2.ClassContentMinAggregateOutputType? $min;

  final _i2.ClassContentMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    '_count': $count?.toJson(),
    '_avg': $avg?.toJson(),
    '_sum': $sum?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class AggregateClassContentCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateClassContentCountArgs({this.select});

  final _i2.ClassContentCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateClassContentAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateClassContentAvgArgs({this.select});

  final _i2.ClassContentAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateClassContentSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateClassContentSumArgs({this.select});

  final _i2.ClassContentSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateClassContentMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateClassContentMinArgs({this.select});

  final _i2.ClassContentMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateClassContentMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateClassContentMaxArgs({this.select});

  final _i2.ClassContentMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateClassContentSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateClassContentSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateClassContentCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateClassContentAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateClassContentSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateClassContentMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateClassContentMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    '_count': $count,
    '_avg': $avg,
    '_sum': $sum,
    '_min': $min,
    '_max': $max,
  };
}

class AppointmentCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentCreateInput({
    this.id,
    required this.appointmentType,
    this.createdAt,
    this.updatedAt,
    this.slotsOfAppointment,
    this.consultation,
    this.subscription,
    this.webinar,
    this.$class,
    this.payment,
  });

  final String? id;

  final _i3.AppointmentsType appointmentType;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.SlotOfAppointmentCreateNestedManyWithoutAppointmentInput?
  slotsOfAppointment;

  final _i2.ConsultationCreateNestedOneWithoutAppointmentInput? consultation;

  final _i2.SubscriptionCreateNestedOneWithoutAppointmentsInput? subscription;

  final _i2.WebinarCreateNestedOneWithoutAppointmentInput? webinar;

  final _i2.ClassCreateNestedOneWithoutAppointmentsInput? $class;

  final _i2.PaymentCreateNestedManyWithoutAppointmentInput? payment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'appointmentType': appointmentType,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'slotsOfAppointment': slotsOfAppointment,
    'consultation': consultation,
    'subscription': subscription,
    'webinar': webinar,
    'class': $class,
    'payment': payment,
  };
}

class AppointmentUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentUncheckedCreateInput({
    this.id,
    required this.appointmentType,
    this.consultationId,
    this.subscriptionId,
    this.webinarId,
    this.classId,
    this.createdAt,
    this.updatedAt,
    this.slotsOfAppointment,
    this.payment,
  });

  final String? id;

  final _i3.AppointmentsType appointmentType;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consultationId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? subscriptionId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? webinarId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? classId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.SlotOfAppointmentUncheckedCreateNestedManyWithoutAppointmentInput?
  slotsOfAppointment;

  final _i2.PaymentUncheckedCreateNestedManyWithoutAppointmentInput? payment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'appointmentType': appointmentType,
    'consultationId': consultationId,
    'subscriptionId': subscriptionId,
    'webinarId': webinarId,
    'classId': classId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'slotsOfAppointment': slotsOfAppointment,
    'payment': payment,
  };
}

class AppointmentCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentCreateManyInput({
    this.id,
    required this.appointmentType,
    this.consultationId,
    this.subscriptionId,
    this.webinarId,
    this.classId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final _i3.AppointmentsType appointmentType;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? consultationId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? subscriptionId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? webinarId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? classId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'appointmentType': appointmentType,
    'consultationId': consultationId,
    'subscriptionId': subscriptionId,
    'webinarId': webinarId,
    'classId': classId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class AppointmentUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentUpdateInput({
    this.id,
    this.appointmentType,
    this.createdAt,
    this.updatedAt,
    this.slotsOfAppointment,
    this.consultation,
    this.subscription,
    this.webinar,
    this.$class,
    this.payment,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    _i3.AppointmentsType,
    _i2.EnumAppointmentsTypeFieldUpdateOperationsInput
  >?
  appointmentType;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.SlotOfAppointmentUpdateManyWithoutAppointmentNestedInput?
  slotsOfAppointment;

  final _i2.ConsultationUpdateOneWithoutAppointmentNestedInput? consultation;

  final _i2.SubscriptionUpdateOneWithoutAppointmentsNestedInput? subscription;

  final _i2.WebinarUpdateOneWithoutAppointmentNestedInput? webinar;

  final _i2.ClassUpdateOneWithoutAppointmentsNestedInput? $class;

  final _i2.PaymentUpdateManyWithoutAppointmentNestedInput? payment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'appointmentType': appointmentType,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'slotsOfAppointment': slotsOfAppointment,
    'consultation': consultation,
    'subscription': subscription,
    'webinar': webinar,
    'class': $class,
    'payment': payment,
  };
}

class AppointmentUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentUncheckedUpdateInput({
    this.id,
    this.appointmentType,
    this.consultationId,
    this.subscriptionId,
    this.webinarId,
    this.classId,
    this.createdAt,
    this.updatedAt,
    this.slotsOfAppointment,
    this.payment,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    _i3.AppointmentsType,
    _i2.EnumAppointmentsTypeFieldUpdateOperationsInput
  >?
  appointmentType;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consultationId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  subscriptionId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  webinarId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  classId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.SlotOfAppointmentUncheckedUpdateManyWithoutAppointmentNestedInput?
  slotsOfAppointment;

  final _i2.PaymentUncheckedUpdateManyWithoutAppointmentNestedInput? payment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'appointmentType': appointmentType,
    'consultationId': consultationId,
    'subscriptionId': subscriptionId,
    'webinarId': webinarId,
    'classId': classId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'slotsOfAppointment': slotsOfAppointment,
    'payment': payment,
  };
}

class AppointmentUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentUncheckedUpdateManyInput({
    this.id,
    this.appointmentType,
    this.consultationId,
    this.subscriptionId,
    this.webinarId,
    this.classId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
    _i3.AppointmentsType,
    _i2.EnumAppointmentsTypeFieldUpdateOperationsInput
  >?
  appointmentType;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  consultationId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  subscriptionId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  webinarId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  classId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'appointmentType': appointmentType,
    'consultationId': consultationId,
    'subscriptionId': subscriptionId,
    'webinarId': webinarId,
    'classId': classId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class AppointmentCountAggregateOutputType {
  const AppointmentCountAggregateOutputType({
    this.id,
    this.appointmentType,
    this.consultationId,
    this.subscriptionId,
    this.webinarId,
    this.classId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  factory AppointmentCountAggregateOutputType.fromJson(Map json) =>
      AppointmentCountAggregateOutputType(
        id: json['id'],
        appointmentType: json['appointmentType'],
        consultationId: json['consultationId'],
        subscriptionId: json['subscriptionId'],
        webinarId: json['webinarId'],
        classId: json['classId'],
        createdAt: json['createdAt'],
        updatedAt: json['updatedAt'],
        $all: json['_all'],
      );

  final int? id;

  final int? appointmentType;

  final int? consultationId;

  final int? subscriptionId;

  final int? webinarId;

  final int? classId;

  final int? createdAt;

  final int? updatedAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
    'id': id,
    'appointmentType': appointmentType,
    'consultationId': consultationId,
    'subscriptionId': subscriptionId,
    'webinarId': webinarId,
    'classId': classId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class AppointmentMinAggregateOutputType {
  const AppointmentMinAggregateOutputType({
    this.id,
    this.appointmentType,
    this.consultationId,
    this.subscriptionId,
    this.webinarId,
    this.classId,
    this.createdAt,
    this.updatedAt,
  });

  factory AppointmentMinAggregateOutputType.fromJson(Map json) =>
      AppointmentMinAggregateOutputType(
        id: json['id'],
        appointmentType: json['appointmentType'] != null
            ? _i3.AppointmentsType.values.firstWhere(
                (e) => e.name == json['appointmentType'],
              )
            : null,
        consultationId: json['consultationId'],
        subscriptionId: json['subscriptionId'],
        webinarId: json['webinarId'],
        classId: json['classId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final _i3.AppointmentsType? appointmentType;

  final String? consultationId;

  final String? subscriptionId;

  final String? webinarId;

  final String? classId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'appointmentType': appointmentType?.name,
    'consultationId': consultationId,
    'subscriptionId': subscriptionId,
    'webinarId': webinarId,
    'classId': classId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class AppointmentMaxAggregateOutputType {
  const AppointmentMaxAggregateOutputType({
    this.id,
    this.appointmentType,
    this.consultationId,
    this.subscriptionId,
    this.webinarId,
    this.classId,
    this.createdAt,
    this.updatedAt,
  });

  factory AppointmentMaxAggregateOutputType.fromJson(Map json) =>
      AppointmentMaxAggregateOutputType(
        id: json['id'],
        appointmentType: json['appointmentType'] != null
            ? _i3.AppointmentsType.values.firstWhere(
                (e) => e.name == json['appointmentType'],
              )
            : null,
        consultationId: json['consultationId'],
        subscriptionId: json['subscriptionId'],
        webinarId: json['webinarId'],
        classId: json['classId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final _i3.AppointmentsType? appointmentType;

  final String? consultationId;

  final String? subscriptionId;

  final String? webinarId;

  final String? classId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'appointmentType': appointmentType?.name,
    'consultationId': consultationId,
    'subscriptionId': subscriptionId,
    'webinarId': webinarId,
    'classId': classId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class AppointmentGroupByOutputType {
  const AppointmentGroupByOutputType({
    this.id,
    this.appointmentType,
    this.consultationId,
    this.subscriptionId,
    this.webinarId,
    this.classId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$min,
    this.$max,
  });

  factory AppointmentGroupByOutputType.fromJson(Map json) =>
      AppointmentGroupByOutputType(
        id: json['id'],
        appointmentType: json['appointmentType'] != null
            ? _i3.AppointmentsType.values.firstWhere(
                (e) => e.name == json['appointmentType'],
              )
            : null,
        consultationId: json['consultationId'],
        subscriptionId: json['subscriptionId'],
        webinarId: json['webinarId'],
        classId: json['classId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
        $count: json['_count'] is Map
            ? _i2.AppointmentCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.AppointmentMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.AppointmentMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? id;

  final _i3.AppointmentsType? appointmentType;

  final String? consultationId;

  final String? subscriptionId;

  final String? webinarId;

  final String? classId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.AppointmentCountAggregateOutputType? $count;

  final _i2.AppointmentMinAggregateOutputType? $min;

  final _i2.AppointmentMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    'id': id,
    'appointmentType': appointmentType?.name,
    'consultationId': consultationId,
    'subscriptionId': subscriptionId,
    'webinarId': webinarId,
    'classId': classId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
    '_count': $count?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class AppointmentCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentCountOrderByAggregateInput({
    this.id,
    this.appointmentType,
    this.consultationId,
    this.subscriptionId,
    this.webinarId,
    this.classId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? appointmentType;

  final _i2.SortOrder? consultationId;

  final _i2.SortOrder? subscriptionId;

  final _i2.SortOrder? webinarId;

  final _i2.SortOrder? classId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'appointmentType': appointmentType,
    'consultationId': consultationId,
    'subscriptionId': subscriptionId,
    'webinarId': webinarId,
    'classId': classId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class AppointmentMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentMaxOrderByAggregateInput({
    this.id,
    this.appointmentType,
    this.consultationId,
    this.subscriptionId,
    this.webinarId,
    this.classId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? appointmentType;

  final _i2.SortOrder? consultationId;

  final _i2.SortOrder? subscriptionId;

  final _i2.SortOrder? webinarId;

  final _i2.SortOrder? classId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'appointmentType': appointmentType,
    'consultationId': consultationId,
    'subscriptionId': subscriptionId,
    'webinarId': webinarId,
    'classId': classId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class AppointmentMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentMinOrderByAggregateInput({
    this.id,
    this.appointmentType,
    this.consultationId,
    this.subscriptionId,
    this.webinarId,
    this.classId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? appointmentType;

  final _i2.SortOrder? consultationId;

  final _i2.SortOrder? subscriptionId;

  final _i2.SortOrder? webinarId;

  final _i2.SortOrder? classId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'appointmentType': appointmentType,
    'consultationId': consultationId,
    'subscriptionId': subscriptionId,
    'webinarId': webinarId,
    'classId': classId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class AppointmentOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentOrderByWithAggregationInput({
    this.id,
    this.appointmentType,
    this.consultationId,
    this.subscriptionId,
    this.webinarId,
    this.classId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$max,
    this.$min,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? appointmentType;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? consultationId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? subscriptionId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? webinarId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? classId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.AppointmentCountOrderByAggregateInput? $count;

  final _i2.AppointmentMaxOrderByAggregateInput? $max;

  final _i2.AppointmentMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'appointmentType': appointmentType,
    'consultationId': consultationId,
    'subscriptionId': subscriptionId,
    'webinarId': webinarId,
    'classId': classId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_max': $max,
    '_min': $min,
  };
}

class NestedEnumAppointmentsTypeWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedEnumAppointmentsTypeWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i3.AppointmentsType? equals;

  final _i1.PrismaUnion<Iterable<_i3.AppointmentsType>, _i3.AppointmentsType>?
  $in;

  final _i1.PrismaUnion<Iterable<_i3.AppointmentsType>, _i3.AppointmentsType>?
  notIn;

  final _i1.PrismaUnion<
    _i3.AppointmentsType,
    _i2.NestedEnumAppointmentsTypeWithAggregatesFilter
  >?
  not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedEnumAppointmentsTypeFilter? $min;

  final _i2.NestedEnumAppointmentsTypeFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class EnumAppointmentsTypeWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumAppointmentsTypeWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i3.AppointmentsType? equals;

  final _i1.PrismaUnion<Iterable<_i3.AppointmentsType>, _i3.AppointmentsType>?
  $in;

  final _i1.PrismaUnion<Iterable<_i3.AppointmentsType>, _i3.AppointmentsType>?
  notIn;

  final _i1.PrismaUnion<
    _i3.AppointmentsType,
    _i2.NestedEnumAppointmentsTypeWithAggregatesFilter
  >?
  not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedEnumAppointmentsTypeFilter? $min;

  final _i2.NestedEnumAppointmentsTypeFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class AppointmentScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.appointmentType,
    this.consultationId,
    this.subscriptionId,
    this.webinarId,
    this.classId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
    _i2.AppointmentScalarWhereWithAggregatesInput,
    Iterable<_i2.AppointmentScalarWhereWithAggregatesInput>
  >?
  AND;

  final Iterable<_i2.AppointmentScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<
    _i2.AppointmentScalarWhereWithAggregatesInput,
    Iterable<_i2.AppointmentScalarWhereWithAggregatesInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? id;

  final _i1.PrismaUnion<
    _i2.EnumAppointmentsTypeWithAggregatesFilter,
    _i3.AppointmentsType
  >?
  appointmentType;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  consultationId;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  subscriptionId;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  webinarId;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  classId;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'appointmentType': appointmentType,
    'consultationId': consultationId,
    'subscriptionId': subscriptionId,
    'webinarId': webinarId,
    'classId': classId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class AppointmentCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentCountAggregateOutputTypeSelect({
    this.id,
    this.appointmentType,
    this.consultationId,
    this.subscriptionId,
    this.webinarId,
    this.classId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  final bool? id;

  final bool? appointmentType;

  final bool? consultationId;

  final bool? subscriptionId;

  final bool? webinarId;

  final bool? classId;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'appointmentType': appointmentType,
    'consultationId': consultationId,
    'subscriptionId': subscriptionId,
    'webinarId': webinarId,
    'classId': classId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class AppointmentGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentGroupByOutputTypeCountArgs({this.select});

  final _i2.AppointmentCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AppointmentMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentMinAggregateOutputTypeSelect({
    this.id,
    this.appointmentType,
    this.consultationId,
    this.subscriptionId,
    this.webinarId,
    this.classId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? appointmentType;

  final bool? consultationId;

  final bool? subscriptionId;

  final bool? webinarId;

  final bool? classId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'appointmentType': appointmentType,
    'consultationId': consultationId,
    'subscriptionId': subscriptionId,
    'webinarId': webinarId,
    'classId': classId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class AppointmentGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentGroupByOutputTypeMinArgs({this.select});

  final _i2.AppointmentMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AppointmentMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentMaxAggregateOutputTypeSelect({
    this.id,
    this.appointmentType,
    this.consultationId,
    this.subscriptionId,
    this.webinarId,
    this.classId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? appointmentType;

  final bool? consultationId;

  final bool? subscriptionId;

  final bool? webinarId;

  final bool? classId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'appointmentType': appointmentType,
    'consultationId': consultationId,
    'subscriptionId': subscriptionId,
    'webinarId': webinarId,
    'classId': classId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class AppointmentGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentGroupByOutputTypeMaxArgs({this.select});

  final _i2.AppointmentMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AppointmentGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AppointmentGroupByOutputTypeSelect({
    this.id,
    this.appointmentType,
    this.consultationId,
    this.subscriptionId,
    this.webinarId,
    this.classId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? appointmentType;

  final bool? consultationId;

  final bool? subscriptionId;

  final bool? webinarId;

  final bool? classId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.AppointmentGroupByOutputTypeCountArgs>?
  $count;

  final _i1.PrismaUnion<bool, _i2.AppointmentGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AppointmentGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'appointmentType': appointmentType,
    'consultationId': consultationId,
    'subscriptionId': subscriptionId,
    'webinarId': webinarId,
    'classId': classId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class AggregateAppointment {
  const AggregateAppointment({this.$count, this.$min, this.$max});

  factory AggregateAppointment.fromJson(Map json) => AggregateAppointment(
    $count: json['_count'] is Map
        ? _i2.AppointmentCountAggregateOutputType.fromJson(json['_count'])
        : null,
    $min: json['_min'] is Map
        ? _i2.AppointmentMinAggregateOutputType.fromJson(json['_min'])
        : null,
    $max: json['_max'] is Map
        ? _i2.AppointmentMaxAggregateOutputType.fromJson(json['_max'])
        : null,
  );

  final _i2.AppointmentCountAggregateOutputType? $count;

  final _i2.AppointmentMinAggregateOutputType? $min;

  final _i2.AppointmentMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    '_count': $count?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class AggregateAppointmentCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateAppointmentCountArgs({this.select});

  final _i2.AppointmentCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateAppointmentMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateAppointmentMinArgs({this.select});

  final _i2.AppointmentMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateAppointmentMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateAppointmentMaxArgs({this.select});

  final _i2.AppointmentMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateAppointmentSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateAppointmentSelect({this.$count, this.$min, this.$max});

  final _i1.PrismaUnion<bool, _i2.AggregateAppointmentCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateAppointmentMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateAppointmentMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class TopicCreateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TopicCreateInput({
    this.id,
    required this.name,
    this.createdAt,
    this.updatedAt,
    this.webinarPlans,
    this.classPlans,
  });

  final String? id;

  final String name;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.WebinarPlanCreateNestedManyWithoutTopicsInput? webinarPlans;

  final _i2.ClassPlanCreateNestedManyWithoutTopicsInput? classPlans;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'webinarPlans': webinarPlans,
    'classPlans': classPlans,
  };
}

class TopicUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TopicUncheckedCreateInput({
    this.id,
    required this.name,
    this.createdAt,
    this.updatedAt,
    this.webinarPlans,
    this.classPlans,
  });

  final String? id;

  final String name;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.WebinarPlanUncheckedCreateNestedManyWithoutTopicsInput?
  webinarPlans;

  final _i2.ClassPlanUncheckedCreateNestedManyWithoutTopicsInput? classPlans;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'webinarPlans': webinarPlans,
    'classPlans': classPlans,
  };
}

class TopicCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TopicCreateManyInput({
    this.id,
    required this.name,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final String name;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class TopicUpdateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TopicUpdateInput({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
    this.webinarPlans,
    this.classPlans,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.WebinarPlanUpdateManyWithoutTopicsNestedInput? webinarPlans;

  final _i2.ClassPlanUpdateManyWithoutTopicsNestedInput? classPlans;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'webinarPlans': webinarPlans,
    'classPlans': classPlans,
  };
}

class TopicUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TopicUncheckedUpdateInput({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
    this.webinarPlans,
    this.classPlans,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.WebinarPlanUncheckedUpdateManyWithoutTopicsNestedInput?
  webinarPlans;

  final _i2.ClassPlanUncheckedUpdateManyWithoutTopicsNestedInput? classPlans;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'webinarPlans': webinarPlans,
    'classPlans': classPlans,
  };
}

class TopicUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TopicUncheckedUpdateManyInput({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class TopicCountAggregateOutputType {
  const TopicCountAggregateOutputType({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  factory TopicCountAggregateOutputType.fromJson(Map json) =>
      TopicCountAggregateOutputType(
        id: json['id'],
        name: json['name'],
        createdAt: json['createdAt'],
        updatedAt: json['updatedAt'],
        $all: json['_all'],
      );

  final int? id;

  final int? name;

  final int? createdAt;

  final int? updatedAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class TopicMinAggregateOutputType {
  const TopicMinAggregateOutputType({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
  });

  factory TopicMinAggregateOutputType.fromJson(Map json) =>
      TopicMinAggregateOutputType(
        id: json['id'],
        name: json['name'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final String? name;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class TopicMaxAggregateOutputType {
  const TopicMaxAggregateOutputType({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
  });

  factory TopicMaxAggregateOutputType.fromJson(Map json) =>
      TopicMaxAggregateOutputType(
        id: json['id'],
        name: json['name'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final String? name;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class TopicGroupByOutputType {
  const TopicGroupByOutputType({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$min,
    this.$max,
  });

  factory TopicGroupByOutputType.fromJson(Map json) => TopicGroupByOutputType(
    id: json['id'],
    name: json['name'],
    createdAt: switch (json['createdAt']) {
      DateTime value => value,
      String value => DateTime.parse(value),
      _ => json['createdAt'],
    },
    updatedAt: switch (json['updatedAt']) {
      DateTime value => value,
      String value => DateTime.parse(value),
      _ => json['updatedAt'],
    },
    $count: json['_count'] is Map
        ? _i2.TopicCountAggregateOutputType.fromJson(json['_count'])
        : null,
    $min: json['_min'] is Map
        ? _i2.TopicMinAggregateOutputType.fromJson(json['_min'])
        : null,
    $max: json['_max'] is Map
        ? _i2.TopicMaxAggregateOutputType.fromJson(json['_max'])
        : null,
  );

  final String? id;

  final String? name;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.TopicCountAggregateOutputType? $count;

  final _i2.TopicMinAggregateOutputType? $min;

  final _i2.TopicMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
    '_count': $count?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class TopicCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TopicCountOrderByAggregateInput({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? name;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class TopicMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TopicMaxOrderByAggregateInput({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? name;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class TopicMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TopicMinOrderByAggregateInput({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? name;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class TopicOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TopicOrderByWithAggregationInput({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$max,
    this.$min,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? name;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.TopicCountOrderByAggregateInput? $count;

  final _i2.TopicMaxOrderByAggregateInput? $max;

  final _i2.TopicMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_max': $max,
    '_min': $min,
  };
}

class TopicScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TopicScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
    _i2.TopicScalarWhereWithAggregatesInput,
    Iterable<_i2.TopicScalarWhereWithAggregatesInput>
  >?
  AND;

  final Iterable<_i2.TopicScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<
    _i2.TopicScalarWhereWithAggregatesInput,
    Iterable<_i2.TopicScalarWhereWithAggregatesInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? name;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class TopicCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TopicCountAggregateOutputTypeSelect({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  final bool? id;

  final bool? name;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class TopicGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TopicGroupByOutputTypeCountArgs({this.select});

  final _i2.TopicCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class TopicMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TopicMinAggregateOutputTypeSelect({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? name;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class TopicGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TopicGroupByOutputTypeMinArgs({this.select});

  final _i2.TopicMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class TopicMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TopicMaxAggregateOutputTypeSelect({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? name;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class TopicGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TopicGroupByOutputTypeMaxArgs({this.select});

  final _i2.TopicMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class TopicGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TopicGroupByOutputTypeSelect({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? name;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.TopicGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.TopicGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.TopicGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class AggregateTopic {
  const AggregateTopic({this.$count, this.$min, this.$max});

  factory AggregateTopic.fromJson(Map json) => AggregateTopic(
    $count: json['_count'] is Map
        ? _i2.TopicCountAggregateOutputType.fromJson(json['_count'])
        : null,
    $min: json['_min'] is Map
        ? _i2.TopicMinAggregateOutputType.fromJson(json['_min'])
        : null,
    $max: json['_max'] is Map
        ? _i2.TopicMaxAggregateOutputType.fromJson(json['_max'])
        : null,
  );

  final _i2.TopicCountAggregateOutputType? $count;

  final _i2.TopicMinAggregateOutputType? $min;

  final _i2.TopicMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    '_count': $count?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class AggregateTopicCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateTopicCountArgs({this.select});

  final _i2.TopicCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateTopicMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateTopicMinArgs({this.select});

  final _i2.TopicMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateTopicMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateTopicMaxArgs({this.select});

  final _i2.TopicMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateTopicSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateTopicSelect({this.$count, this.$min, this.$max});

  final _i1.PrismaUnion<bool, _i2.AggregateTopicCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateTopicMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateTopicMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class NewsletterWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NewsletterWhereUniqueInput({this.id, this.email});

  final String? id;

  final String? email;

  @override
  Map<String, dynamic> toJson() => {'id': id, 'email': email};
}

class NewsletterSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NewsletterSelect({this.id, this.email, this.createdAt, this.updatedAt});

  final bool? id;

  final bool? email;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'email': email,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class NewsletterWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NewsletterWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.email,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
    _i2.NewsletterWhereInput,
    Iterable<_i2.NewsletterWhereInput>
  >?
  AND;

  final Iterable<_i2.NewsletterWhereInput>? OR;

  final _i1.PrismaUnion<
    _i2.NewsletterWhereInput,
    Iterable<_i2.NewsletterWhereInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? email;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'email': email,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class NewsletterOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NewsletterOrderByWithRelationInput({
    this.id,
    this.email,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? email;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'email': email,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

enum NewsletterScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<String>('id', 'Newsletter'),
  email<String>('email', 'Newsletter'),
  createdAt<DateTime>('createdAt', 'Newsletter'),
  updatedAt<DateTime>('updatedAt', 'Newsletter');

  const NewsletterScalar(this.name, this.model);

  @override
  final String name;

  @override
  final String model;
}

class NewsletterCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NewsletterCreateInput({
    this.id,
    required this.email,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final String email;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'email': email,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class NewsletterUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NewsletterUncheckedCreateInput({
    this.id,
    required this.email,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final String email;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'email': email,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class NewsletterCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NewsletterCreateManyInput({
    this.id,
    required this.email,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final String email;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'email': email,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class NewsletterUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NewsletterUpdateInput({
    this.id,
    this.email,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? email;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'email': email,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class NewsletterUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NewsletterUncheckedUpdateInput({
    this.id,
    this.email,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? email;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'email': email,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class NewsletterUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NewsletterUpdateManyMutationInput({
    this.id,
    this.email,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? email;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'email': email,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class NewsletterUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NewsletterUncheckedUpdateManyInput({
    this.id,
    this.email,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? email;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'email': email,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class NewsletterCountAggregateOutputType {
  const NewsletterCountAggregateOutputType({
    this.id,
    this.email,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  factory NewsletterCountAggregateOutputType.fromJson(Map json) =>
      NewsletterCountAggregateOutputType(
        id: json['id'],
        email: json['email'],
        createdAt: json['createdAt'],
        updatedAt: json['updatedAt'],
        $all: json['_all'],
      );

  final int? id;

  final int? email;

  final int? createdAt;

  final int? updatedAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
    'id': id,
    'email': email,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class NewsletterMinAggregateOutputType {
  const NewsletterMinAggregateOutputType({
    this.id,
    this.email,
    this.createdAt,
    this.updatedAt,
  });

  factory NewsletterMinAggregateOutputType.fromJson(Map json) =>
      NewsletterMinAggregateOutputType(
        id: json['id'],
        email: json['email'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final String? email;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'email': email,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class NewsletterMaxAggregateOutputType {
  const NewsletterMaxAggregateOutputType({
    this.id,
    this.email,
    this.createdAt,
    this.updatedAt,
  });

  factory NewsletterMaxAggregateOutputType.fromJson(Map json) =>
      NewsletterMaxAggregateOutputType(
        id: json['id'],
        email: json['email'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final String? email;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'email': email,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class NewsletterGroupByOutputType {
  const NewsletterGroupByOutputType({
    this.id,
    this.email,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$min,
    this.$max,
  });

  factory NewsletterGroupByOutputType.fromJson(Map json) =>
      NewsletterGroupByOutputType(
        id: json['id'],
        email: json['email'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
        $count: json['_count'] is Map
            ? _i2.NewsletterCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.NewsletterMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.NewsletterMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? id;

  final String? email;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.NewsletterCountAggregateOutputType? $count;

  final _i2.NewsletterMinAggregateOutputType? $min;

  final _i2.NewsletterMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    'id': id,
    'email': email,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
    '_count': $count?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class NewsletterCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NewsletterCountOrderByAggregateInput({
    this.id,
    this.email,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? email;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'email': email,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class NewsletterMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NewsletterMaxOrderByAggregateInput({
    this.id,
    this.email,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? email;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'email': email,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class NewsletterMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NewsletterMinOrderByAggregateInput({
    this.id,
    this.email,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? email;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'email': email,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class NewsletterOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NewsletterOrderByWithAggregationInput({
    this.id,
    this.email,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$max,
    this.$min,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? email;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.NewsletterCountOrderByAggregateInput? $count;

  final _i2.NewsletterMaxOrderByAggregateInput? $max;

  final _i2.NewsletterMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'email': email,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_max': $max,
    '_min': $min,
  };
}

class NewsletterScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NewsletterScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.email,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
    _i2.NewsletterScalarWhereWithAggregatesInput,
    Iterable<_i2.NewsletterScalarWhereWithAggregatesInput>
  >?
  AND;

  final Iterable<_i2.NewsletterScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<
    _i2.NewsletterScalarWhereWithAggregatesInput,
    Iterable<_i2.NewsletterScalarWhereWithAggregatesInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? email;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'email': email,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class NewsletterCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NewsletterCountAggregateOutputTypeSelect({
    this.id,
    this.email,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  final bool? id;

  final bool? email;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'email': email,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class NewsletterGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NewsletterGroupByOutputTypeCountArgs({this.select});

  final _i2.NewsletterCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class NewsletterMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NewsletterMinAggregateOutputTypeSelect({
    this.id,
    this.email,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? email;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'email': email,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class NewsletterGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NewsletterGroupByOutputTypeMinArgs({this.select});

  final _i2.NewsletterMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class NewsletterMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NewsletterMaxAggregateOutputTypeSelect({
    this.id,
    this.email,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? email;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'email': email,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class NewsletterGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NewsletterGroupByOutputTypeMaxArgs({this.select});

  final _i2.NewsletterMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class NewsletterGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NewsletterGroupByOutputTypeSelect({
    this.id,
    this.email,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? email;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.NewsletterGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.NewsletterGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.NewsletterGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'email': email,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class AggregateNewsletter {
  const AggregateNewsletter({this.$count, this.$min, this.$max});

  factory AggregateNewsletter.fromJson(Map json) => AggregateNewsletter(
    $count: json['_count'] is Map
        ? _i2.NewsletterCountAggregateOutputType.fromJson(json['_count'])
        : null,
    $min: json['_min'] is Map
        ? _i2.NewsletterMinAggregateOutputType.fromJson(json['_min'])
        : null,
    $max: json['_max'] is Map
        ? _i2.NewsletterMaxAggregateOutputType.fromJson(json['_max'])
        : null,
  );

  final _i2.NewsletterCountAggregateOutputType? $count;

  final _i2.NewsletterMinAggregateOutputType? $min;

  final _i2.NewsletterMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    '_count': $count?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class AggregateNewsletterCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateNewsletterCountArgs({this.select});

  final _i2.NewsletterCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateNewsletterMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateNewsletterMinArgs({this.select});

  final _i2.NewsletterMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateNewsletterMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateNewsletterMaxArgs({this.select});

  final _i2.NewsletterMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateNewsletterSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateNewsletterSelect({this.$count, this.$min, this.$max});

  final _i1.PrismaUnion<bool, _i2.AggregateNewsletterCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateNewsletterMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateNewsletterMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class WaitlistCreateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistCreateInput({
    this.id,
    this.joinedAt,
    required this.user,
    this.webinar,
    this.$class,
  });

  final String? id;

  final DateTime? joinedAt;

  final _i2.UserCreateNestedOneWithoutWaitlistInput user;

  final _i2.WebinarCreateNestedOneWithoutWaitlistInput? webinar;

  final _i2.ClassCreateNestedOneWithoutWaitlistInput? $class;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'joinedAt': joinedAt,
    'user': user,
    'webinar': webinar,
    'class': $class,
  };
}

class WaitlistUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistUncheckedCreateInput({
    this.id,
    this.joinedAt,
    required this.userId,
    this.webinarId,
    this.classId,
  });

  final String? id;

  final DateTime? joinedAt;

  final String userId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? webinarId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? classId;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'joinedAt': joinedAt,
    'userId': userId,
    'webinarId': webinarId,
    'classId': classId,
  };
}

class WaitlistCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistCreateManyInput({
    this.id,
    this.joinedAt,
    required this.userId,
    this.webinarId,
    this.classId,
  });

  final String? id;

  final DateTime? joinedAt;

  final String userId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? webinarId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? classId;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'joinedAt': joinedAt,
    'userId': userId,
    'webinarId': webinarId,
    'classId': classId,
  };
}

class WaitlistUpdateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistUpdateInput({
    this.id,
    this.joinedAt,
    this.user,
    this.webinar,
    this.$class,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  joinedAt;

  final _i2.UserUpdateOneRequiredWithoutWaitlistNestedInput? user;

  final _i2.WebinarUpdateOneWithoutWaitlistNestedInput? webinar;

  final _i2.ClassUpdateOneWithoutWaitlistNestedInput? $class;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'joinedAt': joinedAt,
    'user': user,
    'webinar': webinar,
    'class': $class,
  };
}

class WaitlistUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistUncheckedUpdateInput({
    this.id,
    this.joinedAt,
    this.userId,
    this.webinarId,
    this.classId,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  joinedAt;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  webinarId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  classId;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'joinedAt': joinedAt,
    'userId': userId,
    'webinarId': webinarId,
    'classId': classId,
  };
}

class WaitlistUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistUncheckedUpdateManyInput({
    this.id,
    this.joinedAt,
    this.userId,
    this.webinarId,
    this.classId,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  joinedAt;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  webinarId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  classId;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'joinedAt': joinedAt,
    'userId': userId,
    'webinarId': webinarId,
    'classId': classId,
  };
}

class WaitlistCountAggregateOutputType {
  const WaitlistCountAggregateOutputType({
    this.id,
    this.joinedAt,
    this.userId,
    this.webinarId,
    this.classId,
    this.$all,
  });

  factory WaitlistCountAggregateOutputType.fromJson(Map json) =>
      WaitlistCountAggregateOutputType(
        id: json['id'],
        joinedAt: json['joinedAt'],
        userId: json['userId'],
        webinarId: json['webinarId'],
        classId: json['classId'],
        $all: json['_all'],
      );

  final int? id;

  final int? joinedAt;

  final int? userId;

  final int? webinarId;

  final int? classId;

  final int? $all;

  Map<String, dynamic> toJson() => {
    'id': id,
    'joinedAt': joinedAt,
    'userId': userId,
    'webinarId': webinarId,
    'classId': classId,
    '_all': $all,
  };
}

class WaitlistMinAggregateOutputType {
  const WaitlistMinAggregateOutputType({
    this.id,
    this.joinedAt,
    this.userId,
    this.webinarId,
    this.classId,
  });

  factory WaitlistMinAggregateOutputType.fromJson(Map json) =>
      WaitlistMinAggregateOutputType(
        id: json['id'],
        joinedAt: switch (json['joinedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['joinedAt'],
        },
        userId: json['userId'],
        webinarId: json['webinarId'],
        classId: json['classId'],
      );

  final String? id;

  final DateTime? joinedAt;

  final String? userId;

  final String? webinarId;

  final String? classId;

  Map<String, dynamic> toJson() => {
    'id': id,
    'joinedAt': joinedAt?.toIso8601String(),
    'userId': userId,
    'webinarId': webinarId,
    'classId': classId,
  };
}

class WaitlistMaxAggregateOutputType {
  const WaitlistMaxAggregateOutputType({
    this.id,
    this.joinedAt,
    this.userId,
    this.webinarId,
    this.classId,
  });

  factory WaitlistMaxAggregateOutputType.fromJson(Map json) =>
      WaitlistMaxAggregateOutputType(
        id: json['id'],
        joinedAt: switch (json['joinedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['joinedAt'],
        },
        userId: json['userId'],
        webinarId: json['webinarId'],
        classId: json['classId'],
      );

  final String? id;

  final DateTime? joinedAt;

  final String? userId;

  final String? webinarId;

  final String? classId;

  Map<String, dynamic> toJson() => {
    'id': id,
    'joinedAt': joinedAt?.toIso8601String(),
    'userId': userId,
    'webinarId': webinarId,
    'classId': classId,
  };
}

class WaitlistGroupByOutputType {
  const WaitlistGroupByOutputType({
    this.id,
    this.joinedAt,
    this.userId,
    this.webinarId,
    this.classId,
    this.$count,
    this.$min,
    this.$max,
  });

  factory WaitlistGroupByOutputType.fromJson(Map json) =>
      WaitlistGroupByOutputType(
        id: json['id'],
        joinedAt: switch (json['joinedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['joinedAt'],
        },
        userId: json['userId'],
        webinarId: json['webinarId'],
        classId: json['classId'],
        $count: json['_count'] is Map
            ? _i2.WaitlistCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.WaitlistMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.WaitlistMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? id;

  final DateTime? joinedAt;

  final String? userId;

  final String? webinarId;

  final String? classId;

  final _i2.WaitlistCountAggregateOutputType? $count;

  final _i2.WaitlistMinAggregateOutputType? $min;

  final _i2.WaitlistMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    'id': id,
    'joinedAt': joinedAt?.toIso8601String(),
    'userId': userId,
    'webinarId': webinarId,
    'classId': classId,
    '_count': $count?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class WaitlistCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistCountOrderByAggregateInput({
    this.id,
    this.joinedAt,
    this.userId,
    this.webinarId,
    this.classId,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? joinedAt;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? webinarId;

  final _i2.SortOrder? classId;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'joinedAt': joinedAt,
    'userId': userId,
    'webinarId': webinarId,
    'classId': classId,
  };
}

class WaitlistMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistMaxOrderByAggregateInput({
    this.id,
    this.joinedAt,
    this.userId,
    this.webinarId,
    this.classId,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? joinedAt;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? webinarId;

  final _i2.SortOrder? classId;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'joinedAt': joinedAt,
    'userId': userId,
    'webinarId': webinarId,
    'classId': classId,
  };
}

class WaitlistMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistMinOrderByAggregateInput({
    this.id,
    this.joinedAt,
    this.userId,
    this.webinarId,
    this.classId,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? joinedAt;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? webinarId;

  final _i2.SortOrder? classId;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'joinedAt': joinedAt,
    'userId': userId,
    'webinarId': webinarId,
    'classId': classId,
  };
}

class WaitlistOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistOrderByWithAggregationInput({
    this.id,
    this.joinedAt,
    this.userId,
    this.webinarId,
    this.classId,
    this.$count,
    this.$max,
    this.$min,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? joinedAt;

  final _i2.SortOrder? userId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? webinarId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? classId;

  final _i2.WaitlistCountOrderByAggregateInput? $count;

  final _i2.WaitlistMaxOrderByAggregateInput? $max;

  final _i2.WaitlistMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'joinedAt': joinedAt,
    'userId': userId,
    'webinarId': webinarId,
    'classId': classId,
    '_count': $count,
    '_max': $max,
    '_min': $min,
  };
}

class WaitlistScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.joinedAt,
    this.userId,
    this.webinarId,
    this.classId,
  });

  final _i1.PrismaUnion<
    _i2.WaitlistScalarWhereWithAggregatesInput,
    Iterable<_i2.WaitlistScalarWhereWithAggregatesInput>
  >?
  AND;

  final Iterable<_i2.WaitlistScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<
    _i2.WaitlistScalarWhereWithAggregatesInput,
    Iterable<_i2.WaitlistScalarWhereWithAggregatesInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? id;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? joinedAt;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? userId;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  webinarId;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  classId;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'joinedAt': joinedAt,
    'userId': userId,
    'webinarId': webinarId,
    'classId': classId,
  };
}

class WaitlistCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistCountAggregateOutputTypeSelect({
    this.id,
    this.joinedAt,
    this.userId,
    this.webinarId,
    this.classId,
    this.$all,
  });

  final bool? id;

  final bool? joinedAt;

  final bool? userId;

  final bool? webinarId;

  final bool? classId;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'joinedAt': joinedAt,
    'userId': userId,
    'webinarId': webinarId,
    'classId': classId,
    '_all': $all,
  };
}

class WaitlistGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistGroupByOutputTypeCountArgs({this.select});

  final _i2.WaitlistCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class WaitlistMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistMinAggregateOutputTypeSelect({
    this.id,
    this.joinedAt,
    this.userId,
    this.webinarId,
    this.classId,
  });

  final bool? id;

  final bool? joinedAt;

  final bool? userId;

  final bool? webinarId;

  final bool? classId;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'joinedAt': joinedAt,
    'userId': userId,
    'webinarId': webinarId,
    'classId': classId,
  };
}

class WaitlistGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistGroupByOutputTypeMinArgs({this.select});

  final _i2.WaitlistMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class WaitlistMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistMaxAggregateOutputTypeSelect({
    this.id,
    this.joinedAt,
    this.userId,
    this.webinarId,
    this.classId,
  });

  final bool? id;

  final bool? joinedAt;

  final bool? userId;

  final bool? webinarId;

  final bool? classId;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'joinedAt': joinedAt,
    'userId': userId,
    'webinarId': webinarId,
    'classId': classId,
  };
}

class WaitlistGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistGroupByOutputTypeMaxArgs({this.select});

  final _i2.WaitlistMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class WaitlistGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WaitlistGroupByOutputTypeSelect({
    this.id,
    this.joinedAt,
    this.userId,
    this.webinarId,
    this.classId,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? joinedAt;

  final bool? userId;

  final bool? webinarId;

  final bool? classId;

  final _i1.PrismaUnion<bool, _i2.WaitlistGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.WaitlistGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.WaitlistGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'joinedAt': joinedAt,
    'userId': userId,
    'webinarId': webinarId,
    'classId': classId,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class AggregateWaitlist {
  const AggregateWaitlist({this.$count, this.$min, this.$max});

  factory AggregateWaitlist.fromJson(Map json) => AggregateWaitlist(
    $count: json['_count'] is Map
        ? _i2.WaitlistCountAggregateOutputType.fromJson(json['_count'])
        : null,
    $min: json['_min'] is Map
        ? _i2.WaitlistMinAggregateOutputType.fromJson(json['_min'])
        : null,
    $max: json['_max'] is Map
        ? _i2.WaitlistMaxAggregateOutputType.fromJson(json['_max'])
        : null,
  );

  final _i2.WaitlistCountAggregateOutputType? $count;

  final _i2.WaitlistMinAggregateOutputType? $min;

  final _i2.WaitlistMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    '_count': $count?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class AggregateWaitlistCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateWaitlistCountArgs({this.select});

  final _i2.WaitlistCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateWaitlistMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateWaitlistMinArgs({this.select});

  final _i2.WaitlistMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateWaitlistMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateWaitlistMaxArgs({this.select});

  final _i2.WaitlistMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateWaitlistSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateWaitlistSelect({this.$count, this.$min, this.$max});

  final _i1.PrismaUnion<bool, _i2.AggregateWaitlistCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateWaitlistMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateWaitlistMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

enum MeetingSessionScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<String>('id', 'MeetingSession'),
  streamCallId<String>('streamCallId', 'MeetingSession'),
  platform<_i3.Platform>('platform', 'MeetingSession'),
  passcode<String>('passcode', 'MeetingSession'),
  hostKeys<String>('hostKeys', 'MeetingSession'),
  slotOfAppointmentId<String>('slotOfAppointmentId', 'MeetingSession'),
  createdAt<DateTime>('createdAt', 'MeetingSession'),
  updatedAt<DateTime>('updatedAt', 'MeetingSession');

  const MeetingSessionScalar(this.name, this.model);

  @override
  final String name;

  @override
  final String model;
}

class SlotOfAppointmentCreateWithoutMeetingSessionInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentCreateWithoutMeetingSessionInput({
    this.id,
    required this.slotStartTimeInUTC,
    required this.slotEndTimeInUTC,
    this.isTentative,
    this.createdAt,
    this.updatedAt,
    this.user,
    required this.appointment,
  });

  final String? id;

  final DateTime slotStartTimeInUTC;

  final DateTime slotEndTimeInUTC;

  final bool? isTentative;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.UserCreateNestedManyWithoutSlotsOfAppointmentInput? user;

  final _i2.AppointmentCreateNestedOneWithoutSlotsOfAppointmentInput
  appointment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'isTentative': isTentative,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'user': user,
    'appointment': appointment,
  };
}

class SlotOfAppointmentUncheckedCreateWithoutMeetingSessionInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentUncheckedCreateWithoutMeetingSessionInput({
    this.id,
    required this.slotStartTimeInUTC,
    required this.slotEndTimeInUTC,
    this.isTentative,
    required this.appointmentId,
    this.createdAt,
    this.updatedAt,
    this.user,
  });

  final String? id;

  final DateTime slotStartTimeInUTC;

  final DateTime slotEndTimeInUTC;

  final bool? isTentative;

  final String appointmentId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.UserUncheckedCreateNestedManyWithoutSlotsOfAppointmentInput? user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'isTentative': isTentative,
    'appointmentId': appointmentId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'user': user,
  };
}

class SlotOfAppointmentCreateOrConnectWithoutMeetingSessionInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentCreateOrConnectWithoutMeetingSessionInput({
    required this.where,
    required this.create,
  });

  final _i2.SlotOfAppointmentWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentCreateWithoutMeetingSessionInput,
    _i2.SlotOfAppointmentUncheckedCreateWithoutMeetingSessionInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class SlotOfAppointmentCreateNestedOneWithoutMeetingSessionInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentCreateNestedOneWithoutMeetingSessionInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentCreateWithoutMeetingSessionInput,
    _i2.SlotOfAppointmentUncheckedCreateWithoutMeetingSessionInput
  >?
  create;

  final _i2.SlotOfAppointmentCreateOrConnectWithoutMeetingSessionInput?
  connectOrCreate;

  final _i2.SlotOfAppointmentWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class MeetingSessionCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const MeetingSessionCreateInput({
    this.id,
    required this.streamCallId,
    this.platform,
    this.passcode,
    this.hostKeys,
    this.createdAt,
    this.updatedAt,
    this.recordings,
    required this.slotOfAppointment,
  });

  final String? id;

  final String streamCallId;

  final _i3.Platform? platform;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? passcode;

  final _i1.PrismaUnion<
    _i2.MeetingSessionCreatehostKeysInput,
    Iterable<String>
  >?
  hostKeys;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.RecordingCreateNestedManyWithoutMeetingSessionInput? recordings;

  final _i2.SlotOfAppointmentCreateNestedOneWithoutMeetingSessionInput
  slotOfAppointment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'streamCallId': streamCallId,
    'platform': platform,
    'passcode': passcode,
    'hostKeys': hostKeys,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'recordings': recordings,
    'slotOfAppointment': slotOfAppointment,
  };
}

class MeetingSessionUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const MeetingSessionUncheckedCreateInput({
    this.id,
    required this.streamCallId,
    this.platform,
    this.passcode,
    this.hostKeys,
    required this.slotOfAppointmentId,
    this.createdAt,
    this.updatedAt,
    this.recordings,
  });

  final String? id;

  final String streamCallId;

  final _i3.Platform? platform;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? passcode;

  final _i1.PrismaUnion<
    _i2.MeetingSessionCreatehostKeysInput,
    Iterable<String>
  >?
  hostKeys;

  final String slotOfAppointmentId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.RecordingUncheckedCreateNestedManyWithoutMeetingSessionInput?
  recordings;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'streamCallId': streamCallId,
    'platform': platform,
    'passcode': passcode,
    'hostKeys': hostKeys,
    'slotOfAppointmentId': slotOfAppointmentId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'recordings': recordings,
  };
}

class MeetingSessionCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const MeetingSessionCreateManyInput({
    this.id,
    required this.streamCallId,
    this.platform,
    this.passcode,
    this.hostKeys,
    required this.slotOfAppointmentId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final String streamCallId;

  final _i3.Platform? platform;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? passcode;

  final _i1.PrismaUnion<
    _i2.MeetingSessionCreatehostKeysInput,
    Iterable<String>
  >?
  hostKeys;

  final String slotOfAppointmentId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'streamCallId': streamCallId,
    'platform': platform,
    'passcode': passcode,
    'hostKeys': hostKeys,
    'slotOfAppointmentId': slotOfAppointmentId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class SlotOfAppointmentUpdateWithoutMeetingSessionInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentUpdateWithoutMeetingSessionInput({
    this.id,
    this.slotStartTimeInUTC,
    this.slotEndTimeInUTC,
    this.isTentative,
    this.createdAt,
    this.updatedAt,
    this.user,
    this.appointment,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  slotStartTimeInUTC;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  slotEndTimeInUTC;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? isTentative;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.UserUpdateManyWithoutSlotsOfAppointmentNestedInput? user;

  final _i2.AppointmentUpdateOneRequiredWithoutSlotsOfAppointmentNestedInput?
  appointment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'isTentative': isTentative,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'user': user,
    'appointment': appointment,
  };
}

class SlotOfAppointmentUncheckedUpdateWithoutMeetingSessionInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentUncheckedUpdateWithoutMeetingSessionInput({
    this.id,
    this.slotStartTimeInUTC,
    this.slotEndTimeInUTC,
    this.isTentative,
    this.appointmentId,
    this.createdAt,
    this.updatedAt,
    this.user,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  slotStartTimeInUTC;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  slotEndTimeInUTC;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? isTentative;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  appointmentId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.UserUncheckedUpdateManyWithoutSlotsOfAppointmentNestedInput? user;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'slotStartTimeInUTC': slotStartTimeInUTC,
    'slotEndTimeInUTC': slotEndTimeInUTC,
    'isTentative': isTentative,
    'appointmentId': appointmentId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'user': user,
  };
}

class SlotOfAppointmentUpsertWithoutMeetingSessionInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentUpsertWithoutMeetingSessionInput({
    required this.update,
    required this.create,
  });

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentUpdateWithoutMeetingSessionInput,
    _i2.SlotOfAppointmentUncheckedUpdateWithoutMeetingSessionInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentCreateWithoutMeetingSessionInput,
    _i2.SlotOfAppointmentUncheckedCreateWithoutMeetingSessionInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'update': update, 'create': create};
}

class SlotOfAppointmentUpdateOneRequiredWithoutMeetingSessionNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SlotOfAppointmentUpdateOneRequiredWithoutMeetingSessionNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentCreateWithoutMeetingSessionInput,
    _i2.SlotOfAppointmentUncheckedCreateWithoutMeetingSessionInput
  >?
  create;

  final _i2.SlotOfAppointmentCreateOrConnectWithoutMeetingSessionInput?
  connectOrCreate;

  final _i2.SlotOfAppointmentUpsertWithoutMeetingSessionInput? upsert;

  final _i2.SlotOfAppointmentWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.SlotOfAppointmentUpdateWithoutMeetingSessionInput,
    _i2.SlotOfAppointmentUncheckedUpdateWithoutMeetingSessionInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'connect': connect,
    'update': update,
  };
}

class MeetingSessionUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const MeetingSessionUpdateInput({
    this.id,
    this.streamCallId,
    this.platform,
    this.passcode,
    this.hostKeys,
    this.createdAt,
    this.updatedAt,
    this.recordings,
    this.slotOfAppointment,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  streamCallId;

  final _i1.PrismaUnion<
    _i3.Platform,
    _i2.EnumPlatformFieldUpdateOperationsInput
  >?
  platform;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passcode;

  final _i1.PrismaUnion<
    _i2.MeetingSessionUpdatehostKeysInput,
    Iterable<String>
  >?
  hostKeys;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.RecordingUpdateManyWithoutMeetingSessionNestedInput? recordings;

  final _i2.SlotOfAppointmentUpdateOneRequiredWithoutMeetingSessionNestedInput?
  slotOfAppointment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'streamCallId': streamCallId,
    'platform': platform,
    'passcode': passcode,
    'hostKeys': hostKeys,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'recordings': recordings,
    'slotOfAppointment': slotOfAppointment,
  };
}

class MeetingSessionUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const MeetingSessionUncheckedUpdateInput({
    this.id,
    this.streamCallId,
    this.platform,
    this.passcode,
    this.hostKeys,
    this.slotOfAppointmentId,
    this.createdAt,
    this.updatedAt,
    this.recordings,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  streamCallId;

  final _i1.PrismaUnion<
    _i3.Platform,
    _i2.EnumPlatformFieldUpdateOperationsInput
  >?
  platform;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passcode;

  final _i1.PrismaUnion<
    _i2.MeetingSessionUpdatehostKeysInput,
    Iterable<String>
  >?
  hostKeys;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  slotOfAppointmentId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.RecordingUncheckedUpdateManyWithoutMeetingSessionNestedInput?
  recordings;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'streamCallId': streamCallId,
    'platform': platform,
    'passcode': passcode,
    'hostKeys': hostKeys,
    'slotOfAppointmentId': slotOfAppointmentId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'recordings': recordings,
  };
}

class MeetingSessionUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const MeetingSessionUpdateManyMutationInput({
    this.id,
    this.streamCallId,
    this.platform,
    this.passcode,
    this.hostKeys,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  streamCallId;

  final _i1.PrismaUnion<
    _i3.Platform,
    _i2.EnumPlatformFieldUpdateOperationsInput
  >?
  platform;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passcode;

  final _i1.PrismaUnion<
    _i2.MeetingSessionUpdatehostKeysInput,
    Iterable<String>
  >?
  hostKeys;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'streamCallId': streamCallId,
    'platform': platform,
    'passcode': passcode,
    'hostKeys': hostKeys,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class MeetingSessionUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const MeetingSessionUncheckedUpdateManyInput({
    this.id,
    this.streamCallId,
    this.platform,
    this.passcode,
    this.hostKeys,
    this.slotOfAppointmentId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  streamCallId;

  final _i1.PrismaUnion<
    _i3.Platform,
    _i2.EnumPlatformFieldUpdateOperationsInput
  >?
  platform;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passcode;

  final _i1.PrismaUnion<
    _i2.MeetingSessionUpdatehostKeysInput,
    Iterable<String>
  >?
  hostKeys;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  slotOfAppointmentId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'streamCallId': streamCallId,
    'platform': platform,
    'passcode': passcode,
    'hostKeys': hostKeys,
    'slotOfAppointmentId': slotOfAppointmentId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class MeetingSessionCountAggregateOutputType {
  const MeetingSessionCountAggregateOutputType({
    this.id,
    this.streamCallId,
    this.platform,
    this.passcode,
    this.hostKeys,
    this.slotOfAppointmentId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  factory MeetingSessionCountAggregateOutputType.fromJson(Map json) =>
      MeetingSessionCountAggregateOutputType(
        id: json['id'],
        streamCallId: json['streamCallId'],
        platform: json['platform'],
        passcode: json['passcode'],
        hostKeys: json['hostKeys'],
        slotOfAppointmentId: json['slotOfAppointmentId'],
        createdAt: json['createdAt'],
        updatedAt: json['updatedAt'],
        $all: json['_all'],
      );

  final int? id;

  final int? streamCallId;

  final int? platform;

  final int? passcode;

  final int? hostKeys;

  final int? slotOfAppointmentId;

  final int? createdAt;

  final int? updatedAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
    'id': id,
    'streamCallId': streamCallId,
    'platform': platform,
    'passcode': passcode,
    'hostKeys': hostKeys,
    'slotOfAppointmentId': slotOfAppointmentId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class MeetingSessionMinAggregateOutputType {
  const MeetingSessionMinAggregateOutputType({
    this.id,
    this.streamCallId,
    this.platform,
    this.passcode,
    this.slotOfAppointmentId,
    this.createdAt,
    this.updatedAt,
  });

  factory MeetingSessionMinAggregateOutputType.fromJson(Map json) =>
      MeetingSessionMinAggregateOutputType(
        id: json['id'],
        streamCallId: json['streamCallId'],
        platform: json['platform'] != null
            ? _i3.Platform.values.firstWhere((e) => e.name == json['platform'])
            : null,
        passcode: json['passcode'],
        slotOfAppointmentId: json['slotOfAppointmentId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final String? streamCallId;

  final _i3.Platform? platform;

  final String? passcode;

  final String? slotOfAppointmentId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'streamCallId': streamCallId,
    'platform': platform?.name,
    'passcode': passcode,
    'slotOfAppointmentId': slotOfAppointmentId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class MeetingSessionMaxAggregateOutputType {
  const MeetingSessionMaxAggregateOutputType({
    this.id,
    this.streamCallId,
    this.platform,
    this.passcode,
    this.slotOfAppointmentId,
    this.createdAt,
    this.updatedAt,
  });

  factory MeetingSessionMaxAggregateOutputType.fromJson(Map json) =>
      MeetingSessionMaxAggregateOutputType(
        id: json['id'],
        streamCallId: json['streamCallId'],
        platform: json['platform'] != null
            ? _i3.Platform.values.firstWhere((e) => e.name == json['platform'])
            : null,
        passcode: json['passcode'],
        slotOfAppointmentId: json['slotOfAppointmentId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final String? streamCallId;

  final _i3.Platform? platform;

  final String? passcode;

  final String? slotOfAppointmentId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'streamCallId': streamCallId,
    'platform': platform?.name,
    'passcode': passcode,
    'slotOfAppointmentId': slotOfAppointmentId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class MeetingSessionGroupByOutputType {
  const MeetingSessionGroupByOutputType({
    this.id,
    this.streamCallId,
    this.platform,
    this.passcode,
    this.hostKeys,
    this.slotOfAppointmentId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$min,
    this.$max,
  });

  factory MeetingSessionGroupByOutputType.fromJson(Map json) =>
      MeetingSessionGroupByOutputType(
        id: json['id'],
        streamCallId: json['streamCallId'],
        platform: json['platform'] != null
            ? _i3.Platform.values.firstWhere((e) => e.name == json['platform'])
            : null,
        passcode: json['passcode'],
        hostKeys: json['hostKeys'] is Iterable
            ? (json['hostKeys'] as Iterable).whereType<String>()
            : null,
        slotOfAppointmentId: json['slotOfAppointmentId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
        $count: json['_count'] is Map
            ? _i2.MeetingSessionCountAggregateOutputType.fromJson(
                json['_count'],
              )
            : null,
        $min: json['_min'] is Map
            ? _i2.MeetingSessionMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.MeetingSessionMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? id;

  final String? streamCallId;

  final _i3.Platform? platform;

  final String? passcode;

  final Iterable<String>? hostKeys;

  final String? slotOfAppointmentId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.MeetingSessionCountAggregateOutputType? $count;

  final _i2.MeetingSessionMinAggregateOutputType? $min;

  final _i2.MeetingSessionMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    'id': id,
    'streamCallId': streamCallId,
    'platform': platform?.name,
    'passcode': passcode,
    'hostKeys': hostKeys?.map((e) => e),
    'slotOfAppointmentId': slotOfAppointmentId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
    '_count': $count?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class MeetingSessionCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const MeetingSessionCountOrderByAggregateInput({
    this.id,
    this.streamCallId,
    this.platform,
    this.passcode,
    this.hostKeys,
    this.slotOfAppointmentId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? streamCallId;

  final _i2.SortOrder? platform;

  final _i2.SortOrder? passcode;

  final _i2.SortOrder? hostKeys;

  final _i2.SortOrder? slotOfAppointmentId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'streamCallId': streamCallId,
    'platform': platform,
    'passcode': passcode,
    'hostKeys': hostKeys,
    'slotOfAppointmentId': slotOfAppointmentId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class MeetingSessionMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const MeetingSessionMaxOrderByAggregateInput({
    this.id,
    this.streamCallId,
    this.platform,
    this.passcode,
    this.slotOfAppointmentId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? streamCallId;

  final _i2.SortOrder? platform;

  final _i2.SortOrder? passcode;

  final _i2.SortOrder? slotOfAppointmentId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'streamCallId': streamCallId,
    'platform': platform,
    'passcode': passcode,
    'slotOfAppointmentId': slotOfAppointmentId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class MeetingSessionMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const MeetingSessionMinOrderByAggregateInput({
    this.id,
    this.streamCallId,
    this.platform,
    this.passcode,
    this.slotOfAppointmentId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? streamCallId;

  final _i2.SortOrder? platform;

  final _i2.SortOrder? passcode;

  final _i2.SortOrder? slotOfAppointmentId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'streamCallId': streamCallId,
    'platform': platform,
    'passcode': passcode,
    'slotOfAppointmentId': slotOfAppointmentId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class MeetingSessionOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const MeetingSessionOrderByWithAggregationInput({
    this.id,
    this.streamCallId,
    this.platform,
    this.passcode,
    this.hostKeys,
    this.slotOfAppointmentId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$max,
    this.$min,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? streamCallId;

  final _i2.SortOrder? platform;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? passcode;

  final _i2.SortOrder? hostKeys;

  final _i2.SortOrder? slotOfAppointmentId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.MeetingSessionCountOrderByAggregateInput? $count;

  final _i2.MeetingSessionMaxOrderByAggregateInput? $max;

  final _i2.MeetingSessionMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'streamCallId': streamCallId,
    'platform': platform,
    'passcode': passcode,
    'hostKeys': hostKeys,
    'slotOfAppointmentId': slotOfAppointmentId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_max': $max,
    '_min': $min,
  };
}

class NestedEnumPlatformWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedEnumPlatformWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i3.Platform? equals;

  final _i1.PrismaUnion<Iterable<_i3.Platform>, _i3.Platform>? $in;

  final _i1.PrismaUnion<Iterable<_i3.Platform>, _i3.Platform>? notIn;

  final _i1.PrismaUnion<
    _i3.Platform,
    _i2.NestedEnumPlatformWithAggregatesFilter
  >?
  not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedEnumPlatformFilter? $min;

  final _i2.NestedEnumPlatformFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class EnumPlatformWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumPlatformWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i3.Platform? equals;

  final _i1.PrismaUnion<Iterable<_i3.Platform>, _i3.Platform>? $in;

  final _i1.PrismaUnion<Iterable<_i3.Platform>, _i3.Platform>? notIn;

  final _i1.PrismaUnion<
    _i3.Platform,
    _i2.NestedEnumPlatformWithAggregatesFilter
  >?
  not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedEnumPlatformFilter? $min;

  final _i2.NestedEnumPlatformFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class MeetingSessionScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const MeetingSessionScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.streamCallId,
    this.platform,
    this.passcode,
    this.hostKeys,
    this.slotOfAppointmentId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
    _i2.MeetingSessionScalarWhereWithAggregatesInput,
    Iterable<_i2.MeetingSessionScalarWhereWithAggregatesInput>
  >?
  AND;

  final Iterable<_i2.MeetingSessionScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<
    _i2.MeetingSessionScalarWhereWithAggregatesInput,
    Iterable<_i2.MeetingSessionScalarWhereWithAggregatesInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? streamCallId;

  final _i1.PrismaUnion<_i2.EnumPlatformWithAggregatesFilter, _i3.Platform>?
  platform;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  passcode;

  final _i2.StringNullableListFilter? hostKeys;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>?
  slotOfAppointmentId;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'streamCallId': streamCallId,
    'platform': platform,
    'passcode': passcode,
    'hostKeys': hostKeys,
    'slotOfAppointmentId': slotOfAppointmentId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class MeetingSessionCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const MeetingSessionCountAggregateOutputTypeSelect({
    this.id,
    this.streamCallId,
    this.platform,
    this.passcode,
    this.hostKeys,
    this.slotOfAppointmentId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  final bool? id;

  final bool? streamCallId;

  final bool? platform;

  final bool? passcode;

  final bool? hostKeys;

  final bool? slotOfAppointmentId;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'streamCallId': streamCallId,
    'platform': platform,
    'passcode': passcode,
    'hostKeys': hostKeys,
    'slotOfAppointmentId': slotOfAppointmentId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class MeetingSessionGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const MeetingSessionGroupByOutputTypeCountArgs({this.select});

  final _i2.MeetingSessionCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class MeetingSessionMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const MeetingSessionMinAggregateOutputTypeSelect({
    this.id,
    this.streamCallId,
    this.platform,
    this.passcode,
    this.slotOfAppointmentId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? streamCallId;

  final bool? platform;

  final bool? passcode;

  final bool? slotOfAppointmentId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'streamCallId': streamCallId,
    'platform': platform,
    'passcode': passcode,
    'slotOfAppointmentId': slotOfAppointmentId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class MeetingSessionGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const MeetingSessionGroupByOutputTypeMinArgs({this.select});

  final _i2.MeetingSessionMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class MeetingSessionMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const MeetingSessionMaxAggregateOutputTypeSelect({
    this.id,
    this.streamCallId,
    this.platform,
    this.passcode,
    this.slotOfAppointmentId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? streamCallId;

  final bool? platform;

  final bool? passcode;

  final bool? slotOfAppointmentId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'streamCallId': streamCallId,
    'platform': platform,
    'passcode': passcode,
    'slotOfAppointmentId': slotOfAppointmentId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class MeetingSessionGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const MeetingSessionGroupByOutputTypeMaxArgs({this.select});

  final _i2.MeetingSessionMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class MeetingSessionGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const MeetingSessionGroupByOutputTypeSelect({
    this.id,
    this.streamCallId,
    this.platform,
    this.passcode,
    this.hostKeys,
    this.slotOfAppointmentId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? streamCallId;

  final bool? platform;

  final bool? passcode;

  final bool? hostKeys;

  final bool? slotOfAppointmentId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.MeetingSessionGroupByOutputTypeCountArgs>?
  $count;

  final _i1.PrismaUnion<bool, _i2.MeetingSessionGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.MeetingSessionGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'streamCallId': streamCallId,
    'platform': platform,
    'passcode': passcode,
    'hostKeys': hostKeys,
    'slotOfAppointmentId': slotOfAppointmentId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class AggregateMeetingSession {
  const AggregateMeetingSession({this.$count, this.$min, this.$max});

  factory AggregateMeetingSession.fromJson(Map json) => AggregateMeetingSession(
    $count: json['_count'] is Map
        ? _i2.MeetingSessionCountAggregateOutputType.fromJson(json['_count'])
        : null,
    $min: json['_min'] is Map
        ? _i2.MeetingSessionMinAggregateOutputType.fromJson(json['_min'])
        : null,
    $max: json['_max'] is Map
        ? _i2.MeetingSessionMaxAggregateOutputType.fromJson(json['_max'])
        : null,
  );

  final _i2.MeetingSessionCountAggregateOutputType? $count;

  final _i2.MeetingSessionMinAggregateOutputType? $min;

  final _i2.MeetingSessionMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    '_count': $count?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class AggregateMeetingSessionCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateMeetingSessionCountArgs({this.select});

  final _i2.MeetingSessionCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateMeetingSessionMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateMeetingSessionMinArgs({this.select});

  final _i2.MeetingSessionMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateMeetingSessionMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateMeetingSessionMaxArgs({this.select});

  final _i2.MeetingSessionMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateMeetingSessionSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateMeetingSessionSelect({this.$count, this.$min, this.$max});

  final _i1.PrismaUnion<bool, _i2.AggregateMeetingSessionCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateMeetingSessionMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateMeetingSessionMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class MeetingSessionCreateWithoutRecordingsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const MeetingSessionCreateWithoutRecordingsInput({
    this.id,
    required this.streamCallId,
    this.platform,
    this.passcode,
    this.hostKeys,
    this.createdAt,
    this.updatedAt,
    required this.slotOfAppointment,
  });

  final String? id;

  final String streamCallId;

  final _i3.Platform? platform;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? passcode;

  final _i1.PrismaUnion<
    _i2.MeetingSessionCreatehostKeysInput,
    Iterable<String>
  >?
  hostKeys;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.SlotOfAppointmentCreateNestedOneWithoutMeetingSessionInput
  slotOfAppointment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'streamCallId': streamCallId,
    'platform': platform,
    'passcode': passcode,
    'hostKeys': hostKeys,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'slotOfAppointment': slotOfAppointment,
  };
}

class MeetingSessionUncheckedCreateWithoutRecordingsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const MeetingSessionUncheckedCreateWithoutRecordingsInput({
    this.id,
    required this.streamCallId,
    this.platform,
    this.passcode,
    this.hostKeys,
    required this.slotOfAppointmentId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final String streamCallId;

  final _i3.Platform? platform;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? passcode;

  final _i1.PrismaUnion<
    _i2.MeetingSessionCreatehostKeysInput,
    Iterable<String>
  >?
  hostKeys;

  final String slotOfAppointmentId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'streamCallId': streamCallId,
    'platform': platform,
    'passcode': passcode,
    'hostKeys': hostKeys,
    'slotOfAppointmentId': slotOfAppointmentId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class MeetingSessionCreateOrConnectWithoutRecordingsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const MeetingSessionCreateOrConnectWithoutRecordingsInput({
    required this.where,
    required this.create,
  });

  final _i2.MeetingSessionWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.MeetingSessionCreateWithoutRecordingsInput,
    _i2.MeetingSessionUncheckedCreateWithoutRecordingsInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class MeetingSessionCreateNestedOneWithoutRecordingsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const MeetingSessionCreateNestedOneWithoutRecordingsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.MeetingSessionCreateWithoutRecordingsInput,
    _i2.MeetingSessionUncheckedCreateWithoutRecordingsInput
  >?
  create;

  final _i2.MeetingSessionCreateOrConnectWithoutRecordingsInput?
  connectOrCreate;

  final _i2.MeetingSessionWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'connect': connect,
  };
}

class RecordingCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const RecordingCreateInput({
    this.id,
    required this.title,
    required this.recordingUrl,
    required this.durationInMinutes,
    required this.recordedAt,
    this.createdAt,
    this.updatedAt,
    required this.meetingSession,
  });

  final String? id;

  final String title;

  final String recordingUrl;

  final int durationInMinutes;

  final DateTime recordedAt;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.MeetingSessionCreateNestedOneWithoutRecordingsInput meetingSession;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'recordingUrl': recordingUrl,
    'durationInMinutes': durationInMinutes,
    'recordedAt': recordedAt,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'meetingSession': meetingSession,
  };
}

class RecordingUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const RecordingUncheckedCreateInput({
    this.id,
    required this.title,
    required this.recordingUrl,
    required this.durationInMinutes,
    required this.recordedAt,
    required this.meetingSessionId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final String title;

  final String recordingUrl;

  final int durationInMinutes;

  final DateTime recordedAt;

  final String meetingSessionId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'recordingUrl': recordingUrl,
    'durationInMinutes': durationInMinutes,
    'recordedAt': recordedAt,
    'meetingSessionId': meetingSessionId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class RecordingCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const RecordingCreateManyInput({
    this.id,
    required this.title,
    required this.recordingUrl,
    required this.durationInMinutes,
    required this.recordedAt,
    required this.meetingSessionId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final String title;

  final String recordingUrl;

  final int durationInMinutes;

  final DateTime recordedAt;

  final String meetingSessionId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'recordingUrl': recordingUrl,
    'durationInMinutes': durationInMinutes,
    'recordedAt': recordedAt,
    'meetingSessionId': meetingSessionId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class MeetingSessionUpdateWithoutRecordingsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const MeetingSessionUpdateWithoutRecordingsInput({
    this.id,
    this.streamCallId,
    this.platform,
    this.passcode,
    this.hostKeys,
    this.createdAt,
    this.updatedAt,
    this.slotOfAppointment,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  streamCallId;

  final _i1.PrismaUnion<
    _i3.Platform,
    _i2.EnumPlatformFieldUpdateOperationsInput
  >?
  platform;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passcode;

  final _i1.PrismaUnion<
    _i2.MeetingSessionUpdatehostKeysInput,
    Iterable<String>
  >?
  hostKeys;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.SlotOfAppointmentUpdateOneRequiredWithoutMeetingSessionNestedInput?
  slotOfAppointment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'streamCallId': streamCallId,
    'platform': platform,
    'passcode': passcode,
    'hostKeys': hostKeys,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'slotOfAppointment': slotOfAppointment,
  };
}

class MeetingSessionUncheckedUpdateWithoutRecordingsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const MeetingSessionUncheckedUpdateWithoutRecordingsInput({
    this.id,
    this.streamCallId,
    this.platform,
    this.passcode,
    this.hostKeys,
    this.slotOfAppointmentId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  streamCallId;

  final _i1.PrismaUnion<
    _i3.Platform,
    _i2.EnumPlatformFieldUpdateOperationsInput
  >?
  platform;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  passcode;

  final _i1.PrismaUnion<
    _i2.MeetingSessionUpdatehostKeysInput,
    Iterable<String>
  >?
  hostKeys;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  slotOfAppointmentId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'streamCallId': streamCallId,
    'platform': platform,
    'passcode': passcode,
    'hostKeys': hostKeys,
    'slotOfAppointmentId': slotOfAppointmentId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class MeetingSessionUpsertWithoutRecordingsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const MeetingSessionUpsertWithoutRecordingsInput({
    required this.update,
    required this.create,
  });

  final _i1.PrismaUnion<
    _i2.MeetingSessionUpdateWithoutRecordingsInput,
    _i2.MeetingSessionUncheckedUpdateWithoutRecordingsInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.MeetingSessionCreateWithoutRecordingsInput,
    _i2.MeetingSessionUncheckedCreateWithoutRecordingsInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'update': update, 'create': create};
}

class MeetingSessionUpdateOneRequiredWithoutRecordingsNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const MeetingSessionUpdateOneRequiredWithoutRecordingsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
    _i2.MeetingSessionCreateWithoutRecordingsInput,
    _i2.MeetingSessionUncheckedCreateWithoutRecordingsInput
  >?
  create;

  final _i2.MeetingSessionCreateOrConnectWithoutRecordingsInput?
  connectOrCreate;

  final _i2.MeetingSessionUpsertWithoutRecordingsInput? upsert;

  final _i2.MeetingSessionWhereUniqueInput? connect;

  final _i1.PrismaUnion<
    _i2.MeetingSessionUpdateWithoutRecordingsInput,
    _i2.MeetingSessionUncheckedUpdateWithoutRecordingsInput
  >?
  update;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'connect': connect,
    'update': update,
  };
}

class RecordingUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const RecordingUpdateInput({
    this.id,
    this.title,
    this.recordingUrl,
    this.durationInMinutes,
    this.recordedAt,
    this.createdAt,
    this.updatedAt,
    this.meetingSession,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  recordingUrl;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
  durationInMinutes;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  recordedAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.MeetingSessionUpdateOneRequiredWithoutRecordingsNestedInput?
  meetingSession;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'recordingUrl': recordingUrl,
    'durationInMinutes': durationInMinutes,
    'recordedAt': recordedAt,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'meetingSession': meetingSession,
  };
}

class RecordingUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const RecordingUncheckedUpdateInput({
    this.id,
    this.title,
    this.recordingUrl,
    this.durationInMinutes,
    this.recordedAt,
    this.meetingSessionId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  recordingUrl;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
  durationInMinutes;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  recordedAt;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  meetingSessionId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'recordingUrl': recordingUrl,
    'durationInMinutes': durationInMinutes,
    'recordedAt': recordedAt,
    'meetingSessionId': meetingSessionId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class RecordingUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const RecordingUncheckedUpdateManyInput({
    this.id,
    this.title,
    this.recordingUrl,
    this.durationInMinutes,
    this.recordedAt,
    this.meetingSessionId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? title;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  recordingUrl;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
  durationInMinutes;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  recordedAt;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  meetingSessionId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'recordingUrl': recordingUrl,
    'durationInMinutes': durationInMinutes,
    'recordedAt': recordedAt,
    'meetingSessionId': meetingSessionId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class RecordingCountAggregateOutputType {
  const RecordingCountAggregateOutputType({
    this.id,
    this.title,
    this.recordingUrl,
    this.durationInMinutes,
    this.recordedAt,
    this.meetingSessionId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  factory RecordingCountAggregateOutputType.fromJson(Map json) =>
      RecordingCountAggregateOutputType(
        id: json['id'],
        title: json['title'],
        recordingUrl: json['recordingUrl'],
        durationInMinutes: json['durationInMinutes'],
        recordedAt: json['recordedAt'],
        meetingSessionId: json['meetingSessionId'],
        createdAt: json['createdAt'],
        updatedAt: json['updatedAt'],
        $all: json['_all'],
      );

  final int? id;

  final int? title;

  final int? recordingUrl;

  final int? durationInMinutes;

  final int? recordedAt;

  final int? meetingSessionId;

  final int? createdAt;

  final int? updatedAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'recordingUrl': recordingUrl,
    'durationInMinutes': durationInMinutes,
    'recordedAt': recordedAt,
    'meetingSessionId': meetingSessionId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class RecordingAvgAggregateOutputType {
  const RecordingAvgAggregateOutputType({this.durationInMinutes});

  factory RecordingAvgAggregateOutputType.fromJson(Map json) =>
      RecordingAvgAggregateOutputType(
        durationInMinutes: json['durationInMinutes'],
      );

  final double? durationInMinutes;

  Map<String, dynamic> toJson() => {'durationInMinutes': durationInMinutes};
}

class RecordingSumAggregateOutputType {
  const RecordingSumAggregateOutputType({this.durationInMinutes});

  factory RecordingSumAggregateOutputType.fromJson(Map json) =>
      RecordingSumAggregateOutputType(
        durationInMinutes: json['durationInMinutes'],
      );

  final int? durationInMinutes;

  Map<String, dynamic> toJson() => {'durationInMinutes': durationInMinutes};
}

class RecordingMinAggregateOutputType {
  const RecordingMinAggregateOutputType({
    this.id,
    this.title,
    this.recordingUrl,
    this.durationInMinutes,
    this.recordedAt,
    this.meetingSessionId,
    this.createdAt,
    this.updatedAt,
  });

  factory RecordingMinAggregateOutputType.fromJson(Map json) =>
      RecordingMinAggregateOutputType(
        id: json['id'],
        title: json['title'],
        recordingUrl: json['recordingUrl'],
        durationInMinutes: json['durationInMinutes'],
        recordedAt: switch (json['recordedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['recordedAt'],
        },
        meetingSessionId: json['meetingSessionId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final String? title;

  final String? recordingUrl;

  final int? durationInMinutes;

  final DateTime? recordedAt;

  final String? meetingSessionId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'recordingUrl': recordingUrl,
    'durationInMinutes': durationInMinutes,
    'recordedAt': recordedAt?.toIso8601String(),
    'meetingSessionId': meetingSessionId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class RecordingMaxAggregateOutputType {
  const RecordingMaxAggregateOutputType({
    this.id,
    this.title,
    this.recordingUrl,
    this.durationInMinutes,
    this.recordedAt,
    this.meetingSessionId,
    this.createdAt,
    this.updatedAt,
  });

  factory RecordingMaxAggregateOutputType.fromJson(Map json) =>
      RecordingMaxAggregateOutputType(
        id: json['id'],
        title: json['title'],
        recordingUrl: json['recordingUrl'],
        durationInMinutes: json['durationInMinutes'],
        recordedAt: switch (json['recordedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['recordedAt'],
        },
        meetingSessionId: json['meetingSessionId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final String? title;

  final String? recordingUrl;

  final int? durationInMinutes;

  final DateTime? recordedAt;

  final String? meetingSessionId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'recordingUrl': recordingUrl,
    'durationInMinutes': durationInMinutes,
    'recordedAt': recordedAt?.toIso8601String(),
    'meetingSessionId': meetingSessionId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class RecordingGroupByOutputType {
  const RecordingGroupByOutputType({
    this.id,
    this.title,
    this.recordingUrl,
    this.durationInMinutes,
    this.recordedAt,
    this.meetingSessionId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory RecordingGroupByOutputType.fromJson(Map json) =>
      RecordingGroupByOutputType(
        id: json['id'],
        title: json['title'],
        recordingUrl: json['recordingUrl'],
        durationInMinutes: json['durationInMinutes'],
        recordedAt: switch (json['recordedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['recordedAt'],
        },
        meetingSessionId: json['meetingSessionId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
        $count: json['_count'] is Map
            ? _i2.RecordingCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.RecordingAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.RecordingSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.RecordingMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.RecordingMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? id;

  final String? title;

  final String? recordingUrl;

  final int? durationInMinutes;

  final DateTime? recordedAt;

  final String? meetingSessionId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.RecordingCountAggregateOutputType? $count;

  final _i2.RecordingAvgAggregateOutputType? $avg;

  final _i2.RecordingSumAggregateOutputType? $sum;

  final _i2.RecordingMinAggregateOutputType? $min;

  final _i2.RecordingMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'recordingUrl': recordingUrl,
    'durationInMinutes': durationInMinutes,
    'recordedAt': recordedAt?.toIso8601String(),
    'meetingSessionId': meetingSessionId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
    '_count': $count?.toJson(),
    '_avg': $avg?.toJson(),
    '_sum': $sum?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class RecordingCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const RecordingCountOrderByAggregateInput({
    this.id,
    this.title,
    this.recordingUrl,
    this.durationInMinutes,
    this.recordedAt,
    this.meetingSessionId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? title;

  final _i2.SortOrder? recordingUrl;

  final _i2.SortOrder? durationInMinutes;

  final _i2.SortOrder? recordedAt;

  final _i2.SortOrder? meetingSessionId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'recordingUrl': recordingUrl,
    'durationInMinutes': durationInMinutes,
    'recordedAt': recordedAt,
    'meetingSessionId': meetingSessionId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class RecordingAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const RecordingAvgOrderByAggregateInput({this.durationInMinutes});

  final _i2.SortOrder? durationInMinutes;

  @override
  Map<String, dynamic> toJson() => {'durationInMinutes': durationInMinutes};
}

class RecordingMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const RecordingMaxOrderByAggregateInput({
    this.id,
    this.title,
    this.recordingUrl,
    this.durationInMinutes,
    this.recordedAt,
    this.meetingSessionId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? title;

  final _i2.SortOrder? recordingUrl;

  final _i2.SortOrder? durationInMinutes;

  final _i2.SortOrder? recordedAt;

  final _i2.SortOrder? meetingSessionId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'recordingUrl': recordingUrl,
    'durationInMinutes': durationInMinutes,
    'recordedAt': recordedAt,
    'meetingSessionId': meetingSessionId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class RecordingMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const RecordingMinOrderByAggregateInput({
    this.id,
    this.title,
    this.recordingUrl,
    this.durationInMinutes,
    this.recordedAt,
    this.meetingSessionId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? title;

  final _i2.SortOrder? recordingUrl;

  final _i2.SortOrder? durationInMinutes;

  final _i2.SortOrder? recordedAt;

  final _i2.SortOrder? meetingSessionId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'recordingUrl': recordingUrl,
    'durationInMinutes': durationInMinutes,
    'recordedAt': recordedAt,
    'meetingSessionId': meetingSessionId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class RecordingSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const RecordingSumOrderByAggregateInput({this.durationInMinutes});

  final _i2.SortOrder? durationInMinutes;

  @override
  Map<String, dynamic> toJson() => {'durationInMinutes': durationInMinutes};
}

class RecordingOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const RecordingOrderByWithAggregationInput({
    this.id,
    this.title,
    this.recordingUrl,
    this.durationInMinutes,
    this.recordedAt,
    this.meetingSessionId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? title;

  final _i2.SortOrder? recordingUrl;

  final _i2.SortOrder? durationInMinutes;

  final _i2.SortOrder? recordedAt;

  final _i2.SortOrder? meetingSessionId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.RecordingCountOrderByAggregateInput? $count;

  final _i2.RecordingAvgOrderByAggregateInput? $avg;

  final _i2.RecordingMaxOrderByAggregateInput? $max;

  final _i2.RecordingMinOrderByAggregateInput? $min;

  final _i2.RecordingSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'recordingUrl': recordingUrl,
    'durationInMinutes': durationInMinutes,
    'recordedAt': recordedAt,
    'meetingSessionId': meetingSessionId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_avg': $avg,
    '_max': $max,
    '_min': $min,
    '_sum': $sum,
  };
}

class RecordingScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const RecordingScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.title,
    this.recordingUrl,
    this.durationInMinutes,
    this.recordedAt,
    this.meetingSessionId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
    _i2.RecordingScalarWhereWithAggregatesInput,
    Iterable<_i2.RecordingScalarWhereWithAggregatesInput>
  >?
  AND;

  final Iterable<_i2.RecordingScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<
    _i2.RecordingScalarWhereWithAggregatesInput,
    Iterable<_i2.RecordingScalarWhereWithAggregatesInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? title;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? recordingUrl;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? durationInMinutes;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? recordedAt;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>?
  meetingSessionId;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'title': title,
    'recordingUrl': recordingUrl,
    'durationInMinutes': durationInMinutes,
    'recordedAt': recordedAt,
    'meetingSessionId': meetingSessionId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class RecordingCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const RecordingCountAggregateOutputTypeSelect({
    this.id,
    this.title,
    this.recordingUrl,
    this.durationInMinutes,
    this.recordedAt,
    this.meetingSessionId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  final bool? id;

  final bool? title;

  final bool? recordingUrl;

  final bool? durationInMinutes;

  final bool? recordedAt;

  final bool? meetingSessionId;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'recordingUrl': recordingUrl,
    'durationInMinutes': durationInMinutes,
    'recordedAt': recordedAt,
    'meetingSessionId': meetingSessionId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class RecordingGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const RecordingGroupByOutputTypeCountArgs({this.select});

  final _i2.RecordingCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class RecordingAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const RecordingAvgAggregateOutputTypeSelect({this.durationInMinutes});

  final bool? durationInMinutes;

  @override
  Map<String, dynamic> toJson() => {'durationInMinutes': durationInMinutes};
}

class RecordingGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const RecordingGroupByOutputTypeAvgArgs({this.select});

  final _i2.RecordingAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class RecordingSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const RecordingSumAggregateOutputTypeSelect({this.durationInMinutes});

  final bool? durationInMinutes;

  @override
  Map<String, dynamic> toJson() => {'durationInMinutes': durationInMinutes};
}

class RecordingGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const RecordingGroupByOutputTypeSumArgs({this.select});

  final _i2.RecordingSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class RecordingMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const RecordingMinAggregateOutputTypeSelect({
    this.id,
    this.title,
    this.recordingUrl,
    this.durationInMinutes,
    this.recordedAt,
    this.meetingSessionId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? title;

  final bool? recordingUrl;

  final bool? durationInMinutes;

  final bool? recordedAt;

  final bool? meetingSessionId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'recordingUrl': recordingUrl,
    'durationInMinutes': durationInMinutes,
    'recordedAt': recordedAt,
    'meetingSessionId': meetingSessionId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class RecordingGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const RecordingGroupByOutputTypeMinArgs({this.select});

  final _i2.RecordingMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class RecordingMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const RecordingMaxAggregateOutputTypeSelect({
    this.id,
    this.title,
    this.recordingUrl,
    this.durationInMinutes,
    this.recordedAt,
    this.meetingSessionId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? title;

  final bool? recordingUrl;

  final bool? durationInMinutes;

  final bool? recordedAt;

  final bool? meetingSessionId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'recordingUrl': recordingUrl,
    'durationInMinutes': durationInMinutes,
    'recordedAt': recordedAt,
    'meetingSessionId': meetingSessionId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class RecordingGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const RecordingGroupByOutputTypeMaxArgs({this.select});

  final _i2.RecordingMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class RecordingGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const RecordingGroupByOutputTypeSelect({
    this.id,
    this.title,
    this.recordingUrl,
    this.durationInMinutes,
    this.recordedAt,
    this.meetingSessionId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? title;

  final bool? recordingUrl;

  final bool? durationInMinutes;

  final bool? recordedAt;

  final bool? meetingSessionId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.RecordingGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.RecordingGroupByOutputTypeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.RecordingGroupByOutputTypeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.RecordingGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.RecordingGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'recordingUrl': recordingUrl,
    'durationInMinutes': durationInMinutes,
    'recordedAt': recordedAt,
    'meetingSessionId': meetingSessionId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_avg': $avg,
    '_sum': $sum,
    '_min': $min,
    '_max': $max,
  };
}

class AggregateRecording {
  const AggregateRecording({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateRecording.fromJson(Map json) => AggregateRecording(
    $count: json['_count'] is Map
        ? _i2.RecordingCountAggregateOutputType.fromJson(json['_count'])
        : null,
    $avg: json['_avg'] is Map
        ? _i2.RecordingAvgAggregateOutputType.fromJson(json['_avg'])
        : null,
    $sum: json['_sum'] is Map
        ? _i2.RecordingSumAggregateOutputType.fromJson(json['_sum'])
        : null,
    $min: json['_min'] is Map
        ? _i2.RecordingMinAggregateOutputType.fromJson(json['_min'])
        : null,
    $max: json['_max'] is Map
        ? _i2.RecordingMaxAggregateOutputType.fromJson(json['_max'])
        : null,
  );

  final _i2.RecordingCountAggregateOutputType? $count;

  final _i2.RecordingAvgAggregateOutputType? $avg;

  final _i2.RecordingSumAggregateOutputType? $sum;

  final _i2.RecordingMinAggregateOutputType? $min;

  final _i2.RecordingMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    '_count': $count?.toJson(),
    '_avg': $avg?.toJson(),
    '_sum': $sum?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class AggregateRecordingCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateRecordingCountArgs({this.select});

  final _i2.RecordingCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateRecordingAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateRecordingAvgArgs({this.select});

  final _i2.RecordingAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateRecordingSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateRecordingSumArgs({this.select});

  final _i2.RecordingSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateRecordingMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateRecordingMinArgs({this.select});

  final _i2.RecordingMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateRecordingMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateRecordingMaxArgs({this.select});

  final _i2.RecordingMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateRecordingSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateRecordingSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateRecordingCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateRecordingAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateRecordingSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateRecordingMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateRecordingMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    '_count': $count,
    '_avg': $avg,
    '_sum': $sum,
    '_min': $min,
    '_max': $max,
  };
}

class PaymentCreateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentCreateInput({
    this.id,
    required this.amount,
    required this.currency,
    this.description,
    this.receiptUrl,
    required this.paymentMethod,
    required this.paymentIntent,
    required this.paymentGateway,
    required this.paymentStatus,
    this.expiresAt,
    this.createdAt,
    this.updatedAt,
    required this.user,
    this.appointment,
    this.discountCode,
  });

  final String? id;

  final int amount;

  final String currency;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? receiptUrl;

  final String paymentMethod;

  final String paymentIntent;

  final _i3.PaymentGateway paymentGateway;

  final _i3.PaymentStatus paymentStatus;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? expiresAt;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.UserCreateNestedOneWithoutPaymentInput user;

  final _i2.AppointmentCreateNestedOneWithoutPaymentInput? appointment;

  final _i2.DiscountCodeCreateNestedOneWithoutPaymentInput? discountCode;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'amount': amount,
    'currency': currency,
    'description': description,
    'receiptUrl': receiptUrl,
    'paymentMethod': paymentMethod,
    'paymentIntent': paymentIntent,
    'paymentGateway': paymentGateway,
    'paymentStatus': paymentStatus,
    'expiresAt': expiresAt,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'user': user,
    'appointment': appointment,
    'discountCode': discountCode,
  };
}

class PaymentUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentUncheckedCreateInput({
    this.id,
    required this.amount,
    required this.currency,
    this.description,
    this.receiptUrl,
    required this.paymentMethod,
    required this.paymentIntent,
    required this.paymentGateway,
    required this.paymentStatus,
    this.expiresAt,
    required this.userId,
    this.appointmentId,
    this.discountCodeId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final int amount;

  final String currency;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? receiptUrl;

  final String paymentMethod;

  final String paymentIntent;

  final _i3.PaymentGateway paymentGateway;

  final _i3.PaymentStatus paymentStatus;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? expiresAt;

  final String userId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? appointmentId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? discountCodeId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'amount': amount,
    'currency': currency,
    'description': description,
    'receiptUrl': receiptUrl,
    'paymentMethod': paymentMethod,
    'paymentIntent': paymentIntent,
    'paymentGateway': paymentGateway,
    'paymentStatus': paymentStatus,
    'expiresAt': expiresAt,
    'userId': userId,
    'appointmentId': appointmentId,
    'discountCodeId': discountCodeId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class PaymentCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentCreateManyInput({
    this.id,
    required this.amount,
    required this.currency,
    this.description,
    this.receiptUrl,
    required this.paymentMethod,
    required this.paymentIntent,
    required this.paymentGateway,
    required this.paymentStatus,
    this.expiresAt,
    required this.userId,
    this.appointmentId,
    this.discountCodeId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final int amount;

  final String currency;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? receiptUrl;

  final String paymentMethod;

  final String paymentIntent;

  final _i3.PaymentGateway paymentGateway;

  final _i3.PaymentStatus paymentStatus;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? expiresAt;

  final String userId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? appointmentId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? discountCodeId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'amount': amount,
    'currency': currency,
    'description': description,
    'receiptUrl': receiptUrl,
    'paymentMethod': paymentMethod,
    'paymentIntent': paymentIntent,
    'paymentGateway': paymentGateway,
    'paymentStatus': paymentStatus,
    'expiresAt': expiresAt,
    'userId': userId,
    'appointmentId': appointmentId,
    'discountCodeId': discountCodeId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class PaymentUpdateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentUpdateInput({
    this.id,
    this.amount,
    this.currency,
    this.description,
    this.receiptUrl,
    this.paymentMethod,
    this.paymentIntent,
    this.paymentGateway,
    this.paymentStatus,
    this.expiresAt,
    this.createdAt,
    this.updatedAt,
    this.user,
    this.appointment,
    this.discountCode,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? amount;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? currency;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  receiptUrl;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  paymentMethod;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  paymentIntent;

  final _i1.PrismaUnion<
    _i3.PaymentGateway,
    _i2.EnumPaymentGatewayFieldUpdateOperationsInput
  >?
  paymentGateway;

  final _i1.PrismaUnion<
    _i3.PaymentStatus,
    _i2.EnumPaymentStatusFieldUpdateOperationsInput
  >?
  paymentStatus;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  expiresAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.UserUpdateOneRequiredWithoutPaymentNestedInput? user;

  final _i2.AppointmentUpdateOneWithoutPaymentNestedInput? appointment;

  final _i2.DiscountCodeUpdateOneWithoutPaymentNestedInput? discountCode;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'amount': amount,
    'currency': currency,
    'description': description,
    'receiptUrl': receiptUrl,
    'paymentMethod': paymentMethod,
    'paymentIntent': paymentIntent,
    'paymentGateway': paymentGateway,
    'paymentStatus': paymentStatus,
    'expiresAt': expiresAt,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'user': user,
    'appointment': appointment,
    'discountCode': discountCode,
  };
}

class PaymentUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentUncheckedUpdateInput({
    this.id,
    this.amount,
    this.currency,
    this.description,
    this.receiptUrl,
    this.paymentMethod,
    this.paymentIntent,
    this.paymentGateway,
    this.paymentStatus,
    this.expiresAt,
    this.userId,
    this.appointmentId,
    this.discountCodeId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? amount;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? currency;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  receiptUrl;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  paymentMethod;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  paymentIntent;

  final _i1.PrismaUnion<
    _i3.PaymentGateway,
    _i2.EnumPaymentGatewayFieldUpdateOperationsInput
  >?
  paymentGateway;

  final _i1.PrismaUnion<
    _i3.PaymentStatus,
    _i2.EnumPaymentStatusFieldUpdateOperationsInput
  >?
  paymentStatus;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  expiresAt;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  appointmentId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  discountCodeId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'amount': amount,
    'currency': currency,
    'description': description,
    'receiptUrl': receiptUrl,
    'paymentMethod': paymentMethod,
    'paymentIntent': paymentIntent,
    'paymentGateway': paymentGateway,
    'paymentStatus': paymentStatus,
    'expiresAt': expiresAt,
    'userId': userId,
    'appointmentId': appointmentId,
    'discountCodeId': discountCodeId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class PaymentUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentUncheckedUpdateManyInput({
    this.id,
    this.amount,
    this.currency,
    this.description,
    this.receiptUrl,
    this.paymentMethod,
    this.paymentIntent,
    this.paymentGateway,
    this.paymentStatus,
    this.expiresAt,
    this.userId,
    this.appointmentId,
    this.discountCodeId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? amount;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? currency;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  receiptUrl;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  paymentMethod;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  paymentIntent;

  final _i1.PrismaUnion<
    _i3.PaymentGateway,
    _i2.EnumPaymentGatewayFieldUpdateOperationsInput
  >?
  paymentGateway;

  final _i1.PrismaUnion<
    _i3.PaymentStatus,
    _i2.EnumPaymentStatusFieldUpdateOperationsInput
  >?
  paymentStatus;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  expiresAt;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  appointmentId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  discountCodeId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'amount': amount,
    'currency': currency,
    'description': description,
    'receiptUrl': receiptUrl,
    'paymentMethod': paymentMethod,
    'paymentIntent': paymentIntent,
    'paymentGateway': paymentGateway,
    'paymentStatus': paymentStatus,
    'expiresAt': expiresAt,
    'userId': userId,
    'appointmentId': appointmentId,
    'discountCodeId': discountCodeId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class PaymentCountAggregateOutputType {
  const PaymentCountAggregateOutputType({
    this.id,
    this.amount,
    this.currency,
    this.description,
    this.receiptUrl,
    this.paymentMethod,
    this.paymentIntent,
    this.paymentGateway,
    this.paymentStatus,
    this.expiresAt,
    this.userId,
    this.appointmentId,
    this.discountCodeId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  factory PaymentCountAggregateOutputType.fromJson(Map json) =>
      PaymentCountAggregateOutputType(
        id: json['id'],
        amount: json['amount'],
        currency: json['currency'],
        description: json['description'],
        receiptUrl: json['receiptUrl'],
        paymentMethod: json['paymentMethod'],
        paymentIntent: json['paymentIntent'],
        paymentGateway: json['paymentGateway'],
        paymentStatus: json['paymentStatus'],
        expiresAt: json['expiresAt'],
        userId: json['userId'],
        appointmentId: json['appointmentId'],
        discountCodeId: json['discountCodeId'],
        createdAt: json['createdAt'],
        updatedAt: json['updatedAt'],
        $all: json['_all'],
      );

  final int? id;

  final int? amount;

  final int? currency;

  final int? description;

  final int? receiptUrl;

  final int? paymentMethod;

  final int? paymentIntent;

  final int? paymentGateway;

  final int? paymentStatus;

  final int? expiresAt;

  final int? userId;

  final int? appointmentId;

  final int? discountCodeId;

  final int? createdAt;

  final int? updatedAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
    'id': id,
    'amount': amount,
    'currency': currency,
    'description': description,
    'receiptUrl': receiptUrl,
    'paymentMethod': paymentMethod,
    'paymentIntent': paymentIntent,
    'paymentGateway': paymentGateway,
    'paymentStatus': paymentStatus,
    'expiresAt': expiresAt,
    'userId': userId,
    'appointmentId': appointmentId,
    'discountCodeId': discountCodeId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class PaymentAvgAggregateOutputType {
  const PaymentAvgAggregateOutputType({this.amount});

  factory PaymentAvgAggregateOutputType.fromJson(Map json) =>
      PaymentAvgAggregateOutputType(amount: json['amount']);

  final double? amount;

  Map<String, dynamic> toJson() => {'amount': amount};
}

class PaymentSumAggregateOutputType {
  const PaymentSumAggregateOutputType({this.amount});

  factory PaymentSumAggregateOutputType.fromJson(Map json) =>
      PaymentSumAggregateOutputType(amount: json['amount']);

  final int? amount;

  Map<String, dynamic> toJson() => {'amount': amount};
}

class PaymentMinAggregateOutputType {
  const PaymentMinAggregateOutputType({
    this.id,
    this.amount,
    this.currency,
    this.description,
    this.receiptUrl,
    this.paymentMethod,
    this.paymentIntent,
    this.paymentGateway,
    this.paymentStatus,
    this.expiresAt,
    this.userId,
    this.appointmentId,
    this.discountCodeId,
    this.createdAt,
    this.updatedAt,
  });

  factory PaymentMinAggregateOutputType.fromJson(Map json) =>
      PaymentMinAggregateOutputType(
        id: json['id'],
        amount: json['amount'],
        currency: json['currency'],
        description: json['description'],
        receiptUrl: json['receiptUrl'],
        paymentMethod: json['paymentMethod'],
        paymentIntent: json['paymentIntent'],
        paymentGateway: json['paymentGateway'] != null
            ? _i3.PaymentGateway.values.firstWhere(
                (e) => e.name == json['paymentGateway'],
              )
            : null,
        paymentStatus: json['paymentStatus'] != null
            ? _i3.PaymentStatus.values.firstWhere(
                (e) => e.name == json['paymentStatus'],
              )
            : null,
        expiresAt: switch (json['expiresAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['expiresAt'],
        },
        userId: json['userId'],
        appointmentId: json['appointmentId'],
        discountCodeId: json['discountCodeId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final int? amount;

  final String? currency;

  final String? description;

  final String? receiptUrl;

  final String? paymentMethod;

  final String? paymentIntent;

  final _i3.PaymentGateway? paymentGateway;

  final _i3.PaymentStatus? paymentStatus;

  final DateTime? expiresAt;

  final String? userId;

  final String? appointmentId;

  final String? discountCodeId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'amount': amount,
    'currency': currency,
    'description': description,
    'receiptUrl': receiptUrl,
    'paymentMethod': paymentMethod,
    'paymentIntent': paymentIntent,
    'paymentGateway': paymentGateway?.name,
    'paymentStatus': paymentStatus?.name,
    'expiresAt': expiresAt?.toIso8601String(),
    'userId': userId,
    'appointmentId': appointmentId,
    'discountCodeId': discountCodeId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class PaymentMaxAggregateOutputType {
  const PaymentMaxAggregateOutputType({
    this.id,
    this.amount,
    this.currency,
    this.description,
    this.receiptUrl,
    this.paymentMethod,
    this.paymentIntent,
    this.paymentGateway,
    this.paymentStatus,
    this.expiresAt,
    this.userId,
    this.appointmentId,
    this.discountCodeId,
    this.createdAt,
    this.updatedAt,
  });

  factory PaymentMaxAggregateOutputType.fromJson(Map json) =>
      PaymentMaxAggregateOutputType(
        id: json['id'],
        amount: json['amount'],
        currency: json['currency'],
        description: json['description'],
        receiptUrl: json['receiptUrl'],
        paymentMethod: json['paymentMethod'],
        paymentIntent: json['paymentIntent'],
        paymentGateway: json['paymentGateway'] != null
            ? _i3.PaymentGateway.values.firstWhere(
                (e) => e.name == json['paymentGateway'],
              )
            : null,
        paymentStatus: json['paymentStatus'] != null
            ? _i3.PaymentStatus.values.firstWhere(
                (e) => e.name == json['paymentStatus'],
              )
            : null,
        expiresAt: switch (json['expiresAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['expiresAt'],
        },
        userId: json['userId'],
        appointmentId: json['appointmentId'],
        discountCodeId: json['discountCodeId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final int? amount;

  final String? currency;

  final String? description;

  final String? receiptUrl;

  final String? paymentMethod;

  final String? paymentIntent;

  final _i3.PaymentGateway? paymentGateway;

  final _i3.PaymentStatus? paymentStatus;

  final DateTime? expiresAt;

  final String? userId;

  final String? appointmentId;

  final String? discountCodeId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'amount': amount,
    'currency': currency,
    'description': description,
    'receiptUrl': receiptUrl,
    'paymentMethod': paymentMethod,
    'paymentIntent': paymentIntent,
    'paymentGateway': paymentGateway?.name,
    'paymentStatus': paymentStatus?.name,
    'expiresAt': expiresAt?.toIso8601String(),
    'userId': userId,
    'appointmentId': appointmentId,
    'discountCodeId': discountCodeId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class PaymentGroupByOutputType {
  const PaymentGroupByOutputType({
    this.id,
    this.amount,
    this.currency,
    this.description,
    this.receiptUrl,
    this.paymentMethod,
    this.paymentIntent,
    this.paymentGateway,
    this.paymentStatus,
    this.expiresAt,
    this.userId,
    this.appointmentId,
    this.discountCodeId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory PaymentGroupByOutputType.fromJson(Map json) =>
      PaymentGroupByOutputType(
        id: json['id'],
        amount: json['amount'],
        currency: json['currency'],
        description: json['description'],
        receiptUrl: json['receiptUrl'],
        paymentMethod: json['paymentMethod'],
        paymentIntent: json['paymentIntent'],
        paymentGateway: json['paymentGateway'] != null
            ? _i3.PaymentGateway.values.firstWhere(
                (e) => e.name == json['paymentGateway'],
              )
            : null,
        paymentStatus: json['paymentStatus'] != null
            ? _i3.PaymentStatus.values.firstWhere(
                (e) => e.name == json['paymentStatus'],
              )
            : null,
        expiresAt: switch (json['expiresAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['expiresAt'],
        },
        userId: json['userId'],
        appointmentId: json['appointmentId'],
        discountCodeId: json['discountCodeId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
        $count: json['_count'] is Map
            ? _i2.PaymentCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.PaymentAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.PaymentSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.PaymentMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.PaymentMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? id;

  final int? amount;

  final String? currency;

  final String? description;

  final String? receiptUrl;

  final String? paymentMethod;

  final String? paymentIntent;

  final _i3.PaymentGateway? paymentGateway;

  final _i3.PaymentStatus? paymentStatus;

  final DateTime? expiresAt;

  final String? userId;

  final String? appointmentId;

  final String? discountCodeId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.PaymentCountAggregateOutputType? $count;

  final _i2.PaymentAvgAggregateOutputType? $avg;

  final _i2.PaymentSumAggregateOutputType? $sum;

  final _i2.PaymentMinAggregateOutputType? $min;

  final _i2.PaymentMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    'id': id,
    'amount': amount,
    'currency': currency,
    'description': description,
    'receiptUrl': receiptUrl,
    'paymentMethod': paymentMethod,
    'paymentIntent': paymentIntent,
    'paymentGateway': paymentGateway?.name,
    'paymentStatus': paymentStatus?.name,
    'expiresAt': expiresAt?.toIso8601String(),
    'userId': userId,
    'appointmentId': appointmentId,
    'discountCodeId': discountCodeId,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
    '_count': $count?.toJson(),
    '_avg': $avg?.toJson(),
    '_sum': $sum?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class PaymentCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentCountOrderByAggregateInput({
    this.id,
    this.amount,
    this.currency,
    this.description,
    this.receiptUrl,
    this.paymentMethod,
    this.paymentIntent,
    this.paymentGateway,
    this.paymentStatus,
    this.expiresAt,
    this.userId,
    this.appointmentId,
    this.discountCodeId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? amount;

  final _i2.SortOrder? currency;

  final _i2.SortOrder? description;

  final _i2.SortOrder? receiptUrl;

  final _i2.SortOrder? paymentMethod;

  final _i2.SortOrder? paymentIntent;

  final _i2.SortOrder? paymentGateway;

  final _i2.SortOrder? paymentStatus;

  final _i2.SortOrder? expiresAt;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? appointmentId;

  final _i2.SortOrder? discountCodeId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'amount': amount,
    'currency': currency,
    'description': description,
    'receiptUrl': receiptUrl,
    'paymentMethod': paymentMethod,
    'paymentIntent': paymentIntent,
    'paymentGateway': paymentGateway,
    'paymentStatus': paymentStatus,
    'expiresAt': expiresAt,
    'userId': userId,
    'appointmentId': appointmentId,
    'discountCodeId': discountCodeId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class PaymentAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentAvgOrderByAggregateInput({this.amount});

  final _i2.SortOrder? amount;

  @override
  Map<String, dynamic> toJson() => {'amount': amount};
}

class PaymentMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentMaxOrderByAggregateInput({
    this.id,
    this.amount,
    this.currency,
    this.description,
    this.receiptUrl,
    this.paymentMethod,
    this.paymentIntent,
    this.paymentGateway,
    this.paymentStatus,
    this.expiresAt,
    this.userId,
    this.appointmentId,
    this.discountCodeId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? amount;

  final _i2.SortOrder? currency;

  final _i2.SortOrder? description;

  final _i2.SortOrder? receiptUrl;

  final _i2.SortOrder? paymentMethod;

  final _i2.SortOrder? paymentIntent;

  final _i2.SortOrder? paymentGateway;

  final _i2.SortOrder? paymentStatus;

  final _i2.SortOrder? expiresAt;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? appointmentId;

  final _i2.SortOrder? discountCodeId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'amount': amount,
    'currency': currency,
    'description': description,
    'receiptUrl': receiptUrl,
    'paymentMethod': paymentMethod,
    'paymentIntent': paymentIntent,
    'paymentGateway': paymentGateway,
    'paymentStatus': paymentStatus,
    'expiresAt': expiresAt,
    'userId': userId,
    'appointmentId': appointmentId,
    'discountCodeId': discountCodeId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class PaymentMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentMinOrderByAggregateInput({
    this.id,
    this.amount,
    this.currency,
    this.description,
    this.receiptUrl,
    this.paymentMethod,
    this.paymentIntent,
    this.paymentGateway,
    this.paymentStatus,
    this.expiresAt,
    this.userId,
    this.appointmentId,
    this.discountCodeId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? amount;

  final _i2.SortOrder? currency;

  final _i2.SortOrder? description;

  final _i2.SortOrder? receiptUrl;

  final _i2.SortOrder? paymentMethod;

  final _i2.SortOrder? paymentIntent;

  final _i2.SortOrder? paymentGateway;

  final _i2.SortOrder? paymentStatus;

  final _i2.SortOrder? expiresAt;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? appointmentId;

  final _i2.SortOrder? discountCodeId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'amount': amount,
    'currency': currency,
    'description': description,
    'receiptUrl': receiptUrl,
    'paymentMethod': paymentMethod,
    'paymentIntent': paymentIntent,
    'paymentGateway': paymentGateway,
    'paymentStatus': paymentStatus,
    'expiresAt': expiresAt,
    'userId': userId,
    'appointmentId': appointmentId,
    'discountCodeId': discountCodeId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class PaymentSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentSumOrderByAggregateInput({this.amount});

  final _i2.SortOrder? amount;

  @override
  Map<String, dynamic> toJson() => {'amount': amount};
}

class PaymentOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentOrderByWithAggregationInput({
    this.id,
    this.amount,
    this.currency,
    this.description,
    this.receiptUrl,
    this.paymentMethod,
    this.paymentIntent,
    this.paymentGateway,
    this.paymentStatus,
    this.expiresAt,
    this.userId,
    this.appointmentId,
    this.discountCodeId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? amount;

  final _i2.SortOrder? currency;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? description;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? receiptUrl;

  final _i2.SortOrder? paymentMethod;

  final _i2.SortOrder? paymentIntent;

  final _i2.SortOrder? paymentGateway;

  final _i2.SortOrder? paymentStatus;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? expiresAt;

  final _i2.SortOrder? userId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? appointmentId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? discountCodeId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.PaymentCountOrderByAggregateInput? $count;

  final _i2.PaymentAvgOrderByAggregateInput? $avg;

  final _i2.PaymentMaxOrderByAggregateInput? $max;

  final _i2.PaymentMinOrderByAggregateInput? $min;

  final _i2.PaymentSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'amount': amount,
    'currency': currency,
    'description': description,
    'receiptUrl': receiptUrl,
    'paymentMethod': paymentMethod,
    'paymentIntent': paymentIntent,
    'paymentGateway': paymentGateway,
    'paymentStatus': paymentStatus,
    'expiresAt': expiresAt,
    'userId': userId,
    'appointmentId': appointmentId,
    'discountCodeId': discountCodeId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_avg': $avg,
    '_max': $max,
    '_min': $min,
    '_sum': $sum,
  };
}

class NestedEnumPaymentGatewayWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedEnumPaymentGatewayWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i3.PaymentGateway? equals;

  final _i1.PrismaUnion<Iterable<_i3.PaymentGateway>, _i3.PaymentGateway>? $in;

  final _i1.PrismaUnion<Iterable<_i3.PaymentGateway>, _i3.PaymentGateway>?
  notIn;

  final _i1.PrismaUnion<
    _i3.PaymentGateway,
    _i2.NestedEnumPaymentGatewayWithAggregatesFilter
  >?
  not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedEnumPaymentGatewayFilter? $min;

  final _i2.NestedEnumPaymentGatewayFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class EnumPaymentGatewayWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumPaymentGatewayWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i3.PaymentGateway? equals;

  final _i1.PrismaUnion<Iterable<_i3.PaymentGateway>, _i3.PaymentGateway>? $in;

  final _i1.PrismaUnion<Iterable<_i3.PaymentGateway>, _i3.PaymentGateway>?
  notIn;

  final _i1.PrismaUnion<
    _i3.PaymentGateway,
    _i2.NestedEnumPaymentGatewayWithAggregatesFilter
  >?
  not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedEnumPaymentGatewayFilter? $min;

  final _i2.NestedEnumPaymentGatewayFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class NestedEnumPaymentStatusWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedEnumPaymentStatusWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i3.PaymentStatus? equals;

  final _i1.PrismaUnion<Iterable<_i3.PaymentStatus>, _i3.PaymentStatus>? $in;

  final _i1.PrismaUnion<Iterable<_i3.PaymentStatus>, _i3.PaymentStatus>? notIn;

  final _i1.PrismaUnion<
    _i3.PaymentStatus,
    _i2.NestedEnumPaymentStatusWithAggregatesFilter
  >?
  not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedEnumPaymentStatusFilter? $min;

  final _i2.NestedEnumPaymentStatusFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class EnumPaymentStatusWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumPaymentStatusWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i3.PaymentStatus? equals;

  final _i1.PrismaUnion<Iterable<_i3.PaymentStatus>, _i3.PaymentStatus>? $in;

  final _i1.PrismaUnion<Iterable<_i3.PaymentStatus>, _i3.PaymentStatus>? notIn;

  final _i1.PrismaUnion<
    _i3.PaymentStatus,
    _i2.NestedEnumPaymentStatusWithAggregatesFilter
  >?
  not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedEnumPaymentStatusFilter? $min;

  final _i2.NestedEnumPaymentStatusFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class PaymentScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.amount,
    this.currency,
    this.description,
    this.receiptUrl,
    this.paymentMethod,
    this.paymentIntent,
    this.paymentGateway,
    this.paymentStatus,
    this.expiresAt,
    this.userId,
    this.appointmentId,
    this.discountCodeId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
    _i2.PaymentScalarWhereWithAggregatesInput,
    Iterable<_i2.PaymentScalarWhereWithAggregatesInput>
  >?
  AND;

  final Iterable<_i2.PaymentScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<
    _i2.PaymentScalarWhereWithAggregatesInput,
    Iterable<_i2.PaymentScalarWhereWithAggregatesInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? id;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? amount;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? currency;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  description;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  receiptUrl;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? paymentMethod;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? paymentIntent;

  final _i1.PrismaUnion<
    _i2.EnumPaymentGatewayWithAggregatesFilter,
    _i3.PaymentGateway
  >?
  paymentGateway;

  final _i1.PrismaUnion<
    _i2.EnumPaymentStatusWithAggregatesFilter,
    _i3.PaymentStatus
  >?
  paymentStatus;

  final _i1.PrismaUnion<
    _i2.DateTimeNullableWithAggregatesFilter,
    _i1.PrismaUnion<DateTime, _i1.PrismaNull>
  >?
  expiresAt;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? userId;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  appointmentId;

  final _i1.PrismaUnion<
    _i2.StringNullableWithAggregatesFilter,
    _i1.PrismaUnion<String, _i1.PrismaNull>
  >?
  discountCodeId;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'amount': amount,
    'currency': currency,
    'description': description,
    'receiptUrl': receiptUrl,
    'paymentMethod': paymentMethod,
    'paymentIntent': paymentIntent,
    'paymentGateway': paymentGateway,
    'paymentStatus': paymentStatus,
    'expiresAt': expiresAt,
    'userId': userId,
    'appointmentId': appointmentId,
    'discountCodeId': discountCodeId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class PaymentCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentCountAggregateOutputTypeSelect({
    this.id,
    this.amount,
    this.currency,
    this.description,
    this.receiptUrl,
    this.paymentMethod,
    this.paymentIntent,
    this.paymentGateway,
    this.paymentStatus,
    this.expiresAt,
    this.userId,
    this.appointmentId,
    this.discountCodeId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  final bool? id;

  final bool? amount;

  final bool? currency;

  final bool? description;

  final bool? receiptUrl;

  final bool? paymentMethod;

  final bool? paymentIntent;

  final bool? paymentGateway;

  final bool? paymentStatus;

  final bool? expiresAt;

  final bool? userId;

  final bool? appointmentId;

  final bool? discountCodeId;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'amount': amount,
    'currency': currency,
    'description': description,
    'receiptUrl': receiptUrl,
    'paymentMethod': paymentMethod,
    'paymentIntent': paymentIntent,
    'paymentGateway': paymentGateway,
    'paymentStatus': paymentStatus,
    'expiresAt': expiresAt,
    'userId': userId,
    'appointmentId': appointmentId,
    'discountCodeId': discountCodeId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class PaymentGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentGroupByOutputTypeCountArgs({this.select});

  final _i2.PaymentCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class PaymentAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentAvgAggregateOutputTypeSelect({this.amount});

  final bool? amount;

  @override
  Map<String, dynamic> toJson() => {'amount': amount};
}

class PaymentGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentGroupByOutputTypeAvgArgs({this.select});

  final _i2.PaymentAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class PaymentSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentSumAggregateOutputTypeSelect({this.amount});

  final bool? amount;

  @override
  Map<String, dynamic> toJson() => {'amount': amount};
}

class PaymentGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentGroupByOutputTypeSumArgs({this.select});

  final _i2.PaymentSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class PaymentMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentMinAggregateOutputTypeSelect({
    this.id,
    this.amount,
    this.currency,
    this.description,
    this.receiptUrl,
    this.paymentMethod,
    this.paymentIntent,
    this.paymentGateway,
    this.paymentStatus,
    this.expiresAt,
    this.userId,
    this.appointmentId,
    this.discountCodeId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? amount;

  final bool? currency;

  final bool? description;

  final bool? receiptUrl;

  final bool? paymentMethod;

  final bool? paymentIntent;

  final bool? paymentGateway;

  final bool? paymentStatus;

  final bool? expiresAt;

  final bool? userId;

  final bool? appointmentId;

  final bool? discountCodeId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'amount': amount,
    'currency': currency,
    'description': description,
    'receiptUrl': receiptUrl,
    'paymentMethod': paymentMethod,
    'paymentIntent': paymentIntent,
    'paymentGateway': paymentGateway,
    'paymentStatus': paymentStatus,
    'expiresAt': expiresAt,
    'userId': userId,
    'appointmentId': appointmentId,
    'discountCodeId': discountCodeId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class PaymentGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentGroupByOutputTypeMinArgs({this.select});

  final _i2.PaymentMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class PaymentMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentMaxAggregateOutputTypeSelect({
    this.id,
    this.amount,
    this.currency,
    this.description,
    this.receiptUrl,
    this.paymentMethod,
    this.paymentIntent,
    this.paymentGateway,
    this.paymentStatus,
    this.expiresAt,
    this.userId,
    this.appointmentId,
    this.discountCodeId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? amount;

  final bool? currency;

  final bool? description;

  final bool? receiptUrl;

  final bool? paymentMethod;

  final bool? paymentIntent;

  final bool? paymentGateway;

  final bool? paymentStatus;

  final bool? expiresAt;

  final bool? userId;

  final bool? appointmentId;

  final bool? discountCodeId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'amount': amount,
    'currency': currency,
    'description': description,
    'receiptUrl': receiptUrl,
    'paymentMethod': paymentMethod,
    'paymentIntent': paymentIntent,
    'paymentGateway': paymentGateway,
    'paymentStatus': paymentStatus,
    'expiresAt': expiresAt,
    'userId': userId,
    'appointmentId': appointmentId,
    'discountCodeId': discountCodeId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class PaymentGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentGroupByOutputTypeMaxArgs({this.select});

  final _i2.PaymentMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class PaymentGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentGroupByOutputTypeSelect({
    this.id,
    this.amount,
    this.currency,
    this.description,
    this.receiptUrl,
    this.paymentMethod,
    this.paymentIntent,
    this.paymentGateway,
    this.paymentStatus,
    this.expiresAt,
    this.userId,
    this.appointmentId,
    this.discountCodeId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? amount;

  final bool? currency;

  final bool? description;

  final bool? receiptUrl;

  final bool? paymentMethod;

  final bool? paymentIntent;

  final bool? paymentGateway;

  final bool? paymentStatus;

  final bool? expiresAt;

  final bool? userId;

  final bool? appointmentId;

  final bool? discountCodeId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.PaymentGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.PaymentGroupByOutputTypeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.PaymentGroupByOutputTypeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.PaymentGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.PaymentGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'amount': amount,
    'currency': currency,
    'description': description,
    'receiptUrl': receiptUrl,
    'paymentMethod': paymentMethod,
    'paymentIntent': paymentIntent,
    'paymentGateway': paymentGateway,
    'paymentStatus': paymentStatus,
    'expiresAt': expiresAt,
    'userId': userId,
    'appointmentId': appointmentId,
    'discountCodeId': discountCodeId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_avg': $avg,
    '_sum': $sum,
    '_min': $min,
    '_max': $max,
  };
}

class AggregatePayment {
  const AggregatePayment({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregatePayment.fromJson(Map json) => AggregatePayment(
    $count: json['_count'] is Map
        ? _i2.PaymentCountAggregateOutputType.fromJson(json['_count'])
        : null,
    $avg: json['_avg'] is Map
        ? _i2.PaymentAvgAggregateOutputType.fromJson(json['_avg'])
        : null,
    $sum: json['_sum'] is Map
        ? _i2.PaymentSumAggregateOutputType.fromJson(json['_sum'])
        : null,
    $min: json['_min'] is Map
        ? _i2.PaymentMinAggregateOutputType.fromJson(json['_min'])
        : null,
    $max: json['_max'] is Map
        ? _i2.PaymentMaxAggregateOutputType.fromJson(json['_max'])
        : null,
  );

  final _i2.PaymentCountAggregateOutputType? $count;

  final _i2.PaymentAvgAggregateOutputType? $avg;

  final _i2.PaymentSumAggregateOutputType? $sum;

  final _i2.PaymentMinAggregateOutputType? $min;

  final _i2.PaymentMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    '_count': $count?.toJson(),
    '_avg': $avg?.toJson(),
    '_sum': $sum?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class AggregatePaymentCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregatePaymentCountArgs({this.select});

  final _i2.PaymentCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregatePaymentAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregatePaymentAvgArgs({this.select});

  final _i2.PaymentAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregatePaymentSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregatePaymentSumArgs({this.select});

  final _i2.PaymentSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregatePaymentMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregatePaymentMinArgs({this.select});

  final _i2.PaymentMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregatePaymentMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregatePaymentMaxArgs({this.select});

  final _i2.PaymentMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregatePaymentSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregatePaymentSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregatePaymentCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregatePaymentAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregatePaymentSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregatePaymentMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregatePaymentMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    '_count': $count,
    '_avg': $avg,
    '_sum': $sum,
    '_min': $min,
    '_max': $max,
  };
}

enum DiscountCodeScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<String>('id', 'DiscountCode'),
  code<String>('code', 'DiscountCode'),
  description<String>('description', 'DiscountCode'),
  discountType<_i3.DiscountType>('discountType', 'DiscountCode'),
  discountValue<double>('discountValue', 'DiscountCode'),
  createdAt<DateTime>('createdAt', 'DiscountCode'),
  updatedAt<DateTime>('updatedAt', 'DiscountCode');

  const DiscountCodeScalar(this.name, this.model);

  @override
  final String name;

  @override
  final String model;
}

class PaymentCreateWithoutDiscountCodeInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentCreateWithoutDiscountCodeInput({
    this.id,
    required this.amount,
    required this.currency,
    this.description,
    this.receiptUrl,
    required this.paymentMethod,
    required this.paymentIntent,
    required this.paymentGateway,
    required this.paymentStatus,
    this.expiresAt,
    this.createdAt,
    this.updatedAt,
    required this.user,
    this.appointment,
  });

  final String? id;

  final int amount;

  final String currency;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? receiptUrl;

  final String paymentMethod;

  final String paymentIntent;

  final _i3.PaymentGateway paymentGateway;

  final _i3.PaymentStatus paymentStatus;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? expiresAt;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.UserCreateNestedOneWithoutPaymentInput user;

  final _i2.AppointmentCreateNestedOneWithoutPaymentInput? appointment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'amount': amount,
    'currency': currency,
    'description': description,
    'receiptUrl': receiptUrl,
    'paymentMethod': paymentMethod,
    'paymentIntent': paymentIntent,
    'paymentGateway': paymentGateway,
    'paymentStatus': paymentStatus,
    'expiresAt': expiresAt,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'user': user,
    'appointment': appointment,
  };
}

class PaymentUncheckedCreateWithoutDiscountCodeInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentUncheckedCreateWithoutDiscountCodeInput({
    this.id,
    required this.amount,
    required this.currency,
    this.description,
    this.receiptUrl,
    required this.paymentMethod,
    required this.paymentIntent,
    required this.paymentGateway,
    required this.paymentStatus,
    this.expiresAt,
    required this.userId,
    this.appointmentId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final int amount;

  final String currency;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? receiptUrl;

  final String paymentMethod;

  final String paymentIntent;

  final _i3.PaymentGateway paymentGateway;

  final _i3.PaymentStatus paymentStatus;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? expiresAt;

  final String userId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? appointmentId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'amount': amount,
    'currency': currency,
    'description': description,
    'receiptUrl': receiptUrl,
    'paymentMethod': paymentMethod,
    'paymentIntent': paymentIntent,
    'paymentGateway': paymentGateway,
    'paymentStatus': paymentStatus,
    'expiresAt': expiresAt,
    'userId': userId,
    'appointmentId': appointmentId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class PaymentCreateOrConnectWithoutDiscountCodeInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentCreateOrConnectWithoutDiscountCodeInput({
    required this.where,
    required this.create,
  });

  final _i2.PaymentWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.PaymentCreateWithoutDiscountCodeInput,
    _i2.PaymentUncheckedCreateWithoutDiscountCodeInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'create': create};
}

class PaymentCreateManyDiscountCodeInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentCreateManyDiscountCodeInput({
    this.id,
    required this.amount,
    required this.currency,
    this.description,
    this.receiptUrl,
    required this.paymentMethod,
    required this.paymentIntent,
    required this.paymentGateway,
    required this.paymentStatus,
    this.expiresAt,
    required this.userId,
    this.appointmentId,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final int amount;

  final String currency;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? receiptUrl;

  final String paymentMethod;

  final String paymentIntent;

  final _i3.PaymentGateway paymentGateway;

  final _i3.PaymentStatus paymentStatus;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? expiresAt;

  final String userId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? appointmentId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'amount': amount,
    'currency': currency,
    'description': description,
    'receiptUrl': receiptUrl,
    'paymentMethod': paymentMethod,
    'paymentIntent': paymentIntent,
    'paymentGateway': paymentGateway,
    'paymentStatus': paymentStatus,
    'expiresAt': expiresAt,
    'userId': userId,
    'appointmentId': appointmentId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class PaymentCreateManyDiscountCodeInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentCreateManyDiscountCodeInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<
    _i2.PaymentCreateManyDiscountCodeInput,
    Iterable<_i2.PaymentCreateManyDiscountCodeInput>
  >
  data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
    'data': data,
    'skipDuplicates': skipDuplicates,
  };
}

class PaymentCreateNestedManyWithoutDiscountCodeInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentCreateNestedManyWithoutDiscountCodeInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.PaymentCreateWithoutDiscountCodeInput,
    _i1.PrismaUnion<
      Iterable<_i2.PaymentCreateWithoutDiscountCodeInput>,
      _i1.PrismaUnion<
        _i2.PaymentUncheckedCreateWithoutDiscountCodeInput,
        Iterable<_i2.PaymentUncheckedCreateWithoutDiscountCodeInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.PaymentCreateOrConnectWithoutDiscountCodeInput,
    Iterable<_i2.PaymentCreateOrConnectWithoutDiscountCodeInput>
  >?
  connectOrCreate;

  final _i2.PaymentCreateManyDiscountCodeInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.PaymentWhereUniqueInput,
    Iterable<_i2.PaymentWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class DiscountCodeCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountCodeCreateInput({
    this.id,
    required this.code,
    required this.description,
    required this.discountType,
    required this.discountValue,
    this.createdAt,
    this.updatedAt,
    this.payment,
  });

  final String? id;

  final String code;

  final String description;

  final _i3.DiscountType discountType;

  final double discountValue;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.PaymentCreateNestedManyWithoutDiscountCodeInput? payment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'code': code,
    'description': description,
    'discountType': discountType,
    'discountValue': discountValue,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'Payment': payment,
  };
}

class PaymentUncheckedCreateNestedManyWithoutDiscountCodeInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentUncheckedCreateNestedManyWithoutDiscountCodeInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
    _i2.PaymentCreateWithoutDiscountCodeInput,
    _i1.PrismaUnion<
      Iterable<_i2.PaymentCreateWithoutDiscountCodeInput>,
      _i1.PrismaUnion<
        _i2.PaymentUncheckedCreateWithoutDiscountCodeInput,
        Iterable<_i2.PaymentUncheckedCreateWithoutDiscountCodeInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.PaymentCreateOrConnectWithoutDiscountCodeInput,
    Iterable<_i2.PaymentCreateOrConnectWithoutDiscountCodeInput>
  >?
  connectOrCreate;

  final _i2.PaymentCreateManyDiscountCodeInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.PaymentWhereUniqueInput,
    Iterable<_i2.PaymentWhereUniqueInput>
  >?
  connect;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'createMany': createMany,
    'connect': connect,
  };
}

class DiscountCodeUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountCodeUncheckedCreateInput({
    this.id,
    required this.code,
    required this.description,
    required this.discountType,
    required this.discountValue,
    this.createdAt,
    this.updatedAt,
    this.payment,
  });

  final String? id;

  final String code;

  final String description;

  final _i3.DiscountType discountType;

  final double discountValue;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.PaymentUncheckedCreateNestedManyWithoutDiscountCodeInput? payment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'code': code,
    'description': description,
    'discountType': discountType,
    'discountValue': discountValue,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'Payment': payment,
  };
}

class DiscountCodeCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountCodeCreateManyInput({
    this.id,
    required this.code,
    required this.description,
    required this.discountType,
    required this.discountValue,
    this.createdAt,
    this.updatedAt,
  });

  final String? id;

  final String code;

  final String description;

  final _i3.DiscountType discountType;

  final double discountValue;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'code': code,
    'description': description,
    'discountType': discountType,
    'discountValue': discountValue,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class PaymentUpdateWithoutDiscountCodeInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentUpdateWithoutDiscountCodeInput({
    this.id,
    this.amount,
    this.currency,
    this.description,
    this.receiptUrl,
    this.paymentMethod,
    this.paymentIntent,
    this.paymentGateway,
    this.paymentStatus,
    this.expiresAt,
    this.createdAt,
    this.updatedAt,
    this.user,
    this.appointment,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? amount;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? currency;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  receiptUrl;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  paymentMethod;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  paymentIntent;

  final _i1.PrismaUnion<
    _i3.PaymentGateway,
    _i2.EnumPaymentGatewayFieldUpdateOperationsInput
  >?
  paymentGateway;

  final _i1.PrismaUnion<
    _i3.PaymentStatus,
    _i2.EnumPaymentStatusFieldUpdateOperationsInput
  >?
  paymentStatus;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  expiresAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.UserUpdateOneRequiredWithoutPaymentNestedInput? user;

  final _i2.AppointmentUpdateOneWithoutPaymentNestedInput? appointment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'amount': amount,
    'currency': currency,
    'description': description,
    'receiptUrl': receiptUrl,
    'paymentMethod': paymentMethod,
    'paymentIntent': paymentIntent,
    'paymentGateway': paymentGateway,
    'paymentStatus': paymentStatus,
    'expiresAt': expiresAt,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'user': user,
    'appointment': appointment,
  };
}

class PaymentUncheckedUpdateWithoutDiscountCodeInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentUncheckedUpdateWithoutDiscountCodeInput({
    this.id,
    this.amount,
    this.currency,
    this.description,
    this.receiptUrl,
    this.paymentMethod,
    this.paymentIntent,
    this.paymentGateway,
    this.paymentStatus,
    this.expiresAt,
    this.userId,
    this.appointmentId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? amount;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? currency;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  description;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  receiptUrl;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  paymentMethod;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  paymentIntent;

  final _i1.PrismaUnion<
    _i3.PaymentGateway,
    _i2.EnumPaymentGatewayFieldUpdateOperationsInput
  >?
  paymentGateway;

  final _i1.PrismaUnion<
    _i3.PaymentStatus,
    _i2.EnumPaymentStatusFieldUpdateOperationsInput
  >?
  paymentStatus;

  final _i1.PrismaUnion<
    DateTime,
    _i1.PrismaUnion<
      _i2.NullableDateTimeFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  expiresAt;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<
    String,
    _i1.PrismaUnion<
      _i2.NullableStringFieldUpdateOperationsInput,
      _i1.PrismaNull
    >
  >?
  appointmentId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'amount': amount,
    'currency': currency,
    'description': description,
    'receiptUrl': receiptUrl,
    'paymentMethod': paymentMethod,
    'paymentIntent': paymentIntent,
    'paymentGateway': paymentGateway,
    'paymentStatus': paymentStatus,
    'expiresAt': expiresAt,
    'userId': userId,
    'appointmentId': appointmentId,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class PaymentUpsertWithWhereUniqueWithoutDiscountCodeInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentUpsertWithWhereUniqueWithoutDiscountCodeInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.PaymentWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.PaymentUpdateWithoutDiscountCodeInput,
    _i2.PaymentUncheckedUpdateWithoutDiscountCodeInput
  >
  update;

  final _i1.PrismaUnion<
    _i2.PaymentCreateWithoutDiscountCodeInput,
    _i2.PaymentUncheckedCreateWithoutDiscountCodeInput
  >
  create;

  @override
  Map<String, dynamic> toJson() => {
    'where': where,
    'update': update,
    'create': create,
  };
}

class PaymentUpdateWithWhereUniqueWithoutDiscountCodeInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentUpdateWithWhereUniqueWithoutDiscountCodeInput({
    required this.where,
    required this.data,
  });

  final _i2.PaymentWhereUniqueInput where;

  final _i1.PrismaUnion<
    _i2.PaymentUpdateWithoutDiscountCodeInput,
    _i2.PaymentUncheckedUpdateWithoutDiscountCodeInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class PaymentUpdateManyWithWhereWithoutDiscountCodeInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentUpdateManyWithWhereWithoutDiscountCodeInput({
    required this.where,
    required this.data,
  });

  final _i2.PaymentScalarWhereInput where;

  final _i1.PrismaUnion<
    _i2.PaymentUpdateManyMutationInput,
    _i2.PaymentUncheckedUpdateManyWithoutPaymentInput
  >
  data;

  @override
  Map<String, dynamic> toJson() => {'where': where, 'data': data};
}

class PaymentUpdateManyWithoutDiscountCodeNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentUpdateManyWithoutDiscountCodeNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.PaymentCreateWithoutDiscountCodeInput,
    _i1.PrismaUnion<
      Iterable<_i2.PaymentCreateWithoutDiscountCodeInput>,
      _i1.PrismaUnion<
        _i2.PaymentUncheckedCreateWithoutDiscountCodeInput,
        Iterable<_i2.PaymentUncheckedCreateWithoutDiscountCodeInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.PaymentCreateOrConnectWithoutDiscountCodeInput,
    Iterable<_i2.PaymentCreateOrConnectWithoutDiscountCodeInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.PaymentUpsertWithWhereUniqueWithoutDiscountCodeInput,
    Iterable<_i2.PaymentUpsertWithWhereUniqueWithoutDiscountCodeInput>
  >?
  upsert;

  final _i2.PaymentCreateManyDiscountCodeInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.PaymentWhereUniqueInput,
    Iterable<_i2.PaymentWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.PaymentWhereUniqueInput,
    Iterable<_i2.PaymentWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.PaymentWhereUniqueInput,
    Iterable<_i2.PaymentWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.PaymentWhereUniqueInput,
    Iterable<_i2.PaymentWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.PaymentUpdateWithWhereUniqueWithoutDiscountCodeInput,
    Iterable<_i2.PaymentUpdateWithWhereUniqueWithoutDiscountCodeInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.PaymentUpdateManyWithWhereWithoutDiscountCodeInput,
    Iterable<_i2.PaymentUpdateManyWithWhereWithoutDiscountCodeInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.PaymentScalarWhereInput,
    Iterable<_i2.PaymentScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class DiscountCodeUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountCodeUpdateInput({
    this.id,
    this.code,
    this.description,
    this.discountType,
    this.discountValue,
    this.createdAt,
    this.updatedAt,
    this.payment,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? code;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  description;

  final _i1.PrismaUnion<
    _i3.DiscountType,
    _i2.EnumDiscountTypeFieldUpdateOperationsInput
  >?
  discountType;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
  discountValue;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.PaymentUpdateManyWithoutDiscountCodeNestedInput? payment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'code': code,
    'description': description,
    'discountType': discountType,
    'discountValue': discountValue,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'Payment': payment,
  };
}

class PaymentUncheckedUpdateManyWithoutDiscountCodeNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentUncheckedUpdateManyWithoutDiscountCodeNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
    _i2.PaymentCreateWithoutDiscountCodeInput,
    _i1.PrismaUnion<
      Iterable<_i2.PaymentCreateWithoutDiscountCodeInput>,
      _i1.PrismaUnion<
        _i2.PaymentUncheckedCreateWithoutDiscountCodeInput,
        Iterable<_i2.PaymentUncheckedCreateWithoutDiscountCodeInput>
      >
    >
  >?
  create;

  final _i1.PrismaUnion<
    _i2.PaymentCreateOrConnectWithoutDiscountCodeInput,
    Iterable<_i2.PaymentCreateOrConnectWithoutDiscountCodeInput>
  >?
  connectOrCreate;

  final _i1.PrismaUnion<
    _i2.PaymentUpsertWithWhereUniqueWithoutDiscountCodeInput,
    Iterable<_i2.PaymentUpsertWithWhereUniqueWithoutDiscountCodeInput>
  >?
  upsert;

  final _i2.PaymentCreateManyDiscountCodeInputEnvelope? createMany;

  final _i1.PrismaUnion<
    _i2.PaymentWhereUniqueInput,
    Iterable<_i2.PaymentWhereUniqueInput>
  >?
  set;

  final _i1.PrismaUnion<
    _i2.PaymentWhereUniqueInput,
    Iterable<_i2.PaymentWhereUniqueInput>
  >?
  disconnect;

  final _i1.PrismaUnion<
    _i2.PaymentWhereUniqueInput,
    Iterable<_i2.PaymentWhereUniqueInput>
  >?
  delete;

  final _i1.PrismaUnion<
    _i2.PaymentWhereUniqueInput,
    Iterable<_i2.PaymentWhereUniqueInput>
  >?
  connect;

  final _i1.PrismaUnion<
    _i2.PaymentUpdateWithWhereUniqueWithoutDiscountCodeInput,
    Iterable<_i2.PaymentUpdateWithWhereUniqueWithoutDiscountCodeInput>
  >?
  update;

  final _i1.PrismaUnion<
    _i2.PaymentUpdateManyWithWhereWithoutDiscountCodeInput,
    Iterable<_i2.PaymentUpdateManyWithWhereWithoutDiscountCodeInput>
  >?
  updateMany;

  final _i1.PrismaUnion<
    _i2.PaymentScalarWhereInput,
    Iterable<_i2.PaymentScalarWhereInput>
  >?
  deleteMany;

  @override
  Map<String, dynamic> toJson() => {
    'create': create,
    'connectOrCreate': connectOrCreate,
    'upsert': upsert,
    'createMany': createMany,
    'set': set,
    'disconnect': disconnect,
    'delete': delete,
    'connect': connect,
    'update': update,
    'updateMany': updateMany,
    'deleteMany': deleteMany,
  };
}

class DiscountCodeUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountCodeUncheckedUpdateInput({
    this.id,
    this.code,
    this.description,
    this.discountType,
    this.discountValue,
    this.createdAt,
    this.updatedAt,
    this.payment,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? code;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  description;

  final _i1.PrismaUnion<
    _i3.DiscountType,
    _i2.EnumDiscountTypeFieldUpdateOperationsInput
  >?
  discountType;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
  discountValue;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  final _i2.PaymentUncheckedUpdateManyWithoutDiscountCodeNestedInput? payment;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'code': code,
    'description': description,
    'discountType': discountType,
    'discountValue': discountValue,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    'Payment': payment,
  };
}

class DiscountCodeUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountCodeUpdateManyMutationInput({
    this.id,
    this.code,
    this.description,
    this.discountType,
    this.discountValue,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? code;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  description;

  final _i1.PrismaUnion<
    _i3.DiscountType,
    _i2.EnumDiscountTypeFieldUpdateOperationsInput
  >?
  discountType;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
  discountValue;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'code': code,
    'description': description,
    'discountType': discountType,
    'discountValue': discountValue,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class DiscountCodeUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountCodeUncheckedUpdateManyInput({
    this.id,
    this.code,
    this.description,
    this.discountType,
    this.discountValue,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? code;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
  description;

  final _i1.PrismaUnion<
    _i3.DiscountType,
    _i2.EnumDiscountTypeFieldUpdateOperationsInput
  >?
  discountType;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
  discountValue;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
  updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'code': code,
    'description': description,
    'discountType': discountType,
    'discountValue': discountValue,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class DiscountCodeCountAggregateOutputType {
  const DiscountCodeCountAggregateOutputType({
    this.id,
    this.code,
    this.description,
    this.discountType,
    this.discountValue,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  factory DiscountCodeCountAggregateOutputType.fromJson(Map json) =>
      DiscountCodeCountAggregateOutputType(
        id: json['id'],
        code: json['code'],
        description: json['description'],
        discountType: json['discountType'],
        discountValue: json['discountValue'],
        createdAt: json['createdAt'],
        updatedAt: json['updatedAt'],
        $all: json['_all'],
      );

  final int? id;

  final int? code;

  final int? description;

  final int? discountType;

  final int? discountValue;

  final int? createdAt;

  final int? updatedAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
    'id': id,
    'code': code,
    'description': description,
    'discountType': discountType,
    'discountValue': discountValue,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class DiscountCodeAvgAggregateOutputType {
  const DiscountCodeAvgAggregateOutputType({this.discountValue});

  factory DiscountCodeAvgAggregateOutputType.fromJson(Map json) =>
      DiscountCodeAvgAggregateOutputType(discountValue: json['discountValue']);

  final double? discountValue;

  Map<String, dynamic> toJson() => {'discountValue': discountValue};
}

class DiscountCodeSumAggregateOutputType {
  const DiscountCodeSumAggregateOutputType({this.discountValue});

  factory DiscountCodeSumAggregateOutputType.fromJson(Map json) =>
      DiscountCodeSumAggregateOutputType(discountValue: json['discountValue']);

  final double? discountValue;

  Map<String, dynamic> toJson() => {'discountValue': discountValue};
}

class DiscountCodeMinAggregateOutputType {
  const DiscountCodeMinAggregateOutputType({
    this.id,
    this.code,
    this.description,
    this.discountType,
    this.discountValue,
    this.createdAt,
    this.updatedAt,
  });

  factory DiscountCodeMinAggregateOutputType.fromJson(Map json) =>
      DiscountCodeMinAggregateOutputType(
        id: json['id'],
        code: json['code'],
        description: json['description'],
        discountType: json['discountType'] != null
            ? _i3.DiscountType.values.firstWhere(
                (e) => e.name == json['discountType'],
              )
            : null,
        discountValue: json['discountValue'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final String? code;

  final String? description;

  final _i3.DiscountType? discountType;

  final double? discountValue;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'code': code,
    'description': description,
    'discountType': discountType?.name,
    'discountValue': discountValue,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class DiscountCodeMaxAggregateOutputType {
  const DiscountCodeMaxAggregateOutputType({
    this.id,
    this.code,
    this.description,
    this.discountType,
    this.discountValue,
    this.createdAt,
    this.updatedAt,
  });

  factory DiscountCodeMaxAggregateOutputType.fromJson(Map json) =>
      DiscountCodeMaxAggregateOutputType(
        id: json['id'],
        code: json['code'],
        description: json['description'],
        discountType: json['discountType'] != null
            ? _i3.DiscountType.values.firstWhere(
                (e) => e.name == json['discountType'],
              )
            : null,
        discountValue: json['discountValue'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
      );

  final String? id;

  final String? code;

  final String? description;

  final _i3.DiscountType? discountType;

  final double? discountValue;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
    'id': id,
    'code': code,
    'description': description,
    'discountType': discountType?.name,
    'discountValue': discountValue,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
  };
}

class DiscountCodeGroupByOutputType {
  const DiscountCodeGroupByOutputType({
    this.id,
    this.code,
    this.description,
    this.discountType,
    this.discountValue,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory DiscountCodeGroupByOutputType.fromJson(Map json) =>
      DiscountCodeGroupByOutputType(
        id: json['id'],
        code: json['code'],
        description: json['description'],
        discountType: json['discountType'] != null
            ? _i3.DiscountType.values.firstWhere(
                (e) => e.name == json['discountType'],
              )
            : null,
        discountValue: json['discountValue'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt'],
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt'],
        },
        $count: json['_count'] is Map
            ? _i2.DiscountCodeCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.DiscountCodeAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.DiscountCodeSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.DiscountCodeMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.DiscountCodeMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? id;

  final String? code;

  final String? description;

  final _i3.DiscountType? discountType;

  final double? discountValue;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.DiscountCodeCountAggregateOutputType? $count;

  final _i2.DiscountCodeAvgAggregateOutputType? $avg;

  final _i2.DiscountCodeSumAggregateOutputType? $sum;

  final _i2.DiscountCodeMinAggregateOutputType? $min;

  final _i2.DiscountCodeMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    'id': id,
    'code': code,
    'description': description,
    'discountType': discountType?.name,
    'discountValue': discountValue,
    'createdAt': createdAt?.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
    '_count': $count?.toJson(),
    '_avg': $avg?.toJson(),
    '_sum': $sum?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class DiscountCodeCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountCodeCountOrderByAggregateInput({
    this.id,
    this.code,
    this.description,
    this.discountType,
    this.discountValue,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? code;

  final _i2.SortOrder? description;

  final _i2.SortOrder? discountType;

  final _i2.SortOrder? discountValue;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'code': code,
    'description': description,
    'discountType': discountType,
    'discountValue': discountValue,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class DiscountCodeAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountCodeAvgOrderByAggregateInput({this.discountValue});

  final _i2.SortOrder? discountValue;

  @override
  Map<String, dynamic> toJson() => {'discountValue': discountValue};
}

class DiscountCodeMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountCodeMaxOrderByAggregateInput({
    this.id,
    this.code,
    this.description,
    this.discountType,
    this.discountValue,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? code;

  final _i2.SortOrder? description;

  final _i2.SortOrder? discountType;

  final _i2.SortOrder? discountValue;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'code': code,
    'description': description,
    'discountType': discountType,
    'discountValue': discountValue,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class DiscountCodeMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountCodeMinOrderByAggregateInput({
    this.id,
    this.code,
    this.description,
    this.discountType,
    this.discountValue,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? code;

  final _i2.SortOrder? description;

  final _i2.SortOrder? discountType;

  final _i2.SortOrder? discountValue;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'code': code,
    'description': description,
    'discountType': discountType,
    'discountValue': discountValue,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class DiscountCodeSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountCodeSumOrderByAggregateInput({this.discountValue});

  final _i2.SortOrder? discountValue;

  @override
  Map<String, dynamic> toJson() => {'discountValue': discountValue};
}

class DiscountCodeOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountCodeOrderByWithAggregationInput({
    this.id,
    this.code,
    this.description,
    this.discountType,
    this.discountValue,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? code;

  final _i2.SortOrder? description;

  final _i2.SortOrder? discountType;

  final _i2.SortOrder? discountValue;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.DiscountCodeCountOrderByAggregateInput? $count;

  final _i2.DiscountCodeAvgOrderByAggregateInput? $avg;

  final _i2.DiscountCodeMaxOrderByAggregateInput? $max;

  final _i2.DiscountCodeMinOrderByAggregateInput? $min;

  final _i2.DiscountCodeSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'code': code,
    'description': description,
    'discountType': discountType,
    'discountValue': discountValue,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_avg': $avg,
    '_max': $max,
    '_min': $min,
    '_sum': $sum,
  };
}

class NestedEnumDiscountTypeWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedEnumDiscountTypeWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i3.DiscountType? equals;

  final _i1.PrismaUnion<Iterable<_i3.DiscountType>, _i3.DiscountType>? $in;

  final _i1.PrismaUnion<Iterable<_i3.DiscountType>, _i3.DiscountType>? notIn;

  final _i1.PrismaUnion<
    _i3.DiscountType,
    _i2.NestedEnumDiscountTypeWithAggregatesFilter
  >?
  not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedEnumDiscountTypeFilter? $min;

  final _i2.NestedEnumDiscountTypeFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class EnumDiscountTypeWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumDiscountTypeWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i3.DiscountType? equals;

  final _i1.PrismaUnion<Iterable<_i3.DiscountType>, _i3.DiscountType>? $in;

  final _i1.PrismaUnion<Iterable<_i3.DiscountType>, _i3.DiscountType>? notIn;

  final _i1.PrismaUnion<
    _i3.DiscountType,
    _i2.NestedEnumDiscountTypeWithAggregatesFilter
  >?
  not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedEnumDiscountTypeFilter? $min;

  final _i2.NestedEnumDiscountTypeFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
    'equals': equals,
    'in': $in,
    'notIn': notIn,
    'not': not,
    '_count': $count,
    '_min': $min,
    '_max': $max,
  };
}

class DiscountCodeScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountCodeScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.code,
    this.description,
    this.discountType,
    this.discountValue,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
    _i2.DiscountCodeScalarWhereWithAggregatesInput,
    Iterable<_i2.DiscountCodeScalarWhereWithAggregatesInput>
  >?
  AND;

  final Iterable<_i2.DiscountCodeScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<
    _i2.DiscountCodeScalarWhereWithAggregatesInput,
    Iterable<_i2.DiscountCodeScalarWhereWithAggregatesInput>
  >?
  NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? code;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? description;

  final _i1.PrismaUnion<
    _i2.EnumDiscountTypeWithAggregatesFilter,
    _i3.DiscountType
  >?
  discountType;

  final _i1.PrismaUnion<_i2.FloatWithAggregatesFilter, double>? discountValue;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'AND': AND,
    'OR': OR,
    'NOT': NOT,
    'id': id,
    'code': code,
    'description': description,
    'discountType': discountType,
    'discountValue': discountValue,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class DiscountCodeCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountCodeCountAggregateOutputTypeSelect({
    this.id,
    this.code,
    this.description,
    this.discountType,
    this.discountValue,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  final bool? id;

  final bool? code;

  final bool? description;

  final bool? discountType;

  final bool? discountValue;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'code': code,
    'description': description,
    'discountType': discountType,
    'discountValue': discountValue,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_all': $all,
  };
}

class DiscountCodeGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountCodeGroupByOutputTypeCountArgs({this.select});

  final _i2.DiscountCodeCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class DiscountCodeAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountCodeAvgAggregateOutputTypeSelect({this.discountValue});

  final bool? discountValue;

  @override
  Map<String, dynamic> toJson() => {'discountValue': discountValue};
}

class DiscountCodeGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountCodeGroupByOutputTypeAvgArgs({this.select});

  final _i2.DiscountCodeAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class DiscountCodeSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountCodeSumAggregateOutputTypeSelect({this.discountValue});

  final bool? discountValue;

  @override
  Map<String, dynamic> toJson() => {'discountValue': discountValue};
}

class DiscountCodeGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountCodeGroupByOutputTypeSumArgs({this.select});

  final _i2.DiscountCodeSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class DiscountCodeMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountCodeMinAggregateOutputTypeSelect({
    this.id,
    this.code,
    this.description,
    this.discountType,
    this.discountValue,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? code;

  final bool? description;

  final bool? discountType;

  final bool? discountValue;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'code': code,
    'description': description,
    'discountType': discountType,
    'discountValue': discountValue,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class DiscountCodeGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountCodeGroupByOutputTypeMinArgs({this.select});

  final _i2.DiscountCodeMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class DiscountCodeMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountCodeMaxAggregateOutputTypeSelect({
    this.id,
    this.code,
    this.description,
    this.discountType,
    this.discountValue,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? code;

  final bool? description;

  final bool? discountType;

  final bool? discountValue;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'code': code,
    'description': description,
    'discountType': discountType,
    'discountValue': discountValue,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
  };
}

class DiscountCodeGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountCodeGroupByOutputTypeMaxArgs({this.select});

  final _i2.DiscountCodeMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class DiscountCodeGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountCodeGroupByOutputTypeSelect({
    this.id,
    this.code,
    this.description,
    this.discountType,
    this.discountValue,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? code;

  final bool? description;

  final bool? discountType;

  final bool? discountValue;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.DiscountCodeGroupByOutputTypeCountArgs>?
  $count;

  final _i1.PrismaUnion<bool, _i2.DiscountCodeGroupByOutputTypeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.DiscountCodeGroupByOutputTypeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.DiscountCodeGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.DiscountCodeGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    'id': id,
    'code': code,
    'description': description,
    'discountType': discountType,
    'discountValue': discountValue,
    'createdAt': createdAt,
    'updatedAt': updatedAt,
    '_count': $count,
    '_avg': $avg,
    '_sum': $sum,
    '_min': $min,
    '_max': $max,
  };
}

class AggregateDiscountCode {
  const AggregateDiscountCode({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateDiscountCode.fromJson(Map json) => AggregateDiscountCode(
    $count: json['_count'] is Map
        ? _i2.DiscountCodeCountAggregateOutputType.fromJson(json['_count'])
        : null,
    $avg: json['_avg'] is Map
        ? _i2.DiscountCodeAvgAggregateOutputType.fromJson(json['_avg'])
        : null,
    $sum: json['_sum'] is Map
        ? _i2.DiscountCodeSumAggregateOutputType.fromJson(json['_sum'])
        : null,
    $min: json['_min'] is Map
        ? _i2.DiscountCodeMinAggregateOutputType.fromJson(json['_min'])
        : null,
    $max: json['_max'] is Map
        ? _i2.DiscountCodeMaxAggregateOutputType.fromJson(json['_max'])
        : null,
  );

  final _i2.DiscountCodeCountAggregateOutputType? $count;

  final _i2.DiscountCodeAvgAggregateOutputType? $avg;

  final _i2.DiscountCodeSumAggregateOutputType? $sum;

  final _i2.DiscountCodeMinAggregateOutputType? $min;

  final _i2.DiscountCodeMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
    '_count': $count?.toJson(),
    '_avg': $avg?.toJson(),
    '_sum': $sum?.toJson(),
    '_min': $min?.toJson(),
    '_max': $max?.toJson(),
  };
}

class AggregateDiscountCodeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateDiscountCodeCountArgs({this.select});

  final _i2.DiscountCodeCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateDiscountCodeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateDiscountCodeAvgArgs({this.select});

  final _i2.DiscountCodeAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateDiscountCodeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateDiscountCodeSumArgs({this.select});

  final _i2.DiscountCodeSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateDiscountCodeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateDiscountCodeMinArgs({this.select});

  final _i2.DiscountCodeMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateDiscountCodeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateDiscountCodeMaxArgs({this.select});

  final _i2.DiscountCodeMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateDiscountCodeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateDiscountCodeSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateDiscountCodeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateDiscountCodeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateDiscountCodeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateDiscountCodeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateDiscountCodeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
    '_count': $count,
    '_avg': $avg,
    '_sum': $sum,
    '_min': $min,
    '_max': $max,
  };
}
